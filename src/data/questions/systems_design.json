{
  "category": "systems_design",
  "questions": [
    {
      "id": 100,
      "tag": "systems_design",
      "question": "Design a URL shortening service like bit.ly. Consider scalability, performance, and reliability.",
      "answer": "**System Requirements:**\n- Shorten long URLs to 6-8 character codes\n- Handle 100M URLs per day\n- 100:1 read/write ratio\n- 99.9% uptime\n- Analytics tracking\n\n**Architecture Components:**\n\n**1. Load Balancer:**\n- Distribute incoming requests\n- Health checks for backend services\n- SSL termination\n\n**2. Application Servers:**\n- Stateless web servers\n- Handle URL encoding/decoding\n- Rate limiting and validation\n\n**3. Database Design:**\n- **Primary DB:** URL mappings (SQL/NoSQL)\n- **Cache:** Redis for hot URLs\n- **Analytics DB:** Click tracking data\n\n**4. URL Encoding:**\n- Base62 encoding (a-z, A-Z, 0-9)\n- Counter-based or hash-based approach\n- Collision detection and resolution\n\n**5. Caching Strategy:**\n- Cache popular URLs in Redis\n- CDN for static content\n- Browser caching headers\n\n**6. Analytics Service:**\n- Async processing of click events\n- Data pipeline for reporting\n- Real-time and batch analytics\n\n**Scalability Considerations:**\n- Database sharding by URL hash\n- Read replicas for analytics\n- Auto-scaling application servers\n- Rate limiting to prevent abuse",
      "difficulty": "hard"
    },
    {
      "id": 101,
      "tag": "systems_design",
      "question": "How would you design a chat application like WhatsApp? Focus on real-time messaging and scalability.",
      "answer": "**System Requirements:**\n- Real-time messaging for millions of users\n- Support for 1-on-1 and group chats\n- Message delivery guarantees\n- Online presence tracking\n- File sharing capabilities\n\n**Architecture Components:**\n\n**1. Client Applications:**\n- Mobile apps (iOS/Android)\n- Web application\n- WebSocket connections for real-time communication\n\n**2. Gateway Services:**\n- Connection management\n- Authentication and authorization\n- Protocol translation (WebSocket, HTTP)\n- Load balancing connections\n\n**3. Message Service:**\n- Message routing and delivery\n- Temporary message storage\n- Push notification triggers\n- Message ordering and deduplication\n\n**4. User Service:**\n- User profiles and contacts\n- Online/offline status\n- Authentication management\n- Friend relationships\n\n**5. Data Storage:**\n- **Message Store:** Distributed database (Cassandra/MongoDB)\n- **User Store:** Relational database (PostgreSQL)\n- **Cache:** Redis for active conversations\n- **File Storage:** Object storage (S3) for media\n\n**6. Real-time Communication:**\n- WebSocket connections\n- Message queues (Apache Kafka)\n- Pub/Sub for group messages\n- Connection persistence\n\n**7. Notification Service:**\n- Push notifications (APNs, FCM)\n- Email notifications\n- SMS fallback\n\n**Scalability Solutions:**\n- Horizontal scaling of services\n- Database sharding by user ID\n- CDN for media files\n- Connection pooling and multiplexing",
      "difficulty": "hard"
    },
    {
      "id": 102,
      "tag": "systems_design",
      "question": "Design a distributed cache system like Redis. Explain the architecture and key design decisions.",
      "answer": "**System Requirements:**\n- In-memory key-value storage\n- Sub-millisecond response times\n- High availability and fault tolerance\n- Support for various data types\n- Horizontal scalability\n\n**Core Architecture:**\n\n**1. Memory Management:**\n- Hash table for O(1) key lookups\n- Memory-efficient data structures\n- Eviction policies (LRU, LFU, TTL)\n- Memory fragmentation handling\n\n**2. Data Structures:**\n- Strings, Lists, Sets, Sorted Sets, Hashes\n- Efficient serialization/deserialization\n- Atomic operations support\n- Expiration tracking\n\n**3. Persistence:**\n- **RDB:** Point-in-time snapshots\n- **AOF:** Append-only file logging\n- Configurable persistence strategies\n- Fast restart and recovery\n\n**4. Networking:**\n- TCP server with custom protocol\n- Connection pooling\n- Pipelining support\n- Async I/O (epoll/kqueue)\n\n**5. Clustering:**\n- **Master-Slave Replication:**\n  - Asynchronous replication\n  - Automatic failover\n  - Read scaling with replicas\n\n- **Sharding (Redis Cluster):**\n  - Hash slot distribution (16384 slots)\n  - Consistent hashing\n  - Automatic resharding\n  - Client-side routing\n\n**6. High Availability:**\n- Sentinel for monitoring\n- Automatic master election\n- Health checks and alerts\n- Split-brain prevention\n\n**Key Design Decisions:**\n- Single-threaded for simplicity\n- Event-driven architecture\n- Copy-on-write for snapshots\n- Client-side sharding support",
      "difficulty": "hard"
    }
  ]
}