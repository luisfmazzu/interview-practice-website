{
  "technology": "nodejs",
  "questions": [
    {
      "id": 6000,
      "tag": "nodejs",
      "question": "What is Node.js and how does it work?",
      "answer": "Node.js is an open-source, cross-platform JavaScript runtime environment that allows developers to run JavaScript code outside of a web browser. It's built on Google Chrome's V8 JavaScript engine and enables server-side JavaScript development.\n\nKey characteristics of Node.js:\n\n**Architecture:**\n- Built on Chrome's V8 engine for fast execution\n- Uses an event-driven, non-blocking I/O model\n- Single-threaded with event loop for handling concurrent operations\n- Utilizes libuv library for asynchronous operations\n\n**How it works:**\n```javascript\n// Simple Node.js server\nconst http = require('http');\n\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'text/plain' });\n  res.end('Hello from Node.js!');\n});\n\nserver.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n```\n\n**Benefits:**\n- High performance for I/O-intensive applications\n- Same language (JavaScript) for frontend and backend\n- Large ecosystem through NPM\n- Excellent for real-time applications like chat apps, APIs\n- Fast development cycle\n\nNode.js is ideal for building scalable network applications, REST APIs, real-time applications, and microservices due to its efficient handling of concurrent requests through its event-driven architecture.",
      "keywords": ["runtime", "v8-engine", "event-driven", "non-blocking", "server-side", "javascript", "asynchronous"],
      "difficulty": "easy"
    },
    {
      "id": 6001,
      "tag": "nodejs",
      "question": "Explain the Event Loop in Node.js and how it enables non-blocking I/O.",
      "answer": "The Event Loop is the core mechanism that makes Node.js non-blocking and efficient. It's a single-threaded loop that continuously monitors and executes callbacks for completed asynchronous operations.\n\n**Event Loop Phases:**\n\n1. **Timer Phase**: Executes callbacks for setTimeout() and setInterval()\n2. **Pending Callbacks**: Executes I/O callbacks deferred to the next loop iteration\n3. **Idle, Prepare**: Internal use only\n4. **Poll Phase**: Fetches new I/O events; executes I/O callbacks\n5. **Check Phase**: Executes setImmediate() callbacks\n6. **Close Callbacks**: Executes close event callbacks\n\n**Example of non-blocking behavior:**\n```javascript\nconst fs = require('fs');\n\nconsole.log('Start');\n\n// Non-blocking file read\nfs.readFile('large-file.txt', 'utf8', (err, data) => {\n  console.log('File read complete');\n});\n\n// This executes immediately\nconsole.log('End');\n\n// Output:\n// Start\n// End\n// File read complete\n```\n\n**How it enables non-blocking I/O:**\n- When an I/O operation starts, Node.js delegates it to the system (via libuv)\n- The main thread continues executing other code\n- When I/O completes, the callback is queued in the appropriate phase\n- Event loop picks up and executes the callback\n\nThis allows Node.js to handle thousands of concurrent connections efficiently without blocking the main thread, making it perfect for I/O-intensive applications.",
      "keywords": ["event-loop", "non-blocking", "asynchronous", "callbacks", "phases", "libuv", "concurrency"],
      "difficulty": "easy"
    },
    {
      "id": 6002,
      "tag": "nodejs",
      "question": "What are the key differences between Node.js and browser JavaScript environments?",
      "answer": "While both environments run JavaScript, they serve different purposes and have distinct characteristics:\n\n**Runtime Environment:**\n```javascript\n// Node.js - Server environment\nconst fs = require('fs'); // File system access\nconst path = require('path'); // Path utilities\nprocess.env.NODE_ENV; // Environment variables\n\n// Browser - Client environment\nwindow.location.href; // Current URL\ndocument.getElementById('myDiv'); // DOM manipulation\nnavigator.userAgent; // Browser information\n```\n\n**Key Differences:**\n\n**1. Global Objects:**\n- Node.js: `global`, `process`, `Buffer`, `__dirname`, `__filename`\n- Browser: `window`, `document`, `navigator`, `localStorage`\n\n**2. APIs Available:**\n- Node.js: File system, OS utilities, networking, child processes\n- Browser: DOM, BOM, Fetch API, Web APIs, localStorage\n\n**3. Module System:**\n```javascript\n// Node.js - CommonJS (traditional)\nconst express = require('express');\nmodule.exports = { myFunction };\n\n// Browser - ES modules\nimport express from 'express';\nexport { myFunction };\n```\n\n**4. Security Model:**\n- Node.js: Full system access, no same-origin policy\n- Browser: Sandboxed, same-origin policy, limited file access\n\n**5. Purpose:**\n- Node.js: Server-side development, CLI tools, build tools\n- Browser: Client-side UI, user interactions, web applications\n\nUnderstanding these differences is crucial for writing appropriate code for each environment.",
      "keywords": ["runtime", "environment", "global-objects", "apis", "modules", "security", "server-client"],
      "difficulty": "easy"
    },
    {
      "id": 6003,
      "tag": "nodejs",
      "question": "Explain NPM and package.json. What is their role in Node.js development?",
      "answer": "NPM (Node Package Manager) is the default package manager for Node.js, providing access to the world's largest software registry. The package.json file serves as the manifest for Node.js projects.\n\n**NPM Functions:**\n- Install, update, and remove packages\n- Manage project dependencies\n- Run scripts and build processes\n- Publish and share packages\n\n**package.json Structure:**\n```json\n{\n  \"name\": \"my-node-app\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A sample Node.js application\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"dev\": \"nodemon index.js\",\n    \"test\": \"jest\"\n  },\n  \"dependencies\": {\n    \"express\": \"^4.18.2\",\n    \"mongoose\": \"^7.0.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.22\",\n    \"jest\": \"^29.5.0\"\n  },\n  \"engines\": {\n    \"node\": \">=14.0.0\"\n  }\n}\n```\n\n**Common NPM Commands:**\n```bash\nnpm init                 # Create package.json\nnpm install express      # Install dependency\nnpm install --save-dev jest  # Install dev dependency\nnpm run start           # Run script\nnpm update              # Update dependencies\nnpm audit               # Security audit\n```\n\n**Dependency Types:**\n- **dependencies**: Required for production\n- **devDependencies**: Only needed for development\n- **peerDependencies**: Expected to be provided by parent project\n\n**Benefits:**\n- Standardized project structure\n- Easy dependency management\n- Version control and semantic versioning\n- Script automation\n- Metadata storage\n\nThe package.json file makes projects portable and ensures consistent environments across different machines.",
      "keywords": ["npm", "package-json", "dependencies", "scripts", "package-manager", "versioning", "modules"],
      "difficulty": "easy"
    },
    {
      "id": 6004,
      "tag": "nodejs",
      "question": "What's the difference between require() and import in Node.js? When should you use each?",
      "answer": "Node.js supports two module systems: CommonJS (using require()) and ES Modules (using import/export). Understanding their differences is crucial for modern Node.js development.\n\n**CommonJS (require()):**\n```javascript\n// Importing\nconst fs = require('fs');\nconst { readFile } = require('fs');\nconst express = require('express');\n\n// Exporting\nmodule.exports = {\n  myFunction: () => console.log('Hello')\n};\n\n// Or\nexports.myFunction = () => console.log('Hello');\n```\n\n**ES Modules (import/export):**\n```javascript\n// Importing\nimport fs from 'fs';\nimport { readFile } from 'fs';\nimport express from 'express';\n\n// Exporting\nexport const myFunction = () => console.log('Hello');\nexport default { myFunction };\n```\n\n**Key Differences:**\n\n**1. Loading Behavior:**\n- require(): Synchronous, loads at runtime\n- import: Asynchronous, static analysis at compile time\n\n**2. Conditional Loading:**\n```javascript\n// CommonJS - Works\nif (condition) {\n  const module = require('./module');\n}\n\n// ES Modules - Doesn't work\nif (condition) {\n  import module from './module'; // Error!\n}\n```\n\n**3. File Extensions:**\n- CommonJS: Default in .js files\n- ES Modules: Requires .mjs files or \"type\": \"module\" in package.json\n\n**4. Top-level await:**\n```javascript\n// ES Modules only\nconst data = await fetch('/api/data');\n```\n\n**When to use:**\n- **CommonJS**: Legacy projects, dynamic imports, Node.js built-ins\n- **ES Modules**: Modern projects, better tree-shaking, standardized syntax\n\nES Modules are the future standard, but CommonJS remains widely used and supported.",
      "keywords": ["require", "import", "commonjs", "es-modules", "module-system", "export", "dynamic-import"],
      "difficulty": "easy"
    },
    {
      "id": 6005,
      "tag": "nodejs",
      "question": "Explain asynchronous programming in Node.js with callbacks. What are callback patterns and potential issues?",
      "answer": "Callbacks are the foundation of asynchronous programming in Node.js. A callback is a function passed as an argument to another function and executed after an operation completes.\n\n**Basic Callback Pattern:**\n```javascript\nconst fs = require('fs');\n\n// Error-first callback convention\nfs.readFile('data.txt', 'utf8', (error, data) => {\n  if (error) {\n    console.error('Error reading file:', error);\n    return;\n  }\n  console.log('File contents:', data);\n});\n```\n\n**Common Callback Patterns:**\n\n**1. Error-First Callbacks:**\n```javascript\nfunction processData(data, callback) {\n  setTimeout(() => {\n    try {\n      const result = data.toUpperCase();\n      callback(null, result); // Success: error=null, result provided\n    } catch (error) {\n      callback(error); // Error: pass error as first argument\n    }\n  }, 1000);\n}\n\nprocessData('hello', (error, result) => {\n  if (error) {\n    console.error(error);\n  } else {\n    console.log(result); // 'HELLO'\n  }\n});\n```\n\n**2. Callback Hell:**\n```javascript\n// Problematic nested callbacks\nfs.readFile('file1.txt', (err1, data1) => {\n  if (err1) throw err1;\n  fs.readFile('file2.txt', (err2, data2) => {\n    if (err2) throw err2;\n    fs.writeFile('output.txt', data1 + data2, (err3) => {\n      if (err3) throw err3;\n      console.log('Files merged!');\n    });\n  });\n});\n```\n\n**Issues with Callbacks:**\n- **Callback Hell**: Deep nesting makes code hard to read\n- **Error Handling**: Multiple error checking points\n- **Inversion of Control**: Callback execution depends on calling function\n\n**Solutions:**\n- Named functions instead of anonymous callbacks\n- Promises and async/await\n- Modular code organization\n\nWhile callbacks are fundamental to Node.js, modern development often uses Promises and async/await for better readability.",
      "keywords": ["callbacks", "asynchronous", "error-first", "callback-hell", "non-blocking", "event-driven"],
      "difficulty": "easy"
    },
    {
      "id": 6006,
      "tag": "nodejs",
      "question": "Explain Streams in Node.js. What are the different types and how do you use them effectively?",
      "answer": "Streams are Node.js objects that handle reading or writing data continuously, piece by piece, rather than loading everything into memory at once. They're perfect for handling large datasets efficiently.\n\n**Types of Streams:**\n\n**1. Readable Streams:**\n```javascript\nconst fs = require('fs');\nconst { Readable } = require('stream');\n\n// File readable stream\nconst readStream = fs.createReadStream('large-file.txt');\nreadStream.on('data', (chunk) => {\n  console.log('Received chunk:', chunk.length, 'bytes');\n});\nreadStream.on('end', () => console.log('Reading complete'));\n\n// Custom readable stream\nclass NumberStream extends Readable {\n  constructor(max) {\n    super();\n    this.max = max;\n    this.current = 0;\n  }\n  \n  _read() {\n    if (this.current < this.max) {\n      this.push(String(this.current++));\n    } else {\n      this.push(null); // Signal end\n    }\n  }\n}\n```\n\n**2. Writable Streams:**\n```javascript\nconst fs = require('fs');\nconst { Writable } = require('stream');\n\n// File writable stream\nconst writeStream = fs.createWriteStream('output.txt');\nwriteStream.write('Hello ');\nwriteStream.write('World!');\nwriteStream.end();\n\n// Custom writable stream\nclass LogStream extends Writable {\n  _write(chunk, encoding, callback) {\n    console.log(`[LOG] ${chunk.toString()}`);\n    callback();\n  }\n}\n```\n\n**3. Duplex Streams:**\n```javascript\nconst { Duplex } = require('stream');\n\nclass EchoStream extends Duplex {\n  _read() {}\n  \n  _write(chunk, encoding, callback) {\n    this.push(chunk); // Echo back what was written\n    callback();\n  }\n}\n```\n\n**4. Transform Streams:**\n```javascript\nconst { Transform } = require('stream');\n\nclass UppercaseTransform extends Transform {\n  _transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n}\n\n// Usage with piping\nfs.createReadStream('input.txt')\n  .pipe(new UppercaseTransform())\n  .pipe(fs.createWriteStream('output.txt'));\n```\n\n**Stream Benefits:**\n- Memory efficiency for large files\n- Time efficiency (start processing before full data loads)\n- Composability through piping\n- Backpressure handling\n\n**Best Practices:**\n- Always handle error events\n- Use pipeline() for better error handling\n- Consider stream performance characteristics\n- Use appropriate highWaterMark for buffer size\n\nStreams are essential for building scalable Node.js applications that handle large amounts of data efficiently.",
      "keywords": ["streams", "readable", "writable", "duplex", "transform", "piping", "memory-efficient", "backpressure"],
      "difficulty": "medium"
    },
    {
      "id": 6007,
      "tag": "nodejs",
      "question": "How do child processes and clustering work in Node.js? When and how should you implement them?",
      "answer": "Node.js provides child processes and clustering to utilize multiple CPU cores and handle CPU-intensive tasks, overcoming the single-threaded limitation of the main event loop.\n\n**Child Processes:**\n\n**1. spawn() - For streaming data:**\n```javascript\nconst { spawn } = require('child_process');\n\n// Execute shell command\nconst ls = spawn('ls', ['-la']);\n\nls.stdout.on('data', (data) => {\n  console.log(`stdout: ${data}`);\n});\n\nls.stderr.on('data', (data) => {\n  console.error(`stderr: ${data}`);\n});\n\nls.on('close', (code) => {\n  console.log(`Process exited with code ${code}`);\n});\n```\n\n**2. exec() - For simple commands:**\n```javascript\nconst { exec } = require('child_process');\n\nexec('pwd', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error}`);\n    return;\n  }\n  console.log(`Current directory: ${stdout}`);\n});\n```\n\n**3. fork() - For Node.js scripts:**\n```javascript\n// parent.js\nconst { fork } = require('child_process');\n\nconst worker = fork('./worker.js');\nworker.send({ task: 'heavy-computation', data: [1,2,3,4,5] });\n\nworker.on('message', (result) => {\n  console.log('Result from worker:', result);\n});\n\n// worker.js\nprocess.on('message', (msg) => {\n  if (msg.task === 'heavy-computation') {\n    const result = msg.data.reduce((sum, num) => sum + num * num, 0);\n    process.send({ result });\n  }\n});\n```\n\n**Clustering:**\n```javascript\nconst cluster = require('cluster');\nconst http = require('http');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n  \n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork(); // Restart worker\n  });\n  \n} else {\n  // Workers share the same port\n  http.createServer((req, res) => {\n    res.writeHead(200);\n    res.end(`Hello from worker ${process.pid}\\n`);\n  }).listen(8000);\n  \n  console.log(`Worker ${process.pid} started`);\n}\n```\n\n**Load Balancing with PM2:**\n```javascript\n// ecosystem.config.js\nmodule.exports = {\n  apps: [{\n    name: 'my-app',\n    script: './app.js',\n    instances: 'max', // Use all CPU cores\n    exec_mode: 'cluster'\n  }]\n};\n```\n\n**When to Use:**\n- **Child Processes**: CPU-intensive tasks, external commands, isolation\n- **Clustering**: Web servers, API services, maximizing throughput\n\n**Best Practices:**\n- Monitor worker health and restart failed processes\n- Use message passing for communication\n- Consider memory usage per process\n- Implement graceful shutdowns\n- Use process managers like PM2 for production\n\nProper implementation significantly improves application performance and reliability.",
      "keywords": ["child-processes", "clustering", "spawn", "fork", "exec", "workers", "cpu-intensive", "scalability"],
      "difficulty": "medium"
    },
    {
      "id": 6008,
      "tag": "nodejs",
      "question": "Explain error handling strategies in Node.js. How do you handle errors in different scenarios?",
      "answer": "Effective error handling in Node.js requires understanding different error types and implementing appropriate strategies for each scenario.\n\n**Error Types in Node.js:**\n\n**1. Synchronous Errors (try-catch):**\n```javascript\ntry {\n  const data = JSON.parse(invalidJSON);\n} catch (error) {\n  console.error('JSON parsing error:', error.message);\n}\n\n// Custom error classes\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateUser(user) {\n  if (!user.email) {\n    throw new ValidationError('Email is required');\n  }\n}\n```\n\n**2. Asynchronous Errors (callbacks):**\n```javascript\nconst fs = require('fs');\n\n// Error-first callback pattern\nfs.readFile('nonexistent.txt', (error, data) => {\n  if (error) {\n    console.error('File read error:', error.code);\n    return;\n  }\n  console.log(data);\n});\n\n// Centralized error handling function\nfunction handleFileError(error, filename) {\n  switch (error.code) {\n    case 'ENOENT':\n      console.error(`File not found: ${filename}`);\n      break;\n    case 'EACCES':\n      console.error(`Permission denied: ${filename}`);\n      break;\n    default:\n      console.error(`Unexpected error: ${error.message}`);\n  }\n}\n```\n\n**3. Promise/Async-Await Errors:**\n```javascript\n// Promise chain error handling\nfetchUserData(userId)\n  .then(user => processUser(user))\n  .catch(error => {\n    console.error('User processing failed:', error);\n  });\n\n// Async/await with try-catch\nasync function handleUser(userId) {\n  try {\n    const user = await fetchUserData(userId);\n    const processed = await processUser(user);\n    return processed;\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      console.error('Validation failed:', error.message);\n    } else {\n      console.error('Unexpected error:', error);\n    }\n    throw error; // Re-throw if needed\n  }\n}\n```\n\n**4. Global Error Handling:**\n```javascript\n// Uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n  // Graceful shutdown\n  process.exit(1);\n});\n\n// Unhandled promise rejections\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  // Handle the error appropriately\n});\n```\n\n**Express.js Error Middleware:**\n```javascript\n// Error handling middleware\napp.use((error, req, res, next) => {\n  console.error(error.stack);\n  \n  if (error instanceof ValidationError) {\n    return res.status(400).json({ error: error.message });\n  }\n  \n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Async route error handling\napp.get('/user/:id', async (req, res, next) => {\n  try {\n    const user = await User.findById(req.params.id);\n    res.json(user);\n  } catch (error) {\n    next(error); // Pass to error middleware\n  }\n});\n```\n\n**Best Practices:**\n- Always handle errors explicitly\n- Use appropriate error types for different scenarios\n- Log errors with sufficient context\n- Implement graceful degradation\n- Monitor and alert on critical errors\n- Never ignore errors silently\n\nProper error handling improves application reliability and debugging efficiency.",
      "keywords": ["error-handling", "try-catch", "callbacks", "promises", "async-await", "uncaught-exceptions", "middleware"],
      "difficulty": "medium"
    },
    {
      "id": 6009,
      "tag": "nodejs",
      "question": "What is Buffer in Node.js and how do you work with binary data? When should you use Buffers?",
      "answer": "Buffer is a Node.js global class for handling binary data directly. Since JavaScript strings are UTF-16 encoded and not suitable for binary data, Buffers provide a way to work with raw binary data efficiently.\n\n**Creating Buffers:**\n```javascript\n// Different ways to create buffers\nconst buf1 = Buffer.from('Hello World', 'utf8');\nconst buf2 = Buffer.from([72, 101, 108, 108, 111]); // From array\nconst buf3 = Buffer.alloc(10); // Allocate 10 bytes (filled with zeros)\nconst buf4 = Buffer.allocUnsafe(10); // Faster but contains arbitrary data\n\nconsole.log(buf1); // <Buffer 48 65 6c 6c 6f 20 57 6f 72 6c 64>\nconsole.log(buf1.toString()); // 'Hello World'\nconsole.log(buf1.length); // 11 bytes\n```\n\n**Buffer Operations:**\n```javascript\nconst buffer = Buffer.from('Node.js Buffer Example');\n\n// Reading data\nconsole.log(buffer[0]); // 78 (ASCII code for 'N')\nconsole.log(buffer.readUInt8(0)); // 78\nconsole.log(buffer.slice(0, 4).toString()); // 'Node'\n\n// Writing data\nconst writeBuffer = Buffer.alloc(10);\nwriteBuffer.writeUInt8(65, 0); // Write 'A' at position 0\nwriteBuffer.write('Hello', 1); // Write string starting at position 1\nconsole.log(writeBuffer.toString()); // 'AHello'\n\n// Buffer manipulation\nconst buf1 = Buffer.from('Hello ');\nconst buf2 = Buffer.from('World');\nconst combined = Buffer.concat([buf1, buf2]);\nconsole.log(combined.toString()); // 'Hello World'\n```\n\n**Working with Different Data Types:**\n```javascript\nconst buffer = Buffer.alloc(8);\n\n// Write different numeric types\nbuffer.writeInt32BE(0x12345678, 0); // Big-endian 32-bit int\nbuffer.writeInt32LE(0x12345678, 4); // Little-endian 32-bit int\n\nconsole.log(buffer.readInt32BE(0)); // 305419896\nconsole.log(buffer.readInt32LE(4)); // 305419896\n\n// Working with floats\nconst floatBuffer = Buffer.alloc(8);\nfloatBuffer.writeDoubleLE(3.14159, 0);\nconsole.log(floatBuffer.readDoubleLE(0)); // 3.14159\n```\n\n**File Operations with Buffers:**\n```javascript\nconst fs = require('fs');\n\n// Reading binary file\nfs.readFile('image.png', (err, buffer) => {\n  if (err) throw err;\n  \n  console.log('File size:', buffer.length, 'bytes');\n  console.log('First 4 bytes:', buffer.slice(0, 4));\n  \n  // Check PNG signature\n  const pngSignature = Buffer.from([0x89, 0x50, 0x4E, 0x47]);\n  if (buffer.slice(0, 4).equals(pngSignature)) {\n    console.log('Valid PNG file');\n  }\n});\n\n// Creating binary data\nconst binaryData = Buffer.from([\n  0xFF, 0xD8, 0xFF, 0xE0, // JPEG header\n  0x00, 0x10, 0x4A, 0x46\n]);\n\nfs.writeFile('sample.jpg', binaryData, (err) => {\n  if (err) throw err;\n  console.log('Binary file written');\n});\n```\n\n**Buffer vs String Performance:**\n```javascript\n// Buffer is more efficient for binary operations\nconst iterations = 1000000;\nconst data = 'Hello World'.repeat(100);\n\n// String approach (slower)\nconsole.time('String');\nfor (let i = 0; i < iterations; i++) {\n  const encoded = Buffer.from(data, 'utf8').toString('base64');\n}\nconsole.timeEnd('String');\n\n// Buffer approach (faster)\nconst buffer = Buffer.from(data, 'utf8');\nconsole.time('Buffer');\nfor (let i = 0; i < iterations; i++) {\n  const encoded = buffer.toString('base64');\n}\nconsole.timeEnd('Buffer');\n```\n\n**When to Use Buffers:**\n- File I/O operations (images, videos, documents)\n- Network protocols and binary data transmission\n- Cryptographic operations\n- Performance-critical binary data processing\n- Interfacing with C++ addons\n\nBuffers are essential for any Node.js application dealing with binary data, providing efficient memory management and direct byte-level control.",
      "keywords": ["buffer", "binary-data", "encoding", "file-io", "performance", "bytes", "memory-management"],
      "difficulty": "medium"
    },
    {
      "id": 6010,
      "tag": "nodejs",
      "question": "How do you work with the File System (fs) module in Node.js? What are the differences between synchronous and asynchronous methods?",
      "answer": "The File System (fs) module provides APIs for interacting with the file system in Node.js. It offers both synchronous and asynchronous methods for file operations.\n\n**Asynchronous File Operations (Recommended):**\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\n// Reading files\nfs.readFile('data.txt', 'utf8', (err, data) => {\n  if (err) {\n    console.error('Error reading file:', err);\n    return;\n  }\n  console.log('File contents:', data);\n});\n\n// Writing files\nconst content = 'Hello, Node.js File System!';\nfs.writeFile('output.txt', content, 'utf8', (err) => {\n  if (err) {\n    console.error('Error writing file:', err);\n    return;\n  }\n  console.log('File written successfully');\n});\n\n// Checking file existence\nfs.access('myfile.txt', fs.constants.F_OK, (err) => {\n  if (err) {\n    console.log('File does not exist');\n  } else {\n    console.log('File exists');\n  }\n});\n```\n\n**Synchronous File Operations:**\n```javascript\n// Reading files synchronously\ntry {\n  const data = fs.readFileSync('data.txt', 'utf8');\n  console.log('File contents:', data);\n} catch (err) {\n  console.error('Error reading file:', err);\n}\n\n// Writing files synchronously\ntry {\n  fs.writeFileSync('output.txt', 'Synchronous write', 'utf8');\n  console.log('File written successfully');\n} catch (err) {\n  console.error('Error writing file:', err);\n}\n```\n\n**Promise-based Operations:**\n```javascript\nconst fs = require('fs').promises;\n\nasync function fileOperations() {\n  try {\n    // Read file\n    const data = await fs.readFile('data.txt', 'utf8');\n    console.log('File contents:', data);\n    \n    // Write file\n    await fs.writeFile('output.txt', data.toUpperCase(), 'utf8');\n    \n    // Get file stats\n    const stats = await fs.stat('output.txt');\n    console.log('File size:', stats.size, 'bytes');\n    \n  } catch (err) {\n    console.error('File operation failed:', err);\n  }\n}\n```\n\n**Directory Operations:**\n```javascript\n// Create directory\nfs.mkdir('new-folder', { recursive: true }, (err) => {\n  if (err) throw err;\n  console.log('Directory created');\n});\n\n// Read directory contents\nfs.readdir('.', (err, files) => {\n  if (err) throw err;\n  console.log('Directory contents:', files);\n});\n```\n\n**Key Differences:**\n- **Asynchronous**: Non-blocking, better for I/O-heavy applications, uses callbacks/promises\n- **Synchronous**: Blocking, simpler code but can freeze the event loop\n- **Use async for web servers**, sync for build scripts and CLI tools\n\nAsynchronous methods are generally preferred to maintain Node.js's non-blocking nature.",
      "keywords": ["file-system", "fs-module", "async", "sync", "promises", "file-operations", "directory"],
      "difficulty": "easy"
    },
    {
      "id": 6011,
      "tag": "nodejs",
      "question": "How do you create HTTP servers and handle requests using Node.js's built-in http module?",
      "answer": "The http module is Node.js's core module for creating HTTP servers and handling web requests. It provides the foundation for building web applications and APIs.\n\n**Creating a Basic HTTP Server:**\n```javascript\nconst http = require('http');\nconst url = require('url');\n\n// Create server\nconst server = http.createServer((req, res) => {\n  // Parse URL\n  const parsedUrl = url.parse(req.url, true);\n  const pathname = parsedUrl.pathname;\n  const method = req.method;\n  \n  // Set response headers\n  res.setHeader('Content-Type', 'application/json');\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  \n  // Handle different routes\n  if (pathname === '/' && method === 'GET') {\n    res.statusCode = 200;\n    res.end(JSON.stringify({ message: 'Welcome to Node.js server!' }));\n    \n  } else if (pathname === '/api/users' && method === 'GET') {\n    res.statusCode = 200;\n    res.end(JSON.stringify({ users: ['Alice', 'Bob', 'Charlie'] }));\n    \n  } else {\n    res.statusCode = 404;\n    res.end(JSON.stringify({ error: 'Route not found' }));\n  }\n});\n\n// Start server\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`Server running on http://localhost:${PORT}`);\n});\n```\n\n**Handling POST Requests with Body Data:**\n```javascript\nconst server = http.createServer((req, res) => {\n  if (req.method === 'POST' && req.url === '/api/data') {\n    let body = '';\n    \n    // Collect data chunks\n    req.on('data', (chunk) => {\n      body += chunk.toString();\n    });\n    \n    // Process complete request\n    req.on('end', () => {\n      try {\n        const data = JSON.parse(body);\n        \n        // Process the data\n        const response = {\n          received: data,\n          timestamp: new Date().toISOString()\n        };\n        \n        res.setHeader('Content-Type', 'application/json');\n        res.statusCode = 200;\n        res.end(JSON.stringify(response));\n        \n      } catch (error) {\n        res.statusCode = 400;\n        res.end(JSON.stringify({ error: 'Invalid JSON' }));\n      }\n    });\n  }\n});\n```\n\n**Advanced Server Features:**\n```javascript\nconst server = http.createServer((req, res) => {\n  // Log requests\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n  \n  // Handle CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  // Handle preflight requests\n  if (req.method === 'OPTIONS') {\n    res.statusCode = 204;\n    res.end();\n    return;\n  }\n  \n  // File serving\n  if (req.url.startsWith('/static/')) {\n    const fs = require('fs');\n    const path = require('path');\n    \n    const filePath = path.join(__dirname, req.url);\n    fs.readFile(filePath, (err, data) => {\n      if (err) {\n        res.statusCode = 404;\n        res.end('File not found');\n      } else {\n        res.statusCode = 200;\n        res.end(data);\n      }\n    });\n  }\n});\n```\n\n**Error Handling and Graceful Shutdown:**\n```javascript\nserver.on('error', (err) => {\n  console.error('Server error:', err);\n});\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('Received SIGTERM, shutting down gracefully');\n  server.close(() => {\n    console.log('Process terminated');\n  });\n});\n```\n\n**Making HTTP Requests:**\n```javascript\n// Making HTTP requests\nconst options = {\n  hostname: 'api.example.com',\n  port: 443,\n  path: '/users',\n  method: 'GET',\n  headers: {\n    'Authorization': 'Bearer token123'\n  }\n};\n\nconst req = http.request(options, (res) => {\n  let data = '';\n  \n  res.on('data', (chunk) => {\n    data += chunk;\n  });\n  \n  res.on('end', () => {\n    console.log(JSON.parse(data));\n  });\n});\n\nreq.on('error', (err) => {\n  console.error('Request failed:', err);\n});\n\nreq.end();\n```\n\nThe http module provides the foundation for web development in Node.js, though frameworks like Express.js are commonly used for more complex applications.",
      "keywords": ["http-module", "server", "requests", "responses", "routing", "post-data", "cors"],
      "difficulty": "easy"
    },
    {
      "id": 6012,
      "tag": "nodejs",
      "question": "How do you work with environment variables and process.env in Node.js? What are best practices for configuration management?",
      "answer": "Environment variables provide a way to configure Node.js applications without hardcoding values. The process.env object contains all environment variables available to the Node.js process.\n\n**Accessing Environment Variables:**\n```javascript\n// Reading environment variables\nconst port = process.env.PORT || 3000;\nconst dbUrl = process.env.DATABASE_URL || 'mongodb://localhost:27017/myapp';\nconst nodeEnv = process.env.NODE_ENV || 'development';\nconst apiKey = process.env.API_KEY;\n\nconsole.log('Server port:', port);\nconsole.log('Environment:', nodeEnv);\n\n// Check if required variables are set\nif (!apiKey) {\n  console.error('API_KEY environment variable is required');\n  process.exit(1);\n}\n```\n\n**Using .env Files with dotenv:**\n```javascript\n// Install: npm install dotenv\nrequire('dotenv').config();\n\n// Or load from custom path\nrequire('dotenv').config({ path: './config/.env' });\n\n// .env file contents:\n// PORT=3000\n// DATABASE_URL=mongodb://localhost:27017/myapp\n// JWT_SECRET=your-secret-key\n// NODE_ENV=development\n// API_KEY=your-api-key\n\nconst config = {\n  port: process.env.PORT,\n  database: {\n    url: process.env.DATABASE_URL,\n    maxConnections: parseInt(process.env.DB_MAX_CONNECTIONS) || 10\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: process.env.JWT_EXPIRES_IN || '1h'\n  },\n  environment: process.env.NODE_ENV\n};\n\nmodule.exports = config;\n```\n\n**Configuration Validation:**\n```javascript\nconst requiredEnvVars = ['DATABASE_URL', 'JWT_SECRET', 'API_KEY'];\n\n// Validate required environment variables\nfunction validateEnvironment() {\n  const missing = requiredEnvVars.filter(varName => !process.env[varName]);\n  \n  if (missing.length > 0) {\n    console.error('Missing required environment variables:');\n    missing.forEach(varName => console.error(`- ${varName}`));\n    process.exit(1);\n  }\n}\n\nvalidateEnvironment();\n```\n\n**Environment-Specific Configuration:**\n```javascript\nclass Config {\n  constructor() {\n    this.env = process.env.NODE_ENV || 'development';\n    this.port = process.env.PORT || 3000;\n    this.database = this.getDatabaseConfig();\n    this.logging = this.getLoggingConfig();\n  }\n  \n  getDatabaseConfig() {\n    const base = {\n      host: process.env.DB_HOST || 'localhost',\n      port: parseInt(process.env.DB_PORT) || 5432,\n      database: process.env.DB_NAME || 'myapp'\n    };\n    \n    if (this.env === 'production') {\n      return {\n        ...base,\n        ssl: true,\n        pool: {\n          min: 5,\n          max: 20\n        }\n      };\n    }\n    \n    return {\n      ...base,\n      ssl: false,\n      pool: {\n        min: 1,\n        max: 5\n      }\n    };\n  }\n  \n  getLoggingConfig() {\n    return {\n      level: process.env.LOG_LEVEL || (this.env === 'production' ? 'info' : 'debug'),\n      format: this.env === 'production' ? 'json' : 'simple'\n    };\n  }\n  \n  isProduction() {\n    return this.env === 'production';\n  }\n  \n  isDevelopment() {\n    return this.env === 'development';\n  }\n}\n\nmodule.exports = new Config();\n```\n\n**Type Conversion and Defaults:**\n```javascript\n// Helper functions for type conversion\nfunction getEnvAsNumber(name, defaultValue) {\n  const value = process.env[name];\n  if (value === undefined) return defaultValue;\n  const parsed = parseInt(value, 10);\n  if (isNaN(parsed)) {\n    throw new Error(`Environment variable ${name} must be a number`);\n  }\n  return parsed;\n}\n\nfunction getEnvAsBoolean(name, defaultValue = false) {\n  const value = process.env[name];\n  if (value === undefined) return defaultValue;\n  return value.toLowerCase() === 'true';\n}\n\nfunction getEnvAsArray(name, delimiter = ',', defaultValue = []) {\n  const value = process.env[name];\n  if (value === undefined) return defaultValue;\n  return value.split(delimiter).map(item => item.trim());\n}\n\n// Usage\nconst config = {\n  port: getEnvAsNumber('PORT', 3000),\n  debug: getEnvAsBoolean('DEBUG', false),\n  allowedOrigins: getEnvAsArray('ALLOWED_ORIGINS', ',', ['*']),\n  workers: getEnvAsNumber('WORKERS', require('os').cpus().length)\n};\n```\n\n**Best Practices:**\n- Never commit .env files to version control\n- Use .env.example to document required variables\n- Validate required environment variables on startup\n- Use consistent naming conventions (UPPER_SNAKE_CASE)\n- Provide sensible defaults for non-sensitive values\n- Keep production secrets secure and rotate regularly\n- Use configuration management tools for complex deployments\n\nProper environment variable management is crucial for secure and maintainable Node.js applications.",
      "keywords": ["environment-variables", "process-env", "dotenv", "configuration", "validation", "deployment"],
      "difficulty": "easy"
    },
    {
      "id": 6013,
      "tag": "nodejs",
      "question": "How do you use the Path module for file path operations in Node.js? What are common use cases and platform considerations?",
      "answer": "The Path module provides utilities for working with file and directory paths in a platform-independent way. It handles differences between Windows and Unix-like systems automatically.\n\n**Basic Path Operations:**\n```javascript\nconst path = require('path');\n\n// Path joining and resolution\nconst fullPath = path.join('/users', 'john', 'documents', 'file.txt');\nconsole.log(fullPath); // /users/john/documents/file.txt\n\n// Resolve to absolute path\nconst absolutePath = path.resolve('src', 'components', 'Header.js');\nconsole.log(absolutePath); // /current/working/directory/src/components/Header.js\n\n// Current file directory (commonly used pattern)\nconst currentDir = __dirname;\nconst configPath = path.join(__dirname, 'config', 'database.json');\nconst publicDir = path.join(__dirname, '..', 'public');\n```\n\n**Path Parsing and Information:**\n```javascript\nconst filePath = '/home/user/documents/report.pdf';\n\n// Parse path into components\nconst parsed = path.parse(filePath);\nconsole.log(parsed);\n// {\n//   root: '/',\n//   dir: '/home/user/documents',\n//   base: 'report.pdf',\n//   ext: '.pdf',\n//   name: 'report'\n// }\n\n// Get specific parts\nconsole.log(path.dirname(filePath));  // '/home/user/documents'\nconsole.log(path.basename(filePath)); // 'report.pdf'\nconsole.log(path.basename(filePath, '.pdf')); // 'report'\nconsole.log(path.extname(filePath));  // '.pdf'\n```\n\n**Platform-Independent Path Handling:**\n```javascript\n// Path separators\nconsole.log(path.sep); // '/' on Unix, '\\\\' on Windows\nconsole.log(path.delimiter); // ':' on Unix, ';' on Windows\n\n// Build paths correctly for any platform\nconst crossPlatformPath = path.join('src', 'utils', 'helper.js');\n// Results in 'src/utils/helper.js' on Unix\n// Results in 'src\\\\utils\\\\helper.js' on Windows\n\n// Normalize paths\nconst messyPath = '/users//john/../jane/./documents';\nconsole.log(path.normalize(messyPath)); // '/users/jane/documents'\n```\n\n**Common Use Cases:**\n\n**1. Module and File Loading:**\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\n// Load configuration file\nfunction loadConfig(filename) {\n  const configPath = path.join(__dirname, 'config', filename);\n  \n  if (!fs.existsSync(configPath)) {\n    throw new Error(`Config file not found: ${configPath}`);\n  }\n  \n  return JSON.parse(fs.readFileSync(configPath, 'utf8'));\n}\n\n// Static file serving\nfunction serveStaticFile(req, res) {\n  const requestedPath = req.url.replace(/\\.\\.\\//g, ''); // Security: prevent directory traversal\n  const filePath = path.join(__dirname, 'public', requestedPath);\n  \n  // Ensure file is within public directory\n  const publicDir = path.join(__dirname, 'public');\n  const resolvedPath = path.resolve(filePath);\n  \n  if (!resolvedPath.startsWith(publicDir)) {\n    res.statusCode = 403;\n    res.end('Forbidden');\n    return;\n  }\n  \n  fs.readFile(filePath, (err, data) => {\n    if (err) {\n      res.statusCode = 404;\n      res.end('File not found');\n    } else {\n      res.end(data);\n    }\n  });\n}\n```\n\n**2. Build Tools and File Processing:**\n```javascript\nconst path = require('path');\nconst fs = require('fs');\n\n// Process multiple files\nfunction processFiles(sourceDir, outputDir, processor) {\n  const files = fs.readdirSync(sourceDir);\n  \n  files.forEach(filename => {\n    const inputPath = path.join(sourceDir, filename);\n    const outputPath = path.join(outputDir, \n      path.basename(filename, path.extname(filename)) + '.processed' + path.extname(filename)\n    );\n    \n    const content = fs.readFileSync(inputPath, 'utf8');\n    const processed = processor(content);\n    fs.writeFileSync(outputPath, processed);\n    \n    console.log(`Processed: ${filename} -> ${path.basename(outputPath)}`);\n  });\n}\n\n// Template engine helper\nfunction resolveTemplatePath(templateName, templateDir = 'views') {\n  const templatePath = path.join(__dirname, templateDir, templateName);\n  \n  // Try different extensions\n  const extensions = ['.hbs', '.ejs', '.pug', '.html'];\n  \n  for (const ext of extensions) {\n    const fullPath = templatePath + ext;\n    if (fs.existsSync(fullPath)) {\n      return fullPath;\n    }\n  }\n  \n  throw new Error(`Template not found: ${templateName}`);\n}\n```\n\n**3. URL to File System Mapping:**\n```javascript\n// Convert URL paths to file system paths safely\nfunction urlToFilePath(urlPath, baseDir) {\n  // Remove query string and decode URI\n  const cleanPath = decodeURIComponent(urlPath.split('?')[0]);\n  \n  // Remove leading slash and join with base directory\n  const relativePath = cleanPath.replace(/^\\/+/, '');\n  const filePath = path.join(baseDir, relativePath);\n  \n  // Ensure the resolved path is within the base directory\n  const resolvedBase = path.resolve(baseDir);\n  const resolvedFile = path.resolve(filePath);\n  \n  if (!resolvedFile.startsWith(resolvedBase + path.sep)) {\n    throw new Error('Path traversal attempt detected');\n  }\n  \n  return resolvedFile;\n}\n```\n\n**Security Considerations:**\n```javascript\n// Prevent directory traversal attacks\nfunction sanitizePath(userInput, baseDir) {\n  // Remove dangerous patterns\n  const cleaned = userInput.replace(/\\.\\.\\//g, '').replace(/\\.\\.\\\\\\)/g, '');\n  \n  const fullPath = path.join(baseDir, cleaned);\n  const resolvedPath = path.resolve(fullPath);\n  const resolvedBase = path.resolve(baseDir);\n  \n  // Ensure path stays within base directory\n  if (!resolvedPath.startsWith(resolvedBase + path.sep)) {\n    throw new Error('Invalid path');\n  }\n  \n  return resolvedPath;\n}\n```\n\nThe Path module is essential for building cross-platform Node.js applications that handle file operations correctly across different operating systems.",
      "keywords": ["path-module", "file-paths", "cross-platform", "directory", "basename", "extname", "join", "resolve"],
      "difficulty": "easy"
    },
    {
      "id": 6014,
      "tag": "nodejs",
      "question": "How do you use the OS module to gather system information in Node.js? What system details can you access?",
      "answer": "The OS module provides operating system-related utilities that allow Node.js applications to gather system information, monitor resources, and make platform-specific decisions.\n\n**Basic System Information:**\n```javascript\nconst os = require('os');\n\n// Platform information\nconsole.log('Platform:', os.platform()); // 'darwin', 'linux', 'win32'\nconsole.log('Architecture:', os.arch()); // 'x64', 'arm64', 'x32'\nconsole.log('Release:', os.release()); // OS version\nconsole.log('Type:', os.type()); // 'Linux', 'Darwin', 'Windows_NT'\n\n// Host information\nconsole.log('Hostname:', os.hostname());\nconsole.log('Username:', os.userInfo().username);\nconsole.log('Home directory:', os.homedir());\nconsole.log('Temp directory:', os.tmpdir());\n```\n\n**CPU Information:**\n```javascript\nconst cpus = os.cpus();\nconsole.log(`CPU Cores: ${cpus.length}`);\nconsole.log('CPU Model:', cpus[0].model);\nconsole.log('CPU Speed:', cpus[0].speed, 'MHz');\n\n// Detailed CPU information\ncpus.forEach((cpu, index) => {\n  console.log(`Core ${index}:`);\n  console.log('  Model:', cpu.model);\n  console.log('  Speed:', cpu.speed, 'MHz');\n  console.log('  Times:', cpu.times);\n});\n\n// Calculate CPU usage\nfunction getCPUUsage() {\n  const cpus = os.cpus();\n  let totalIdle = 0;\n  let totalTick = 0;\n  \n  cpus.forEach(cpu => {\n    for (type in cpu.times) {\n      totalTick += cpu.times[type];\n    }\n    totalIdle += cpu.times.idle;\n  });\n  \n  const idle = totalIdle / cpus.length;\n  const total = totalTick / cpus.length;\n  const usage = 100 - ~~(100 * idle / total);\n  \n  return {\n    idle: idle,\n    total: total,\n    usage: usage\n  };\n}\n```\n\n**Memory Information:**\n```javascript\n// Memory in bytes\nconst totalMemory = os.totalmem();\nconst freeMemory = os.freemem();\nconst usedMemory = totalMemory - freeMemory;\n\nconsole.log(`Total Memory: ${(totalMemory / 1024 / 1024 / 1024).toFixed(2)} GB`);\nconsole.log(`Free Memory: ${(freeMemory / 1024 / 1024 / 1024).toFixed(2)} GB`);\nconsole.log(`Used Memory: ${(usedMemory / 1024 / 1024 / 1024).toFixed(2)} GB`);\nconsole.log(`Memory Usage: ${((usedMemory / totalMemory) * 100).toFixed(2)}%`);\n\n// Memory monitoring function\nfunction formatBytes(bytes) {\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  if (bytes === 0) return '0 Bytes';\n  const i = Math.floor(Math.log(bytes) / Math.log(1024));\n  return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];\n}\n\nfunction getMemoryInfo() {\n  return {\n    total: formatBytes(os.totalmem()),\n    free: formatBytes(os.freemem()),\n    used: formatBytes(os.totalmem() - os.freemem()),\n    usagePercent: (((os.totalmem() - os.freemem()) / os.totalmem()) * 100).toFixed(2)\n  };\n}\n```\n\n**Network Interfaces:**\n```javascript\nconst networkInterfaces = os.networkInterfaces();\n\n// Display all network interfaces\nfor (const [interfaceName, addresses] of Object.entries(networkInterfaces)) {\n  console.log(`Interface: ${interfaceName}`);\n  addresses.forEach(address => {\n    console.log(`  Family: ${address.family}`);\n    console.log(`  Address: ${address.address}`);\n    console.log(`  Internal: ${address.internal}`);\n    console.log('---');\n  });\n}\n\n// Get external IP addresses\nfunction getExternalIPs() {\n  const interfaces = os.networkInterfaces();\n  const addresses = [];\n  \n  for (const interfaceName in interfaces) {\n    for (const interface of interfaces[interfaceName]) {\n      // Skip internal and non-IPv4 addresses\n      if (interface.family === 'IPv4' && !interface.internal) {\n        addresses.push({\n          interface: interfaceName,\n          address: interface.address\n        });\n      }\n    }\n  }\n  \n  return addresses;\n}\n```\n\n**System Monitoring Application:**\n```javascript\nclass SystemMonitor {\n  constructor() {\n    this.startTime = Date.now();\n  }\n  \n  getSystemInfo() {\n    const uptime = os.uptime();\n    const loadavg = os.loadavg();\n    \n    return {\n      platform: os.platform(),\n      hostname: os.hostname(),\n      uptime: this.formatUptime(uptime),\n      loadAverage: {\n        '1min': loadavg[0].toFixed(2),\n        '5min': loadavg[1].toFixed(2),\n        '15min': loadavg[2].toFixed(2)\n      },\n      memory: {\n        total: this.formatBytes(os.totalmem()),\n        free: this.formatBytes(os.freemem()),\n        used: this.formatBytes(os.totalmem() - os.freemem())\n      },\n      cpus: os.cpus().length,\n      processUptime: this.formatUptime(process.uptime())\n    };\n  }\n  \n  formatUptime(seconds) {\n    const days = Math.floor(seconds / 86400);\n    const hours = Math.floor((seconds % 86400) / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    \n    return `${days}d ${hours}h ${minutes}m`;\n  }\n  \n  formatBytes(bytes) {\n    return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';\n  }\n  \n  startMonitoring(intervalMs = 5000) {\n    setInterval(() => {\n      const info = this.getSystemInfo();\n      console.clear();\n      console.log('System Monitor');\n      console.log('='.repeat(50));\n      Object.entries(info).forEach(([key, value]) => {\n        console.log(`${key}:`, typeof value === 'object' ? JSON.stringify(value, null, 2) : value);\n      });\n    }, intervalMs);\n  }\n}\n\n// Usage\nconst monitor = new SystemMonitor();\n// monitor.startMonitoring();\n```\n\n**Platform-Specific Logic:**\n```javascript\n// Execute platform-specific code\nfunction getPlatformSpecificInfo() {\n  const platform = os.platform();\n  \n  switch (platform) {\n    case 'win32':\n      return {\n        shell: process.env.COMSPEC || 'cmd.exe',\n        pathSeparator: ';',\n        newline: '\\r\\n'\n      };\n    case 'darwin':\n      return {\n        shell: process.env.SHELL || '/bin/bash',\n        pathSeparator: ':',\n        newline: '\\n'\n      };\n    case 'linux':\n      return {\n        shell: process.env.SHELL || '/bin/bash',\n        pathSeparator: ':',\n        newline: '\\n'\n      };\n    default:\n      return {\n        shell: '/bin/sh',\n        pathSeparator: ':',\n        newline: '\\n'\n      };\n  }\n}\n```\n\nThe OS module is essential for building system-aware applications, monitoring tools, and applications that need to adapt to different operating system environments.",
      "keywords": ["os-module", "system-info", "cpu", "memory", "network", "platform", "monitoring", "uptime"],
      "difficulty": "easy"
    },
    {
      "id": 6015,
      "tag": "nodejs",
      "question": "How do you use the Crypto module for hashing, encryption, and cryptographic operations in Node.js?",
      "answer": "The Crypto module provides cryptographic functionality including hash functions, HMAC, encryption, decryption, and random number generation. It's essential for security implementations in Node.js applications.\n\n**Hashing Operations:**\n```javascript\nconst crypto = require('crypto');\n\n// Basic hashing\nfunction hashPassword(password) {\n  return crypto.createHash('sha256').update(password).digest('hex');\n}\n\n// Salt-based hashing (more secure)\nfunction hashPasswordWithSalt(password) {\n  const salt = crypto.randomBytes(16).toString('hex');\n  const hash = crypto.createHash('sha256').update(password + salt).digest('hex');\n  return {\n    hash: hash,\n    salt: salt\n  };\n}\n\n// Verify password with salt\nfunction verifyPassword(password, storedHash, storedSalt) {\n  const hash = crypto.createHash('sha256').update(password + storedSalt).digest('hex');\n  return hash === storedHash;\n}\n\n// Using scrypt for password hashing (recommended)\nfunction hashPasswordScrypt(password, callback) {\n  const salt = crypto.randomBytes(16);\n  crypto.scrypt(password, salt, 64, (err, derivedKey) => {\n    if (err) return callback(err);\n    callback(null, {\n      hash: derivedKey.toString('hex'),\n      salt: salt.toString('hex')\n    });\n  });\n}\n```\n\n**HMAC (Hash-based Message Authentication Code):**\n```javascript\n// HMAC for message integrity\nfunction createHMAC(message, secretKey) {\n  return crypto.createHmac('sha256', secretKey)\n    .update(message)\n    .digest('hex');\n}\n\n// Verify HMAC\nfunction verifyHMAC(message, secretKey, expectedHmac) {\n  const calculatedHmac = createHMAC(message, secretKey);\n  return crypto.timingSafeEqual(\n    Buffer.from(calculatedHmac, 'hex'),\n    Buffer.from(expectedHmac, 'hex')\n  );\n}\n\n// JWT-like token creation\nfunction createSecureToken(payload, secret) {\n  const header = JSON.stringify({ alg: 'HS256', typ: 'JWT' });\n  const encodedHeader = Buffer.from(header).toString('base64url');\n  const encodedPayload = Buffer.from(JSON.stringify(payload)).toString('base64url');\n  \n  const signature = crypto\n    .createHmac('sha256', secret)\n    .update(`${encodedHeader}.${encodedPayload}`)\n    .digest('base64url');\n  \n  return `${encodedHeader}.${encodedPayload}.${signature}`;\n}\n```\n\n**Symmetric Encryption (AES):**\n```javascript\n// AES encryption\nfunction encrypt(text, password) {\n  const algorithm = 'aes-256-gcm';\n  const key = crypto.scryptSync(password, 'salt', 32);\n  const iv = crypto.randomBytes(16);\n  \n  const cipher = crypto.createCipher(algorithm, key, iv);\n  \n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  return {\n    encrypted: encrypted,\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex')\n  };\n}\n\n// AES decryption\nfunction decrypt(encryptedData, password) {\n  const algorithm = 'aes-256-gcm';\n  const key = crypto.scryptSync(password, 'salt', 32);\n  \n  const decipher = crypto.createDecipher(\n    algorithm,\n    key,\n    Buffer.from(encryptedData.iv, 'hex')\n  );\n  \n  decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));\n  \n  let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  \n  return decrypted;\n}\n```\n\n**Asymmetric Encryption (RSA):**\n```javascript\n// Generate RSA key pair\nfunction generateKeyPair() {\n  return crypto.generateKeyPairSync('rsa', {\n    modulusLength: 2048,\n    publicKeyEncoding: {\n      type: 'spki',\n      format: 'pem'\n    },\n    privateKeyEncoding: {\n      type: 'pkcs8',\n      format: 'pem'\n    }\n  });\n}\n\n// RSA encryption\nfunction encryptRSA(text, publicKey) {\n  const buffer = Buffer.from(text, 'utf8');\n  const encrypted = crypto.publicEncrypt(publicKey, buffer);\n  return encrypted.toString('base64');\n}\n\n// RSA decryption\nfunction decryptRSA(encryptedText, privateKey) {\n  const buffer = Buffer.from(encryptedText, 'base64');\n  const decrypted = crypto.privateDecrypt(privateKey, buffer);\n  return decrypted.toString('utf8');\n}\n\n// Digital signatures\nfunction signMessage(message, privateKey) {\n  const sign = crypto.createSign('RSA-SHA256');\n  sign.update(message);\n  return sign.sign(privateKey, 'base64');\n}\n\nfunction verifySignature(message, signature, publicKey) {\n  const verify = crypto.createVerify('RSA-SHA256');\n  verify.update(message);\n  return verify.verify(publicKey, signature, 'base64');\n}\n```\n\n**Random Number Generation:**\n```javascript\n// Generate secure random numbers\nfunction generateRandomString(length = 32) {\n  return crypto.randomBytes(length).toString('hex');\n}\n\n// Generate UUID v4\nfunction generateUUID() {\n  return crypto.randomUUID();\n}\n\n// Generate secure random integers\nfunction randomInt(min, max) {\n  return crypto.randomInt(min, max);\n}\n\n// Generate cryptographically secure session ID\nfunction generateSessionId() {\n  const timestamp = Date.now().toString(36);\n  const randomPart = crypto.randomBytes(16).toString('hex');\n  return `${timestamp}_${randomPart}`;\n}\n```\n\n**Practical Security Implementation:**\n```javascript\nclass SecurityManager {\n  constructor(secretKey) {\n    this.secretKey = secretKey;\n    this.algorithm = 'aes-256-gcm';\n  }\n  \n  // Hash password with salt\n  async hashPassword(password) {\n    const salt = crypto.randomBytes(16);\n    return new Promise((resolve, reject) => {\n      crypto.scrypt(password, salt, 64, (err, derivedKey) => {\n        if (err) reject(err);\n        resolve({\n          hash: derivedKey.toString('hex'),\n          salt: salt.toString('hex')\n        });\n      });\n    });\n  }\n  \n  // Verify password\n  async verifyPassword(password, storedHash, storedSalt) {\n    return new Promise((resolve, reject) => {\n      crypto.scrypt(password, Buffer.from(storedSalt, 'hex'), 64, (err, derivedKey) => {\n        if (err) reject(err);\n        resolve(derivedKey.toString('hex') === storedHash);\n      });\n    });\n  }\n  \n  // Encrypt sensitive data\n  encryptData(data) {\n    const iv = crypto.randomBytes(16);\n    const key = crypto.scryptSync(this.secretKey, 'salt', 32);\n    const cipher = crypto.createCipher(this.algorithm, key, iv);\n    \n    let encrypted = cipher.update(JSON.stringify(data), 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n  \n  // Generate secure API token\n  generateApiToken(userId, expiresIn = 3600000) { // 1 hour default\n    const payload = {\n      userId,\n      expiresAt: Date.now() + expiresIn,\n      nonce: crypto.randomBytes(16).toString('hex')\n    };\n    \n    return createSecureToken(payload, this.secretKey);\n  }\n}\n\n// Usage\nconst security = new SecurityManager('your-secret-key');\n```\n\n**Best Practices:**\n- Always use salt for password hashing\n- Use timing-safe comparison for security checks\n- Generate strong random keys and IVs\n- Use authenticated encryption modes (GCM)\n- Keep cryptographic keys secure and rotate them regularly\n- Use established algorithms (AES, RSA, SHA-256)\n- Validate inputs before cryptographic operations\n\nThe Crypto module provides robust security features essential for building secure Node.js applications.",
      "keywords": ["crypto-module", "hashing", "encryption", "hmac", "aes", "rsa", "security", "random", "salt"],
      "difficulty": "easy"
    },
    {
      "id": 6016,
      "tag": "nodejs",
      "question": "How do you build web applications with Express.js? Explain middleware, routing, and common patterns.",
      "answer": "Express.js is the most popular web framework for Node.js, providing a minimal and flexible approach to building web applications and APIs with powerful features like middleware, routing, and templating.\n\n**Basic Express Application Setup:**\n```javascript\nconst express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// Built-in middleware\napp.use(express.json()); // Parse JSON bodies\napp.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies\napp.use(express.static('public')); // Serve static files\n\n// Basic route\napp.get('/', (req, res) => {\n  res.json({ message: 'Welcome to Express API!' });\n});\n\napp.listen(port, () => {\n  console.log(`Server running on http://localhost:${port}`);\n});\n```\n\n**Express Middleware:**\nMiddleware functions execute during the request-response cycle and can modify request/response objects or end the cycle.\n\n```javascript\n// Custom middleware\nconst logger = (req, res, next) => {\n  console.log(`${new Date().toISOString()} - ${req.method} ${req.url}`);\n  next(); // Call next middleware\n};\n\nconst authenticate = (req, res, next) => {\n  const token = req.headers.authorization;\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  // Verify token logic here\n  try {\n    // const decoded = jwt.verify(token, secret);\n    // req.user = decoded;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n\nconst validateUserInput = (req, res, next) => {\n  const { email, password } = req.body;\n  \n  if (!email || !password) {\n    return res.status(400).json({ \n      error: 'Email and password are required' \n    });\n  }\n  \n  if (password.length < 6) {\n    return res.status(400).json({ \n      error: 'Password must be at least 6 characters' \n    });\n  }\n  \n  next();\n};\n\n// Apply middleware\napp.use(logger); // Global middleware\napp.use('/api/protected', authenticate); // Route-specific middleware\n```\n\n**Express Routing:**\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Users router\nconst usersRouter = express.Router();\n\n// CRUD operations\nusersRouter.get('/', async (req, res) => {\n  try {\n    // const users = await User.find();\n    const users = [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }];\n    res.json(users);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nusersRouter.get('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    // const user = await User.findById(id);\n    const user = { id, name: 'John Doe', email: 'john@example.com' };\n    \n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\nusersRouter.post('/', validateUserInput, async (req, res) => {\n  try {\n    const userData = req.body;\n    // const user = await User.create(userData);\n    const user = { id: Date.now(), ...userData };\n    \n    res.status(201).json(user);\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\nusersRouter.put('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    const updateData = req.body;\n    \n    // const user = await User.findByIdAndUpdate(id, updateData, { new: true });\n    const user = { id, ...updateData };\n    \n    res.json(user);\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\nusersRouter.delete('/:id', async (req, res) => {\n  try {\n    const { id } = req.params;\n    // await User.findByIdAndDelete(id);\n    \n    res.status(204).send();\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n});\n\n// Mount router\napp.use('/api/users', usersRouter);\n```\n\n**Advanced Express Patterns:**\n\n**1. Error Handling:**\n```javascript\n// Async error wrapper\nconst asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\n// Custom error class\nclass AppError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.statusCode = statusCode;\n    this.isOperational = true;\n  }\n}\n\n// Global error handler\nconst errorHandler = (error, req, res, next) => {\n  let { statusCode = 500, message } = error;\n  \n  if (process.env.NODE_ENV === 'development') {\n    res.status(statusCode).json({\n      error: message,\n      stack: error.stack\n    });\n  } else {\n    res.status(statusCode).json({\n      error: error.isOperational ? message : 'Internal server error'\n    });\n  }\n};\n\n// Use error handler (must be last middleware)\napp.use(errorHandler);\n```\n\n**2. Request Validation and Sanitization:**\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\nconst cors = require('cors');\n\n// Security middleware\napp.use(helmet());\napp.use(cors({\n  origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],\n  credentials: true\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP, please try again later.'\n});\n\napp.use('/api/', limiter);\n\n// Input validation middleware\nconst { body, validationResult } = require('express-validator');\n\nconst validateUser = [\n  body('email').isEmail().normalizeEmail(),\n  body('password').isLength({ min: 6 }).trim(),\n  body('name').trim().isLength({ min: 2 }),\n  \n  (req, res, next) => {\n    const errors = validationResult(req);\n    if (!errors.isEmpty()) {\n      return res.status(400).json({ \n        errors: errors.array() \n      });\n    }\n    next();\n  }\n];\n\napp.post('/api/users', validateUser, asyncHandler(async (req, res) => {\n  // User creation logic\n}));\n```\n\n**3. Application Structure:**\n```javascript\n// controllers/userController.js\nexports.getUsers = asyncHandler(async (req, res) => {\n  const { page = 1, limit = 10, search } = req.query;\n  \n  const options = {\n    page: parseInt(page),\n    limit: parseInt(limit)\n  };\n  \n  const filter = search ? { name: { $regex: search, $options: 'i' } } : {};\n  \n  // const users = await User.paginate(filter, options);\n  const users = { docs: [], totalPages: 1, page: 1 };\n  \n  res.json({\n    users: users.docs,\n    pagination: {\n      currentPage: users.page,\n      totalPages: users.totalPages,\n      hasNext: users.page < users.totalPages,\n      hasPrev: users.page > 1\n    }\n  });\n});\n\n// routes/users.js\nconst express = require('express');\nconst userController = require('../controllers/userController');\nconst { authenticate, authorize } = require('../middleware/auth');\n\nconst router = express.Router();\n\nrouter\n  .route('/')\n  .get(userController.getUsers)\n  .post(authenticate, authorize('admin'), userController.createUser);\n\nrouter\n  .route('/:id')\n  .get(userController.getUserById)\n  .put(authenticate, userController.updateUser)\n  .delete(authenticate, authorize('admin'), userController.deleteUser);\n\nmodule.exports = router;\n```\n\n**4. Complete Application Example:**\n```javascript\n// app.js\nconst express = require('express');\nconst morgan = require('morgan');\nconst compression = require('compression');\n\nconst app = express();\n\n// Middleware stack\napp.use(morgan('combined'));\napp.use(compression());\napp.use(express.json({ limit: '10mb' }));\napp.use(express.urlencoded({ extended: true, limit: '10mb' }));\n\n// API routes\napp.use('/api/users', require('./routes/users'));\napp.use('/api/posts', require('./routes/posts'));\napp.use('/api/auth', require('./routes/auth'));\n\n// Health check\napp.get('/health', (req, res) => {\n  res.json({ \n    status: 'OK', \n    timestamp: new Date().toISOString(),\n    uptime: process.uptime()\n  });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Global error handler\napp.use(require('./middleware/errorHandler'));\n\nmodule.exports = app;\n```\n\nExpress.js provides a robust foundation for building scalable web applications with its middleware system, flexible routing, and extensive ecosystem of plugins and extensions.",
      "keywords": ["express", "middleware", "routing", "web-framework", "api", "validation", "error-handling", "security"],
      "difficulty": "medium"
    },
    {
      "id": 6017,
      "tag": "nodejs",
      "question": "How do you integrate databases with Node.js applications? Explain ORM/ODM patterns and connection management.",
      "answer": "Database integration in Node.js involves connecting to databases using drivers, ORMs (Object-Relational Mapping), or ODMs (Object-Document Mapping), managing connections efficiently, and implementing proper data access patterns.\n\n**SQL Database Integration (PostgreSQL with Sequelize ORM):**\n\n**Setup and Configuration:**\n```javascript\n// config/database.js\nconst { Sequelize } = require('sequelize');\n\nconst sequelize = new Sequelize(\n  process.env.DB_NAME,\n  process.env.DB_USER,\n  process.env.DB_PASSWORD,\n  {\n    host: process.env.DB_HOST,\n    dialect: 'postgres',\n    pool: {\n      max: 10,\n      min: 0,\n      acquire: 30000,\n      idle: 10000\n    },\n    logging: process.env.NODE_ENV === 'development' ? console.log : false\n  }\n);\n\n// Test connection\nasync function connectDatabase() {\n  try {\n    await sequelize.authenticate();\n    console.log('Database connected successfully');\n  } catch (error) {\n    console.error('Database connection failed:', error);\n    process.exit(1);\n  }\n}\n\nmodule.exports = { sequelize, connectDatabase };\n```\n\n**Sequelize Models:**\n```javascript\n// models/User.js\nconst { DataTypes } = require('sequelize');\nconst { sequelize } = require('../config/database');\n\nconst User = sequelize.define('User', {\n  id: {\n    type: DataTypes.UUID,\n    defaultValue: DataTypes.UUIDV4,\n    primaryKey: true\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true,\n    validate: {\n      isEmail: true\n    }\n  },\n  password: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  firstName: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  lastName: {\n    type: DataTypes.STRING,\n    allowNull: false\n  },\n  isActive: {\n    type: DataTypes.BOOLEAN,\n    defaultValue: true\n  }\n}, {\n  timestamps: true,\n  paranoid: true, // Soft delete\n  hooks: {\n    beforeCreate: async (user) => {\n      const bcrypt = require('bcrypt');\n      user.password = await bcrypt.hash(user.password, 12);\n    }\n  }\n});\n\n// Instance methods\nUser.prototype.comparePassword = async function(candidatePassword) {\n  const bcrypt = require('bcrypt');\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\n// Associations\nUser.associate = (models) => {\n  User.hasMany(models.Post, { foreignKey: 'userId', as: 'posts' });\n  User.belongsToMany(models.Role, { \n    through: 'UserRoles',\n    foreignKey: 'userId'\n  });\n};\n\nmodule.exports = User;\n```\n\n**Database Service Layer:**\n```javascript\n// services/userService.js\nconst User = require('../models/User');\nconst { Op } = require('sequelize');\n\nclass UserService {\n  async createUser(userData) {\n    try {\n      const user = await User.create(userData);\n      return this.sanitizeUser(user);\n    } catch (error) {\n      if (error.name === 'SequelizeUniqueConstraintError') {\n        throw new Error('Email already exists');\n      }\n      throw error;\n    }\n  }\n  \n  async getUserById(id, includeDeleted = false) {\n    const options = {\n      where: { id },\n      include: [{\n        model: require('../models/Post'),\n        as: 'posts',\n        where: { isPublished: true },\n        required: false\n      }]\n    };\n    \n    if (includeDeleted) {\n      options.paranoid = false;\n    }\n    \n    const user = await User.findOne(options);\n    return user ? this.sanitizeUser(user) : null;\n  }\n  \n  async getUserByEmail(email) {\n    const user = await User.findOne({ where: { email } });\n    return user;\n  }\n  \n  async updateUser(id, updateData) {\n    const [updatedRowsCount] = await User.update(updateData, {\n      where: { id },\n      returning: true\n    });\n    \n    if (updatedRowsCount === 0) {\n      throw new Error('User not found');\n    }\n    \n    return this.getUserById(id);\n  }\n  \n  async deleteUser(id) {\n    const deletedRowsCount = await User.destroy({ where: { id } });\n    return deletedRowsCount > 0;\n  }\n  \n  async searchUsers(query, page = 1, limit = 10) {\n    const offset = (page - 1) * limit;\n    \n    const { rows: users, count } = await User.findAndCountAll({\n      where: {\n        [Op.or]: [\n          { firstName: { [Op.iLike]: `%${query}%` } },\n          { lastName: { [Op.iLike]: `%${query}%` } },\n          { email: { [Op.iLike]: `%${query}%` } }\n        ]\n      },\n      limit,\n      offset,\n      order: [['createdAt', 'DESC']]\n    });\n    \n    return {\n      users: users.map(user => this.sanitizeUser(user)),\n      pagination: {\n        currentPage: page,\n        totalPages: Math.ceil(count / limit),\n        totalItems: count,\n        hasNext: page * limit < count,\n        hasPrev: page > 1\n      }\n    };\n  }\n  \n  sanitizeUser(user) {\n    const { password, ...sanitized } = user.toJSON();\n    return sanitized;\n  }\n}\n\nmodule.exports = new UserService();\n```\n\n**MongoDB Integration (Mongoose ODM):**\n\n**Mongoose Setup:**\n```javascript\n// config/mongodb.js\nconst mongoose = require('mongoose');\n\nconst connectMongoDB = async () => {\n  try {\n    const conn = await mongoose.connect(process.env.MONGODB_URI, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true,\n      maxPoolSize: 10,\n      serverSelectionTimeoutMS: 5000,\n      socketTimeoutMS: 45000\n    });\n    \n    console.log(`MongoDB connected: ${conn.connection.host}`);\n  } catch (error) {\n    console.error('MongoDB connection error:', error);\n    process.exit(1);\n  }\n};\n\n// Connection event handlers\nmongoose.connection.on('connected', () => {\n  console.log('Mongoose connected to MongoDB');\n});\n\nmongoose.connection.on('error', (err) => {\n  console.error('Mongoose connection error:', err);\n});\n\nmongoose.connection.on('disconnected', () => {\n  console.log('Mongoose disconnected');\n});\n\nmodule.exports = { connectMongoDB };\n```\n\n**Mongoose Schema and Model:**\n```javascript\n// models/User.js (MongoDB)\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcrypt');\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: [true, 'Email is required'],\n    unique: true,\n    lowercase: true,\n    validate: {\n      validator: (email) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email),\n      message: 'Invalid email format'\n    }\n  },\n  password: {\n    type: String,\n    required: [true, 'Password is required'],\n    minlength: [6, 'Password must be at least 6 characters'],\n    select: false // Don't include in queries by default\n  },\n  profile: {\n    firstName: {\n      type: String,\n      required: [true, 'First name is required'],\n      trim: true\n    },\n    lastName: {\n      type: String,\n      required: [true, 'Last name is required'],\n      trim: true\n    },\n    avatar: String,\n    bio: String\n  },\n  roles: [{\n    type: String,\n    enum: ['user', 'admin', 'moderator'],\n    default: 'user'\n  }],\n  settings: {\n    notifications: {\n      email: { type: Boolean, default: true },\n      push: { type: Boolean, default: false }\n    },\n    privacy: {\n      profilePublic: { type: Boolean, default: true }\n    }\n  },\n  lastLogin: Date,\n  isActive: {\n    type: Boolean,\n    default: true\n  }\n}, {\n  timestamps: true,\n  toJSON: { \n    virtuals: true,\n    transform: function(doc, ret) {\n      delete ret.password;\n      return ret;\n    }\n  }\n});\n\n// Virtual fields\nuserSchema.virtual('fullName').get(function() {\n  return `${this.profile.firstName} ${this.profile.lastName}`;\n});\n\n// Middleware\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  this.password = await bcrypt.hash(this.password, 12);\n  next();\n});\n\n// Instance methods\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nuserSchema.methods.updateLastLogin = function() {\n  this.lastLogin = new Date();\n  return this.save({ validateBeforeSave: false });\n};\n\n// Static methods\nuserSchema.statics.findByEmail = function(email) {\n  return this.findOne({ email }).select('+password');\n};\n\nuserSchema.statics.getActiveUsers = function() {\n  return this.find({ isActive: true });\n};\n\n// Indexes\nuserSchema.index({ email: 1 });\nuserSchema.index({ 'profile.firstName': 'text', 'profile.lastName': 'text' });\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n**Connection Pool Management:**\n```javascript\n// config/connectionManager.js\nclass ConnectionManager {\n  constructor() {\n    this.connections = new Map();\n    this.maxConnections = 10;\n    this.connectionTimeout = 30000;\n  }\n  \n  async getConnection(database = 'default') {\n    if (this.connections.has(database)) {\n      return this.connections.get(database);\n    }\n    \n    if (this.connections.size >= this.maxConnections) {\n      throw new Error('Maximum connections reached');\n    }\n    \n    const connection = await this.createConnection(database);\n    this.connections.set(database, connection);\n    \n    // Set connection timeout\n    setTimeout(() => {\n      this.closeConnection(database);\n    }, this.connectionTimeout);\n    \n    return connection;\n  }\n  \n  async createConnection(database) {\n    // Implementation depends on database type\n    const { Pool } = require('pg');\n    \n    return new Pool({\n      host: process.env.DB_HOST,\n      port: process.env.DB_PORT,\n      database: process.env.DB_NAME,\n      user: process.env.DB_USER,\n      password: process.env.DB_PASSWORD,\n      max: 5,\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000\n    });\n  }\n  \n  async closeConnection(database) {\n    const connection = this.connections.get(database);\n    if (connection) {\n      await connection.end();\n      this.connections.delete(database);\n    }\n  }\n  \n  async closeAllConnections() {\n    for (const [database, connection] of this.connections) {\n      await connection.end();\n    }\n    this.connections.clear();\n  }\n}\n\nmodule.exports = new ConnectionManager();\n```\n\n**Transaction Management:**\n```javascript\n// services/transactionService.js\nconst { sequelize } = require('../config/database');\n\nclass TransactionService {\n  async transferFunds(fromUserId, toUserId, amount) {\n    const transaction = await sequelize.transaction();\n    \n    try {\n      // Debit from source account\n      await Account.decrement(\n        'balance',\n        { \n          by: amount,\n          where: { userId: fromUserId },\n          transaction\n        }\n      );\n      \n      // Credit to destination account\n      await Account.increment(\n        'balance',\n        {\n          by: amount,\n          where: { userId: toUserId },\n          transaction\n        }\n      );\n      \n      // Log transaction\n      await Transaction.create({\n        fromUserId,\n        toUserId,\n        amount,\n        type: 'transfer',\n        status: 'completed'\n      }, { transaction });\n      \n      await transaction.commit();\n      return { success: true };\n      \n    } catch (error) {\n      await transaction.rollback();\n      throw error;\n    }\n  }\n}\n```\n\n**Best Practices:**\n- Use connection pooling for better performance\n- Implement proper error handling and transaction management\n- Use migrations for schema changes\n- Implement database health checks\n- Use environment-specific configurations\n- Monitor database performance and connections\n- Implement proper indexing strategies\n- Use prepared statements to prevent SQL injection\n- Implement caching strategies for frequently accessed data\n\nDatabase integration is crucial for Node.js applications, requiring careful consideration of performance, security, and maintainability.",
      "keywords": ["database", "orm", "odm", "sequelize", "mongoose", "sql", "mongodb", "connections", "transactions"],
      "difficulty": "medium"
    },
    {
      "id": 6018,
      "tag": "nodejs",
      "question": "How does memory management and garbage collection work in Node.js? How do you identify and fix memory leaks?",
      "answer": "Node.js uses V8's garbage collection system for automatic memory management, but understanding how it works is crucial for building high-performance applications and avoiding memory leaks.\n\n**V8 Memory Structure:**\nNode.js memory is divided into several spaces:\n- **Heap Space**: Where objects are stored\n- **Stack Space**: For function calls and local variables\n- **Code Space**: For compiled code\n- **Map Space**: For object property maps\n\n```javascript\n// Check memory usage\nfunction getMemoryUsage() {\n  const used = process.memoryUsage();\n  const usage = {};\n  \n  for (let key in used) {\n    usage[key] = `${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`;\n  }\n  \n  return {\n    ...usage,\n    heapUsed: used.heapUsed,\n    heapTotal: used.heapTotal,\n    external: used.external,\n    rss: used.rss // Resident Set Size\n  };\n}\n\nconsole.log('Memory Usage:', getMemoryUsage());\n```\n\n**Garbage Collection Process:**\nV8 uses a generational garbage collector with two main generations:\n\n**1. Young Generation (Scavenger):**\n- Fast collection for short-lived objects\n- Uses copying algorithm\n- Runs frequently\n\n**2. Old Generation (Mark-Sweep-Compact):**\n- Slower collection for long-lived objects\n- Uses mark-and-sweep algorithm\n- Runs less frequently but takes more time\n\n```javascript\n// Monitor garbage collection\nconst v8 = require('v8');\n\n// Get heap statistics\nfunction getHeapStats() {\n  const stats = v8.getHeapStatistics();\n  return {\n    totalHeapSize: Math.round(stats.total_heap_size / 1024 / 1024),\n    totalHeapSizeExecutable: Math.round(stats.total_heap_size_executable / 1024 / 1024),\n    usedHeapSize: Math.round(stats.used_heap_size / 1024 / 1024),\n    heapSizeLimit: Math.round(stats.heap_size_limit / 1024 / 1024),\n    totalPhysicalSize: Math.round(stats.total_physical_size / 1024 / 1024)\n  };\n}\n\n// Force garbage collection (only in development with --expose-gc flag)\nif (global.gc) {\n  console.log('Before GC:', getHeapStats());\n  global.gc();\n  console.log('After GC:', getHeapStats());\n}\n```\n\n**Common Memory Leak Patterns:**\n\n**1. Event Listener Leaks:**\n```javascript\n// BAD: Memory leak\nclass BadEventHandler {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    \n    // Event listener keeps reference to this object\n    process.on('SIGINT', () => {\n      console.log('Received SIGINT');\n    });\n  }\n}\n\n// GOOD: Proper cleanup\nclass GoodEventHandler {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    this.handleSIGINT = () => {\n      console.log('Received SIGINT');\n      this.cleanup();\n    };\n    \n    process.on('SIGINT', this.handleSIGINT);\n  }\n  \n  cleanup() {\n    process.removeListener('SIGINT', this.handleSIGINT);\n    this.data = null;\n  }\n}\n```\n\n**2. Closure Memory Leaks:**\n```javascript\n// BAD: Closure retains large object\nfunction createBadHandler() {\n  const largeData = new Array(1000000).fill('data');\n  \n  return function() {\n    // Even though we don't use largeData here,\n    // the closure keeps it in memory\n    console.log('Handler called');\n  };\n}\n\n// GOOD: Explicitly null out unused variables\nfunction createGoodHandler() {\n  let largeData = new Array(1000000).fill('data');\n  const neededData = largeData.slice(0, 10);\n  \n  largeData = null; // Release reference\n  \n  return function() {\n    console.log('Handler called with needed data:', neededData.length);\n  };\n}\n```\n\n**3. Timer Leaks:**\n```javascript\n// BAD: Timer keeps object alive\nclass BadTimer {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    this.timer = setInterval(() => {\n      console.log('Timer tick');\n    }, 1000);\n  }\n  \n  // Missing cleanup method\n}\n\n// GOOD: Proper timer cleanup\nclass GoodTimer {\n  constructor() {\n    this.data = new Array(1000000).fill('data');\n    this.timer = setInterval(() => {\n      console.log('Timer tick');\n    }, 1000);\n  }\n  \n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n    this.data = null;\n  }\n}\n```\n\n**Memory Leak Detection Tools:**\n\n**1. Built-in Memory Monitoring:**\n```javascript\nclass MemoryMonitor {\n  constructor(interval = 5000) {\n    this.interval = interval;\n    this.baseline = null;\n    this.samples = [];\n  }\n  \n  start() {\n    this.baseline = process.memoryUsage().heapUsed;\n    \n    this.timer = setInterval(() => {\n      const current = process.memoryUsage();\n      const sample = {\n        timestamp: Date.now(),\n        heapUsed: current.heapUsed,\n        heapTotal: current.heapTotal,\n        external: current.external,\n        rss: current.rss,\n        heapGrowth: current.heapUsed - this.baseline\n      };\n      \n      this.samples.push(sample);\n      \n      // Keep only last 100 samples\n      if (this.samples.length > 100) {\n        this.samples = this.samples.slice(-100);\n      }\n      \n      this.analyzeGrowth();\n    }, this.interval);\n  }\n  \n  analyzeGrowth() {\n    if (this.samples.length < 10) return;\n    \n    const recent = this.samples.slice(-10);\n    const growth = recent.map(s => s.heapGrowth);\n    const averageGrowth = growth.reduce((a, b) => a + b) / growth.length;\n    \n    if (averageGrowth > 50 * 1024 * 1024) { // 50MB growth\n      console.warn('Potential memory leak detected!');\n      console.warn('Average heap growth:', Math.round(averageGrowth / 1024 / 1024), 'MB');\n    }\n  }\n  \n  getReport() {\n    if (!this.samples.length) return null;\n    \n    const latest = this.samples[this.samples.length - 1];\n    return {\n      totalSamples: this.samples.length,\n      currentHeap: Math.round(latest.heapUsed / 1024 / 1024),\n      heapGrowth: Math.round(latest.heapGrowth / 1024 / 1024),\n      trend: this.calculateTrend()\n    };\n  }\n  \n  calculateTrend() {\n    if (this.samples.length < 2) return 'unknown';\n    \n    const first = this.samples[0].heapUsed;\n    const last = this.samples[this.samples.length - 1].heapUsed;\n    const growth = last - first;\n    \n    if (growth > 10 * 1024 * 1024) return 'increasing';\n    if (growth < -10 * 1024 * 1024) return 'decreasing';\n    return 'stable';\n  }\n  \n  stop() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n}\n\n// Usage\nconst monitor = new MemoryMonitor(1000);\nmonitor.start();\n\n// Check memory every minute\nsetInterval(() => {\n  const report = monitor.getReport();\n  if (report) {\n    console.log('Memory Report:', report);\n  }\n}, 60000);\n```\n\n**2. Heap Snapshot Analysis:**\n```javascript\nconst v8 = require('v8');\nconst fs = require('fs');\n\n// Create heap snapshot\nfunction createHeapSnapshot(filename) {\n  const snapshot = v8.writeHeapSnapshot(filename);\n  console.log('Heap snapshot saved to:', snapshot);\n  return snapshot;\n}\n\n// Compare heap snapshots\nclass HeapAnalyzer {\n  constructor() {\n    this.snapshots = [];\n  }\n  \n  takeSnapshot(label = Date.now().toString()) {\n    const filename = `heap-${label}.heapsnapshot`;\n    const snapshot = v8.writeHeapSnapshot(filename);\n    \n    this.snapshots.push({\n      label,\n      filename: snapshot,\n      timestamp: Date.now(),\n      memoryUsage: process.memoryUsage()\n    });\n    \n    console.log(`Snapshot '${label}' created:`, snapshot);\n    return snapshot;\n  }\n  \n  getSnapshots() {\n    return this.snapshots.map(s => ({\n      label: s.label,\n      timestamp: s.timestamp,\n      heapUsed: Math.round(s.memoryUsage.heapUsed / 1024 / 1024)\n    }));\n  }\n  \n  cleanup() {\n    this.snapshots.forEach(snapshot => {\n      try {\n        fs.unlinkSync(snapshot.filename);\n      } catch (err) {\n        console.error('Failed to delete snapshot:', err);\n      }\n    });\n    this.snapshots = [];\n  }\n}\n```\n\n**Memory Optimization Strategies:**\n\n**1. Object Pooling:**\n```javascript\nclass ObjectPool {\n  constructor(createFn, resetFn, initialSize = 10) {\n    this.createFn = createFn;\n    this.resetFn = resetFn;\n    this.pool = [];\n    \n    // Pre-populate pool\n    for (let i = 0; i < initialSize; i++) {\n      this.pool.push(this.createFn());\n    }\n  }\n  \n  acquire() {\n    if (this.pool.length > 0) {\n      return this.pool.pop();\n    }\n    return this.createFn();\n  }\n  \n  release(obj) {\n    this.resetFn(obj);\n    this.pool.push(obj);\n  }\n  \n  size() {\n    return this.pool.length;\n  }\n}\n\n// Usage example\nconst bufferPool = new ObjectPool(\n  () => Buffer.alloc(1024),\n  (buffer) => buffer.fill(0),\n  20\n);\n\nfunction processData(data) {\n  const buffer = bufferPool.acquire();\n  \n  try {\n    // Process data using buffer\n    buffer.write(data);\n    return buffer.toString();\n  } finally {\n    bufferPool.release(buffer);\n  }\n}\n```\n\n**2. Weak References:**\n```javascript\n// Use WeakMap for associating data with objects\nconst objectData = new WeakMap();\n\nclass DataManager {\n  setData(obj, data) {\n    objectData.set(obj, data);\n  }\n  \n  getData(obj) {\n    return objectData.get(obj);\n  }\n  \n  hasData(obj) {\n    return objectData.has(obj);\n  }\n}\n\n// When obj is garbage collected,\n// its entry in WeakMap is automatically removed\n```\n\n**Memory Profiling in Production:**\n```javascript\n// Safe memory monitoring for production\nclass ProductionMemoryMonitor {\n  constructor(options = {}) {\n    this.warningThreshold = options.warningThreshold || 500 * 1024 * 1024; // 500MB\n    this.criticalThreshold = options.criticalThreshold || 1000 * 1024 * 1024; // 1GB\n    this.checkInterval = options.checkInterval || 30000; // 30 seconds\n  }\n  \n  start() {\n    this.timer = setInterval(() => {\n      const usage = process.memoryUsage();\n      \n      if (usage.heapUsed > this.criticalThreshold) {\n        console.error('CRITICAL: High memory usage', {\n          heapUsed: Math.round(usage.heapUsed / 1024 / 1024),\n          heapTotal: Math.round(usage.heapTotal / 1024 / 1024),\n          rss: Math.round(usage.rss / 1024 / 1024)\n        });\n        \n        // Trigger emergency cleanup or restart\n        this.handleCriticalMemory();\n        \n      } else if (usage.heapUsed > this.warningThreshold) {\n        console.warn('WARNING: High memory usage', {\n          heapUsed: Math.round(usage.heapUsed / 1024 / 1024)\n        });\n      }\n    }, this.checkInterval);\n  }\n  \n  handleCriticalMemory() {\n    // Force garbage collection if available\n    if (global.gc) {\n      global.gc();\n    }\n    \n    // Emit event for application-specific cleanup\n    process.emit('memoryPressure', process.memoryUsage());\n  }\n  \n  stop() {\n    if (this.timer) {\n      clearInterval(this.timer);\n      this.timer = null;\n    }\n  }\n}\n```\n\n**Best Practices:**\n- Monitor memory usage in development and production\n- Use heap snapshots to identify memory leaks\n- Implement proper cleanup for event listeners, timers, and connections\n- Use WeakMap/WeakSet for object associations\n- Implement object pooling for frequently created objects\n- Use streaming for large data processing\n- Set memory limits appropriately (--max-old-space-size)\n- Profile and optimize hot code paths\n\nProper memory management is crucial for Node.js application performance and stability, especially in production environments with long-running processes.",
      "keywords": ["memory-management", "garbage-collection", "v8", "memory-leaks", "heap", "profiling", "optimization"],
      "difficulty": "hard"
    },
    {
      "id": 6019,
      "tag": "nodejs",
      "question": "How do you optimize Node.js application performance? What tools and techniques are available for profiling and monitoring?",
      "answer": "Node.js performance optimization involves understanding bottlenecks, implementing proper monitoring, and applying various optimization techniques across different layers of the application stack.\n\n**Performance Profiling Tools:**\n\n**1. Built-in Node.js Profiler:**\n```javascript\n// Start with profiling flags\n// node --prof --inspect app.js\n// node --prof-process isolate-*.log\n\nconst { performance, PerformanceObserver } = require('perf_hooks');\n\n// Performance timing\nclass PerformanceProfiler {\n  constructor() {\n    this.marks = new Map();\n    this.measures = new Map();\n    this.setupObserver();\n  }\n  \n  setupObserver() {\n    const obs = new PerformanceObserver((items) => {\n      items.getEntries().forEach((entry) => {\n        if (entry.entryType === 'measure') {\n          console.log(`${entry.name}: ${entry.duration.toFixed(2)}ms`);\n        }\n      });\n    });\n    obs.observe({ entryTypes: ['measure'] });\n  }\n  \n  mark(name) {\n    performance.mark(name);\n    this.marks.set(name, performance.now());\n  }\n  \n  measure(name, startMark, endMark) {\n    performance.measure(name, startMark, endMark);\n    const duration = this.marks.get(endMark) - this.marks.get(startMark);\n    this.measures.set(name, duration);\n    return duration;\n  }\n  \n  timedFunction(name, fn) {\n    return async (...args) => {\n      const startMark = `${name}-start-${Date.now()}`;\n      const endMark = `${name}-end-${Date.now()}`;\n      \n      this.mark(startMark);\n      try {\n        const result = await fn(...args);\n        this.mark(endMark);\n        this.measure(name, startMark, endMark);\n        return result;\n      } catch (error) {\n        this.mark(endMark);\n        this.measure(`${name}-error`, startMark, endMark);\n        throw error;\n      }\n    };\n  }\n  \n  getReport() {\n    return {\n      marks: Array.from(this.marks.entries()),\n      measures: Array.from(this.measures.entries()),\n      memoryUsage: process.memoryUsage(),\n      cpuUsage: process.cpuUsage()\n    };\n  }\n}\n\n// Usage\nconst profiler = new PerformanceProfiler();\n\nconst timedDatabaseQuery = profiler.timedFunction('db-query', async (query) => {\n  // Simulate database query\n  await new Promise(resolve => setTimeout(resolve, 100));\n  return { results: [] };\n});\n```\n\n**2. Advanced Performance Monitoring:**\n```javascript\nconst EventEmitter = require('events');\n\nclass ApplicationPerformanceMonitor extends EventEmitter {\n  constructor(options = {}) {\n    super();\n    this.metrics = {\n      requests: { total: 0, errors: 0, avgResponseTime: 0 },\n      memory: { current: 0, peak: 0, warnings: 0 },\n      eventLoop: { lag: 0, maxLag: 0 },\n      gc: { collections: 0, totalTime: 0 }\n    };\n    \n    this.options = {\n      memoryWarningThreshold: options.memoryWarningThreshold || 500 * 1024 * 1024,\n      eventLoopWarningThreshold: options.eventLoopWarningThreshold || 100,\n      ...options\n    };\n    \n    this.responseTimes = [];\n    this.startTime = Date.now();\n    \n    this.setupEventLoopMonitoring();\n    this.setupMemoryMonitoring();\n    this.setupGCMonitoring();\n  }\n  \n  setupEventLoopMonitoring() {\n    let start = process.hrtime.bigint();\n    \n    setInterval(() => {\n      const delta = process.hrtime.bigint() - start;\n      const nanosecondDelay = Number(delta - 10000000n); // 10ms expected\n      const millisecondDelay = nanosecondDelay / 1000000;\n      \n      this.metrics.eventLoop.lag = millisecondDelay;\n      if (millisecondDelay > this.metrics.eventLoop.maxLag) {\n        this.metrics.eventLoop.maxLag = millisecondDelay;\n      }\n      \n      if (millisecondDelay > this.options.eventLoopWarningThreshold) {\n        this.emit('eventLoopLag', { lag: millisecondDelay });\n      }\n      \n      start = process.hrtime.bigint();\n    }, 10);\n  }\n  \n  setupMemoryMonitoring() {\n    setInterval(() => {\n      const usage = process.memoryUsage();\n      this.metrics.memory.current = usage.heapUsed;\n      \n      if (usage.heapUsed > this.metrics.memory.peak) {\n        this.metrics.memory.peak = usage.heapUsed;\n      }\n      \n      if (usage.heapUsed > this.options.memoryWarningThreshold) {\n        this.metrics.memory.warnings++;\n        this.emit('memoryWarning', { usage });\n      }\n    }, 5000);\n  }\n  \n  setupGCMonitoring() {\n    const v8 = require('v8');\n    \n    // Monitor GC events\n    const obs = new (require('perf_hooks').PerformanceObserver)((items) => {\n      items.getEntries().forEach((entry) => {\n        if (entry.entryType === 'gc') {\n          this.metrics.gc.collections++;\n          this.metrics.gc.totalTime += entry.duration;\n          \n          if (entry.duration > 50) { // Long GC pause\n            this.emit('longGC', { duration: entry.duration, kind: entry.kind });\n          }\n        }\n      });\n    });\n    \n    obs.observe({ entryTypes: ['gc'] });\n  }\n  \n  trackRequest(responseTime, isError = false) {\n    this.metrics.requests.total++;\n    if (isError) this.metrics.requests.errors++;\n    \n    this.responseTimes.push(responseTime);\n    if (this.responseTimes.length > 1000) {\n      this.responseTimes = this.responseTimes.slice(-1000);\n    }\n    \n    // Calculate rolling average\n    const sum = this.responseTimes.reduce((a, b) => a + b, 0);\n    this.metrics.requests.avgResponseTime = sum / this.responseTimes.length;\n  }\n  \n  getMetrics() {\n    const uptime = Date.now() - this.startTime;\n    \n    return {\n      uptime,\n      timestamp: Date.now(),\n      ...this.metrics,\n      requests: {\n        ...this.metrics.requests,\n        rps: this.metrics.requests.total / (uptime / 1000),\n        errorRate: (this.metrics.requests.errors / this.metrics.requests.total) || 0\n      },\n      responseTimes: {\n        avg: this.metrics.requests.avgResponseTime,\n        p95: this.getPercentile(95),\n        p99: this.getPercentile(99)\n      }\n    };\n  }\n  \n  getPercentile(percentile) {\n    if (this.responseTimes.length === 0) return 0;\n    \n    const sorted = [...this.responseTimes].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index];\n  }\n}\n\n// Express middleware for performance monitoring\nfunction createPerformanceMiddleware(monitor) {\n  return (req, res, next) => {\n    const startTime = Date.now();\n    \n    res.on('finish', () => {\n      const responseTime = Date.now() - startTime;\n      const isError = res.statusCode >= 400;\n      monitor.trackRequest(responseTime, isError);\n    });\n    \n    next();\n  };\n}\n```\n\n**3. Database Query Optimization:**\n```javascript\nclass DatabaseOptimizer {\n  constructor(db) {\n    this.db = db;\n    this.queryCache = new Map();\n    this.slowQueries = [];\n    this.queryStats = new Map();\n  }\n  \n  async optimizedQuery(sql, params, options = {}) {\n    const cacheKey = this.getCacheKey(sql, params);\n    const startTime = Date.now();\n    \n    // Check cache first\n    if (options.cache && this.queryCache.has(cacheKey)) {\n      const cached = this.queryCache.get(cacheKey);\n      if (Date.now() - cached.timestamp < (options.cacheTtl || 60000)) {\n        return cached.result;\n      }\n    }\n    \n    try {\n      const result = await this.db.query(sql, params);\n      const duration = Date.now() - startTime;\n      \n      // Track query performance\n      this.trackQueryPerformance(sql, duration);\n      \n      // Cache result if requested\n      if (options.cache) {\n        this.queryCache.set(cacheKey, {\n          result,\n          timestamp: Date.now()\n        });\n      }\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      this.trackQueryPerformance(sql, duration, error);\n      throw error;\n    }\n  }\n  \n  trackQueryPerformance(sql, duration, error = null) {\n    const queryKey = sql.substring(0, 100); // First 100 chars as identifier\n    \n    if (!this.queryStats.has(queryKey)) {\n      this.queryStats.set(queryKey, {\n        sql: queryKey,\n        count: 0,\n        totalTime: 0,\n        avgTime: 0,\n        maxTime: 0,\n        errors: 0\n      });\n    }\n    \n    const stats = this.queryStats.get(queryKey);\n    stats.count++;\n    stats.totalTime += duration;\n    stats.avgTime = stats.totalTime / stats.count;\n    \n    if (duration > stats.maxTime) {\n      stats.maxTime = duration;\n    }\n    \n    if (error) {\n      stats.errors++;\n    }\n    \n    // Log slow queries\n    if (duration > 1000) { // Queries taking more than 1 second\n      this.slowQueries.push({\n        sql,\n        duration,\n        timestamp: Date.now(),\n        error: error ? error.message : null\n      });\n      \n      // Keep only last 100 slow queries\n      if (this.slowQueries.length > 100) {\n        this.slowQueries = this.slowQueries.slice(-100);\n      }\n    }\n  }\n  \n  getCacheKey(sql, params) {\n    return `${sql}:${JSON.stringify(params)}`;\n  }\n  \n  getQueryReport() {\n    return {\n      totalQueries: Array.from(this.queryStats.values()).reduce((sum, stat) => sum + stat.count, 0),\n      slowQueries: this.slowQueries.length,\n      cacheSize: this.queryCache.size,\n      topSlowQueries: [...this.queryStats.values()]\n        .sort((a, b) => b.avgTime - a.avgTime)\n        .slice(0, 10)\n    };\n  }\n  \n  clearCache() {\n    this.queryCache.clear();\n  }\n}\n```\n\n**4. Caching Strategies:**\n```javascript\nclass MultiLevelCache {\n  constructor(options = {}) {\n    this.memoryCache = new Map();\n    this.memoryLimit = options.memoryLimit || 1000;\n    this.defaultTtl = options.defaultTtl || 300000; // 5 minutes\n    this.stats = {\n      hits: 0,\n      misses: 0,\n      sets: 0,\n      evictions: 0\n    };\n  }\n  \n  async get(key, fallbackFn, options = {}) {\n    // Check memory cache first\n    const memoryResult = this.getFromMemory(key);\n    if (memoryResult !== null) {\n      this.stats.hits++;\n      return memoryResult;\n    }\n    \n    // Check external cache (Redis, etc.)\n    if (options.useExternalCache && this.externalCache) {\n      const externalResult = await this.externalCache.get(key);\n      if (externalResult !== null) {\n        // Store in memory cache for faster subsequent access\n        this.setInMemory(key, externalResult, options.ttl);\n        this.stats.hits++;\n        return externalResult;\n      }\n    }\n    \n    this.stats.misses++;\n    \n    // Execute fallback function if provided\n    if (fallbackFn) {\n      const result = await fallbackFn();\n      await this.set(key, result, options);\n      return result;\n    }\n    \n    return null;\n  }\n  \n  async set(key, value, options = {}) {\n    const ttl = options.ttl || this.defaultTtl;\n    \n    // Set in memory cache\n    this.setInMemory(key, value, ttl);\n    \n    // Set in external cache if available\n    if (options.useExternalCache && this.externalCache) {\n      await this.externalCache.set(key, value, ttl);\n    }\n    \n    this.stats.sets++;\n  }\n  \n  getFromMemory(key) {\n    const item = this.memoryCache.get(key);\n    if (!item) return null;\n    \n    if (Date.now() > item.expires) {\n      this.memoryCache.delete(key);\n      return null;\n    }\n    \n    return item.value;\n  }\n  \n  setInMemory(key, value, ttl) {\n    // Evict oldest items if cache is full\n    if (this.memoryCache.size >= this.memoryLimit) {\n      const oldestKey = this.memoryCache.keys().next().value;\n      this.memoryCache.delete(oldestKey);\n      this.stats.evictions++;\n    }\n    \n    this.memoryCache.set(key, {\n      value,\n      expires: Date.now() + ttl,\n      created: Date.now()\n    });\n  }\n  \n  getStats() {\n    const hitRate = this.stats.hits / (this.stats.hits + this.stats.misses) || 0;\n    \n    return {\n      ...this.stats,\n      hitRate: (hitRate * 100).toFixed(2) + '%',\n      memorySize: this.memoryCache.size,\n      memoryLimit: this.memoryLimit\n    };\n  }\n  \n  clear() {\n    this.memoryCache.clear();\n    if (this.externalCache) {\n      this.externalCache.flushall();\n    }\n  }\n}\n```\n\n**5. Clustering and Load Balancing:**\n```javascript\nconst cluster = require('cluster');\nconst os = require('os');\n\nclass ClusterManager {\n  constructor(options = {}) {\n    this.workerCount = options.workers || os.cpus().length;\n    this.restartDelay = options.restartDelay || 1000;\n    this.maxRestarts = options.maxRestarts || 10;\n    this.workerRestarts = new Map();\n  }\n  \n  start(appFactory) {\n    if (cluster.isMaster) {\n      this.startMaster();\n    } else {\n      this.startWorker(appFactory);\n    }\n  }\n  \n  startMaster() {\n    console.log(`Master ${process.pid} is running`);\n    console.log(`Starting ${this.workerCount} workers`);\n    \n    // Fork workers\n    for (let i = 0; i < this.workerCount; i++) {\n      this.forkWorker();\n    }\n    \n    // Handle worker exits\n    cluster.on('exit', (worker, code, signal) => {\n      console.log(`Worker ${worker.process.pid} died with code ${code} and signal ${signal}`);\n      \n      const restarts = this.workerRestarts.get(worker.id) || 0;\n      \n      if (restarts < this.maxRestarts) {\n        console.log(`Restarting worker ${worker.id}`);\n        setTimeout(() => {\n          this.forkWorker();\n        }, this.restartDelay);\n        \n        this.workerRestarts.set(worker.id, restarts + 1);\n      } else {\n        console.error(`Worker ${worker.id} has reached max restarts (${this.maxRestarts})`);\n      }\n    });\n    \n    // Graceful shutdown\n    process.on('SIGTERM', () => this.gracefulShutdown());\n    process.on('SIGINT', () => this.gracefulShutdown());\n  }\n  \n  forkWorker() {\n    const worker = cluster.fork();\n    \n    // Monitor worker health\n    worker.on('message', (msg) => {\n      if (msg.type === 'healthcheck') {\n        worker.send({ type: 'healthcheck-response', timestamp: Date.now() });\n      }\n    });\n    \n    return worker;\n  }\n  \n  startWorker(appFactory) {\n    const app = appFactory();\n    const port = process.env.PORT || 3000;\n    \n    app.listen(port, () => {\n      console.log(`Worker ${process.pid} listening on port ${port}`);\n    });\n    \n    // Worker health monitoring\n    setInterval(() => {\n      process.send({ type: 'healthcheck', worker: process.pid });\n    }, 30000);\n    \n    // Graceful worker shutdown\n    process.on('SIGTERM', () => {\n      console.log(`Worker ${process.pid} received SIGTERM`);\n      app.close(() => {\n        process.exit(0);\n      });\n    });\n  }\n  \n  gracefulShutdown() {\n    console.log('Master received shutdown signal, closing workers...');\n    \n    const workers = Object.values(cluster.workers);\n    workers.forEach(worker => {\n      worker.send('shutdown');\n      worker.disconnect();\n    });\n    \n    setTimeout(() => {\n      workers.forEach(worker => {\n        if (!worker.isDead()) {\n          worker.kill();\n        }\n      });\n      process.exit(0);\n    }, 10000);\n  }\n}\n```\n\n**Performance Best Practices:**\n\n1. **Use streaming for large data**\n2. **Implement proper caching strategies**\n3. **Optimize database queries and indexes**\n4. **Use clustering for CPU-intensive operations**\n5. **Monitor event loop lag**\n6. **Implement connection pooling**\n7. **Use compression for HTTP responses**\n8. **Profile and optimize hot code paths**\n9. **Use async/await properly to avoid blocking**\n10. **Implement proper error handling to prevent crashes**\n\n**Production Monitoring Setup:**\n```javascript\n// Comprehensive monitoring setup\nconst monitor = new ApplicationPerformanceMonitor({\n  memoryWarningThreshold: 500 * 1024 * 1024, // 500MB\n  eventLoopWarningThreshold: 100 // 100ms\n});\n\nmonitor.on('memoryWarning', ({ usage }) => {\n  console.warn('High memory usage detected:', {\n    heapUsed: Math.round(usage.heapUsed / 1024 / 1024),\n    heapTotal: Math.round(usage.heapTotal / 1024 / 1024)\n  });\n});\n\nmonitor.on('eventLoopLag', ({ lag }) => {\n  console.warn('Event loop lag detected:', Math.round(lag), 'ms');\n});\n\n// Expose metrics endpoint\napp.get('/metrics', (req, res) => {\n  res.json(monitor.getMetrics());\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  const metrics = monitor.getMetrics();\n  const isHealthy = metrics.memory.current < 800 * 1024 * 1024 && // Under 800MB\n                   metrics.eventLoop.lag < 200; // Under 200ms\n  \n  res.status(isHealthy ? 200 : 503).json({\n    status: isHealthy ? 'healthy' : 'unhealthy',\n    metrics: metrics\n  });\n});\n```\n\nProper performance optimization requires understanding your application's specific bottlenecks and implementing targeted solutions with continuous monitoring.",
      "keywords": ["performance", "optimization", "profiling", "monitoring", "clustering", "caching", "event-loop", "metrics"],
      "difficulty": "hard"
    }
  ]
}