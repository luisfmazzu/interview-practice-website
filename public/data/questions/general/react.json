{
  "technology": "react",
  "questions": [
    {
      "id": 2000,
      "tag": "react",
      "question": "What is the difference between functional and class components in React?",
      "answer": "**Functional Components:**\n- Simple functions that return JSX\n- Use hooks for state and lifecycle\n- Less boilerplate code\n- Better performance (no instance creation)\n- Recommended approach since React 16.8\n\n**Class Components:**\n- ES6 classes extending React.Component\n- Use this.state and lifecycle methods\n- More verbose syntax\n- Have component instances\n- Legacy approach\n\n**Example:**\n```javascript\n// Functional Component\nfunction Welcome({ name }) {\n  const [count, setCount] = useState(0);\n  return <h1>Hello, {name}! Count: {count}</h1>;\n}\n\n// Class Component\nclass Welcome extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  render() {\n    return <h1>Hello, {this.props.name}! Count: {this.state.count}</h1>;\n  }\n}\n```",
      "keywords": ["functional components", "class components", "hooks", "lifecycle methods", "this.state", "JSX", "React.Component"],
      "difficulty": "easy"
    },
    {
      "id": 2001,
      "tag": "react",
      "question": "Explain the useState hook and provide an example.",
      "answer": "useState is a React hook that allows functional components to have state.\n\n**Syntax:**\n```javascript\nconst [state, setState] = useState(initialValue);\n```\n\n**Example:**\n```javascript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    setCount(count + 1);\n    // Or with functional update:\n    // setCount(prevCount => prevCount + 1);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n**Key points:**\n- Returns array with current state and setter function\n- State updates are asynchronous\n- Use functional updates for state based on previous state\n- Can have multiple useState calls in one component",
      "keywords": ["useState", "hook", "state", "setState", "functional components", "destructuring", "asynchronous", "functional updates"],
      "difficulty": "easy"
    },
    {
      "id": 2002,
      "tag": "react",
      "question": "What is the useEffect hook and when would you use it?",
      "answer": "useEffect is a React hook for performing side effects in functional components.\n\n**Basic Syntax:**\n```javascript\nuseEffect(() => {\n  // Effect logic\n  return () => {\n    // Cleanup (optional)\n  };\n}, [dependencies]); // Dependencies array (optional)\n```\n\n**Common Use Cases:**\n1. **Data fetching:**\n```javascript\nuseEffect(() => {\n  fetchData().then(setData);\n}, []); // Empty array = run once on mount\n```\n\n2. **Subscriptions:**\n```javascript\nuseEffect(() => {\n  const subscription = subscribe();\n  return () => subscription.unsubscribe();\n}, []);\n```\n\n3. **DOM manipulation:**\n```javascript\nuseEffect(() => {\n  document.title = `Count: ${count}`;\n}, [count]); // Run when count changes\n```\n\n**Dependency Array:**\n- No array: runs after every render\n- Empty array []: runs once on mount\n- With values [a, b]: runs when a or b changes",
      "keywords": ["useEffect", "hook", "side effects", "dependencies array", "cleanup", "data fetching", "subscriptions", "DOM manipulation", "mount", "unmount"],
      "difficulty": "medium"
    },
    {
      "id": 2003,
      "tag": "react",
      "question": "Explain React's virtual DOM and its benefits.",
      "answer": "The Virtual DOM is a JavaScript representation of the actual DOM kept in memory and synced with the real DOM through a process called reconciliation.\n\n**How it works:**\n1. React creates a virtual representation of the DOM\n2. When state changes, a new virtual DOM tree is created\n3. React compares (diffs) the new tree with the previous one\n4. Only the differences are updated in the real DOM\n\n**Benefits:**\n- **Performance:** Batch updates and minimize DOM manipulation\n- **Predictability:** Declarative programming model\n- **Developer Experience:** Easier to reason about state changes\n- **Cross-browser Compatibility:** React handles browser differences\n\n**Example:**\n```javascript\n// State change triggers virtual DOM diff\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1> {/* Only this text node updates */}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n**Note:** The virtual DOM is an implementation detail - React Fiber uses a different reconciliation algorithm.",
      "keywords": ["Virtual DOM", "reconciliation", "diffing", "real DOM", "performance", "batch updates", "declarative", "React Fiber", "DOM manipulation"],
      "difficulty": "medium"
    },
    {
      "id": 2004,
      "tag": "react",
      "question": "What are React keys and why are they important?",
      "answer": "Keys are special attributes that help React identify which list items have changed, been added, or removed.\n\n**Why Keys Matter:**\n- Help React efficiently update the DOM\n- Maintain component state correctly\n- Avoid rendering bugs in lists\n- Improve performance during reconciliation\n\n**Good vs Bad Examples:**\n```javascript\n// ❌ Bad: Using array index\nitems.map((item, index) => (\n  <li key={index}>{item.name}</li>\n));\n\n// ❌ Bad: No key\nitems.map(item => (\n  <li>{item.name}</li>\n));\n\n// ✅ Good: Using unique, stable identifier\nitems.map(item => (\n  <li key={item.id}>{item.name}</li>\n));\n```\n\n**Key Requirements:**\n- Must be unique among siblings\n- Should be stable (not change between renders)\n- Should be predictable (same input = same key)\n\n**Common Mistake:**\nUsing array index as key can cause issues when list order changes, as React may incorrectly associate state with wrong components.",
      "keywords": ["keys", "list rendering", "reconciliation", "unique identifiers", "array index", "component state", "siblings", "stable", "predictable"],
      "difficulty": "medium"
    },
    {
      "id": 2005,
      "tag": "react",
      "question": "What is JSX and how does it work under the hood?",
      "answer": "JSX (JavaScript XML) is a syntax extension for JavaScript that allows you to write HTML-like code in your JavaScript files. It's compiled to regular JavaScript function calls.\n\n**JSX to JavaScript Transformation:**\n```javascript\n// JSX\nconst element = <h1 className=\"title\">Hello World!</h1>;\n\n// Compiles to (React 17+):\nimport { jsx as _jsx } from 'react/jsx-runtime';\nconst element = _jsx('h1', { className: 'title', children: 'Hello World!' });\n\n// Before React 17:\nconst element = React.createElement('h1', { className: 'title' }, 'Hello World!');\n```\n\n**JSX Rules:**\n- Must return a single parent element (or Fragment)\n- Use `className` instead of `class`\n- Use camelCase for attributes\n- Self-closing tags must end with `/>`\n- Expressions go in curly braces `{}`\n\n**Benefits:**\n- More readable than createElement calls\n- Familiar HTML-like syntax\n- Compile-time error checking\n- Better developer experience with IDE support",
      "keywords": ["JSX", "JavaScript XML", "React.createElement", "jsx-runtime", "compilation", "transpilation", "className", "camelCase", "expressions", "curly braces"],
      "difficulty": "easy"
    },
    {
      "id": 2006,
      "tag": "react",
      "question": "What is the difference between props and state in React?",
      "answer": "Props and state are both ways to manage data in React components, but they serve different purposes.\n\n**Props (Properties):**\n- Data passed from parent to child components\n- Read-only (immutable)\n- Cannot be modified by the receiving component\n- Used for component configuration and communication\n\n**State:**\n- Internal data managed by the component itself\n- Mutable (can be updated)\n- Triggers re-renders when changed\n- Local to the component\n\n**Example:**\n```javascript\n// Parent component\nfunction App() {\n  const [count, setCount] = useState(0); // State\n  \n  return (\n    <div>\n      <Counter count={count} onIncrement={() => setCount(count + 1)} /> {/* Props */}\n    </div>\n  );\n}\n\n// Child component\nfunction Counter({ count, onIncrement }) {\n  const [isHovered, setIsHovered] = useState(false); // Local state\n  \n  return (\n    <button \n      onClick={onIncrement}\n      onMouseEnter={() => setIsHovered(true)}\n      style={{ backgroundColor: isHovered ? 'lightblue' : 'white' }}\n    >\n      Count: {count}\n    </button>\n  );\n}\n```",
      "keywords": ["props", "state", "immutable", "mutable", "parent component", "child component", "useState", "re-render", "configuration", "communication"],
      "difficulty": "easy"
    },
    {
      "id": 2007,
      "tag": "react",
      "question": "What are controlled vs uncontrolled components?",
      "answer": "This refers to how form inputs manage their state in React.\n\n**Controlled Components:**\n- Form input values are controlled by React state\n- Value is set via props and changes via event handlers\n- React is the \"single source of truth\"\n- More predictable and easier to validate\n\n**Uncontrolled Components:**\n- Form inputs manage their own state internally\n- Access values using refs\n- DOM is the source of truth\n- Less code, but harder to validate or manipulate\n\n**Examples:**\n```javascript\n// Controlled Component\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n  \n  return (\n    <input \n      value={value} \n      onChange={(e) => setValue(e.target.value)}\n      placeholder=\"Controlled\"\n    />\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledInput() {\n  const inputRef = useRef();\n  \n  const handleSubmit = () => {\n    console.log(inputRef.current.value);\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} placeholder=\"Uncontrolled\" />\n      <button onClick={handleSubmit}>Get Value</button>\n    </div>\n  );\n}\n```\n\n**When to use:**\n- **Controlled:** Form validation, conditional formatting, dynamic inputs\n- **Uncontrolled:** Simple forms, performance-critical scenarios",
      "keywords": ["controlled components", "uncontrolled components", "form inputs", "state management", "refs", "single source of truth", "DOM", "validation", "event handlers"],
      "difficulty": "easy"
    },
    {
      "id": 2008,
      "tag": "react",
      "question": "What are the different ways to implement conditional rendering in React?",
      "answer": "React offers several techniques for conditional rendering based on state or props.\n\n**1. If/Else Statements:**\n```javascript\nfunction Greeting({ isLoggedIn }) {\n  if (isLoggedIn) {\n    return <h1>Welcome back!</h1>;\n  } else {\n    return <h1>Please sign in.</h1>;\n  }\n}\n```\n\n**2. Ternary Operator:**\n```javascript\nfunction Greeting({ isLoggedIn }) {\n  return (\n    <h1>{isLoggedIn ? 'Welcome back!' : 'Please sign in.'}</h1>\n  );\n}\n```\n\n**3. Logical AND (&&) Operator:**\n```javascript\nfunction Notification({ hasMessages }) {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {hasMessages && <p>You have new messages!</p>}\n    </div>\n  );\n}\n```\n\n**4. Switch Statements (for multiple conditions):**\n```javascript\nfunction StatusIndicator({ status }) {\n  const renderStatus = () => {\n    switch (status) {\n      case 'loading': return <Spinner />;\n      case 'error': return <Error />;\n      case 'success': return <Success />;\n      default: return null;\n    }\n  };\n  \n  return <div>{renderStatus()}</div>;\n}\n```\n\n**5. IIFE (Immediately Invoked Function Expression):**\n```javascript\nfunction ComplexComponent({ data }) {\n  return (\n    <div>\n      {(() => {\n        if (!data) return <Loading />;\n        if (data.error) return <Error error={data.error} />;\n        return <Content data={data} />;\n      })()\n      }\n    </div>\n  );\n}\n```",
      "keywords": ["conditional rendering", "ternary operator", "logical AND", "if else", "switch statement", "IIFE", "null", "falsy values"],
      "difficulty": "easy"
    },
    {
      "id": 2009,
      "tag": "react",
      "question": "How does event handling work in React?",
      "answer": "React uses SyntheticEvents, which are wrappers around native DOM events that provide consistent behavior across browsers.\n\n**Basic Event Handling:**\n```javascript\nfunction Button() {\n  const handleClick = (event) => {\n    console.log('Button clicked!', event);\n    event.preventDefault(); // Works across all browsers\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Event Object Properties:**\n- `event.target`: Element that triggered the event\n- `event.currentTarget`: Element the event handler is attached to\n- `event.preventDefault()`: Prevents default behavior\n- `event.stopPropagation()`: Stops event bubbling\n\n**Passing Parameters:**\n```javascript\nfunction ItemList({ items }) {\n  const handleDelete = (id, event) => {\n    console.log('Delete item:', id);\n  };\n  \n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>\n          {item.name}\n          <button onClick={(e) => handleDelete(item.id, e)}>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Form Events:**\n```javascript\nfunction LoginForm() {\n  const [email, setEmail] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitting:', email);\n  };\n  \n  const handleChange = (e) => {\n    setEmail(e.target.value);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" value={email} onChange={handleChange} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n```\n\n**Benefits of SyntheticEvents:**\n- Cross-browser compatibility\n- Consistent API\n- Automatic event delegation\n- Memory efficient",
      "keywords": ["SyntheticEvents", "event handling", "onClick", "onChange", "onSubmit", "event object", "preventDefault", "stopPropagation", "event delegation", "cross-browser"],
      "difficulty": "easy"
    },
    {
      "id": 2010,
      "tag": "react",
      "question": "What is the useRef hook and what are its common use cases?",
      "answer": "useRef is a React hook that creates a mutable reference that persists across re-renders without causing re-renders when changed.\n\n**Basic Syntax:**\n```javascript\nconst ref = useRef(initialValue);\n```\n\n**Common Use Cases:**\n\n**1. Accessing DOM Elements:**\n```javascript\nfunction FocusInput() {\n  const inputRef = useRef(null);\n  \n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </div>\n  );\n}\n```\n\n**2. Storing Mutable Values:**\n```javascript\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  const intervalRef = useRef(null);\n  \n  const startTimer = () => {\n    intervalRef.current = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n  };\n  \n  const stopTimer = () => {\n    clearInterval(intervalRef.current);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={startTimer}>Start</button>\n      <button onClick={stopTimer}>Stop</button>\n    </div>\n  );\n}\n```\n\n**3. Keeping Previous Values:**\n```javascript\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nfunction Component({ value }) {\n  const previousValue = usePrevious(value);\n  return <div>Current: {value}, Previous: {previousValue}</div>;\n}\n```\n\n**Key Points:**\n- Doesn't trigger re-renders when `.current` changes\n- Persists across re-renders\n- Mutable unlike state\n- Useful for imperative operations",
      "keywords": ["useRef", "mutable reference", "DOM access", "imperative operations", "previous values", "intervals", "focus", "current property", "persistent"],
      "difficulty": "easy"
    },
    {
      "id": 2011,
      "tag": "react",
      "question": "Explain React component lifecycle methods in class components.",
      "answer": "React class components have lifecycle methods that allow you to hook into different phases of a component's life.\n\n**Three Main Phases:**\n\n**1. Mounting (Component Creation):**\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    // Initialize state, bind methods\n  }\n  \n  componentDidMount() {\n    // DOM is available, make API calls\n    fetch('/api/data').then(data => this.setState({ data }));\n  }\n}\n```\n\n**2. Updating (Re-renders):**\n```javascript\ncomponentDidUpdate(prevProps, prevState) {\n  // Component updated, compare prev and current\n  if (prevProps.userId !== this.props.userId) {\n    this.fetchUserData(this.props.userId);\n  }\n}\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  // Capture info before DOM update (rare)\n  return null;\n}\n```\n\n**3. Unmounting (Component Removal):**\n```javascript\ncomponentWillUnmount() {\n  // Cleanup: clear timers, cancel requests, remove listeners\n  clearInterval(this.timer);\n  this.abortController.abort();\n}\n```\n\n**Complete Example:**\n```javascript\nclass UserProfile extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { user: null, loading: true };\n  }\n  \n  componentDidMount() {\n    this.fetchUser(this.props.userId);\n  }\n  \n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser(this.props.userId);\n    }\n  }\n  \n  componentWillUnmount() {\n    // Cancel any pending requests\n  }\n  \n  fetchUser = (userId) => {\n    this.setState({ loading: true });\n    // API call logic\n  };\n  \n  render() {\n    return this.state.loading ? <div>Loading...</div> : <div>{this.state.user.name}</div>;\n  }\n}\n```\n\n**Modern Equivalent (Hooks):**\nUse useEffect hook in functional components for similar functionality.",
      "keywords": ["lifecycle methods", "mounting", "updating", "unmounting", "componentDidMount", "componentDidUpdate", "componentWillUnmount", "constructor", "render", "class components"],
      "difficulty": "easy"
    },
    {
      "id": 2012,
      "tag": "react",
      "question": "How do you render lists in React and what are best practices for keys?",
      "answer": "Rendering lists in React involves mapping over arrays and returning JSX elements, with proper key management being crucial for performance.\n\n**Basic List Rendering:**\n```javascript\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <span>{todo.text}</span>\n          <button>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Complex List with Components:**\n```javascript\nfunction UserList({ users }) {\n  return (\n    <div>\n      {users.map(user => (\n        <UserCard \n          key={user.id} \n          user={user} \n          onDelete={() => handleDelete(user.id)}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n**Conditional List Items:**\n```javascript\nfunction ProductList({ products, showOutOfStock }) {\n  return (\n    <div>\n      {products\n        .filter(product => showOutOfStock || product.inStock)\n        .map(product => (\n          <ProductCard key={product.id} product={product} />\n        ))\n      }\n    </div>\n  );\n}\n```\n\n**Best Practices for Keys:**\n\n**✅ Good Keys:**\n```javascript\n// Unique database IDs\nitems.map(item => <Item key={item.id} data={item} />)\n\n// Generated stable IDs\nitems.map(item => <Item key={`${item.type}-${item.name}`} data={item} />)\n```\n\n**❌ Avoid:**\n```javascript\n// Array index (problematic with reordering)\nitems.map((item, index) => <Item key={index} data={item} />)\n\n// Random values (causes unnecessary re-renders)\nitems.map(item => <Item key={Math.random()} data={item} />)\n```\n\n**Empty Lists:**\n```javascript\nfunction MessageList({ messages }) {\n  return (\n    <div>\n      {messages.length === 0 ? (\n        <p>No messages yet</p>\n      ) : (\n        messages.map(message => (\n          <Message key={message.id} data={message} />\n        ))\n      )}\n    </div>\n  );\n}\n```\n\n**Performance Tip:** For large lists, consider virtualization libraries like react-window or react-virtualized.",
      "keywords": ["list rendering", "map", "keys", "unique identifiers", "array index", "filter", "conditional rendering", "empty lists", "performance", "virtualization"],
      "difficulty": "easy"
    },
    {
      "id": 2013,
      "tag": "react",
      "question": "What is the useCallback hook and when should you use it?",
      "answer": "useCallback is a React hook that returns a memoized callback function. It's used to optimize performance by preventing unnecessary re-creation of functions.\n\n**Basic Syntax:**\n```javascript\nconst memoizedCallback = useCallback(\n  () => {\n    // callback logic\n  },\n  [dependencies]\n);\n```\n\n**Problem Without useCallback:**\n```javascript\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  \n  // This function is recreated on every render\n  const handleClick = () => {\n    console.log('clicked');\n  };\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <ExpensiveChild onClick={handleClick} /> {/* Re-renders even when only name changes */}\n    </div>\n  );\n}\n```\n\n**Solution With useCallback:**\n```javascript\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  \n  // Function is memoized and only recreated when dependencies change\n  const handleClick = useCallback(() => {\n    console.log('clicked', count);\n  }, [count]); // Only recreate when count changes\n  \n  const handleIncrement = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []); // No dependencies, never recreates\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <ExpensiveChild onClick={handleClick} onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\nconst ExpensiveChild = React.memo(({ onClick, onIncrement }) => {\n  console.log('ExpensiveChild rendered');\n  return (\n    <div>\n      <button onClick={onClick}>Log Count</button>\n      <button onClick={onIncrement}>Increment</button>\n    </div>\n  );\n});\n```\n\n**When to Use useCallback:**\n- Passing callbacks to optimized child components (wrapped with React.memo)\n- Callbacks passed to dependency arrays of other hooks\n- Preventing infinite loops in useEffect\n- When callback creation is expensive\n\n**When NOT to Use:**\n- Simple functions that aren't passed as props\n- When the dependencies change frequently anyway\n- Over-optimization can hurt performance\n\n**With useEffect:**\n```javascript\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  \n  const fetchResults = useCallback(async (searchQuery) => {\n    const data = await api.search(searchQuery);\n    setResults(data);\n  }, []);\n  \n  useEffect(() => {\n    fetchResults(query);\n  }, [query, fetchResults]); // fetchResults won't cause infinite loops\n  \n  return <ResultsList results={results} />;\n}\n```",
      "keywords": ["useCallback", "memoization", "performance optimization", "React.memo", "function recreation", "dependencies", "useEffect", "infinite loops", "callback functions"],
      "difficulty": "medium"
    },
    {
      "id": 2014,
      "tag": "react",
      "question": "Explain the useMemo hook and how it helps with performance optimization.",
      "answer": "useMemo is a React hook that memoizes expensive calculations and only recalculates when dependencies change, helping optimize performance.\n\n**Basic Syntax:**\n```javascript\nconst memoizedValue = useMemo(\n  () => expensiveCalculation(a, b),\n  [a, b]\n);\n```\n\n**Problem Without useMemo:**\n```javascript\nfunction ExpensiveComponent({ items, filter }) {\n  // This expensive calculation runs on every render\n  const expensiveValue = items\n    .filter(item => item.category === filter)\n    .reduce((sum, item) => sum + item.value, 0);\n  \n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Total: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n}\n```\n\n**Solution With useMemo:**\n```javascript\nfunction ExpensiveComponent({ items, filter }) {\n  // Only recalculates when items or filter change\n  const expensiveValue = useMemo(() => {\n    console.log('Calculating expensive value...');\n    return items\n      .filter(item => item.category === filter)\n      .reduce((sum, item) => sum + item.value, 0);\n  }, [items, filter]);\n  \n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Total: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n}\n```\n\n**Memoizing Objects and Arrays:**\n```javascript\nfunction UserProfile({ user }) {\n  // Prevents new object creation on every render\n  const userSettings = useMemo(() => ({\n    theme: user.preferences.theme,\n    language: user.preferences.language,\n    notifications: user.preferences.notifications\n  }), [user.preferences]);\n  \n  // Prevents new array creation\n  const sortedFriends = useMemo(() => \n    user.friends.sort((a, b) => a.name.localeCompare(b.name)),\n    [user.friends]\n  );\n  \n  return (\n    <div>\n      <Settings config={userSettings} />\n      <FriendsList friends={sortedFriends} />\n    </div>\n  );\n}\n```\n\n**Custom Hook with useMemo:**\n```javascript\nfunction useFilteredAndSortedData(data, filter, sortBy) {\n  return useMemo(() => {\n    return data\n      .filter(item => item.type === filter)\n      .sort((a, b) => {\n        if (sortBy === 'name') return a.name.localeCompare(b.name);\n        if (sortBy === 'date') return new Date(a.date) - new Date(b.date);\n        return 0;\n      });\n  }, [data, filter, sortBy]);\n}\n```\n\n**When to Use useMemo:**\n- Expensive calculations that depend on specific values\n- Creating objects/arrays that are passed as props to memoized components\n- Breaking referential equality issues\n- Heavy filtering, sorting, or data transformations\n\n**When NOT to Use:**\n- Simple calculations (primitives, basic operations)\n- Values that change frequently anyway\n- Over-memoization can hurt performance due to comparison overhead",
      "keywords": ["useMemo", "memoization", "performance optimization", "expensive calculations", "referential equality", "dependencies", "data transformation", "filtering", "sorting"],
      "difficulty": "medium"
    },
    {
      "id": 2015,
      "tag": "react",
      "question": "Explain the useContext hook and React's Context API.",
      "answer": "useContext hook and Context API provide a way to share data across the component tree without prop drilling.\n\n**Creating Context:**\n```javascript\nimport { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext();\n\n// Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Custom hook for using context\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n```\n\n**Using Context:**\n```javascript\nfunction App() {\n  return (\n    <ThemeProvider>\n      <Header />\n      <MainContent />\n      <Footer />\n    </ThemeProvider>\n  );\n}\n\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <header style={{ backgroundColor: theme === 'light' ? 'white' : 'black' }}>\n      <h1>My App</h1>\n      <button onClick={toggleTheme}>\n        Switch to {theme === 'light' ? 'dark' : 'light'} mode\n      </button>\n    </header>\n  );\n}\n\nfunction MainContent() {\n  const { theme } = useTheme();\n  \n  return (\n    <main style={{ color: theme === 'light' ? 'black' : 'white' }}>\n      <p>Content styled with current theme</p>\n    </main>\n  );\n}\n```\n\n**Multiple Contexts:**\n```javascript\nconst UserContext = createContext();\nconst SettingsContext = createContext();\n\nfunction App() {\n  return (\n    <UserProvider>\n      <SettingsProvider>\n        <ThemeProvider>\n          <Dashboard />\n        </ThemeProvider>\n      </SettingsProvider>\n    </UserProvider>\n  );\n}\n\nfunction Dashboard() {\n  const user = useContext(UserContext);\n  const settings = useContext(SettingsContext);\n  const { theme } = useTheme();\n  \n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <p>Language: {settings.language}</p>\n      <p>Theme: {theme}</p>\n    </div>\n  );\n}\n```\n\n**Advanced Pattern - Reducer with Context:**\n```javascript\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  return useContext(StateContext);\n}\n\nfunction useAppDispatch() {\n  return useContext(DispatchContext);\n}\n```\n\n**Benefits:**\n- Eliminates prop drilling\n- Clean component hierarchy\n- Centralized state management\n- Type-safe with TypeScript\n\n**Considerations:**\n- Context changes re-render all consuming components\n- Not suitable for frequently changing data\n- Consider splitting contexts for different concerns\n- Use React.memo to optimize consumers",
      "keywords": ["useContext", "Context API", "createContext", "Provider", "prop drilling", "global state", "custom hooks", "context splitting", "performance", "state management"],
      "difficulty": "medium"
    },
    {
      "id": 2016,
      "tag": "react",
      "question": "What are custom hooks and what are their benefits?",
      "answer": "Custom hooks are JavaScript functions that start with 'use' and allow you to extract and reuse stateful logic between components.\n\n**Basic Custom Hook:**\n```javascript\n// Custom hook for managing counter state\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  \n  const increment = useCallback(() => setCount(prev => prev + 1), []);\n  const decrement = useCallback(() => setCount(prev => prev - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n  \n  return { count, increment, decrement, reset };\n}\n\n// Usage in components\nfunction Counter() {\n  const { count, increment, decrement, reset } = useCounter(10);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n```\n\n**Data Fetching Hook:**\n```javascript\nfunction useApi(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Failed to fetch');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    if (url) fetchData();\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { data: user, loading, error } = useApi(`/api/users/${userId}`);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return null;\n  \n  return <div><h1>{user.name}</h1><p>{user.email}</p></div>;\n}\n```\n\n**Form Management Hook:**\n```javascript\nfunction useForm(initialValues, validationRules = {}) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  \n  const handleChange = (name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Validate if field has been touched\n    if (touched[name] && validationRules[name]) {\n      const error = validationRules[name](value);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const handleBlur = (name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    if (validationRules[name]) {\n      const error = validationRules[name](values[name]);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const isValid = Object.values(errors).every(error => !error);\n  \n  return {\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    isValid\n  };\n}\n```\n\n**Local Storage Hook:**\n```javascript\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n  \n  const setStoredValue = useCallback((newValue) => {\n    try {\n      setValue(newValue);\n      window.localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.error('Error saving to localStorage:', error);\n    }\n  }, [key]);\n  \n  return [value, setStoredValue];\n}\n```\n\n**Benefits of Custom Hooks:**\n- **Reusability:** Share logic across multiple components\n- **Separation of Concerns:** Extract complex logic from components\n- **Testing:** Test logic independently of UI\n- **Cleaner Components:** Focus on rendering, not state management\n- **Composition:** Combine multiple custom hooks\n- **Type Safety:** Full TypeScript support\n\n**Rules for Custom Hooks:**\n- Must start with 'use'\n- Can only be called at the top level\n- Can use other hooks\n- Should be pure functions that return consistent values",
      "keywords": ["custom hooks", "reusable logic", "stateful logic", "separation of concerns", "composition", "data fetching", "form management", "localStorage", "testing", "TypeScript"],
      "difficulty": "medium"
    },
    {
      "id": 2017,
      "tag": "react",
      "question": "What are React fragments and when should you use them?",
      "answer": "React fragments allow you to group multiple elements without adding extra DOM nodes. They solve the problem of needing a single parent element in JSX.\n\n**Problem Without Fragments:**\n```javascript\n// Creates unnecessary div wrapper\nfunction UserInfo() {\n  return (\n    <div> {/* Extra wrapper div */}\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </div>\n  );\n}\n```\n\n**Solution With Fragments:**\n```javascript\n// Method 1: React.Fragment\nfunction UserInfo() {\n  return (\n    <React.Fragment>\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </React.Fragment>\n  );\n}\n\n// Method 2: Short syntax (preferred)\nfunction UserInfo() {\n  return (\n    <>\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </>\n  );\n}\n```\n\n**When to Use Fragments:**\n- Avoid unnecessary wrapper divs\n- Maintain proper HTML semantics\n- Table rows, list items, or form elements\n- CSS Grid/Flexbox layouts where extra wrappers break styling\n\n**Fragment with Keys (for lists):**\n```javascript\nfunction ItemList({ items }) {\n  return (\n    <dl>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.definition}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n```\n\n**Benefits:**\n- Cleaner DOM structure\n- Better performance (fewer DOM nodes)\n- Proper HTML semantics\n- CSS styling flexibility",
      "keywords": ["React.Fragment", "fragments", "short syntax", "DOM nodes", "JSX", "wrapper divs", "HTML semantics", "keys", "performance"],
      "difficulty": "easy"
    },
    {
      "id": 2018,
      "tag": "react",
      "question": "How do default props and prop types work in React?",
      "answer": "Default props and prop types help with component reliability by providing default values and type checking for props.\n\n**Default Props (Function Components):**\n```javascript\nfunction Button({ text, variant, disabled, onClick }) {\n  return (\n    <button \n      className={`btn btn-${variant}`}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {text}\n    </button>\n  );\n}\n\n// Method 1: Default parameters\nfunction Button({ \n  text = 'Click me', \n  variant = 'primary', \n  disabled = false, \n  onClick = () => {} \n}) {\n  return <button className={`btn btn-${variant}`}>{text}</button>;\n}\n\n// Method 2: defaultProps (legacy)\nButton.defaultProps = {\n  text: 'Click me',\n  variant: 'primary',\n  disabled: false,\n  onClick: () => {}\n};\n```\n\n**PropTypes (Development-time type checking):**\n```javascript\nimport PropTypes from 'prop-types';\n\nfunction UserCard({ name, age, email, isActive, hobbies, onEdit }) {\n  return (\n    <div>\n      <h3>{name}</h3>\n      <p>Age: {age}</p>\n      <p>Email: {email}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n      <ul>\n        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}\n      </ul>\n      <button onClick={onEdit}>Edit</button>\n    </div>\n  );\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  email: PropTypes.string.isRequired,\n  isActive: PropTypes.bool,\n  hobbies: PropTypes.arrayOf(PropTypes.string),\n  onEdit: PropTypes.func.isRequired\n};\n\nUserCard.defaultProps = {\n  age: 0,\n  isActive: true,\n  hobbies: []\n};\n```\n\n**Common PropTypes:**\n```javascript\nMyComponent.propTypes = {\n  // Basic types\n  name: PropTypes.string,\n  count: PropTypes.number,\n  isVisible: PropTypes.bool,\n  callback: PropTypes.func,\n  data: PropTypes.object,\n  items: PropTypes.array,\n  \n  // Required props\n  id: PropTypes.string.isRequired,\n  \n  // Specific values\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n  \n  // Array of specific type\n  numbers: PropTypes.arrayOf(PropTypes.number),\n  \n  // Object with specific shape\n  user: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    email: PropTypes.string\n  }),\n  \n  // Custom validator\n  score: function(props, propName, componentName) {\n    if (props[propName] < 0 || props[propName] > 100) {\n      return new Error(`${propName} should be between 0 and 100`);\n    }\n  }\n};\n```\n\n**Modern Alternative (TypeScript):**\n```typescript\ninterface ButtonProps {\n  text?: string;\n  variant?: 'primary' | 'secondary' | 'danger';\n  disabled?: boolean;\n  onClick: () => void;\n}\n\nfunction Button({ \n  text = 'Click me', \n  variant = 'primary', \n  disabled = false, \n  onClick \n}: ButtonProps) {\n  return (\n    <button \n      className={`btn btn-${variant}`}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {text}\n    </button>\n  );\n}\n```",
      "keywords": ["default props", "defaultProps", "PropTypes", "type checking", "prop validation", "isRequired", "default parameters", "TypeScript", "component reliability"],
      "difficulty": "easy"
    },
    {
      "id": 2019,
      "tag": "react",
      "question": "What are synthetic events and how do they differ from native DOM events?",
      "answer": "Synthetic events are React's wrapper around native DOM events that provide consistent behavior across different browsers and additional functionality.\n\n**Key Differences:**\n\n**Native DOM Events:**\n```javascript\n// Native event handling (outside React)\ndocument.getElementById('button').addEventListener('click', function(e) {\n  console.log(e); // Native Event object\n  e.stopPropagation(); // Browser-specific implementation\n});\n```\n\n**Synthetic Events:**\n```javascript\nfunction Button() {\n  const handleClick = (e) => {\n    console.log(e); // SyntheticEvent object\n    console.log(e.nativeEvent); // Access to original native event\n    e.preventDefault(); // Consistent across browsers\n    e.stopPropagation(); // Consistent across browsers\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**SyntheticEvent Properties:**\n```javascript\nfunction InputHandler() {\n  const handleEvent = (e) => {\n    // Common properties available across all browsers\n    console.log(e.type); // Event type (click, change, etc.)\n    console.log(e.target); // Element that triggered the event\n    console.log(e.currentTarget); // Element event handler is attached to\n    console.log(e.timeStamp); // When event occurred\n    \n    // Methods work consistently across browsers\n    e.preventDefault(); // Prevent default behavior\n    e.stopPropagation(); // Stop event bubbling\n    \n    // Access native event if needed\n    console.log(e.nativeEvent);\n  };\n  \n  return (\n    <div>\n      <input onChange={handleEvent} onClick={handleEvent} />\n      <button onSubmit={handleEvent}>Submit</button>\n    </div>\n  );\n}\n```\n\n**Event Pooling (React 16 and below):**\n```javascript\nfunction OldEventHandling() {\n  const handleClick = (e) => {\n    // In React 16 and below, events were pooled\n    console.log(e.type); // Works immediately\n    \n    setTimeout(() => {\n      console.log(e.type); // Would be null due to pooling\n      \n      // Solution: persist the event\n      e.persist();\n      console.log(e.type); // Now works\n    }, 1000);\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n\n// React 17+: No more event pooling\nfunction ModernEventHandling() {\n  const handleClick = (e) => {\n    setTimeout(() => {\n      console.log(e.type); // Works fine, no need for e.persist()\n    }, 1000);\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Form Events Example:**\n```javascript\nfunction FormComponent() {\n  const handleSubmit = (e) => {\n    e.preventDefault(); // Prevents page reload\n    console.log('Form submitted');\n  };\n  \n  const handleChange = (e) => {\n    console.log(e.target.value); // Consistent across all browsers\n    console.log(e.target.name); // Input name attribute\n  };\n  \n  const handleKeyPress = (e) => {\n    if (e.key === 'Enter') {\n      console.log('Enter pressed');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        name=\"username\" \n        onChange={handleChange} \n        onKeyPress={handleKeyPress} \n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**Benefits of Synthetic Events:**\n- **Cross-browser compatibility:** Consistent API across all browsers\n- **Event delegation:** Better performance through automatic event delegation\n- **Additional features:** Extra properties and methods not in native events\n- **Memory efficiency:** Event pooling (React 16 and below)\n- **Easier testing:** Predictable event objects for unit tests\n\n**When to Use Native Events:**\n- Direct DOM manipulation outside React\n- Third-party library integration\n- Specific browser APIs not wrapped by SyntheticEvents\n- Performance-critical scenarios requiring direct event handling",
      "keywords": ["synthetic events", "native events", "cross-browser compatibility", "event delegation", "event pooling", "preventDefault", "stopPropagation", "nativeEvent", "SyntheticEvent"],
      "difficulty": "easy"
    },
    {
      "id": 2020,
      "tag": "react",
      "question": "What is React.memo and how does it help optimize component performance?",
      "answer": "React.memo is a higher-order component that memoizes functional components, preventing unnecessary re-renders when props haven't changed.\n\n**Basic Usage:**\n```javascript\n// Without React.memo - re-renders on every parent render\nfunction ExpensiveComponent({ name, count }) {\n  console.log('ExpensiveComponent rendered');\n  \n  // Expensive calculation\n  const expensiveValue = useMemo(() => {\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += i;\n    }\n    return result;\n  }, []);\n  \n  return (\n    <div>\n      <h2>Hello {name}</h2>\n      <p>Count: {count}</p>\n      <p>Expensive result: {expensiveValue}</p>\n    </div>\n  );\n}\n\n// With React.memo - only re-renders when props change\nconst MemoizedComponent = React.memo(ExpensiveComponent);\n```\n\n**Parent Component Example:**\n```javascript\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('John');\n  const [otherState, setOtherState] = useState('');\n  \n  return (\n    <div>\n      <input \n        value={otherState} \n        onChange={(e) => setOtherState(e.target.value)}\n        placeholder=\"This won't cause re-render\"\n      />\n      \n      {/* Only re-renders when name or count change */}\n      <MemoizedComponent name={name} count={count} />\n      \n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setName(name === 'John' ? 'Jane' : 'John')}>\n        Toggle Name\n      </button>\n    </div>\n  );\n}\n```\n\n**Custom Comparison Function:**\n```javascript\nfunction UserCard({ user, theme }) {\n  return (\n    <div className={`card ${theme}`}>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n      <p>Last login: {user.lastLogin}</p>\n    </div>\n  );\n}\n\n// Custom comparison - only re-render if user.name or theme changes\nconst MemoizedUserCard = React.memo(UserCard, (prevProps, nextProps) => {\n  // Return true if props are equal (should NOT re-render)\n  // Return false if props are different (should re-render)\n  return (\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.theme === nextProps.theme\n  );\n});\n```\n\n**Common Pitfalls - Object/Array Props:**\n```javascript\n// ❌ Problem: New object created on every render\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <MemoizedChild \n      user={{ name: 'John', age: 30 }} // New object every render!\n      onAction={() => console.log('action')} // New function every render!\n    />\n  );\n}\n\n// ✅ Solution: Memoize objects and callbacks\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  const user = useMemo(() => ({ name: 'John', age: 30 }), []);\n  const handleAction = useCallback(() => console.log('action'), []);\n  \n  return (\n    <MemoizedChild user={user} onAction={handleAction} />\n  );\n}\n```\n\n**With Complex Props:**\n```javascript\nfunction ProductList({ products, filters, onProductClick }) {\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => {\n      return filters.category ? product.category === filters.category : true;\n    });\n  }, [products, filters]);\n  \n  return (\n    <div>\n      {filteredProducts.map(product => (\n        <ProductCard\n          key={product.id}\n          product={product}\n          onClick={onProductClick}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Memoize ProductCard to prevent unnecessary re-renders\nconst ProductCard = React.memo(({ product, onClick }) => {\n  return (\n    <div onClick={() => onClick(product.id)}>\n      <h3>{product.name}</h3>\n      <p>${product.price}</p>\n    </div>\n  );\n});\n```\n\n**When to Use React.memo:**\n- Components that render frequently with same props\n- Expensive rendering operations\n- Components in large lists\n- Pure functional components\n\n**When NOT to Use React.memo:**\n- Props change frequently anyway\n- Simple components with minimal rendering cost\n- Over-optimization can hurt performance\n- Components that always receive different props\n\n**Performance Tip:**\nCombine with useCallback and useMemo to maximize benefits:\n```javascript\nconst OptimizedParent = () => {\n  const [items, setItems] = useState([]);\n  const [filter, setFilter] = useState('');\n  \n  const filteredItems = useMemo(() => \n    items.filter(item => item.name.includes(filter)), \n    [items, filter]\n  );\n  \n  const handleItemClick = useCallback((id) => {\n    console.log('Clicked item:', id);\n  }, []);\n  \n  return (\n    <MemoizedItemList \n      items={filteredItems} \n      onItemClick={handleItemClick} \n    />\n  );\n};\n```",
      "keywords": ["React.memo", "memoization", "performance optimization", "re-renders", "shallow comparison", "custom comparison", "useCallback", "useMemo", "props comparison", "higher-order component"],
      "difficulty": "easy"
    },
    {
      "id": 2021,
      "tag": "react",
      "question": "Explain the useReducer hook and when you should use it over useState.",
      "answer": "useReducer is a React hook that provides a more predictable way to manage complex state logic using a reducer function, similar to Redux.\n\n**Basic useReducer Setup:**\n```javascript\nimport React, { useReducer } from 'react';\n\n// Define initial state\nconst initialState = { count: 0 };\n\n// Define reducer function\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    case 'RESET':\n      return { count: 0 };\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(counterReducer, initialState);\n  \n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>\n      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>\n    </div>\n  );\n}\n```\n\n**Complex State Example:**\n```javascript\nconst initialState = {\n  user: null,\n  loading: false,\n  error: null,\n  posts: []\n};\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'FETCH_USER_START':\n      return {\n        ...state,\n        loading: true,\n        error: null\n      };\n      \n    case 'FETCH_USER_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        user: action.payload,\n        error: null\n      };\n      \n    case 'FETCH_USER_ERROR':\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n        user: null\n      };\n      \n    case 'ADD_POST':\n      return {\n        ...state,\n        posts: [...state.posts, action.payload]\n      };\n      \n    case 'DELETE_POST':\n      return {\n        ...state,\n        posts: state.posts.filter(post => post.id !== action.payload)\n      };\n      \n    default:\n      return state;\n  }\n}\n\nfunction UserDashboard() {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  const fetchUser = async (userId) => {\n    dispatch({ type: 'FETCH_USER_START' });\n    \n    try {\n      const user = await api.getUser(userId);\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });\n    }\n  };\n  \n  const addPost = (post) => {\n    dispatch({ type: 'ADD_POST', payload: post });\n  };\n  \n  if (state.loading) return <div>Loading...</div>;\n  if (state.error) return <div>Error: {state.error}</div>;\n  \n  return (\n    <div>\n      {state.user && <h1>Welcome, {state.user.name}!</h1>}\n      <PostList posts={state.posts} onAddPost={addPost} />\n    </div>\n  );\n}\n```\n\n**useReducer with useContext (Global State):**\n```javascript\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\n// Custom hooks for consuming context\nfunction useAppState() {\n  const context = useContext(StateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = useContext(DispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within AppProvider');\n  }\n  return context;\n}\n```\n\n**When to Use useReducer vs useState:**\n\n**Use useReducer when:**\n- Complex state logic with multiple sub-values\n- Next state depends on previous state\n- State transitions need to be predictable\n- Managing related state that changes together\n- Need to optimize performance (fewer re-renders)\n- Complex update logic that would benefit from centralization\n\n**Use useState when:**\n- Simple state values (strings, numbers, booleans)\n- Independent state variables\n- State updates are straightforward\n- Small components with minimal state logic\n\n**Comparison Example:**\n```javascript\n// useState - Good for simple state\nfunction SimpleForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [loading, setLoading] = useState(false);\n  \n  // Multiple separate setState calls\n  const handleSubmit = async () => {\n    setLoading(true);\n    try {\n      await submitForm({ name, email });\n      setName('');\n      setEmail('');\n    } finally {\n      setLoading(false);\n    }\n  };\n}\n\n// useReducer - Better for complex state\nfunction ComplexForm() {\n  const [state, dispatch] = useReducer(formReducer, {\n    name: '',\n    email: '',\n    loading: false,\n    errors: {},\n    submitted: false\n  });\n  \n  // Single dispatch call for related state changes\n  const handleSubmit = async () => {\n    dispatch({ type: 'SUBMIT_START' });\n    try {\n      await submitForm({ name: state.name, email: state.email });\n      dispatch({ type: 'SUBMIT_SUCCESS' });\n    } catch (error) {\n      dispatch({ type: 'SUBMIT_ERROR', payload: error.message });\n    }\n  };\n}\n```",
      "keywords": ["useReducer", "reducer function", "complex state", "state management", "dispatch", "action types", "predictable updates", "useState comparison", "global state", "context"],
      "difficulty": "easy"
    },
    {
      "id": 2022,
      "tag": "react",
      "question": "What are error boundaries in React and how do you implement them?",
      "answer": "Error boundaries are React components that catch JavaScript errors anywhere in their component tree, log errors, and display fallback UI instead of crashing the entire application.\n\n**Class Component Error Boundary:**\n```javascript\nimport React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state so next render shows fallback UI\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log error details\n    console.error('Error caught by boundary:', error, errorInfo);\n    \n    // Update state with error details\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n    \n    // Send error to logging service\n    this.logErrorToService(error, errorInfo);\n  }\n  \n  logErrorToService(error, errorInfo) {\n    // Example: Send to error tracking service\n    // Sentry.captureException(error, { extra: errorInfo });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      // Fallback UI\n      return (\n        <div style={{ padding: '20px', border: '1px solid red' }}>\n          <h2>Something went wrong!</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            <summary>Error Details (Click to expand)</summary>\n            <p><strong>Error:</strong> {this.state.error && this.state.error.toString()}</p>\n            <p><strong>Stack Trace:</strong> {this.state.errorInfo.componentStack}</p>\n          </details>\n          <button onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    \n    // Normal render\n    return this.props.children;\n  }\n}\n```\n\n**Usage Example:**\n```javascript\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <ErrorBoundary>\n        <MainContent /> {/* If this crashes, ErrorBoundary catches it */}\n      </ErrorBoundary>\n      <ErrorBoundary>\n        <Sidebar /> {/* Independent error boundary */}\n      </ErrorBoundary>\n      <Footer />\n    </div>\n  );\n}\n\n// Component that might throw an error\nfunction BuggyComponent({ shouldThrow }) {\n  if (shouldThrow) {\n    throw new Error('I crashed!');\n  }\n  return <div>I'm working fine!</div>;\n}\n```\n\n**Custom Error Boundary Hook (Functional Component Approach):**\n```javascript\n// Note: Error boundaries must be class components\n// But you can create a custom hook for error handling\nimport { useState, useEffect } from 'react';\n\nfunction useErrorHandler() {\n  const [error, setError] = useState(null);\n  \n  const resetError = () => setError(null);\n  \n  const catchError = (error, errorInfo) => {\n    setError({ error, errorInfo });\n    console.error('Error caught:', error, errorInfo);\n  };\n  \n  return { error, resetError, catchError };\n}\n\n// Wrapper component using the hook\nfunction ErrorBoundaryWrapper({ children, fallback }) {\n  return (\n    <ErrorBoundary fallback={fallback}>\n      {children}\n    </ErrorBoundary>\n  );\n}\n```\n\n**Advanced Error Boundary with Context:**\n```javascript\nconst ErrorContext = createContext();\n\nclass GlobalErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      errors: [],\n      hasGlobalError: false \n    };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasGlobalError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    const errorReport = {\n      id: Date.now(),\n      error: error.toString(),\n      stack: error.stack,\n      componentStack: errorInfo.componentStack,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.setState(prevState => ({\n      errors: [...prevState.errors, errorReport]\n    }));\n    \n    // Report to monitoring service\n    this.reportError(errorReport);\n  }\n  \n  reportError = (errorReport) => {\n    // Send to error tracking service\n    fetch('/api/errors', {\n      method: 'POST',\n      body: JSON.stringify(errorReport),\n      headers: { 'Content-Type': 'application/json' }\n    });\n  };\n  \n  clearErrors = () => {\n    this.setState({ errors: [], hasGlobalError: false });\n  };\n  \n  render() {\n    const value = {\n      errors: this.state.errors,\n      hasGlobalError: this.state.hasGlobalError,\n      clearErrors: this.clearErrors\n    };\n    \n    return (\n      <ErrorContext.Provider value={value}>\n        {this.props.children}\n      </ErrorContext.Provider>\n    );\n  }\n}\n\n// Hook to use error context\nfunction useErrorContext() {\n  return useContext(ErrorContext);\n}\n```\n\n**What Error Boundaries DON'T Catch:**\n- Event handlers (use try-catch instead)\n- Asynchronous code (setTimeout, requestAnimationFrame callbacks)\n- Errors during server-side rendering\n- Errors thrown in the error boundary itself\n\n**Error Handling in Event Handlers:**\n```javascript\nfunction SafeComponent() {\n  const [error, setError] = useState(null);\n  \n  const handleClick = () => {\n    try {\n      // Potentially dangerous operation\n      riskyOperation();\n    } catch (error) {\n      setError(error.message);\n    }\n  };\n  \n  if (error) {\n    return <div>Error in event handler: {error}</div>;\n  }\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Best Practices:**\n- Place error boundaries at multiple levels (global, feature, component)\n- Provide meaningful fallback UI\n- Log errors for monitoring and debugging\n- Don't catch errors that should crash the app (authentication failures)\n- Use error boundaries to prevent cascade failures\n- Consider user experience in error states\n- Implement retry mechanisms where appropriate",
      "keywords": ["error boundaries", "componentDidCatch", "getDerivedStateFromError", "fallback UI", "error handling", "crash prevention", "error logging", "class components", "try-catch", "error reporting"],
      "difficulty": "easy"
    },
    {
      "id": 2023,
      "tag": "react",
      "question": "What is React Strict Mode and what benefits does it provide?",
      "answer": "React Strict Mode is a development tool that helps identify potential problems in an application by activating additional checks and warnings for its descendants.\n\n**Basic Usage:**\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// Or wrap specific components\nfunction MyApp() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <MainContent /> {/* Only this component tree is in strict mode */}\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n```\n\n**What Strict Mode Does:**\n\n**1. Detects Components with Unsafe Lifecycles:**\n```javascript\n// ❌ These will show warnings in Strict Mode\nclass BadComponent extends React.Component {\n  componentWillMount() { // Deprecated\n    console.log('Will mount');\n  }\n  \n  componentWillReceiveProps(nextProps) { // Deprecated\n    console.log('Will receive props');\n  }\n  \n  componentWillUpdate(nextProps, nextState) { // Deprecated\n    console.log('Will update');\n  }\n}\n\n// ✅ Safe alternatives\nclass GoodComponent extends React.Component {\n  componentDidMount() {\n    console.log('Did mount');\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.userId !== this.props.userId) {\n      console.log('User changed');\n    }\n  }\n  \n  static getDerivedStateFromProps(props, state) {\n    if (props.userId !== state.prevUserId) {\n      return {\n        prevUserId: props.userId,\n        userData: null\n      };\n    }\n    return null;\n  }\n}\n```\n\n**2. Double-Invokes Functions to Detect Side Effects:**\n```javascript\n// Strict Mode will call these twice in development\nfunction MyComponent() {\n  // ❌ Side effects in render (will be called twice)\n  console.log('Rendering component'); // This logs twice\n  Math.random(); // Different results on double-invoke\n  \n  // ✅ Pure render function\n  const [count, setCount] = useState(0);\n  \n  // ❌ Side effects in constructor/initializer\n  const [data] = useState(() => {\n    console.log('Initializing state'); // This logs twice\n    return fetchInitialData(); // Could cause issues\n  });\n  \n  // ✅ Side effects in useEffect\n  useEffect(() => {\n    console.log('Effect running'); // This logs twice\n    fetchData(); // Safe place for side effects\n  }, []);\n  \n  return <div>Count: {count}</div>;\n}\n```\n\n**3. Detects Legacy String Ref Usage:**\n```javascript\nclass LegacyComponent extends React.Component {\n  componentDidMount() {\n    // ❌ String refs (deprecated) - Strict Mode warns\n    this.refs.myInput.focus();\n  }\n  \n  render() {\n    return <input ref=\"myInput\" />; // Warning in Strict Mode\n  }\n}\n\n// ✅ Modern ref usage\nfunction ModernComponent() {\n  const inputRef = useRef(null);\n  \n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n  \n  return <input ref={inputRef} />;\n}\n```\n\n**4. Detects Legacy Context API:**\n```javascript\n// ❌ Legacy context API - warns in Strict Mode\nclass LegacyProvider extends React.Component {\n  static childContextTypes = {\n    theme: PropTypes.string\n  };\n  \n  getChildContext() {\n    return { theme: 'dark' };\n  }\n}\n\n// ✅ Modern Context API\nconst ThemeContext = React.createContext('light');\n\nfunction ModernProvider({ children }) {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n**5. Detects Findable Side Effects in useEffect:**\n```javascript\nfunction ComponentWithEffects() {\n  const [data, setData] = useState(null);\n  \n  // Strict Mode helps identify missing cleanup\n  useEffect(() => {\n    const subscription = subscribeToData((newData) => {\n      setData(newData);\n    });\n    \n    // ❌ Missing cleanup - Strict Mode helps detect memory leaks\n    // return () => subscription.unsubscribe();\n  }, []);\n  \n  // ✅ Proper effect with cleanup\n  useEffect(() => {\n    const subscription = subscribeToData((newData) => {\n      setData(newData);\n    });\n    \n    return () => subscription.unsubscribe(); // Cleanup\n  }, []);\n  \n  return <div>{data ? data.message : 'Loading...'}</div>;\n}\n```\n\n**Benefits of Strict Mode:**\n- **Early Problem Detection:** Catches issues before production\n- **Future-Proofing:** Identifies deprecated patterns\n- **Better Code Quality:** Encourages best practices\n- **Side Effect Detection:** Helps identify unintentional side effects\n- **Concurrent Mode Preparation:** Prepares code for React's concurrent features\n\n**Important Notes:**\n- Only runs in development mode\n- Does not affect production builds\n- Can be applied to any part of the component tree\n- Double-invocation helps identify impure functions\n- Warnings are development-only and help improve code quality\n\n**Common Issues in Strict Mode:**\n```javascript\n// Console logs appearing twice\nfunction MyComponent() {\n  console.log('Component rendered'); // Logs twice in Strict Mode\n  return <div>Hello</div>;\n}\n\n// State initializers running twice\nfunction ComponentWithState() {\n  const [count, setCount] = useState(() => {\n    console.log('State initializer'); // Runs twice\n    return 0;\n  });\n  \n  return <div>{count}</div>;\n}\n\n// Effects running twice\nfunction ComponentWithEffect() {\n  useEffect(() => {\n    console.log('Effect ran'); // Runs twice\n  }, []);\n  \n  return <div>Component</div>;\n}\n```\n\nThis double-invocation is intentional and helps developers write more resilient code by exposing side effects that shouldn't exist in pure functions.",
      "keywords": ["React.StrictMode", "development tool", "deprecated lifecycles", "side effects", "double invocation", "legacy patterns", "string refs", "legacy context", "warnings", "code quality"],
      "difficulty": "easy"
    },
    {
      "id": 2024,
      "tag": "react",
      "question": "What are Higher-Order Components (HOCs) and how do you implement them?",
      "answer": "Higher-Order Components (HOCs) are advanced React patterns where a function takes a component and returns a new enhanced component. They're used for code reuse, logic abstraction, and cross-cutting concerns.\n\n**Basic HOC Structure:**\n```javascript\n// HOC is a function that takes a component and returns a new component\nfunction withEnhancement(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    // Add enhancement logic here\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nconst EnhancedMyComponent = withEnhancement(MyComponent);\n```\n\n**Authentication HOC Example:**\n```javascript\nfunction withAuth(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [loading, setLoading] = useState(true);\n    \n    useEffect(() => {\n      const checkAuth = async () => {\n        try {\n          const token = localStorage.getItem('token');\n          const isValid = await validateToken(token);\n          setIsAuthenticated(isValid);\n        } catch (error) {\n          setIsAuthenticated(false);\n        } finally {\n          setLoading(false);\n        }\n      };\n      \n      checkAuth();\n    }, []);\n    \n    if (loading) {\n      return <div>Checking authentication...</div>;\n    }\n    \n    if (!isAuthenticated) {\n      return <div>Please log in to access this page.</div>;\n    }\n    \n    return <WrappedComponent {...props} isAuthenticated={isAuthenticated} />;\n  };\n}\n\n// Usage\nfunction Dashboard() {\n  return <div>Welcome to the dashboard!</div>;\n}\n\nconst ProtectedDashboard = withAuth(Dashboard);\n```\n\n**Data Fetching HOC:**\n```javascript\nfunction withApiData(url, propName = 'data') {\n  return function(WrappedComponent) {\n    return function DataFetchingComponent(props) {\n      const [data, setData] = useState(null);\n      const [loading, setLoading] = useState(true);\n      const [error, setError] = useState(null);\n      \n      useEffect(() => {\n        const fetchData = async () => {\n          try {\n            setLoading(true);\n            const response = await fetch(url);\n            if (!response.ok) throw new Error('Failed to fetch');\n            const result = await response.json();\n            setData(result);\n          } catch (err) {\n            setError(err.message);\n          } finally {\n            setLoading(false);\n          }\n        };\n        \n        fetchData();\n      }, []);\n      \n      const enhancedProps = {\n        ...props,\n        [propName]: data,\n        loading,\n        error\n      };\n      \n      return <WrappedComponent {...enhancedProps} />;\n    };\n  };\n}\n\n// Usage\nfunction UserList({ users, loading, error }) {\n  if (loading) return <div>Loading users...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <ul>\n      {users?.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}\n\nconst UsersWithData = withApiData('/api/users', 'users')(UserList);\n```\n\n**Logging HOC:**\n```javascript\nfunction withLogging(WrappedComponent) {\n  return function LoggingComponent(props) {\n    const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    \n    useEffect(() => {\n      console.log(`${componentName} mounted`);\n      return () => {\n        console.log(`${componentName} unmounted`);\n      };\n    }, []);\n    \n    useEffect(() => {\n      console.log(`${componentName} updated with props:`, props);\n    });\n    \n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nfunction MyComponent({ name }) {\n  return <div>Hello, {name}!</div>;\n}\n\nconst LoggedComponent = withLogging(MyComponent);\n```\n\n**Conditional Rendering HOC:**\n```javascript\nfunction withConditionalRendering(condition, fallbackComponent = null) {\n  return function(WrappedComponent) {\n    return function ConditionalComponent(props) {\n      if (!condition(props)) {\n        return fallbackComponent ? React.createElement(fallbackComponent, props) : null;\n      }\n      \n      return <WrappedComponent {...props} />;\n    };\n  };\n}\n\n// Usage\nfunction AdminPanel() {\n  return <div>Admin-only content</div>;\n}\n\nfunction AccessDenied() {\n  return <div>Access denied. Admin privileges required.</div>;\n}\n\nconst ConditionalAdminPanel = withConditionalRendering(\n  (props) => props.user?.role === 'admin',\n  AccessDenied\n)(AdminPanel);\n```\n\n**Composing Multiple HOCs:**\n```javascript\nimport { compose } from 'redux'; // or create your own compose function\n\nfunction compose(...funcs) {\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\n// Individual HOCs\nconst withAuth = (Component) => (props) => { /* auth logic */ };\nconst withLogging = (Component) => (props) => { /* logging logic */ };\nconst withApiData = (url) => (Component) => (props) => { /* data fetching */ };\n\n// Compose multiple HOCs\nconst enhance = compose(\n  withAuth,\n  withLogging,\n  withApiData('/api/users')\n);\n\nconst EnhancedUserList = enhance(UserList);\n\n// Equivalent to:\n// const EnhancedUserList = withAuth(withLogging(withApiData('/api/users')(UserList)));\n```\n\n**Best Practices for HOCs:**\n\n**1. Preserve Static Methods:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  function EnhancedComponent(props) {\n    return <WrappedComponent {...props} />;\n  }\n  \n  // Copy static methods\n  Object.keys(WrappedComponent).forEach(key => {\n    EnhancedComponent[key] = WrappedComponent[key];\n  });\n  \n  return EnhancedComponent;\n}\n```\n\n**2. Use Display Names for Debugging:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  function EnhancedComponent(props) {\n    return <WrappedComponent {...props} />;\n  }\n  \n  const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  EnhancedComponent.displayName = `withEnhancement(${componentName})`;\n  \n  return EnhancedComponent;\n}\n```\n\n**3. Pass Through Refs:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  const EnhancedComponent = React.forwardRef((props, ref) => {\n    return <WrappedComponent {...props} ref={ref} />;\n  });\n  \n  EnhancedComponent.displayName = `withEnhancement(${WrappedComponent.name})`;\n  \n  return EnhancedComponent;\n}\n```\n\n**Modern Alternatives to HOCs:**\n\n**1. Custom Hooks (Preferred):**\n```javascript\n// Instead of withApiData HOC\nfunction useApiData(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    // fetch logic\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Usage is cleaner\nfunction UserList() {\n  const { data: users, loading, error } = useApiData('/api/users');\n  \n  if (loading) return <div>Loading...</div>;\n  return <ul>{users?.map(user => <li key={user.id}>{user.name}</li>)}</ul>;\n}\n```\n\n**2. Render Props:**\n```javascript\nfunction DataProvider({ url, children }) {\n  const { data, loading, error } = useApiData(url);\n  return children({ data, loading, error });\n}\n\n// Usage\nfunction App() {\n  return (\n    <DataProvider url=\"/api/users\">\n      {({ data: users, loading, error }) => {\n        if (loading) return <div>Loading...</div>;\n        if (error) return <div>Error: {error}</div>;\n        return <UserList users={users} />;\n      }}\n    </DataProvider>\n  );\n}\n```\n\n**When to Use HOCs:**\n- Cross-cutting concerns (auth, logging, error handling)\n- When you need to wrap multiple components with same logic\n- Legacy codebases where hooks aren't available\n- When you need to manipulate component props before passing them down\n\n**When NOT to Use HOCs:**\n- Simple state logic (use hooks instead)\n- When render props or hooks provide cleaner solutions\n- Performance-critical scenarios (HOCs add extra component layers)",
      "keywords": ["Higher-Order Components", "HOCs", "code reuse", "cross-cutting concerns", "component enhancement", "authentication", "data fetching", "composition", "custom hooks", "render props"],
      "difficulty": "medium"
    },
    {
      "id": 2025,
      "tag": "react",
      "question": "Explain the render props pattern and its advantages over other patterns.",
      "answer": "The render props pattern is a technique for sharing code between React components using a prop whose value is a function. It provides a flexible way to share logic while maintaining component composition.\n\n**Basic Render Props Pattern:**\n```javascript\n// Component that provides logic via render prop\nfunction MouseTracker({ render }) {\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n  \n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setMousePosition({ x: event.clientX, y: event.clientY });\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    return () => document.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n  \n  // Call the render prop function with the shared state\n  return render(mousePosition);\n}\n\n// Usage with render prop\nfunction App() {\n  return (\n    <div>\n      <h1>Mouse Tracker Demo</h1>\n      <MouseTracker render={({ x, y }) => (\n        <div>\n          <h2>Mouse position: ({x}, {y})</h2>\n        </div>\n      )} />\n      \n      {/* Different rendering logic with same data */}\n      <MouseTracker render={({ x, y }) => (\n        <div \n          style={{\n            position: 'absolute',\n            left: x,\n            top: y,\n            width: '10px',\n            height: '10px',\n            background: 'red',\n            borderRadius: '50%'\n          }}\n        />\n      )} />\n    </div>\n  );\n}\n```\n\n**Using Children as Render Prop:**\n```javascript\nfunction DataProvider({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Failed to fetch');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url]);\n  \n  // Children function receives state as arguments\n  return children({ data, loading, error });\n}\n\n// Usage with children as function\nfunction UsersList() {\n  return (\n    <DataProvider url=\"/api/users\">\n      {({ data: users, loading, error }) => {\n        if (loading) return <div className=\"spinner\">Loading users...</div>;\n        if (error) return <div className=\"error\">Error: {error}</div>;\n        if (!users) return <div>No users found</div>;\n        \n        return (\n          <ul className=\"users-list\">\n            {users.map(user => (\n              <li key={user.id} className=\"user-item\">\n                <strong>{user.name}</strong> - {user.email}\n              </li>\n            ))}\n          </ul>\n        );\n      }}\n    </DataProvider>\n  );\n}\n```\n\n**Form Management with Render Props:**\n```javascript\nfunction FormProvider({ initialValues, validationRules, onSubmit, children }) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  const handleChange = (name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: null }));\n    }\n  };\n  \n  const handleBlur = (name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    validateField(name, values[name]);\n  };\n  \n  const validateField = (name, value) => {\n    if (validationRules[name]) {\n      const error = validationRules[name](value, values);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    // Validate all fields\n    const newErrors = {};\n    Object.keys(validationRules).forEach(field => {\n      const error = validationRules[field](values[field], values);\n      if (error) newErrors[field] = error;\n    });\n    \n    setErrors(newErrors);\n    \n    if (Object.keys(newErrors).length === 0) {\n      setIsSubmitting(true);\n      try {\n        await onSubmit(values);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n  \n  return children({\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    handleChange,\n    handleBlur,\n    handleSubmit\n  });\n}\n\n// Usage\nfunction LoginForm() {\n  const validationRules = {\n    email: (value) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n    },\n    password: (value) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n    }\n  };\n  \n  const handleSubmit = async (values) => {\n    console.log('Logging in with:', values);\n    // API call logic\n  };\n  \n  return (\n    <FormProvider \n      initialValues={{ email: '', password: '' }}\n      validationRules={validationRules}\n      onSubmit={handleSubmit}\n    >\n      {({ values, errors, touched, isSubmitting, handleChange, handleBlur, handleSubmit }) => (\n        <form onSubmit={handleSubmit}>\n          <div>\n            <input\n              type=\"email\"\n              placeholder=\"Email\"\n              value={values.email}\n              onChange={(e) => handleChange('email', e.target.value)}\n              onBlur={() => handleBlur('email')}\n            />\n            {touched.email && errors.email && (\n              <span className=\"error\">{errors.email}</span>\n            )}\n          </div>\n          \n          <div>\n            <input\n              type=\"password\"\n              placeholder=\"Password\"\n              value={values.password}\n              onChange={(e) => handleChange('password', e.target.value)}\n              onBlur={() => handleBlur('password')}\n            />\n            {touched.password && errors.password && (\n              <span className=\"error\">{errors.password}</span>\n            )}\n          </div>\n          \n          <button type=\"submit\" disabled={isSubmitting}>\n            {isSubmitting ? 'Logging in...' : 'Login'}\n          </button>\n        </form>\n      )}\n    </FormProvider>\n  );\n}\n```\n\n**Toggle Component with Render Props:**\n```javascript\nfunction Toggle({ initial = false, children }) {\n  const [isOn, setIsOn] = useState(initial);\n  \n  const toggle = () => setIsOn(prev => !prev);\n  const turnOn = () => setIsOn(true);\n  const turnOff = () => setIsOn(false);\n  \n  return children({ isOn, toggle, turnOn, turnOff });\n}\n\n// Multiple use cases with same logic\nfunction App() {\n  return (\n    <div>\n      {/* Modal toggle */}\n      <Toggle>\n        {({ isOn, toggle }) => (\n          <div>\n            <button onClick={toggle}>Show Modal</button>\n            {isOn && (\n              <div className=\"modal\">\n                <div className=\"modal-content\">\n                  <h2>Modal Title</h2>\n                  <button onClick={toggle}>Close</button>\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </Toggle>\n      \n      {/* Theme toggle */}\n      <Toggle initial={false}>\n        {({ isOn: isDark, toggle }) => (\n          <div className={isDark ? 'dark-theme' : 'light-theme'}>\n            <button onClick={toggle}>\n              Switch to {isDark ? 'Light' : 'Dark'} Theme\n            </button>\n            <p>Current theme: {isDark ? 'Dark' : 'Light'}</p>\n          </div>\n        )}\n      </Toggle>\n    </div>\n  );\n}\n```\n\n**Advantages of Render Props:**\n\n**1. Maximum Flexibility:**\n- Complete control over rendering logic\n- Can use same logic with different UI implementations\n- Easy to compose and combine\n\n**2. Clear Separation of Concerns:**\n- Logic provider components focus only on state/behavior\n- Rendering components focus only on presentation\n- Clear interface through function parameters\n\n**3. No Prop Naming Conflicts:**\n- Consumer controls prop names through destructuring\n- No need to worry about prop collision\n\n**4. Better TypeScript Support:**\n```typescript\ninterface DataProviderProps {\n  url: string;\n  children: (state: {\n    data: any;\n    loading: boolean;\n    error: string | null;\n  }) => React.ReactNode;\n}\n```\n\n**Comparison with Other Patterns:**\n\n**Render Props vs HOCs:**\n```javascript\n// HOC - less flexible, wraps component\nconst EnhancedComponent = withData('/api/users')(UserList);\n\n// Render Props - more flexible, explicit\n<DataProvider url=\"/api/users\">\n  {({ data, loading, error }) => (\n    <UserList users={data} loading={loading} error={error} />\n  )}\n</DataProvider>\n```\n\n**Render Props vs Custom Hooks:**\n```javascript\n// Custom Hook - cleaner for simple cases\nfunction UserList() {\n  const { data: users, loading, error } = useApiData('/api/users');\n  return <div>{/* render logic */}</div>;\n}\n\n// Render Props - better for complex composition\n<DataProvider url=\"/api/users\">\n  {({ data: users, loading, error }) => (\n    <ErrorBoundary>\n      <LoadingSpinner show={loading} />\n      <UserList users={users} />\n    </ErrorBoundary>\n  )}\n</DataProvider>\n```\n\n**Best Practices:**\n- Use descriptive names for render prop functions\n- Provide TypeScript interfaces for better DX\n- Consider performance implications (new functions on each render)\n- Use children prop for single render prop scenarios\n- Combine with other patterns when beneficial\n\n**When to Use Render Props:**\n- Complex logic sharing scenarios\n- When you need maximum rendering flexibility\n- Building reusable utility components\n- When HOCs feel too restrictive\n- Component libraries that need customizable rendering",
      "keywords": ["render props", "function as children", "code sharing", "composition", "flexibility", "separation of concerns", "reusability", "HOCs comparison", "custom hooks", "TypeScript"],
      "difficulty": "medium"
    },
    {
      "id": 2026,
      "tag": "react",
      "question": "What is React Suspense and how does lazy loading work?",
      "answer": "React Suspense is a feature that allows components to 'wait' for something before rendering, providing a declarative way to handle loading states. It's commonly used with lazy loading for code splitting.\n\n**Basic Suspense with Lazy Loading:**\n```javascript\nimport React, { Suspense, lazy } from 'react';\n\n// Lazy load components\nconst LazyHome = lazy(() => import('./components/Home'));\nconst LazyAbout = lazy(() => import('./components/About'));\nconst LazyDashboard = lazy(() => import('./components/Dashboard'));\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <Link to=\"/\">Home</Link>\n          <Link to=\"/about\">About</Link>\n          <Link to=\"/dashboard\">Dashboard</Link>\n        </nav>\n        \n        {/* Suspense provides fallback UI while components load */}\n        <Suspense fallback={<div className=\"loading\">Loading page...</div>}>\n          <Routes>\n            <Route path=\"/\" element={<LazyHome />} />\n            <Route path=\"/about\" element={<LazyAbout />} />\n            <Route path=\"/dashboard\" element={<LazyDashboard />} />\n          </Routes>\n        </Suspense>\n      </div>\n    </Router>\n  );\n}\n```\n\n**Advanced Lazy Loading Patterns:**\n```javascript\n// Lazy load with named exports\nconst LazyComponent = lazy(() => \n  import('./components/MyComponent').then(module => ({\n    default: module.MyComponent // Wrap named export as default\n  }))\n);\n\n// Conditional lazy loading\nconst LazyAdminPanel = lazy(() => {\n  // Could add authentication checks here\n  return import('./components/AdminPanel');\n});\n\n// Lazy loading with dynamic imports\nfunction DynamicComponentLoader({ componentName }) {\n  const [Component, setComponent] = useState(null);\n  \n  useEffect(() => {\n    const loadComponent = async () => {\n      try {\n        const module = await import(`./components/${componentName}`);\n        setComponent(() => module.default);\n      } catch (error) {\n        console.error('Failed to load component:', error);\n      }\n    };\n    \n    loadComponent();\n  }, [componentName]);\n  \n  if (!Component) {\n    return <div>Loading component...</div>;\n  }\n  \n  return <Component />;\n}\n```\n\n**Nested Suspense Boundaries:**\n```javascript\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Header />\n      \n      {/* Top-level Suspense for route-level components */}\n      <Suspense fallback={<PageSkeleton />}>\n        <main>\n          <Routes>\n            <Route path=\"/\" element={<Home />} />\n            <Route path=\"/dashboard\" element={\n              // Nested Suspense for dashboard-specific components\n              <Suspense fallback={<DashboardSkeleton />}>\n                <Dashboard />\n              </Suspense>\n            } />\n          </Routes>\n        </main>\n      </Suspense>\n      \n      <Footer />\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      <h1>Dashboard</h1>\n      \n      {/* More nested Suspense for individual widgets */}\n      <div className=\"widgets\">\n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyChart />\n        </Suspense>\n        \n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyAnalytics />\n        </Suspense>\n        \n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyReports />\n        </Suspense>\n      </div>\n    </div>\n  );\n}\n```\n\n**Error Boundaries with Suspense:**\n```javascript\nclass LazyLoadErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Lazy loading error:', error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Failed to load component</h2>\n          <p>Please try refreshing the page.</p>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Usage with error boundary\nfunction App() {\n  return (\n    <LazyLoadErrorBoundary>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Router>\n          <Routes>\n            <Route path=\"/\" element={<LazyHome />} />\n            <Route path=\"/about\" element={<LazyAbout />} />\n          </Routes>\n        </Router>\n      </Suspense>\n    </LazyLoadErrorBoundary>\n  );\n}\n```\n\n**Custom Suspense Hook:**\n```javascript\nfunction useSuspenseQuery(queryFn, deps = []) {\n  const [promise, setPromise] = useState(null);\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    let cancelled = false;\n    \n    const executeQuery = async () => {\n      const queryPromise = queryFn();\n      setPromise(queryPromise);\n      \n      try {\n        const result = await queryPromise;\n        if (!cancelled) {\n          setData(result);\n          setPromise(null);\n        }\n      } catch (error) {\n        if (!cancelled) {\n          setPromise(null);\n          throw error;\n        }\n      }\n    };\n    \n    executeQuery();\n    \n    return () => {\n      cancelled = true;\n    };\n  }, deps);\n  \n  if (promise) {\n    throw promise; // Suspense will catch this\n  }\n  \n  return data;\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const user = useSuspenseQuery(() => \n    fetch(`/api/users/${userId}`).then(r => r.json()),\n    [userId]\n  );\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading user...</div>}>\n      <UserProfile userId=\"123\" />\n    </Suspense>\n  );\n}\n```\n\n**Preloading Components:**\n```javascript\n// Preload components on user interaction\nconst LazyDashboard = lazy(() => import('./Dashboard'));\n\nfunction HomePage() {\n  const handleMouseEnterDashboardLink = () => {\n    // Preload the dashboard component on hover\n    import('./Dashboard');\n  };\n  \n  return (\n    <div>\n      <h1>Welcome to Home</h1>\n      <Link \n        to=\"/dashboard\"\n        onMouseEnter={handleMouseEnterDashboardLink}\n      >\n        Go to Dashboard\n      </Link>\n    </div>\n  );\n}\n\n// Preload based on route prefetch\nfunction useRoutePreload() {\n  useEffect(() => {\n    // Preload likely next routes after initial page load\n    const timer = setTimeout(() => {\n      import('./Dashboard');\n      import('./Profile');\n    }, 2000);\n    \n    return () => clearTimeout(timer);\n  }, []);\n}\n```\n\n**Suspense with Data Fetching (React 18+):**\n```javascript\n// Note: This is experimental and requires special data fetching libraries\nfunction SuspenseDataExample() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<PostSkeleton />}>\n        <PostList />\n        <Suspense fallback={<CommentsSkeleton />}>\n          <CommentsList />\n        </Suspense>\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// With libraries like SWR or React Query that support Suspense\nfunction PostList() {\n  const { data: posts } = useSWR('/api/posts', fetcher, {\n    suspense: true\n  });\n  \n  return (\n    <div>\n      {posts.map(post => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <p>{post.excerpt}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n**Skeleton Loading Components:**\n```javascript\nfunction PostSkeleton() {\n  return (\n    <div className=\"post-skeleton\">\n      {Array(5).fill().map((_, i) => (\n        <div key={i} className=\"skeleton-item\">\n          <div className=\"skeleton-title\"></div>\n          <div className=\"skeleton-text\"></div>\n          <div className=\"skeleton-text short\"></div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// CSS for skeleton loading\n/*\n.skeleton-item {\n  margin-bottom: 20px;\n  padding: 15px;\n  border: 1px solid #e1e1e1;\n  border-radius: 4px;\n}\n\n.skeleton-title,\n.skeleton-text {\n  height: 20px;\n  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n  background-size: 200% 100%;\n  animation: loading 1.5s infinite;\n  margin-bottom: 10px;\n  border-radius: 4px;\n}\n\n.skeleton-title {\n  height: 24px;\n  width: 60%;\n}\n\n.skeleton-text.short {\n  width: 40%;\n}\n\n@keyframes loading {\n  0% { background-position: 200% 0; }\n  100% { background-position: -200% 0; }\n}\n*/\n```\n\n**Benefits of Suspense and Lazy Loading:**\n- **Code Splitting:** Smaller initial bundle sizes\n- **Better Performance:** Only load code when needed\n- **Improved UX:** Smooth loading states\n- **Declarative Loading:** No need to manually manage loading states\n- **Nested Loading:** Different loading states for different parts of the app\n- **Error Handling:** Works well with error boundaries\n\n**Best Practices:**\n- Use meaningful fallback components (skeletons, spinners)\n- Combine with error boundaries for robust error handling\n- Consider preloading for better user experience\n- Use nested Suspense boundaries for granular loading states\n- Monitor bundle sizes to ensure effective code splitting\n- Test loading states and error scenarios thoroughly",
      "keywords": ["Suspense", "lazy loading", "code splitting", "dynamic imports", "loading states", "error boundaries", "preloading", "skeleton loading", "bundle optimization", "React.lazy"],
      "difficulty": "medium"
    },
    {
      "id": 2027,
      "tag": "react",
      "question": "What are React 18's concurrent features and how do they improve performance?",
      "answer": "React 18 introduces concurrent features that allow React to interrupt, pause, resume, or abandon rendering work to keep the main thread responsive and improve user experience.\n\n**Key Concurrent Features:**\n\n**1. Concurrent Rendering:**\n```javascript\n// React 18: createRoot enables concurrent features\nimport { createRoot } from 'react-dom/client';\n\nconst container = document.getElementById('root');\nconst root = createRoot(container);\nroot.render(<App />);\n\n// Legacy (React 17): Blocking rendering\n// import ReactDOM from 'react-dom';\n// ReactDOM.render(<App />, document.getElementById('root'));\n```\n\n**2. Automatic Batching:**\n```javascript\n// React 18: Automatic batching in all scenarios\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  \n  function handleClick() {\n    // These updates are automatically batched (single re-render)\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }\n  \n  async function handleAsyncClick() {\n    await fetch('/api/data');\n    // React 18: These are also batched!\n    // React 17: These would cause separate re-renders\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }\n  \n  setTimeout(() => {\n    // React 18: Batched\n    // React 17: Separate re-renders\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }, 1000);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Flag: {flag.toString()}</p>\n      <button onClick={handleClick}>Sync Update</button>\n      <button onClick={handleAsyncClick}>Async Update</button>\n    </div>\n  );\n}\n\n// Opt out of automatic batching if needed\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React will re-render here\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React will re-render again here\n}\n```\n\n**3. useTransition Hook:**\n```javascript\nimport { useState, useTransition, useDeferredValue } from 'react';\n\nfunction SearchApp() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleSearch = (value) => {\n    setQuery(value); // Urgent: update input immediately\n    \n    // Non-urgent: mark expensive search as transition\n    startTransition(() => {\n      // This update can be interrupted if user types again\n      const filteredResults = performExpensiveSearch(value);\n      setResults(filteredResults);\n    });\n  };\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      \n      {isPending && <div className=\"loading\">Searching...</div>}\n      \n      <SearchResults results={results} />\n    </div>\n  );\n}\n\nfunction performExpensiveSearch(query) {\n  // Simulate expensive operation\n  const results = [];\n  for (let i = 0; i < 10000; i++) {\n    if (mockData[i]?.name.toLowerCase().includes(query.toLowerCase())) {\n      results.push(mockData[i]);\n    }\n  }\n  return results;\n}\n```\n\n**4. useDeferredValue Hook:**\n```javascript\nfunction SearchWithDeferredValue() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  // Expensive component that depends on deferred value\n  const results = useMemo(() => {\n    return performExpensiveSearch(deferredQuery);\n  }, [deferredQuery]);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      \n      {/* Show loading indicator when values don't match */}\n      {query !== deferredQuery && <div>Updating results...</div>}\n      \n      <SearchResults results={results} />\n    </div>\n  );\n}\n\n// Alternative: Wrap expensive component with useDeferredValue\nfunction DeferredSearchResults({ query }) {\n  const deferredQuery = useDeferredValue(query);\n  const results = useMemo(() => performExpensiveSearch(deferredQuery), [deferredQuery]);\n  \n  return <SearchResults results={results} />;\n}\n```\n\n**5. useId Hook for Accessibility:**\n```javascript\nfunction FormField({ label, type = 'text' }) {\n  // Generates unique, stable IDs for server/client rendering\n  const id = useId();\n  \n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input id={id} type={type} />\n    </div>\n  );\n}\n\n// Multiple IDs in same component\nfunction MultiFieldForm() {\n  const baseId = useId();\n  \n  return (\n    <form>\n      <label htmlFor={`${baseId}-name`}>Name</label>\n      <input id={`${baseId}-name`} />\n      \n      <label htmlFor={`${baseId}-email`}>Email</label>\n      <input id={`${baseId}-email`} type=\"email\" />\n      \n      <fieldset>\n        <legend>Preferences</legend>\n        <label htmlFor={`${baseId}-notifications`}>Enable notifications</label>\n        <input id={`${baseId}-notifications`} type=\"checkbox\" />\n      </fieldset>\n    </form>\n  );\n}\n```\n\n**6. Suspense Improvements:**\n```javascript\n// React 18: Improved Suspense with concurrent features\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <Suspense fallback={<MainContentSkeleton />}>\n        <MainContent />\n        <Suspense fallback={<SidebarSkeleton />}>\n          <Sidebar />\n        </Suspense>\n      </Suspense>\n    </div>\n  );\n}\n\n// Suspense with transitions\nfunction TabsWithSuspense() {\n  const [tab, setTab] = useState('posts');\n  const [isPending, startTransition] = useTransition();\n  \n  function selectTab(nextTab) {\n    startTransition(() => {\n      setTab(nextTab);\n    });\n  }\n  \n  return (\n    <div>\n      <div className=\"tabs\">\n        <button \n          className={tab === 'posts' ? 'active' : ''}\n          onClick={() => selectTab('posts')}\n        >\n          Posts {isPending && tab === 'posts' && '(Loading...)'}\n        </button>\n        <button \n          className={tab === 'contact' ? 'active' : ''}\n          onClick={() => selectTab('contact')}\n        >\n          Contact {isPending && tab === 'contact' && '(Loading...)'}\n        </button>\n      </div>\n      \n      <Suspense fallback={<TabContentSkeleton />}>\n        {tab === 'posts' && <PostsTab />}\n        {tab === 'contact' && <ContactTab />}\n      </Suspense>\n    </div>\n  );\n}\n```\n\n**7. startTransition API:**\n```javascript\nimport { startTransition } from 'react';\n\n// Use without hook when you don't need isPending\nfunction updateWithoutHook() {\n  startTransition(() => {\n    // Mark this update as non-urgent\n    setExpensiveState(computeExpensiveValue());\n  });\n}\n\n// Prioritizing user interactions\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [filter, setFilter] = useState('all');\n  \n  const addTodo = (text) => {\n    // Urgent: Adding todo should be immediate\n    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }]);\n  };\n  \n  const updateFilter = (newFilter) => {\n    // Non-urgent: Filtering can be delayed\n    startTransition(() => {\n      setFilter(newFilter);\n    });\n  };\n  \n  return (\n    <div>\n      <AddTodoForm onAdd={addTodo} />\n      <FilterButtons onFilterChange={updateFilter} currentFilter={filter} />\n      <TodoList todos={todos} filter={filter} />\n    </div>\n  );\n}\n```\n\n**Performance Benefits:**\n\n**1. Interruptible Rendering:**\n```javascript\n// React can pause rendering expensive components\n// to handle urgent updates like user input\nfunction ExpensiveList({ items, searchTerm }) {\n  const [isPending, startTransition] = useTransition();\n  const [filteredItems, setFilteredItems] = useState(items);\n  \n  useEffect(() => {\n    startTransition(() => {\n      // This expensive filtering can be interrupted\n      const filtered = items.filter(item => {\n        // Simulate expensive operation\n        for (let i = 0; i < 1000; i++) {\n          Math.random();\n        }\n        return item.name.includes(searchTerm);\n      });\n      setFilteredItems(filtered);\n    });\n  }, [items, searchTerm]);\n  \n  return (\n    <div>\n      {isPending && <div>Filtering...</div>}\n      {filteredItems.map(item => <ExpensiveItem key={item.id} item={item} />)}\n    </div>\n  );\n}\n```\n\n**2. Better CPU Utilization:**\n```javascript\n// React 18 yields control back to browser between work\nfunction LargeTable({ data }) {\n  const deferredData = useDeferredValue(data);\n  \n  return (\n    <table>\n      <tbody>\n        {deferredData.map(row => (\n          <TableRow key={row.id} data={row} />\n        ))}\n      </tbody>\n    </table>\n  );\n}\n\n// Component can update smoothly even with large datasets\nfunction TableRow({ data }) {\n  return (\n    <tr>\n      {Object.entries(data).map(([key, value]) => (\n        <td key={key}>{value}</td>\n      ))}\n    </tr>\n  );\n}\n```\n\n**Migration Considerations:**\n\n**1. Gradual Adoption:**\n```javascript\n// Start with createRoot\nconst root = createRoot(container);\nroot.render(<App />);\n\n// Then gradually add concurrent features\nfunction App() {\n  return (\n    <div>\n      {/* Use useTransition for non-urgent updates */}\n      <SearchWithTransition />\n      \n      {/* Use useDeferredValue for expensive components */}\n      <ExpensiveChart data={deferredData} />\n    </div>\n  );\n}\n```\n\n**2. Testing Concurrent Features:**\n```javascript\n// Test that transitions don't break functionality\nimport { act } from '@testing-library/react';\n\ntest('search with transition', async () => {\n  render(<SearchApp />);\n  \n  const input = screen.getByPlaceholderText('Search...');\n  \n  await act(async () => {\n    fireEvent.change(input, { target: { value: 'test' } });\n    // Wait for transition to complete\n    await waitFor(() => {\n      expect(screen.getByText('Results for: test')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n**Benefits Summary:**\n- **Improved Responsiveness:** UI stays responsive during heavy computations\n- **Better UX:** Smooth interactions even with large datasets\n- **Automatic Optimization:** React handles prioritization automatically\n- **Backward Compatible:** Existing code continues to work\n- **Granular Control:** Choose what updates are urgent vs non-urgent\n- **Better Performance:** More efficient use of CPU and memory",
      "keywords": ["React 18", "concurrent features", "useTransition", "useDeferredValue", "useId", "automatic batching", "startTransition", "concurrent rendering", "Suspense improvements", "performance optimization"],
      "difficulty": "medium"
    },
    {
      "id": 2028,
      "tag": "react",
      "question": "Explain React's reconciliation algorithm and Fiber architecture.",
      "answer": "React's reconciliation is the process of comparing (diffing) the new virtual DOM tree with the previous one to determine what changes need to be made to the actual DOM. Fiber is React's reconciliation engine that enables concurrent features and better performance.\n\n**Pre-Fiber Reconciliation (React 15 and earlier):**\n```javascript\n// The old stack reconciler was synchronous and blocking\nfunction oldReconciliation() {\n  // Problems with the old approach:\n  // 1. Synchronous - couldn't be interrupted\n  // 2. Recursive - could cause stack overflow\n  // 3. All-or-nothing - had to finish entire tree\n  \n  function reconcileChildren(prevChildren, nextChildren) {\n    // Recursive traversal - blocking main thread\n    for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i++) {\n      reconcileChild(prevChildren[i], nextChildren[i]);\n    }\n  }\n}\n```\n\n**Fiber Architecture Concepts:**\n```javascript\n// Fiber is a unit of work that represents a component instance\nconst FiberNode = {\n  // Component information\n  type: 'div',           // Component type\n  key: null,             // React key\n  props: { className: 'container' },\n  \n  // Tree structure\n  parent: null,          // Parent fiber\n  child: null,           // First child fiber\n  sibling: null,         // Next sibling fiber\n  \n  // Work scheduling\n  pendingProps: {},      // Props for this update\n  memoizedProps: {},     // Props from last render\n  updateQueue: null,     // Queue of state updates\n  \n  // Priority and scheduling\n  lanes: 0,              // Priority lanes\n  childLanes: 0,         // Child priority lanes\n  \n  // Effects\n  flags: 0,              // Effect flags (insertion, deletion, update)\n  subtreeFlags: 0,       // Subtree effect flags\n  \n  // State\n  memoizedState: null,   // State from last render\n  \n  // Alternate for double buffering\n  alternate: null        // Previous/next version of this fiber\n};\n```\n\n**Reconciliation Process:**\n```javascript\n// Simplified reconciliation flow\nfunction reconcileChildren(workInProgress, nextChildren) {\n  const currentFirstChild = workInProgress.child;\n  \n  // Different strategies based on children type\n  if (typeof nextChildren === 'string' || typeof nextChildren === 'number') {\n    return reconcileSingleTextNode(workInProgress, currentFirstChild, nextChildren);\n  }\n  \n  if (typeof nextChildren === 'object' && nextChildren !== null) {\n    switch (nextChildren.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n        return reconcileSingleElement(workInProgress, currentFirstChild, nextChildren);\n      case REACT_FRAGMENT_TYPE:\n        return reconcileChildrenArray(workInProgress, currentFirstChild, nextChildren.props.children);\n    }\n    \n    if (Array.isArray(nextChildren)) {\n      return reconcileChildrenArray(workInProgress, currentFirstChild, nextChildren);\n    }\n  }\n  \n  return deleteRemainingChildren(workInProgress, currentFirstChild);\n}\n\n// Key-based reconciliation for arrays\nfunction reconcileChildrenArray(workInProgress, currentFirstChild, newChildren) {\n  let resultingFirstChild = null;\n  let previousNewFiber = null;\n  let oldFiber = currentFirstChild;\n  let newIdx = 0;\n  \n  // First pass: match by index and key\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    if (oldFiber.index > newIdx) break;\n    \n    const newFiber = updateSlot(workInProgress, oldFiber, newChildren[newIdx]);\n    if (newFiber === null) break;\n    \n    if (shouldTrackSideEffects && oldFiber && newFiber.alternate === null) {\n      deleteChild(workInProgress, oldFiber);\n    }\n    \n    placeChild(newFiber, newIdx);\n    \n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n    \n    previousNewFiber = newFiber;\n    oldFiber = oldFiber.sibling;\n  }\n  \n  // Handle remaining children...\n  return resultingFirstChild;\n}\n```\n\n**Work Loop and Scheduling:**\n```javascript\n// Fiber work loop - can be interrupted\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  const current = unitOfWork.alternate;\n  \n  // Begin work phase - reconcile this fiber\n  let next = beginWork(current, unitOfWork, renderLanes);\n  \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  \n  if (next === null) {\n    // Complete work phase - finish this fiber\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n}\n\n// Priority-based scheduling\nconst priorities = {\n  ImmediatePriority: 1,    // User input, critical updates\n  UserBlockingPriority: 2, // User interactions\n  NormalPriority: 3,       // Network requests, timers\n  LowPriority: 4,          // Analytics, logging\n  IdlePriority: 5          // Background tasks\n};\n\nfunction scheduleUpdateOnFiber(fiber, lane, eventTime) {\n  markUpdateLaneFromFiberToRoot(fiber, lane);\n  \n  if (lane === SyncLane) {\n    // Synchronous update\n    performSyncWorkOnRoot(root);\n  } else {\n    // Concurrent update\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n```\n\n**Double Buffering:**\n```javascript\n// React uses two fiber trees for smooth updates\nfunction commitRoot(root) {\n  const finishedWork = root.finishedWork;\n  \n  // Swap the current and work-in-progress trees\n  root.current = finishedWork;\n  \n  // Apply DOM mutations\n  commitMutationEffects(finishedWork);\n  \n  // Run effects (useEffect, useLayoutEffect)\n  commitLayoutEffects(finishedWork);\n}\n\n// Example of how alternate works\nfunction createFiberAlternate(current, pendingProps) {\n  let workInProgress = current.alternate;\n  \n  if (workInProgress === null) {\n    // Create new fiber\n    workInProgress = createFiber(current.tag, pendingProps, current.key);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n    \n    // Link alternates\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // Reuse existing alternate\n    workInProgress.pendingProps = pendingProps;\n    workInProgress.flags = NoFlags;\n    workInProgress.subtreeFlags = NoFlags;\n  }\n  \n  return workInProgress;\n}\n```\n\n**Component Lifecycle with Fiber:**\n```javascript\n// How Fiber handles component updates\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps) {\n  const context = prepareToReadContext(workInProgress);\n  \n  let nextChildren;\n  \n  // Render phase - call the component function\n  prepareToUseHooks(current, workInProgress);\n  nextChildren = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    context,\n    renderLanes\n  );\n  finishHooks();\n  \n  // Reconcile children\n  reconcileChildren(current, workInProgress, nextChildren);\n  \n  return workInProgress.child;\n}\n\n// Hook processing in Fiber\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n  \n  // Reset hooks state\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  \n  // Set current dispatcher (different for mount vs update)\n  ReactCurrentDispatcher.current = \n    current === null || current.memoizedState === null\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  \n  // Call the component function\n  let children = Component(props, secondArg);\n  \n  // Handle re-renders due to state updates during render\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    let numberOfReRenders = 0;\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      numberOfReRenders++;\n      \n      // Reset and re-render\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n      \n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass && numberOfReRenders < RE_RENDER_LIMIT);\n  }\n  \n  return children;\n}\n```\n\n**Time Slicing Implementation:**\n```javascript\n// Fiber enables time slicing for smooth user experience\nconst ENOUGH_TIME = 5; // 5ms time slice\n\nfunction shouldYield() {\n  const timeElapsed = getCurrentTime() - startTime;\n  if (timeElapsed < ENOUGH_TIME) {\n    return false;\n  }\n  \n  // Check if there's a higher priority task waiting\n  if (needsPaint || scheduling.isInputPending()) {\n    return true;\n  }\n  \n  return timeElapsed >= ENOUGH_TIME;\n}\n\n// Resumable work\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n  \n  if (workInProgress !== null) {\n    // More work to do, yield to browser\n    return RootInProgress;\n  } else {\n    // Work completed\n    return RootCompleted;\n  }\n}\n```\n\n**Error Boundaries with Fiber:**\n```javascript\nfunction handleError(root, thrownValue) {\n  let workInProgress = root.current;\n  \n  // Walk up the fiber tree to find error boundary\n  do {\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        const instance = workInProgress.stateNode;\n        if (typeof instance.componentDidCatch === 'function' ||\n            typeof instance.getDerivedStateFromError === 'function') {\n          // Found error boundary\n          const errorInfo = createCapturedValue(thrownValue, workInProgress);\n          const update = createUpdate(NoLane, eventTime);\n          update.payload = { element: null };\n          update.callback = () => {\n            logCapturedError(root, errorInfo);\n            instance.componentDidCatch(thrownValue, errorInfo);\n          };\n          \n          enqueueUpdate(workInProgress, update);\n          scheduleUpdateOnFiber(workInProgress, SyncLane, eventTime);\n          return;\n        }\n        break;\n    }\n    \n    workInProgress = workInProgress.parent;\n  } while (workInProgress !== null);\n  \n  // No error boundary found, crash the app\n  throw thrownValue;\n}\n```\n\n**Benefits of Fiber:**\n- **Interruptible:** Can pause and resume work\n- **Prioritization:** Handle urgent updates first\n- **Concurrent:** Multiple updates can be prepared simultaneously\n- **Incremental:** Work is broken into small units\n- **Better Error Handling:** More precise error boundaries\n- **Time Slicing:** Maintains 60fps by yielding to browser\n- **Smoother Animations:** Less jank during heavy operations\n- **Better Developer Experience:** React DevTools can show work-in-progress state\n\n**Performance Implications:**\n```javascript\n// Fiber enables these performance optimizations:\n\n// 1. Avoid blocking the main thread\nfunction ExpensiveComponent({ items }) {\n  // This won't block user input anymore\n  const processedItems = items.map(item => expensiveProcessing(item));\n  return <div>{processedItems}</div>;\n}\n\n// 2. Prioritize user interactions\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  const handleInputChange = (value) => {\n    setQuery(value); // High priority\n    \n    startTransition(() => {\n      setResults(searchExpensiveData(value)); // Low priority\n    });\n  };\n  \n  return (\n    <div>\n      <input onChange={(e) => handleInputChange(e.target.value)} />\n      <SearchResults results={results} />\n    </div>\n  );\n}\n```\n\nFiber represents a fundamental architectural improvement that enables React's modern concurrent features while maintaining backward compatibility and improving overall performance.",
      "keywords": ["reconciliation", "Fiber architecture", "virtual DOM", "diffing algorithm", "work loop", "time slicing", "priority scheduling", "double buffering", "interruptible rendering", "concurrent features"],
      "difficulty": "hard"
    },
    {
      "id": 2029,
      "tag": "react",
      "question": "What are advanced performance optimization techniques in React?",
      "answer": "Advanced React performance optimization involves multiple strategies including code splitting, memoization, virtual scrolling, tree shaking, and architectural patterns that minimize unnecessary work.\n\n**1. Code Splitting and Bundle Optimization:**\n```javascript\n// Route-based code splitting\nimport { lazy, Suspense } from 'react';\n\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Profile = lazy(() => import('./Profile'));\nconst Settings = lazy(() => import('./Settings'));\n\n// Component-based code splitting with preloading\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n  \n  // Preload component on hover\n  const preloadChart = () => {\n    import('./HeavyChart');\n  };\n  \n  return (\n    <div>\n      <button \n        onMouseEnter={preloadChart}\n        onClick={() => setShowChart(true)}\n      >\n        Show Chart\n      </button>\n      \n      {showChart && (\n        <Suspense fallback={<ChartSkeleton />}>\n          <HeavyChart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Dynamic imports with error handling\nconst loadComponentWithRetry = (componentImport, retries = 3) => {\n  return new Promise((resolve, reject) => {\n    componentImport()\n      .then(resolve)\n      .catch((error) => {\n        if (retries > 0) {\n          setTimeout(() => {\n            loadComponentWithRetry(componentImport, retries - 1)\n              .then(resolve)\n              .catch(reject);\n          }, 1000);\n        } else {\n          reject(error);\n        }\n      });\n  });\n};\n\nconst RetryableComponent = lazy(() => \n  loadComponentWithRetry(() => import('./UnreliableComponent'))\n);\n```\n\n**2. Advanced Memoization Patterns:**\n```javascript\n// Memoization with complex dependency tracking\nfunction useStableMemo(factory, deps) {\n  const memoRef = useRef();\n  \n  if (!memoRef.current || !depsEqual(memoRef.current.deps, deps)) {\n    memoRef.current = {\n      value: factory(),\n      deps: deps.slice()\n    };\n  }\n  \n  return memoRef.current.value;\n}\n\nfunction depsEqual(prevDeps, nextDeps) {\n  if (prevDeps.length !== nextDeps.length) return false;\n  return prevDeps.every((dep, i) => Object.is(dep, nextDeps[i]));\n}\n\n// Selective memoization based on props\nconst ExpensiveComponent = React.memo(({ data, config, onAction }) => {\n  const processedData = useMemo(() => {\n    return data.map(item => expensiveTransformation(item, config));\n  }, [data, config.processMode, config.filters]); // Only specific config props\n  \n  const memoizedAction = useCallback((id) => {\n    onAction(id, config.actionType);\n  }, [onAction, config.actionType]);\n  \n  return (\n    <div>\n      {processedData.map(item => (\n        <ItemComponent \n          key={item.id} \n          item={item} \n          onAction={memoizedAction} \n        />\n      ))}\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Custom equality check\n  return (\n    prevProps.data === nextProps.data &&\n    prevProps.config.processMode === nextProps.config.processMode &&\n    prevProps.config.filters === nextProps.config.filters &&\n    prevProps.onAction === nextProps.onAction\n  );\n});\n```\n\n**3. Virtual Scrolling Implementation:**\n```javascript\n// Custom virtual scrolling hook\nfunction useVirtualScrolling({ items, itemHeight, containerHeight, overscan = 5 }) {\n  const [scrollTop, setScrollTop] = useState(0);\n  \n  const totalHeight = items.length * itemHeight;\n  const visibleStart = Math.floor(scrollTop / itemHeight);\n  const visibleEnd = Math.min(\n    visibleStart + Math.ceil(containerHeight / itemHeight),\n    items.length - 1\n  );\n  \n  const start = Math.max(0, visibleStart - overscan);\n  const end = Math.min(items.length - 1, visibleEnd + overscan);\n  \n  const visibleItems = items.slice(start, end + 1).map((item, index) => ({\n    ...item,\n    index: start + index\n  }));\n  \n  const offsetY = start * itemHeight;\n  \n  return {\n    visibleItems,\n    totalHeight,\n    offsetY,\n    onScroll: (e) => setScrollTop(e.target.scrollTop)\n  };\n}\n\n// Virtual list component\nfunction VirtualList({ items, itemHeight = 50, height = 400 }) {\n  const { visibleItems, totalHeight, offsetY, onScroll } = useVirtualScrolling({\n    items,\n    itemHeight,\n    containerHeight: height\n  });\n  \n  return (\n    <div \n      style={{ height, overflow: 'auto' }} \n      onScroll={onScroll}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${offsetY}px)` }}>\n          {visibleItems.map(item => (\n            <div \n              key={item.id} \n              style={{ height: itemHeight }}\n            >\n              <ItemComponent item={item} />\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n**4. State Management Optimization:**\n```javascript\n// Normalized state shape for better performance\nconst initialState = {\n  users: {\n    byId: {},\n    allIds: []\n  },\n  posts: {\n    byId: {},\n    allIds: []\n  },\n  ui: {\n    selectedUserId: null,\n    loading: false\n  }\n};\n\n// Selector memoization\nconst createMemoizedSelector = (selector) => {\n  let lastArgs = [];\n  let lastResult;\n  \n  return (...args) => {\n    if (!shallowEqual(args, lastArgs)) {\n      lastResult = selector(...args);\n      lastArgs = args;\n    }\n    return lastResult;\n  };\n};\n\nconst getUserPosts = createMemoizedSelector(\n  (state, userId) => {\n    return state.posts.allIds\n      .map(id => state.posts.byId[id])\n      .filter(post => post.authorId === userId);\n  }\n);\n\n// Context splitting to avoid unnecessary re-renders\nconst UserStateContext = createContext();\nconst UserDispatchContext = createContext();\n\nfunction UserProvider({ children }) {\n  const [state, dispatch] = useReducer(userReducer, initialUserState);\n  \n  // Memoize contexts to prevent unnecessary re-renders\n  const stateValue = useMemo(() => state, [state]);\n  const dispatchValue = useMemo(() => dispatch, [dispatch]);\n  \n  return (\n    <UserStateContext.Provider value={stateValue}>\n      <UserDispatchContext.Provider value={dispatchValue}>\n        {children}\n      </UserDispatchContext.Provider>\n    </UserStateContext.Provider>\n  );\n}\n```\n\n**5. Render Optimization Patterns:**\n```javascript\n// Render props with memoization\nfunction DataProvider({ children, url }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const memoizedChildren = useMemo(() => {\n    return children({ data, loading });\n  }, [children, data, loading]);\n  \n  return memoizedChildren;\n}\n\n// Compound component pattern for better performance\nfunction Table({ children, data }) {\n  const tableContext = useMemo(() => ({ data }), [data]);\n  \n  return (\n    <TableContext.Provider value={tableContext}>\n      <table>{children}</table>\n    </TableContext.Provider>\n  );\n}\n\nconst TableHeader = React.memo(({ children }) => {\n  return <thead><tr>{children}</tr></thead>;\n});\n\nconst TableRow = React.memo(({ index }) => {\n  const { data } = useContext(TableContext);\n  const rowData = data[index];\n  \n  return (\n    <tr>\n      {Object.values(rowData).map((value, i) => (\n        <td key={i}>{value}</td>\n      ))}\n    </tr>\n  );\n});\n\n// Usage\n<Table data={tableData}>\n  <TableHeader>\n    <th>Name</th>\n    <th>Email</th>\n    <th>Role</th>\n  </TableHeader>\n  <tbody>\n    {tableData.map((_, index) => (\n      <TableRow key={index} index={index} />\n    ))}\n  </tbody>\n</Table>\n```\n\n**6. Web Workers for Heavy Computations:**\n```javascript\n// Web Worker for CPU-intensive tasks\n// worker.js\nself.onmessage = function(e) {\n  const { type, data } = e.data;\n  \n  switch (type) {\n    case 'PROCESS_DATA':\n      const result = processLargeDataset(data);\n      self.postMessage({ type: 'DATA_PROCESSED', result });\n      break;\n    case 'SORT_DATA':\n      const sorted = expensiveSort(data);\n      self.postMessage({ type: 'DATA_SORTED', result: sorted });\n      break;\n  }\n};\n\n// Hook to use web workers\nfunction useWebWorker(workerScript) {\n  const workerRef = useRef();\n  const [isLoading, setIsLoading] = useState(false);\n  \n  useEffect(() => {\n    workerRef.current = new Worker(workerScript);\n    \n    workerRef.current.onmessage = (e) => {\n      setIsLoading(false);\n    };\n    \n    return () => {\n      workerRef.current.terminate();\n    };\n  }, [workerScript]);\n  \n  const postMessage = useCallback((message) => {\n    setIsLoading(true);\n    workerRef.current.postMessage(message);\n  }, []);\n  \n  return { postMessage, isLoading };\n}\n\n// Component using web worker\nfunction DataProcessor({ data }) {\n  const [processedData, setProcessedData] = useState(null);\n  const { postMessage, isLoading } = useWebWorker('./worker.js');\n  \n  const processData = useCallback(() => {\n    postMessage({ type: 'PROCESS_DATA', data });\n  }, [data, postMessage]);\n  \n  useEffect(() => {\n    const handleMessage = (e) => {\n      if (e.data.type === 'DATA_PROCESSED') {\n        setProcessedData(e.data.result);\n      }\n    };\n    \n    if ('Worker' in window) {\n      const worker = new Worker('./worker.js');\n      worker.onmessage = handleMessage;\n      return () => worker.terminate();\n    }\n  }, []);\n  \n  return (\n    <div>\n      <button onClick={processData} disabled={isLoading}>\n        {isLoading ? 'Processing...' : 'Process Data'}\n      </button>\n      {processedData && <DataVisualization data={processedData} />}\n    </div>\n  );\n}\n```\n\n**7. Memory Leak Prevention:**\n```javascript\n// Cleanup patterns to prevent memory leaks\nfunction useCleanupEffect(effect, deps) {\n  useEffect(() => {\n    const cleanup = effect();\n    \n    return () => {\n      if (typeof cleanup === 'function') {\n        cleanup();\n      }\n    };\n  }, deps);\n}\n\n// Automatic cleanup for subscriptions\nfunction useSubscription(subscribeFn) {\n  const [data, setData] = useState(null);\n  const subscriptionRef = useRef();\n  \n  useEffect(() => {\n    subscriptionRef.current = subscribeFn((newData) => {\n      setData(newData);\n    });\n    \n    return () => {\n      if (subscriptionRef.current && subscriptionRef.current.unsubscribe) {\n        subscriptionRef.current.unsubscribe();\n      }\n    };\n  }, [subscribeFn]);\n  \n  return data;\n}\n\n// Memory-efficient event listeners\nfunction useEventListener(event, handler, element = window) {\n  const savedHandler = useRef();\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  \n  useEffect(() => {\n    const eventListener = (event) => savedHandler.current(event);\n    element.addEventListener(event, eventListener);\n    \n    return () => {\n      element.removeEventListener(event, eventListener);\n    };\n  }, [event, element]);\n}\n```\n\n**8. Bundle Analysis and Tree Shaking:**\n```javascript\n// Analyze bundle with webpack-bundle-analyzer\n// package.json\n{\n  \"scripts\": {\n    \"analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\"\n  }\n}\n\n// Tree shaking optimization\n// Instead of importing entire library\n// import _ from 'lodash'; // Bad - imports entire library\n\n// Import only what you need\nimport debounce from 'lodash/debounce'; // Good - only imports debounce\nimport { debounce } from 'lodash'; // Still good with proper tree-shaking\n\n// Use ES modules for better tree shaking\nexport { default as Button } from './Button';\nexport { default as Modal } from './Modal';\nexport { default as Form } from './Form';\n\n// Dynamic imports for unused code paths\nif (process.env.NODE_ENV === 'development') {\n  import('./DevTools').then(({ DevTools }) => {\n    // Only load dev tools in development\n  });\n}\n```\n\n**Performance Monitoring:**\n```javascript\n// Performance monitoring hooks\nfunction usePerformanceMonitor(componentName) {\n  useEffect(() => {\n    const startTime = performance.now();\n    \n    return () => {\n      const endTime = performance.now();\n      console.log(`${componentName} render time: ${endTime - startTime}ms`);\n    };\n  });\n}\n\n// React DevTools Profiler API\nfunction ProfiledComponent({ children }) {\n  const onRenderCallback = (id, phase, actualDuration) => {\n    console.log('Render:', { id, phase, actualDuration });\n  };\n  \n  return (\n    <Profiler id=\"ProfiledComponent\" onRender={onRenderCallback}>\n      {children}\n    </Profiler>\n  );\n}\n```\n\n**Key Optimization Strategies:**\n- **Measure First:** Use React DevTools Profiler before optimizing\n- **Minimize Bundle Size:** Code splitting, tree shaking, dynamic imports\n- **Reduce Re-renders:** Memoization, stable references, context splitting\n- **Optimize Heavy Operations:** Web workers, virtual scrolling, debouncing\n- **Memory Management:** Proper cleanup, avoid memory leaks\n- **Network Optimization:** Prefetching, caching, compression\n- **State Shape:** Normalized data, efficient selectors\n- **Component Architecture:** Smart composition, render props, compound components",
      "keywords": ["performance optimization", "code splitting", "memoization", "virtual scrolling", "web workers", "tree shaking", "bundle analysis", "memory leaks", "state normalization", "React Profiler"],
      "difficulty": "hard"
    }
  ]
}