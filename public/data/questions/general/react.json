{
  "technology": "react",
  "questions": [
    {
      "id": 20,
      "tag": "react",
      "question": "What is the difference between functional and class components in React?",
      "answer": "**Functional Components:**\n- Simple functions that return JSX\n- Use hooks for state and lifecycle\n- Less boilerplate code\n- Better performance (no instance creation)\n- Recommended approach since React 16.8\n\n**Class Components:**\n- ES6 classes extending React.Component\n- Use this.state and lifecycle methods\n- More verbose syntax\n- Have component instances\n- Legacy approach\n\n**Example:**\n```javascript\n// Functional Component\nfunction Welcome({ name }) {\n  const [count, setCount] = useState(0);\n  return <h1>Hello, {name}! Count: {count}</h1>;\n}\n\n// Class Component\nclass Welcome extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  render() {\n    return <h1>Hello, {this.props.name}! Count: {this.state.count}</h1>;\n  }\n}\n```",
      "difficulty": "easy"
    },
    {
      "id": 21,
      "tag": "react",
      "question": "Explain the useState hook and provide an example.",
      "answer": "useState is a React hook that allows functional components to have state.\n\n**Syntax:**\n```javascript\nconst [state, setState] = useState(initialValue);\n```\n\n**Example:**\n```javascript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    setCount(count + 1);\n    // Or with functional update:\n    // setCount(prevCount => prevCount + 1);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n**Key points:**\n- Returns array with current state and setter function\n- State updates are asynchronous\n- Use functional updates for state based on previous state\n- Can have multiple useState calls in one component",
      "difficulty": "easy"
    },
    {
      "id": 22,
      "tag": "react",
      "question": "What is the useEffect hook and when would you use it?",
      "answer": "useEffect is a React hook for performing side effects in functional components.\n\n**Basic Syntax:**\n```javascript\nuseEffect(() => {\n  // Effect logic\n  return () => {\n    // Cleanup (optional)\n  };\n}, [dependencies]); // Dependencies array (optional)\n```\n\n**Common Use Cases:**\n1. **Data fetching:**\n```javascript\nuseEffect(() => {\n  fetchData().then(setData);\n}, []); // Empty array = run once on mount\n```\n\n2. **Subscriptions:**\n```javascript\nuseEffect(() => {\n  const subscription = subscribe();\n  return () => subscription.unsubscribe();\n}, []);\n```\n\n3. **DOM manipulation:**\n```javascript\nuseEffect(() => {\n  document.title = `Count: ${count}`;\n}, [count]); // Run when count changes\n```\n\n**Dependency Array:**\n- No array: runs after every render\n- Empty array []: runs once on mount\n- With values [a, b]: runs when a or b changes",
      "difficulty": "medium"
    },
    {
      "id": 23,
      "tag": "react",
      "question": "Explain React's virtual DOM and its benefits.",
      "answer": "The Virtual DOM is a JavaScript representation of the actual DOM kept in memory and synced with the real DOM through a process called reconciliation.\n\n**How it works:**\n1. React creates a virtual representation of the DOM\n2. When state changes, a new virtual DOM tree is created\n3. React compares (diffs) the new tree with the previous one\n4. Only the differences are updated in the real DOM\n\n**Benefits:**\n- **Performance:** Batch updates and minimize DOM manipulation\n- **Predictability:** Declarative programming model\n- **Developer Experience:** Easier to reason about state changes\n- **Cross-browser Compatibility:** React handles browser differences\n\n**Example:**\n```javascript\n// State change triggers virtual DOM diff\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1> {/* Only this text node updates */}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n**Note:** The virtual DOM is an implementation detail - React Fiber uses a different reconciliation algorithm.",
      "difficulty": "medium"
    },
    {
      "id": 24,
      "tag": "react",
      "question": "What are React keys and why are they important?",
      "answer": "Keys are special attributes that help React identify which list items have changed, been added, or removed.\n\n**Why Keys Matter:**\n- Help React efficiently update the DOM\n- Maintain component state correctly\n- Avoid rendering bugs in lists\n- Improve performance during reconciliation\n\n**Good vs Bad Examples:**\n```javascript\n// ❌ Bad: Using array index\nitems.map((item, index) => (\n  <li key={index}>{item.name}</li>\n));\n\n// ❌ Bad: No key\nitems.map(item => (\n  <li>{item.name}</li>\n));\n\n// ✅ Good: Using unique, stable identifier\nitems.map(item => (\n  <li key={item.id}>{item.name}</li>\n));\n```\n\n**Key Requirements:**\n- Must be unique among siblings\n- Should be stable (not change between renders)\n- Should be predictable (same input = same key)\n\n**Common Mistake:**\nUsing array index as key can cause issues when list order changes, as React may incorrectly associate state with wrong components.",
      "difficulty": "medium"
    }
  ]
}