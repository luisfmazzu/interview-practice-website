{
  "technology": "react",
  "questions": [
    {
      "id": 2000,
      "tag": "react",
      "question": "What is the difference between functional and class components in React?",
      "answer": "**Functional Components:**\n- Simple functions that return JSX\n- Use hooks for state and lifecycle\n- Less boilerplate code\n- Better performance (no instance creation)\n- Recommended approach since React 16.8\n\n**Class Components:**\n- ES6 classes extending React.Component\n- Use this.state and lifecycle methods\n- More verbose syntax\n- Have component instances\n- Legacy approach\n\n**Example:**\n```javascript\n// Functional Component\nfunction Welcome({ name }) {\n  const [count, setCount] = useState(0);\n  return <h1>Hello, {name}! Count: {count}</h1>;\n}\n\n// Class Component\nclass Welcome extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  \n  render() {\n    return <h1>Hello, {this.props.name}! Count: {this.state.count}</h1>;\n  }\n}\n```",
      "keywords": ["functional components", "class components", "hooks", "lifecycle methods", "this.state", "JSX", "React.Component"],
      "difficulty": "easy"
    },
    {
      "id": 2001,
      "tag": "react",
      "question": "Explain the useState hook and provide an example.",
      "answer": "useState is a React hook that allows functional components to have state.\n\n**Syntax:**\n```javascript\nconst [state, setState] = useState(initialValue);\n```\n\n**Example:**\n```javascript\nimport React, { useState } from 'react';\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  \n  const increment = () => {\n    setCount(count + 1);\n    // Or with functional update:\n    // setCount(prevCount => prevCount + 1);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n```\n\n**Key points:**\n- Returns array with current state and setter function\n- State updates are asynchronous\n- Use functional updates for state based on previous state\n- Can have multiple useState calls in one component",
      "keywords": ["useState", "hook", "state", "setState", "functional components", "destructuring", "asynchronous", "functional updates"],
      "difficulty": "easy"
    },
    {
      "id": 2002,
      "tag": "react",
      "question": "What is the useEffect hook and when would you use it?",
      "answer": "useEffect is a React hook for performing side effects in functional components.\n\n**Basic Syntax:**\n```javascript\nuseEffect(() => {\n  // Effect logic\n  return () => {\n    // Cleanup (optional)\n  };\n}, [dependencies]); // Dependencies array (optional)\n```\n\n**Common Use Cases:**\n1. **Data fetching:**\n```javascript\nuseEffect(() => {\n  fetchData().then(setData);\n}, []); // Empty array = run once on mount\n```\n\n2. **Subscriptions:**\n```javascript\nuseEffect(() => {\n  const subscription = subscribe();\n  return () => subscription.unsubscribe();\n}, []);\n```\n\n3. **DOM manipulation:**\n```javascript\nuseEffect(() => {\n  document.title = `Count: ${count}`;\n}, [count]); // Run when count changes\n```\n\n**Dependency Array:**\n- No array: runs after every render\n- Empty array []: runs once on mount\n- With values [a, b]: runs when a or b changes",
      "keywords": ["useEffect", "hook", "side effects", "dependencies array", "cleanup", "data fetching", "subscriptions", "DOM manipulation", "mount", "unmount"],
      "difficulty": "medium"
    },
    {
      "id": 2003,
      "tag": "react",
      "question": "Explain React's virtual DOM and its benefits.",
      "answer": "The Virtual DOM is a JavaScript representation of the actual DOM kept in memory and synced with the real DOM through a process called reconciliation.\n\n**How it works:**\n1. React creates a virtual representation of the DOM\n2. When state changes, a new virtual DOM tree is created\n3. React compares (diffs) the new tree with the previous one\n4. Only the differences are updated in the real DOM\n\n**Benefits:**\n- **Performance:** Batch updates and minimize DOM manipulation\n- **Predictability:** Declarative programming model\n- **Developer Experience:** Easier to reason about state changes\n- **Cross-browser Compatibility:** React handles browser differences\n\n**Example:**\n```javascript\n// State change triggers virtual DOM diff\nfunction App() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <h1>Count: {count}</h1> {/* Only this text node updates */}\n      <button onClick={() => setCount(count + 1)}>+</button>\n    </div>\n  );\n}\n```\n\n**Note:** The virtual DOM is an implementation detail - React Fiber uses a different reconciliation algorithm.",
      "keywords": ["Virtual DOM", "reconciliation", "diffing", "real DOM", "performance", "batch updates", "declarative", "React Fiber", "DOM manipulation"],
      "difficulty": "medium"
    },
    {
      "id": 2004,
      "tag": "react",
      "question": "What are React keys and why are they important?",
      "answer": "Keys are special attributes that help React identify which list items have changed, been added, or removed.\n\n**Why Keys Matter:**\n- Help React efficiently update the DOM\n- Maintain component state correctly\n- Avoid rendering bugs in lists\n- Improve performance during reconciliation\n\n**Good vs Bad Examples:**\n```javascript\n// ❌ Bad: Using array index\nitems.map((item, index) => (\n  <li key={index}>{item.name}</li>\n));\n\n// ❌ Bad: No key\nitems.map(item => (\n  <li>{item.name}</li>\n));\n\n// ✅ Good: Using unique, stable identifier\nitems.map(item => (\n  <li key={item.id}>{item.name}</li>\n));\n```\n\n**Key Requirements:**\n- Must be unique among siblings\n- Should be stable (not change between renders)\n- Should be predictable (same input = same key)\n\n**Common Mistake:**\nUsing array index as key can cause issues when list order changes, as React may incorrectly associate state with wrong components.",
      "keywords": ["keys", "list rendering", "reconciliation", "unique identifiers", "array index", "component state", "siblings", "stable", "predictable"],
      "difficulty": "medium"
    },
    {
      "id": 2005,
      "tag": "react",
      "question": "What is JSX and how does it work under the hood?",
      "answer": "JSX (JavaScript XML) is a syntax extension for JavaScript that allows you to write HTML-like code in your JavaScript files. It's compiled to regular JavaScript function calls.\n\n**JSX to JavaScript Transformation:**\n```javascript\n// JSX\nconst element = <h1 className=\"title\">Hello World!</h1>;\n\n// Compiles to (React 17+):\nimport { jsx as _jsx } from 'react/jsx-runtime';\nconst element = _jsx('h1', { className: 'title', children: 'Hello World!' });\n\n// Before React 17:\nconst element = React.createElement('h1', { className: 'title' }, 'Hello World!');\n```\n\n**JSX Rules:**\n- Must return a single parent element (or Fragment)\n- Use `className` instead of `class`\n- Use camelCase for attributes\n- Self-closing tags must end with `/>`\n- Expressions go in curly braces `{}`\n\n**Benefits:**\n- More readable than createElement calls\n- Familiar HTML-like syntax\n- Compile-time error checking\n- Better developer experience with IDE support",
      "keywords": ["JSX", "JavaScript XML", "React.createElement", "jsx-runtime", "compilation", "transpilation", "className", "camelCase", "expressions", "curly braces"],
      "difficulty": "easy"
    },
    {
      "id": 2006,
      "tag": "react",
      "question": "What is the difference between props and state in React?",
      "answer": "Props and state are both ways to manage data in React components, but they serve different purposes.\n\n**Props (Properties):**\n- Data passed from parent to child components\n- Read-only (immutable)\n- Cannot be modified by the receiving component\n- Used for component configuration and communication\n\n**State:**\n- Internal data managed by the component itself\n- Mutable (can be updated)\n- Triggers re-renders when changed\n- Local to the component\n\n**Example:**\n```javascript\n// Parent component\nfunction App() {\n  const [count, setCount] = useState(0); // State\n  \n  return (\n    <div>\n      <Counter count={count} onIncrement={() => setCount(count + 1)} /> {/* Props */}\n    </div>\n  );\n}\n\n// Child component\nfunction Counter({ count, onIncrement }) {\n  const [isHovered, setIsHovered] = useState(false); // Local state\n  \n  return (\n    <button \n      onClick={onIncrement}\n      onMouseEnter={() => setIsHovered(true)}\n      style={{ backgroundColor: isHovered ? 'lightblue' : 'white' }}\n    >\n      Count: {count}\n    </button>\n  );\n}\n```",
      "keywords": ["props", "state", "immutable", "mutable", "parent component", "child component", "useState", "re-render", "configuration", "communication"],
      "difficulty": "easy"
    },
    {
      "id": 2007,
      "tag": "react",
      "question": "What are controlled vs uncontrolled components?",
      "answer": "This refers to how form inputs manage their state in React.\n\n**Controlled Components:**\n- Form input values are controlled by React state\n- Value is set via props and changes via event handlers\n- React is the \"single source of truth\"\n- More predictable and easier to validate\n\n**Uncontrolled Components:**\n- Form inputs manage their own state internally\n- Access values using refs\n- DOM is the source of truth\n- Less code, but harder to validate or manipulate\n\n**Examples:**\n```javascript\n// Controlled Component\nfunction ControlledInput() {\n  const [value, setValue] = useState('');\n  \n  return (\n    <input \n      value={value} \n      onChange={(e) => setValue(e.target.value)}\n      placeholder=\"Controlled\"\n    />\n  );\n}\n\n// Uncontrolled Component\nfunction UncontrolledInput() {\n  const inputRef = useRef();\n  \n  const handleSubmit = () => {\n    console.log(inputRef.current.value);\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} placeholder=\"Uncontrolled\" />\n      <button onClick={handleSubmit}>Get Value</button>\n    </div>\n  );\n}\n```\n\n**When to use:**\n- **Controlled:** Form validation, conditional formatting, dynamic inputs\n- **Uncontrolled:** Simple forms, performance-critical scenarios",
      "keywords": ["controlled components", "uncontrolled components", "form inputs", "state management", "refs", "single source of truth", "DOM", "validation", "event handlers"],
      "difficulty": "easy"
    },
    {
      "id": 2008,
      "tag": "react",
      "question": "What are the different ways to implement conditional rendering in React?",
      "answer": "React offers several techniques for conditional rendering based on state or props.\n\n**1. If/Else Statements:**\n```javascript\nfunction Greeting({ isLoggedIn }) {\n  if (isLoggedIn) {\n    return <h1>Welcome back!</h1>;\n  } else {\n    return <h1>Please sign in.</h1>;\n  }\n}\n```\n\n**2. Ternary Operator:**\n```javascript\nfunction Greeting({ isLoggedIn }) {\n  return (\n    <h1>{isLoggedIn ? 'Welcome back!' : 'Please sign in.'}</h1>\n  );\n}\n```\n\n**3. Logical AND (&&) Operator:**\n```javascript\nfunction Notification({ hasMessages }) {\n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {hasMessages && <p>You have new messages!</p>}\n    </div>\n  );\n}\n```\n\n**4. Switch Statements (for multiple conditions):**\n```javascript\nfunction StatusIndicator({ status }) {\n  const renderStatus = () => {\n    switch (status) {\n      case 'loading': return <Spinner />;\n      case 'error': return <Error />;\n      case 'success': return <Success />;\n      default: return null;\n    }\n  };\n  \n  return <div>{renderStatus()}</div>;\n}\n```\n\n**5. IIFE (Immediately Invoked Function Expression):**\n```javascript\nfunction ComplexComponent({ data }) {\n  return (\n    <div>\n      {(() => {\n        if (!data) return <Loading />;\n        if (data.error) return <Error error={data.error} />;\n        return <Content data={data} />;\n      })()\n      }\n    </div>\n  );\n}\n```",
      "keywords": ["conditional rendering", "ternary operator", "logical AND", "if else", "switch statement", "IIFE", "null", "falsy values"],
      "difficulty": "easy"
    },
    {
      "id": 2009,
      "tag": "react",
      "question": "How does event handling work in React?",
      "answer": "React uses SyntheticEvents, which are wrappers around native DOM events that provide consistent behavior across browsers.\n\n**Basic Event Handling:**\n```javascript\nfunction Button() {\n  const handleClick = (event) => {\n    console.log('Button clicked!', event);\n    event.preventDefault(); // Works across all browsers\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Event Object Properties:**\n- `event.target`: Element that triggered the event\n- `event.currentTarget`: Element the event handler is attached to\n- `event.preventDefault()`: Prevents default behavior\n- `event.stopPropagation()`: Stops event bubbling\n\n**Passing Parameters:**\n```javascript\nfunction ItemList({ items }) {\n  const handleDelete = (id, event) => {\n    console.log('Delete item:', id);\n  };\n  \n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>\n          {item.name}\n          <button onClick={(e) => handleDelete(item.id, e)}>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Form Events:**\n```javascript\nfunction LoginForm() {\n  const [email, setEmail] = useState('');\n  \n  const handleSubmit = (e) => {\n    e.preventDefault();\n    console.log('Submitting:', email);\n  };\n  \n  const handleChange = (e) => {\n    setEmail(e.target.value);\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input type=\"email\" value={email} onChange={handleChange} />\n      <button type=\"submit\">Login</button>\n    </form>\n  );\n}\n```\n\n**Benefits of SyntheticEvents:**\n- Cross-browser compatibility\n- Consistent API\n- Automatic event delegation\n- Memory efficient",
      "keywords": ["SyntheticEvents", "event handling", "onClick", "onChange", "onSubmit", "event object", "preventDefault", "stopPropagation", "event delegation", "cross-browser"],
      "difficulty": "easy"
    },
    {
      "id": 2010,
      "tag": "react",
      "question": "What is the useRef hook and what are its common use cases?",
      "answer": "useRef is a React hook that creates a mutable reference that persists across re-renders without causing re-renders when changed.\n\n**Basic Syntax:**\n```javascript\nconst ref = useRef(initialValue);\n```\n\n**Common Use Cases:**\n\n**1. Accessing DOM Elements:**\n```javascript\nfunction FocusInput() {\n  const inputRef = useRef(null);\n  \n  const focusInput = () => {\n    inputRef.current.focus();\n  };\n  \n  return (\n    <div>\n      <input ref={inputRef} type=\"text\" />\n      <button onClick={focusInput}>Focus Input</button>\n    </div>\n  );\n}\n```\n\n**2. Storing Mutable Values:**\n```javascript\nfunction Timer() {\n  const [count, setCount] = useState(0);\n  const intervalRef = useRef(null);\n  \n  const startTimer = () => {\n    intervalRef.current = setInterval(() => {\n      setCount(prev => prev + 1);\n    }, 1000);\n  };\n  \n  const stopTimer = () => {\n    clearInterval(intervalRef.current);\n  };\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={startTimer}>Start</button>\n      <button onClick={stopTimer}>Stop</button>\n    </div>\n  );\n}\n```\n\n**3. Keeping Previous Values:**\n```javascript\nfunction usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nfunction Component({ value }) {\n  const previousValue = usePrevious(value);\n  return <div>Current: {value}, Previous: {previousValue}</div>;\n}\n```\n\n**Key Points:**\n- Doesn't trigger re-renders when `.current` changes\n- Persists across re-renders\n- Mutable unlike state\n- Useful for imperative operations",
      "keywords": ["useRef", "mutable reference", "DOM access", "imperative operations", "previous values", "intervals", "focus", "current property", "persistent"],
      "difficulty": "easy"
    },
    {
      "id": 2011,
      "tag": "react",
      "question": "Explain React component lifecycle methods in class components.",
      "answer": "React class components have lifecycle methods that allow you to hook into different phases of a component's life.\n\n**Three Main Phases:**\n\n**1. Mounting (Component Creation):**\n```javascript\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { data: null };\n    // Initialize state, bind methods\n  }\n  \n  componentDidMount() {\n    // DOM is available, make API calls\n    fetch('/api/data').then(data => this.setState({ data }));\n  }\n}\n```\n\n**2. Updating (Re-renders):**\n```javascript\ncomponentDidUpdate(prevProps, prevState) {\n  // Component updated, compare prev and current\n  if (prevProps.userId !== this.props.userId) {\n    this.fetchUserData(this.props.userId);\n  }\n}\n\ngetSnapshotBeforeUpdate(prevProps, prevState) {\n  // Capture info before DOM update (rare)\n  return null;\n}\n```\n\n**3. Unmounting (Component Removal):**\n```javascript\ncomponentWillUnmount() {\n  // Cleanup: clear timers, cancel requests, remove listeners\n  clearInterval(this.timer);\n  this.abortController.abort();\n}\n```\n\n**Complete Example:**\n```javascript\nclass UserProfile extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { user: null, loading: true };\n  }\n  \n  componentDidMount() {\n    this.fetchUser(this.props.userId);\n  }\n  \n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.fetchUser(this.props.userId);\n    }\n  }\n  \n  componentWillUnmount() {\n    // Cancel any pending requests\n  }\n  \n  fetchUser = (userId) => {\n    this.setState({ loading: true });\n    // API call logic\n  };\n  \n  render() {\n    return this.state.loading ? <div>Loading...</div> : <div>{this.state.user.name}</div>;\n  }\n}\n```\n\n**Modern Equivalent (Hooks):**\nUse useEffect hook in functional components for similar functionality.",
      "keywords": ["lifecycle methods", "mounting", "updating", "unmounting", "componentDidMount", "componentDidUpdate", "componentWillUnmount", "constructor", "render", "class components"],
      "difficulty": "easy"
    },
    {
      "id": 2012,
      "tag": "react",
      "question": "How do you render lists in React and what are best practices for keys?",
      "answer": "Rendering lists in React involves mapping over arrays and returning JSX elements, with proper key management being crucial for performance.\n\n**Basic List Rendering:**\n```javascript\nfunction TodoList({ todos }) {\n  return (\n    <ul>\n      {todos.map(todo => (\n        <li key={todo.id}>\n          <span>{todo.text}</span>\n          <button>Delete</button>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**Complex List with Components:**\n```javascript\nfunction UserList({ users }) {\n  return (\n    <div>\n      {users.map(user => (\n        <UserCard \n          key={user.id} \n          user={user} \n          onDelete={() => handleDelete(user.id)}\n        />\n      ))}\n    </div>\n  );\n}\n```\n\n**Conditional List Items:**\n```javascript\nfunction ProductList({ products, showOutOfStock }) {\n  return (\n    <div>\n      {products\n        .filter(product => showOutOfStock || product.inStock)\n        .map(product => (\n          <ProductCard key={product.id} product={product} />\n        ))\n      }\n    </div>\n  );\n}\n```\n\n**Best Practices for Keys:**\n\n**✅ Good Keys:**\n```javascript\n// Unique database IDs\nitems.map(item => <Item key={item.id} data={item} />)\n\n// Generated stable IDs\nitems.map(item => <Item key={`${item.type}-${item.name}`} data={item} />)\n```\n\n**❌ Avoid:**\n```javascript\n// Array index (problematic with reordering)\nitems.map((item, index) => <Item key={index} data={item} />)\n\n// Random values (causes unnecessary re-renders)\nitems.map(item => <Item key={Math.random()} data={item} />)\n```\n\n**Empty Lists:**\n```javascript\nfunction MessageList({ messages }) {\n  return (\n    <div>\n      {messages.length === 0 ? (\n        <p>No messages yet</p>\n      ) : (\n        messages.map(message => (\n          <Message key={message.id} data={message} />\n        ))\n      )}\n    </div>\n  );\n}\n```\n\n**Performance Tip:** For large lists, consider virtualization libraries like react-window or react-virtualized.",
      "keywords": ["list rendering", "map", "keys", "unique identifiers", "array index", "filter", "conditional rendering", "empty lists", "performance", "virtualization"],
      "difficulty": "easy"
    },
    {
      "id": 2013,
      "tag": "react",
      "question": "What is the useCallback hook and when should you use it?",
      "answer": "useCallback is a React hook that returns a memoized callback function. It's used to optimize performance by preventing unnecessary re-creation of functions.\n\n**Basic Syntax:**\n```javascript\nconst memoizedCallback = useCallback(\n  () => {\n    // callback logic\n  },\n  [dependencies]\n);\n```\n\n**Problem Without useCallback:**\n```javascript\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  \n  // This function is recreated on every render\n  const handleClick = () => {\n    console.log('clicked');\n  };\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <ExpensiveChild onClick={handleClick} /> {/* Re-renders even when only name changes */}\n    </div>\n  );\n}\n```\n\n**Solution With useCallback:**\n```javascript\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('');\n  \n  // Function is memoized and only recreated when dependencies change\n  const handleClick = useCallback(() => {\n    console.log('clicked', count);\n  }, [count]); // Only recreate when count changes\n  \n  const handleIncrement = useCallback(() => {\n    setCount(prev => prev + 1);\n  }, []); // No dependencies, never recreates\n  \n  return (\n    <div>\n      <input value={name} onChange={(e) => setName(e.target.value)} />\n      <ExpensiveChild onClick={handleClick} onIncrement={handleIncrement} />\n    </div>\n  );\n}\n\nconst ExpensiveChild = React.memo(({ onClick, onIncrement }) => {\n  console.log('ExpensiveChild rendered');\n  return (\n    <div>\n      <button onClick={onClick}>Log Count</button>\n      <button onClick={onIncrement}>Increment</button>\n    </div>\n  );\n});\n```\n\n**When to Use useCallback:**\n- Passing callbacks to optimized child components (wrapped with React.memo)\n- Callbacks passed to dependency arrays of other hooks\n- Preventing infinite loops in useEffect\n- When callback creation is expensive\n\n**When NOT to Use:**\n- Simple functions that aren't passed as props\n- When the dependencies change frequently anyway\n- Over-optimization can hurt performance\n\n**With useEffect:**\n```javascript\nfunction SearchResults({ query }) {\n  const [results, setResults] = useState([]);\n  \n  const fetchResults = useCallback(async (searchQuery) => {\n    const data = await api.search(searchQuery);\n    setResults(data);\n  }, []);\n  \n  useEffect(() => {\n    fetchResults(query);\n  }, [query, fetchResults]); // fetchResults won't cause infinite loops\n  \n  return <ResultsList results={results} />;\n}\n```",
      "keywords": ["useCallback", "memoization", "performance optimization", "React.memo", "function recreation", "dependencies", "useEffect", "infinite loops", "callback functions"],
      "difficulty": "medium"
    },
    {
      "id": 2014,
      "tag": "react",
      "question": "Explain the useMemo hook and how it helps with performance optimization.",
      "answer": "useMemo is a React hook that memoizes expensive calculations and only recalculates when dependencies change, helping optimize performance.\n\n**Basic Syntax:**\n```javascript\nconst memoizedValue = useMemo(\n  () => expensiveCalculation(a, b),\n  [a, b]\n);\n```\n\n**Problem Without useMemo:**\n```javascript\nfunction ExpensiveComponent({ items, filter }) {\n  // This expensive calculation runs on every render\n  const expensiveValue = items\n    .filter(item => item.category === filter)\n    .reduce((sum, item) => sum + item.value, 0);\n  \n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Total: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n}\n```\n\n**Solution With useMemo:**\n```javascript\nfunction ExpensiveComponent({ items, filter }) {\n  // Only recalculates when items or filter change\n  const expensiveValue = useMemo(() => {\n    console.log('Calculating expensive value...');\n    return items\n      .filter(item => item.category === filter)\n      .reduce((sum, item) => sum + item.value, 0);\n  }, [items, filter]);\n  \n  const [count, setCount] = useState(0);\n  \n  return (\n    <div>\n      <p>Total: {expensiveValue}</p>\n      <button onClick={() => setCount(count + 1)}>Count: {count}</button>\n    </div>\n  );\n}\n```\n\n**Memoizing Objects and Arrays:**\n```javascript\nfunction UserProfile({ user }) {\n  // Prevents new object creation on every render\n  const userSettings = useMemo(() => ({\n    theme: user.preferences.theme,\n    language: user.preferences.language,\n    notifications: user.preferences.notifications\n  }), [user.preferences]);\n  \n  // Prevents new array creation\n  const sortedFriends = useMemo(() => \n    user.friends.sort((a, b) => a.name.localeCompare(b.name)),\n    [user.friends]\n  );\n  \n  return (\n    <div>\n      <Settings config={userSettings} />\n      <FriendsList friends={sortedFriends} />\n    </div>\n  );\n}\n```\n\n**Custom Hook with useMemo:**\n```javascript\nfunction useFilteredAndSortedData(data, filter, sortBy) {\n  return useMemo(() => {\n    return data\n      .filter(item => item.type === filter)\n      .sort((a, b) => {\n        if (sortBy === 'name') return a.name.localeCompare(b.name);\n        if (sortBy === 'date') return new Date(a.date) - new Date(b.date);\n        return 0;\n      });\n  }, [data, filter, sortBy]);\n}\n```\n\n**When to Use useMemo:**\n- Expensive calculations that depend on specific values\n- Creating objects/arrays that are passed as props to memoized components\n- Breaking referential equality issues\n- Heavy filtering, sorting, or data transformations\n\n**When NOT to Use:**\n- Simple calculations (primitives, basic operations)\n- Values that change frequently anyway\n- Over-memoization can hurt performance due to comparison overhead",
      "keywords": ["useMemo", "memoization", "performance optimization", "expensive calculations", "referential equality", "dependencies", "data transformation", "filtering", "sorting"],
      "difficulty": "medium"
    },
    {
      "id": 2015,
      "tag": "react",
      "question": "Explain the useContext hook and React's Context API.",
      "answer": "useContext hook and Context API provide a way to share data across the component tree without prop drilling.\n\n**Creating Context:**\n```javascript\nimport { createContext, useContext, useState } from 'react';\n\n// Create context\nconst ThemeContext = createContext();\n\n// Provider component\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState('light');\n  \n  const toggleTheme = () => {\n    setTheme(prev => prev === 'light' ? 'dark' : 'light');\n  };\n  \n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\n// Custom hook for using context\nfunction useTheme() {\n  const context = useContext(ThemeContext);\n  if (!context) {\n    throw new Error('useTheme must be used within ThemeProvider');\n  }\n  return context;\n}\n```\n\n**Using Context:**\n```javascript\nfunction App() {\n  return (\n    <ThemeProvider>\n      <Header />\n      <MainContent />\n      <Footer />\n    </ThemeProvider>\n  );\n}\n\nfunction Header() {\n  const { theme, toggleTheme } = useTheme();\n  \n  return (\n    <header style={{ backgroundColor: theme === 'light' ? 'white' : 'black' }}>\n      <h1>My App</h1>\n      <button onClick={toggleTheme}>\n        Switch to {theme === 'light' ? 'dark' : 'light'} mode\n      </button>\n    </header>\n  );\n}\n\nfunction MainContent() {\n  const { theme } = useTheme();\n  \n  return (\n    <main style={{ color: theme === 'light' ? 'black' : 'white' }}>\n      <p>Content styled with current theme</p>\n    </main>\n  );\n}\n```\n\n**Multiple Contexts:**\n```javascript\nconst UserContext = createContext();\nconst SettingsContext = createContext();\n\nfunction App() {\n  return (\n    <UserProvider>\n      <SettingsProvider>\n        <ThemeProvider>\n          <Dashboard />\n        </ThemeProvider>\n      </SettingsProvider>\n    </UserProvider>\n  );\n}\n\nfunction Dashboard() {\n  const user = useContext(UserContext);\n  const settings = useContext(SettingsContext);\n  const { theme } = useTheme();\n  \n  return (\n    <div>\n      <h1>Welcome, {user.name}!</h1>\n      <p>Language: {settings.language}</p>\n      <p>Theme: {theme}</p>\n    </div>\n  );\n}\n```\n\n**Advanced Pattern - Reducer with Context:**\n```javascript\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\nfunction useAppState() {\n  return useContext(StateContext);\n}\n\nfunction useAppDispatch() {\n  return useContext(DispatchContext);\n}\n```\n\n**Benefits:**\n- Eliminates prop drilling\n- Clean component hierarchy\n- Centralized state management\n- Type-safe with TypeScript\n\n**Considerations:**\n- Context changes re-render all consuming components\n- Not suitable for frequently changing data\n- Consider splitting contexts for different concerns\n- Use React.memo to optimize consumers",
      "keywords": ["useContext", "Context API", "createContext", "Provider", "prop drilling", "global state", "custom hooks", "context splitting", "performance", "state management"],
      "difficulty": "medium"
    },
    {
      "id": 2016,
      "tag": "react",
      "question": "What are custom hooks and what are their benefits?",
      "answer": "Custom hooks are JavaScript functions that start with 'use' and allow you to extract and reuse stateful logic between components.\n\n**Basic Custom Hook:**\n```javascript\n// Custom hook for managing counter state\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  \n  const increment = useCallback(() => setCount(prev => prev + 1), []);\n  const decrement = useCallback(() => setCount(prev => prev - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n  \n  return { count, increment, decrement, reset };\n}\n\n// Usage in components\nfunction Counter() {\n  const { count, increment, decrement, reset } = useCounter(10);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n```\n\n**Data Fetching Hook:**\n```javascript\nfunction useApi(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Failed to fetch');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    if (url) fetchData();\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { data: user, loading, error } = useApi(`/api/users/${userId}`);\n  \n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return null;\n  \n  return <div><h1>{user.name}</h1><p>{user.email}</p></div>;\n}\n```\n\n**Form Management Hook:**\n```javascript\nfunction useForm(initialValues, validationRules = {}) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  \n  const handleChange = (name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Validate if field has been touched\n    if (touched[name] && validationRules[name]) {\n      const error = validationRules[name](value);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const handleBlur = (name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    if (validationRules[name]) {\n      const error = validationRules[name](values[name]);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const isValid = Object.values(errors).every(error => !error);\n  \n  return {\n    values,\n    errors,\n    touched,\n    handleChange,\n    handleBlur,\n    isValid\n  };\n}\n```\n\n**Local Storage Hook:**\n```javascript\nfunction useLocalStorage(key, initialValue) {\n  const [value, setValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n  \n  const setStoredValue = useCallback((newValue) => {\n    try {\n      setValue(newValue);\n      window.localStorage.setItem(key, JSON.stringify(newValue));\n    } catch (error) {\n      console.error('Error saving to localStorage:', error);\n    }\n  }, [key]);\n  \n  return [value, setStoredValue];\n}\n```\n\n**Benefits of Custom Hooks:**\n- **Reusability:** Share logic across multiple components\n- **Separation of Concerns:** Extract complex logic from components\n- **Testing:** Test logic independently of UI\n- **Cleaner Components:** Focus on rendering, not state management\n- **Composition:** Combine multiple custom hooks\n- **Type Safety:** Full TypeScript support\n\n**Rules for Custom Hooks:**\n- Must start with 'use'\n- Can only be called at the top level\n- Can use other hooks\n- Should be pure functions that return consistent values",
      "keywords": ["custom hooks", "reusable logic", "stateful logic", "separation of concerns", "composition", "data fetching", "form management", "localStorage", "testing", "TypeScript"],
      "difficulty": "medium"
    },
    {
      "id": 2017,
      "tag": "react",
      "question": "What are React fragments and when should you use them?",
      "answer": "React fragments allow you to group multiple elements without adding extra DOM nodes. They solve the problem of needing a single parent element in JSX.\n\n**Problem Without Fragments:**\n```javascript\n// Creates unnecessary div wrapper\nfunction UserInfo() {\n  return (\n    <div> {/* Extra wrapper div */}\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </div>\n  );\n}\n```\n\n**Solution With Fragments:**\n```javascript\n// Method 1: React.Fragment\nfunction UserInfo() {\n  return (\n    <React.Fragment>\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </React.Fragment>\n  );\n}\n\n// Method 2: Short syntax (preferred)\nfunction UserInfo() {\n  return (\n    <>\n      <h2>John Doe</h2>\n      <p>Software Developer</p>\n      <p>john@example.com</p>\n    </>\n  );\n}\n```\n\n**When to Use Fragments:**\n- Avoid unnecessary wrapper divs\n- Maintain proper HTML semantics\n- Table rows, list items, or form elements\n- CSS Grid/Flexbox layouts where extra wrappers break styling\n\n**Fragment with Keys (for lists):**\n```javascript\nfunction ItemList({ items }) {\n  return (\n    <dl>\n      {items.map(item => (\n        <React.Fragment key={item.id}>\n          <dt>{item.term}</dt>\n          <dd>{item.definition}</dd>\n        </React.Fragment>\n      ))}\n    </dl>\n  );\n}\n```\n\n**Benefits:**\n- Cleaner DOM structure\n- Better performance (fewer DOM nodes)\n- Proper HTML semantics\n- CSS styling flexibility",
      "keywords": ["React.Fragment", "fragments", "short syntax", "DOM nodes", "JSX", "wrapper divs", "HTML semantics", "keys", "performance"],
      "difficulty": "easy"
    },
    {
      "id": 2018,
      "tag": "react",
      "question": "How do default props and prop types work in React?",
      "answer": "Default props and prop types help with component reliability by providing default values and type checking for props.\n\n**Default Props (Function Components):**\n```javascript\nfunction Button({ text, variant, disabled, onClick }) {\n  return (\n    <button \n      className={`btn btn-${variant}`}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {text}\n    </button>\n  );\n}\n\n// Method 1: Default parameters\nfunction Button({ \n  text = 'Click me', \n  variant = 'primary', \n  disabled = false, \n  onClick = () => {} \n}) {\n  return <button className={`btn btn-${variant}`}>{text}</button>;\n}\n\n// Method 2: defaultProps (legacy)\nButton.defaultProps = {\n  text: 'Click me',\n  variant: 'primary',\n  disabled: false,\n  onClick: () => {}\n};\n```\n\n**PropTypes (Development-time type checking):**\n```javascript\nimport PropTypes from 'prop-types';\n\nfunction UserCard({ name, age, email, isActive, hobbies, onEdit }) {\n  return (\n    <div>\n      <h3>{name}</h3>\n      <p>Age: {age}</p>\n      <p>Email: {email}</p>\n      <p>Status: {isActive ? 'Active' : 'Inactive'}</p>\n      <ul>\n        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}\n      </ul>\n      <button onClick={onEdit}>Edit</button>\n    </div>\n  );\n}\n\nUserCard.propTypes = {\n  name: PropTypes.string.isRequired,\n  age: PropTypes.number,\n  email: PropTypes.string.isRequired,\n  isActive: PropTypes.bool,\n  hobbies: PropTypes.arrayOf(PropTypes.string),\n  onEdit: PropTypes.func.isRequired\n};\n\nUserCard.defaultProps = {\n  age: 0,\n  isActive: true,\n  hobbies: []\n};\n```\n\n**Common PropTypes:**\n```javascript\nMyComponent.propTypes = {\n  // Basic types\n  name: PropTypes.string,\n  count: PropTypes.number,\n  isVisible: PropTypes.bool,\n  callback: PropTypes.func,\n  data: PropTypes.object,\n  items: PropTypes.array,\n  \n  // Required props\n  id: PropTypes.string.isRequired,\n  \n  // Specific values\n  size: PropTypes.oneOf(['small', 'medium', 'large']),\n  \n  // Array of specific type\n  numbers: PropTypes.arrayOf(PropTypes.number),\n  \n  // Object with specific shape\n  user: PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    email: PropTypes.string\n  }),\n  \n  // Custom validator\n  score: function(props, propName, componentName) {\n    if (props[propName] < 0 || props[propName] > 100) {\n      return new Error(`${propName} should be between 0 and 100`);\n    }\n  }\n};\n```\n\n**Modern Alternative (TypeScript):**\n```typescript\ninterface ButtonProps {\n  text?: string;\n  variant?: 'primary' | 'secondary' | 'danger';\n  disabled?: boolean;\n  onClick: () => void;\n}\n\nfunction Button({ \n  text = 'Click me', \n  variant = 'primary', \n  disabled = false, \n  onClick \n}: ButtonProps) {\n  return (\n    <button \n      className={`btn btn-${variant}`}\n      disabled={disabled}\n      onClick={onClick}\n    >\n      {text}\n    </button>\n  );\n}\n```",
      "keywords": ["default props", "defaultProps", "PropTypes", "type checking", "prop validation", "isRequired", "default parameters", "TypeScript", "component reliability"],
      "difficulty": "easy"
    },
    {
      "id": 2019,
      "tag": "react",
      "question": "What are synthetic events and how do they differ from native DOM events?",
      "answer": "Synthetic events are React's wrapper around native DOM events that provide consistent behavior across different browsers and additional functionality.\n\n**Key Differences:**\n\n**Native DOM Events:**\n```javascript\n// Native event handling (outside React)\ndocument.getElementById('button').addEventListener('click', function(e) {\n  console.log(e); // Native Event object\n  e.stopPropagation(); // Browser-specific implementation\n});\n```\n\n**Synthetic Events:**\n```javascript\nfunction Button() {\n  const handleClick = (e) => {\n    console.log(e); // SyntheticEvent object\n    console.log(e.nativeEvent); // Access to original native event\n    e.preventDefault(); // Consistent across browsers\n    e.stopPropagation(); // Consistent across browsers\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**SyntheticEvent Properties:**\n```javascript\nfunction InputHandler() {\n  const handleEvent = (e) => {\n    // Common properties available across all browsers\n    console.log(e.type); // Event type (click, change, etc.)\n    console.log(e.target); // Element that triggered the event\n    console.log(e.currentTarget); // Element event handler is attached to\n    console.log(e.timeStamp); // When event occurred\n    \n    // Methods work consistently across browsers\n    e.preventDefault(); // Prevent default behavior\n    e.stopPropagation(); // Stop event bubbling\n    \n    // Access native event if needed\n    console.log(e.nativeEvent);\n  };\n  \n  return (\n    <div>\n      <input onChange={handleEvent} onClick={handleEvent} />\n      <button onSubmit={handleEvent}>Submit</button>\n    </div>\n  );\n}\n```\n\n**Event Pooling (React 16 and below):**\n```javascript\nfunction OldEventHandling() {\n  const handleClick = (e) => {\n    // In React 16 and below, events were pooled\n    console.log(e.type); // Works immediately\n    \n    setTimeout(() => {\n      console.log(e.type); // Would be null due to pooling\n      \n      // Solution: persist the event\n      e.persist();\n      console.log(e.type); // Now works\n    }, 1000);\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n\n// React 17+: No more event pooling\nfunction ModernEventHandling() {\n  const handleClick = (e) => {\n    setTimeout(() => {\n      console.log(e.type); // Works fine, no need for e.persist()\n    }, 1000);\n  };\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Form Events Example:**\n```javascript\nfunction FormComponent() {\n  const handleSubmit = (e) => {\n    e.preventDefault(); // Prevents page reload\n    console.log('Form submitted');\n  };\n  \n  const handleChange = (e) => {\n    console.log(e.target.value); // Consistent across all browsers\n    console.log(e.target.name); // Input name attribute\n  };\n  \n  const handleKeyPress = (e) => {\n    if (e.key === 'Enter') {\n      console.log('Enter pressed');\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input \n        name=\"username\" \n        onChange={handleChange} \n        onKeyPress={handleKeyPress} \n      />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n}\n```\n\n**Benefits of Synthetic Events:**\n- **Cross-browser compatibility:** Consistent API across all browsers\n- **Event delegation:** Better performance through automatic event delegation\n- **Additional features:** Extra properties and methods not in native events\n- **Memory efficiency:** Event pooling (React 16 and below)\n- **Easier testing:** Predictable event objects for unit tests\n\n**When to Use Native Events:**\n- Direct DOM manipulation outside React\n- Third-party library integration\n- Specific browser APIs not wrapped by SyntheticEvents\n- Performance-critical scenarios requiring direct event handling",
      "keywords": ["synthetic events", "native events", "cross-browser compatibility", "event delegation", "event pooling", "preventDefault", "stopPropagation", "nativeEvent", "SyntheticEvent"],
      "difficulty": "easy"
    },
    {
      "id": 2020,
      "tag": "react",
      "question": "What is React.memo and how does it help optimize component performance?",
      "answer": "React.memo is a higher-order component that memoizes functional components, preventing unnecessary re-renders when props haven't changed.\n\n**Basic Usage:**\n```javascript\n// Without React.memo - re-renders on every parent render\nfunction ExpensiveComponent({ name, count }) {\n  console.log('ExpensiveComponent rendered');\n  \n  // Expensive calculation\n  const expensiveValue = useMemo(() => {\n    let result = 0;\n    for (let i = 0; i < 1000000; i++) {\n      result += i;\n    }\n    return result;\n  }, []);\n  \n  return (\n    <div>\n      <h2>Hello {name}</h2>\n      <p>Count: {count}</p>\n      <p>Expensive result: {expensiveValue}</p>\n    </div>\n  );\n}\n\n// With React.memo - only re-renders when props change\nconst MemoizedComponent = React.memo(ExpensiveComponent);\n```\n\n**Parent Component Example:**\n```javascript\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [name, setName] = useState('John');\n  const [otherState, setOtherState] = useState('');\n  \n  return (\n    <div>\n      <input \n        value={otherState} \n        onChange={(e) => setOtherState(e.target.value)}\n        placeholder=\"This won't cause re-render\"\n      />\n      \n      {/* Only re-renders when name or count change */}\n      <MemoizedComponent name={name} count={count} />\n      \n      <button onClick={() => setCount(count + 1)}>Increment Count</button>\n      <button onClick={() => setName(name === 'John' ? 'Jane' : 'John')}>\n        Toggle Name\n      </button>\n    </div>\n  );\n}\n```\n\n**Custom Comparison Function:**\n```javascript\nfunction UserCard({ user, theme }) {\n  return (\n    <div className={`card ${theme}`}>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n      <p>Last login: {user.lastLogin}</p>\n    </div>\n  );\n}\n\n// Custom comparison - only re-render if user.name or theme changes\nconst MemoizedUserCard = React.memo(UserCard, (prevProps, nextProps) => {\n  // Return true if props are equal (should NOT re-render)\n  // Return false if props are different (should re-render)\n  return (\n    prevProps.user.name === nextProps.user.name &&\n    prevProps.theme === nextProps.theme\n  );\n});\n```\n\n**Common Pitfalls - Object/Array Props:**\n```javascript\n// ❌ Problem: New object created on every render\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  return (\n    <MemoizedChild \n      user={{ name: 'John', age: 30 }} // New object every render!\n      onAction={() => console.log('action')} // New function every render!\n    />\n  );\n}\n\n// ✅ Solution: Memoize objects and callbacks\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  \n  const user = useMemo(() => ({ name: 'John', age: 30 }), []);\n  const handleAction = useCallback(() => console.log('action'), []);\n  \n  return (\n    <MemoizedChild user={user} onAction={handleAction} />\n  );\n}\n```\n\n**With Complex Props:**\n```javascript\nfunction ProductList({ products, filters, onProductClick }) {\n  const filteredProducts = useMemo(() => {\n    return products.filter(product => {\n      return filters.category ? product.category === filters.category : true;\n    });\n  }, [products, filters]);\n  \n  return (\n    <div>\n      {filteredProducts.map(product => (\n        <ProductCard\n          key={product.id}\n          product={product}\n          onClick={onProductClick}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Memoize ProductCard to prevent unnecessary re-renders\nconst ProductCard = React.memo(({ product, onClick }) => {\n  return (\n    <div onClick={() => onClick(product.id)}>\n      <h3>{product.name}</h3>\n      <p>${product.price}</p>\n    </div>\n  );\n});\n```\n\n**When to Use React.memo:**\n- Components that render frequently with same props\n- Expensive rendering operations\n- Components in large lists\n- Pure functional components\n\n**When NOT to Use React.memo:**\n- Props change frequently anyway\n- Simple components with minimal rendering cost\n- Over-optimization can hurt performance\n- Components that always receive different props\n\n**Performance Tip:**\nCombine with useCallback and useMemo to maximize benefits:\n```javascript\nconst OptimizedParent = () => {\n  const [items, setItems] = useState([]);\n  const [filter, setFilter] = useState('');\n  \n  const filteredItems = useMemo(() => \n    items.filter(item => item.name.includes(filter)), \n    [items, filter]\n  );\n  \n  const handleItemClick = useCallback((id) => {\n    console.log('Clicked item:', id);\n  }, []);\n  \n  return (\n    <MemoizedItemList \n      items={filteredItems} \n      onItemClick={handleItemClick} \n    />\n  );\n};\n```",
      "keywords": ["React.memo", "memoization", "performance optimization", "re-renders", "shallow comparison", "custom comparison", "useCallback", "useMemo", "props comparison", "higher-order component"],
      "difficulty": "easy"
    },
    {
      "id": 2021,
      "tag": "react",
      "question": "Explain the useReducer hook and when you should use it over useState.",
      "answer": "useReducer is a React hook that provides a more predictable way to manage complex state logic using a reducer function, similar to Redux.\n\n**Basic useReducer Setup:**\n```javascript\nimport React, { useReducer } from 'react';\n\n// Define initial state\nconst initialState = { count: 0 };\n\n// Define reducer function\nfunction counterReducer(state, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { count: state.count + 1 };\n    case 'DECREMENT':\n      return { count: state.count - 1 };\n    case 'RESET':\n      return { count: 0 };\n    default:\n      throw new Error(`Unknown action type: ${action.type}`);\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(counterReducer, initialState);\n  \n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>\n      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>\n      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>\n    </div>\n  );\n}\n```\n\n**Complex State Example:**\n```javascript\nconst initialState = {\n  user: null,\n  loading: false,\n  error: null,\n  posts: []\n};\n\nfunction appReducer(state, action) {\n  switch (action.type) {\n    case 'FETCH_USER_START':\n      return {\n        ...state,\n        loading: true,\n        error: null\n      };\n      \n    case 'FETCH_USER_SUCCESS':\n      return {\n        ...state,\n        loading: false,\n        user: action.payload,\n        error: null\n      };\n      \n    case 'FETCH_USER_ERROR':\n      return {\n        ...state,\n        loading: false,\n        error: action.payload,\n        user: null\n      };\n      \n    case 'ADD_POST':\n      return {\n        ...state,\n        posts: [...state.posts, action.payload]\n      };\n      \n    case 'DELETE_POST':\n      return {\n        ...state,\n        posts: state.posts.filter(post => post.id !== action.payload)\n      };\n      \n    default:\n      return state;\n  }\n}\n\nfunction UserDashboard() {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  const fetchUser = async (userId) => {\n    dispatch({ type: 'FETCH_USER_START' });\n    \n    try {\n      const user = await api.getUser(userId);\n      dispatch({ type: 'FETCH_USER_SUCCESS', payload: user });\n    } catch (error) {\n      dispatch({ type: 'FETCH_USER_ERROR', payload: error.message });\n    }\n  };\n  \n  const addPost = (post) => {\n    dispatch({ type: 'ADD_POST', payload: post });\n  };\n  \n  if (state.loading) return <div>Loading...</div>;\n  if (state.error) return <div>Error: {state.error}</div>;\n  \n  return (\n    <div>\n      {state.user && <h1>Welcome, {state.user.name}!</h1>}\n      <PostList posts={state.posts} onAddPost={addPost} />\n    </div>\n  );\n}\n```\n\n**useReducer with useContext (Global State):**\n```javascript\nconst StateContext = createContext();\nconst DispatchContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n  \n  return (\n    <StateContext.Provider value={state}>\n      <DispatchContext.Provider value={dispatch}>\n        {children}\n      </DispatchContext.Provider>\n    </StateContext.Provider>\n  );\n}\n\n// Custom hooks for consuming context\nfunction useAppState() {\n  const context = useContext(StateContext);\n  if (!context) {\n    throw new Error('useAppState must be used within AppProvider');\n  }\n  return context;\n}\n\nfunction useAppDispatch() {\n  const context = useContext(DispatchContext);\n  if (!context) {\n    throw new Error('useAppDispatch must be used within AppProvider');\n  }\n  return context;\n}\n```\n\n**When to Use useReducer vs useState:**\n\n**Use useReducer when:**\n- Complex state logic with multiple sub-values\n- Next state depends on previous state\n- State transitions need to be predictable\n- Managing related state that changes together\n- Need to optimize performance (fewer re-renders)\n- Complex update logic that would benefit from centralization\n\n**Use useState when:**\n- Simple state values (strings, numbers, booleans)\n- Independent state variables\n- State updates are straightforward\n- Small components with minimal state logic\n\n**Comparison Example:**\n```javascript\n// useState - Good for simple state\nfunction SimpleForm() {\n  const [name, setName] = useState('');\n  const [email, setEmail] = useState('');\n  const [loading, setLoading] = useState(false);\n  \n  // Multiple separate setState calls\n  const handleSubmit = async () => {\n    setLoading(true);\n    try {\n      await submitForm({ name, email });\n      setName('');\n      setEmail('');\n    } finally {\n      setLoading(false);\n    }\n  };\n}\n\n// useReducer - Better for complex state\nfunction ComplexForm() {\n  const [state, dispatch] = useReducer(formReducer, {\n    name: '',\n    email: '',\n    loading: false,\n    errors: {},\n    submitted: false\n  });\n  \n  // Single dispatch call for related state changes\n  const handleSubmit = async () => {\n    dispatch({ type: 'SUBMIT_START' });\n    try {\n      await submitForm({ name: state.name, email: state.email });\n      dispatch({ type: 'SUBMIT_SUCCESS' });\n    } catch (error) {\n      dispatch({ type: 'SUBMIT_ERROR', payload: error.message });\n    }\n  };\n}\n```",
      "keywords": ["useReducer", "reducer function", "complex state", "state management", "dispatch", "action types", "predictable updates", "useState comparison", "global state", "context"],
      "difficulty": "easy"
    },
    {
      "id": 2022,
      "tag": "react",
      "question": "What are error boundaries in React and how do you implement them?",
      "answer": "Error boundaries are React components that catch JavaScript errors anywhere in their component tree, log errors, and display fallback UI instead of crashing the entire application.\n\n**Class Component Error Boundary:**\n```javascript\nimport React from 'react';\n\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false, error: null, errorInfo: null };\n  }\n  \n  static getDerivedStateFromError(error) {\n    // Update state so next render shows fallback UI\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    // Log error details\n    console.error('Error caught by boundary:', error, errorInfo);\n    \n    // Update state with error details\n    this.setState({\n      error: error,\n      errorInfo: errorInfo\n    });\n    \n    // Send error to logging service\n    this.logErrorToService(error, errorInfo);\n  }\n  \n  logErrorToService(error, errorInfo) {\n    // Example: Send to error tracking service\n    // Sentry.captureException(error, { extra: errorInfo });\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      // Fallback UI\n      return (\n        <div style={{ padding: '20px', border: '1px solid red' }}>\n          <h2>Something went wrong!</h2>\n          <details style={{ whiteSpace: 'pre-wrap' }}>\n            <summary>Error Details (Click to expand)</summary>\n            <p><strong>Error:</strong> {this.state.error && this.state.error.toString()}</p>\n            <p><strong>Stack Trace:</strong> {this.state.errorInfo.componentStack}</p>\n          </details>\n          <button onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    \n    // Normal render\n    return this.props.children;\n  }\n}\n```\n\n**Usage Example:**\n```javascript\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <ErrorBoundary>\n        <MainContent /> {/* If this crashes, ErrorBoundary catches it */}\n      </ErrorBoundary>\n      <ErrorBoundary>\n        <Sidebar /> {/* Independent error boundary */}\n      </ErrorBoundary>\n      <Footer />\n    </div>\n  );\n}\n\n// Component that might throw an error\nfunction BuggyComponent({ shouldThrow }) {\n  if (shouldThrow) {\n    throw new Error('I crashed!');\n  }\n  return <div>I'm working fine!</div>;\n}\n```\n\n**Custom Error Boundary Hook (Functional Component Approach):**\n```javascript\n// Note: Error boundaries must be class components\n// But you can create a custom hook for error handling\nimport { useState, useEffect } from 'react';\n\nfunction useErrorHandler() {\n  const [error, setError] = useState(null);\n  \n  const resetError = () => setError(null);\n  \n  const catchError = (error, errorInfo) => {\n    setError({ error, errorInfo });\n    console.error('Error caught:', error, errorInfo);\n  };\n  \n  return { error, resetError, catchError };\n}\n\n// Wrapper component using the hook\nfunction ErrorBoundaryWrapper({ children, fallback }) {\n  return (\n    <ErrorBoundary fallback={fallback}>\n      {children}\n    </ErrorBoundary>\n  );\n}\n```\n\n**Advanced Error Boundary with Context:**\n```javascript\nconst ErrorContext = createContext();\n\nclass GlobalErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { \n      errors: [],\n      hasGlobalError: false \n    };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasGlobalError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    const errorReport = {\n      id: Date.now(),\n      error: error.toString(),\n      stack: error.stack,\n      componentStack: errorInfo.componentStack,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.setState(prevState => ({\n      errors: [...prevState.errors, errorReport]\n    }));\n    \n    // Report to monitoring service\n    this.reportError(errorReport);\n  }\n  \n  reportError = (errorReport) => {\n    // Send to error tracking service\n    fetch('/api/errors', {\n      method: 'POST',\n      body: JSON.stringify(errorReport),\n      headers: { 'Content-Type': 'application/json' }\n    });\n  };\n  \n  clearErrors = () => {\n    this.setState({ errors: [], hasGlobalError: false });\n  };\n  \n  render() {\n    const value = {\n      errors: this.state.errors,\n      hasGlobalError: this.state.hasGlobalError,\n      clearErrors: this.clearErrors\n    };\n    \n    return (\n      <ErrorContext.Provider value={value}>\n        {this.props.children}\n      </ErrorContext.Provider>\n    );\n  }\n}\n\n// Hook to use error context\nfunction useErrorContext() {\n  return useContext(ErrorContext);\n}\n```\n\n**What Error Boundaries DON'T Catch:**\n- Event handlers (use try-catch instead)\n- Asynchronous code (setTimeout, requestAnimationFrame callbacks)\n- Errors during server-side rendering\n- Errors thrown in the error boundary itself\n\n**Error Handling in Event Handlers:**\n```javascript\nfunction SafeComponent() {\n  const [error, setError] = useState(null);\n  \n  const handleClick = () => {\n    try {\n      // Potentially dangerous operation\n      riskyOperation();\n    } catch (error) {\n      setError(error.message);\n    }\n  };\n  \n  if (error) {\n    return <div>Error in event handler: {error}</div>;\n  }\n  \n  return <button onClick={handleClick}>Click me</button>;\n}\n```\n\n**Best Practices:**\n- Place error boundaries at multiple levels (global, feature, component)\n- Provide meaningful fallback UI\n- Log errors for monitoring and debugging\n- Don't catch errors that should crash the app (authentication failures)\n- Use error boundaries to prevent cascade failures\n- Consider user experience in error states\n- Implement retry mechanisms where appropriate",
      "keywords": ["error boundaries", "componentDidCatch", "getDerivedStateFromError", "fallback UI", "error handling", "crash prevention", "error logging", "class components", "try-catch", "error reporting"],
      "difficulty": "easy"
    },
    {
      "id": 2023,
      "tag": "react",
      "question": "What is React Strict Mode and what benefits does it provide?",
      "answer": "React Strict Mode is a development tool that helps identify potential problems in an application by activating additional checks and warnings for its descendants.\n\n**Basic Usage:**\n```javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// Or wrap specific components\nfunction MyApp() {\n  return (\n    <div>\n      <Header />\n      <React.StrictMode>\n        <MainContent /> {/* Only this component tree is in strict mode */}\n      </React.StrictMode>\n      <Footer />\n    </div>\n  );\n}\n```\n\n**What Strict Mode Does:**\n\n**1. Detects Components with Unsafe Lifecycles:**\n```javascript\n// ❌ These will show warnings in Strict Mode\nclass BadComponent extends React.Component {\n  componentWillMount() { // Deprecated\n    console.log('Will mount');\n  }\n  \n  componentWillReceiveProps(nextProps) { // Deprecated\n    console.log('Will receive props');\n  }\n  \n  componentWillUpdate(nextProps, nextState) { // Deprecated\n    console.log('Will update');\n  }\n}\n\n// ✅ Safe alternatives\nclass GoodComponent extends React.Component {\n  componentDidMount() {\n    console.log('Did mount');\n  }\n  \n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.userId !== this.props.userId) {\n      console.log('User changed');\n    }\n  }\n  \n  static getDerivedStateFromProps(props, state) {\n    if (props.userId !== state.prevUserId) {\n      return {\n        prevUserId: props.userId,\n        userData: null\n      };\n    }\n    return null;\n  }\n}\n```\n\n**2. Double-Invokes Functions to Detect Side Effects:**\n```javascript\n// Strict Mode will call these twice in development\nfunction MyComponent() {\n  // ❌ Side effects in render (will be called twice)\n  console.log('Rendering component'); // This logs twice\n  Math.random(); // Different results on double-invoke\n  \n  // ✅ Pure render function\n  const [count, setCount] = useState(0);\n  \n  // ❌ Side effects in constructor/initializer\n  const [data] = useState(() => {\n    console.log('Initializing state'); // This logs twice\n    return fetchInitialData(); // Could cause issues\n  });\n  \n  // ✅ Side effects in useEffect\n  useEffect(() => {\n    console.log('Effect running'); // This logs twice\n    fetchData(); // Safe place for side effects\n  }, []);\n  \n  return <div>Count: {count}</div>;\n}\n```\n\n**3. Detects Legacy String Ref Usage:**\n```javascript\nclass LegacyComponent extends React.Component {\n  componentDidMount() {\n    // ❌ String refs (deprecated) - Strict Mode warns\n    this.refs.myInput.focus();\n  }\n  \n  render() {\n    return <input ref=\"myInput\" />; // Warning in Strict Mode\n  }\n}\n\n// ✅ Modern ref usage\nfunction ModernComponent() {\n  const inputRef = useRef(null);\n  \n  useEffect(() => {\n    inputRef.current.focus();\n  }, []);\n  \n  return <input ref={inputRef} />;\n}\n```\n\n**4. Detects Legacy Context API:**\n```javascript\n// ❌ Legacy context API - warns in Strict Mode\nclass LegacyProvider extends React.Component {\n  static childContextTypes = {\n    theme: PropTypes.string\n  };\n  \n  getChildContext() {\n    return { theme: 'dark' };\n  }\n}\n\n// ✅ Modern Context API\nconst ThemeContext = React.createContext('light');\n\nfunction ModernProvider({ children }) {\n  return (\n    <ThemeContext.Provider value=\"dark\">\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n```\n\n**5. Detects Findable Side Effects in useEffect:**\n```javascript\nfunction ComponentWithEffects() {\n  const [data, setData] = useState(null);\n  \n  // Strict Mode helps identify missing cleanup\n  useEffect(() => {\n    const subscription = subscribeToData((newData) => {\n      setData(newData);\n    });\n    \n    // ❌ Missing cleanup - Strict Mode helps detect memory leaks\n    // return () => subscription.unsubscribe();\n  }, []);\n  \n  // ✅ Proper effect with cleanup\n  useEffect(() => {\n    const subscription = subscribeToData((newData) => {\n      setData(newData);\n    });\n    \n    return () => subscription.unsubscribe(); // Cleanup\n  }, []);\n  \n  return <div>{data ? data.message : 'Loading...'}</div>;\n}\n```\n\n**Benefits of Strict Mode:**\n- **Early Problem Detection:** Catches issues before production\n- **Future-Proofing:** Identifies deprecated patterns\n- **Better Code Quality:** Encourages best practices\n- **Side Effect Detection:** Helps identify unintentional side effects\n- **Concurrent Mode Preparation:** Prepares code for React's concurrent features\n\n**Important Notes:**\n- Only runs in development mode\n- Does not affect production builds\n- Can be applied to any part of the component tree\n- Double-invocation helps identify impure functions\n- Warnings are development-only and help improve code quality\n\n**Common Issues in Strict Mode:**\n```javascript\n// Console logs appearing twice\nfunction MyComponent() {\n  console.log('Component rendered'); // Logs twice in Strict Mode\n  return <div>Hello</div>;\n}\n\n// State initializers running twice\nfunction ComponentWithState() {\n  const [count, setCount] = useState(() => {\n    console.log('State initializer'); // Runs twice\n    return 0;\n  });\n  \n  return <div>{count}</div>;\n}\n\n// Effects running twice\nfunction ComponentWithEffect() {\n  useEffect(() => {\n    console.log('Effect ran'); // Runs twice\n  }, []);\n  \n  return <div>Component</div>;\n}\n```\n\nThis double-invocation is intentional and helps developers write more resilient code by exposing side effects that shouldn't exist in pure functions.",
      "keywords": ["React.StrictMode", "development tool", "deprecated lifecycles", "side effects", "double invocation", "legacy patterns", "string refs", "legacy context", "warnings", "code quality"],
      "difficulty": "easy"
    },
    {
      "id": 2024,
      "tag": "react",
      "question": "What are Higher-Order Components (HOCs) and how do you implement them?",
      "answer": "Higher-Order Components (HOCs) are advanced React patterns where a function takes a component and returns a new enhanced component. They're used for code reuse, logic abstraction, and cross-cutting concerns.\n\n**Basic HOC Structure:**\n```javascript\n// HOC is a function that takes a component and returns a new component\nfunction withEnhancement(WrappedComponent) {\n  return function EnhancedComponent(props) {\n    // Add enhancement logic here\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nconst EnhancedMyComponent = withEnhancement(MyComponent);\n```\n\n**Authentication HOC Example:**\n```javascript\nfunction withAuth(WrappedComponent) {\n  return function AuthenticatedComponent(props) {\n    const [isAuthenticated, setIsAuthenticated] = useState(false);\n    const [loading, setLoading] = useState(true);\n    \n    useEffect(() => {\n      const checkAuth = async () => {\n        try {\n          const token = localStorage.getItem('token');\n          const isValid = await validateToken(token);\n          setIsAuthenticated(isValid);\n        } catch (error) {\n          setIsAuthenticated(false);\n        } finally {\n          setLoading(false);\n        }\n      };\n      \n      checkAuth();\n    }, []);\n    \n    if (loading) {\n      return <div>Checking authentication...</div>;\n    }\n    \n    if (!isAuthenticated) {\n      return <div>Please log in to access this page.</div>;\n    }\n    \n    return <WrappedComponent {...props} isAuthenticated={isAuthenticated} />;\n  };\n}\n\n// Usage\nfunction Dashboard() {\n  return <div>Welcome to the dashboard!</div>;\n}\n\nconst ProtectedDashboard = withAuth(Dashboard);\n```\n\n**Data Fetching HOC:**\n```javascript\nfunction withApiData(url, propName = 'data') {\n  return function(WrappedComponent) {\n    return function DataFetchingComponent(props) {\n      const [data, setData] = useState(null);\n      const [loading, setLoading] = useState(true);\n      const [error, setError] = useState(null);\n      \n      useEffect(() => {\n        const fetchData = async () => {\n          try {\n            setLoading(true);\n            const response = await fetch(url);\n            if (!response.ok) throw new Error('Failed to fetch');\n            const result = await response.json();\n            setData(result);\n          } catch (err) {\n            setError(err.message);\n          } finally {\n            setLoading(false);\n          }\n        };\n        \n        fetchData();\n      }, []);\n      \n      const enhancedProps = {\n        ...props,\n        [propName]: data,\n        loading,\n        error\n      };\n      \n      return <WrappedComponent {...enhancedProps} />;\n    };\n  };\n}\n\n// Usage\nfunction UserList({ users, loading, error }) {\n  if (loading) return <div>Loading users...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <ul>\n      {users?.map(user => <li key={user.id}>{user.name}</li>)}\n    </ul>\n  );\n}\n\nconst UsersWithData = withApiData('/api/users', 'users')(UserList);\n```\n\n**Logging HOC:**\n```javascript\nfunction withLogging(WrappedComponent) {\n  return function LoggingComponent(props) {\n    const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n    \n    useEffect(() => {\n      console.log(`${componentName} mounted`);\n      return () => {\n        console.log(`${componentName} unmounted`);\n      };\n    }, []);\n    \n    useEffect(() => {\n      console.log(`${componentName} updated with props:`, props);\n    });\n    \n    return <WrappedComponent {...props} />;\n  };\n}\n\n// Usage\nfunction MyComponent({ name }) {\n  return <div>Hello, {name}!</div>;\n}\n\nconst LoggedComponent = withLogging(MyComponent);\n```\n\n**Conditional Rendering HOC:**\n```javascript\nfunction withConditionalRendering(condition, fallbackComponent = null) {\n  return function(WrappedComponent) {\n    return function ConditionalComponent(props) {\n      if (!condition(props)) {\n        return fallbackComponent ? React.createElement(fallbackComponent, props) : null;\n      }\n      \n      return <WrappedComponent {...props} />;\n    };\n  };\n}\n\n// Usage\nfunction AdminPanel() {\n  return <div>Admin-only content</div>;\n}\n\nfunction AccessDenied() {\n  return <div>Access denied. Admin privileges required.</div>;\n}\n\nconst ConditionalAdminPanel = withConditionalRendering(\n  (props) => props.user?.role === 'admin',\n  AccessDenied\n)(AdminPanel);\n```\n\n**Composing Multiple HOCs:**\n```javascript\nimport { compose } from 'redux'; // or create your own compose function\n\nfunction compose(...funcs) {\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\n// Individual HOCs\nconst withAuth = (Component) => (props) => { /* auth logic */ };\nconst withLogging = (Component) => (props) => { /* logging logic */ };\nconst withApiData = (url) => (Component) => (props) => { /* data fetching */ };\n\n// Compose multiple HOCs\nconst enhance = compose(\n  withAuth,\n  withLogging,\n  withApiData('/api/users')\n);\n\nconst EnhancedUserList = enhance(UserList);\n\n// Equivalent to:\n// const EnhancedUserList = withAuth(withLogging(withApiData('/api/users')(UserList)));\n```\n\n**Best Practices for HOCs:**\n\n**1. Preserve Static Methods:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  function EnhancedComponent(props) {\n    return <WrappedComponent {...props} />;\n  }\n  \n  // Copy static methods\n  Object.keys(WrappedComponent).forEach(key => {\n    EnhancedComponent[key] = WrappedComponent[key];\n  });\n  \n  return EnhancedComponent;\n}\n```\n\n**2. Use Display Names for Debugging:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  function EnhancedComponent(props) {\n    return <WrappedComponent {...props} />;\n  }\n  \n  const componentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  EnhancedComponent.displayName = `withEnhancement(${componentName})`;\n  \n  return EnhancedComponent;\n}\n```\n\n**3. Pass Through Refs:**\n```javascript\nfunction withEnhancement(WrappedComponent) {\n  const EnhancedComponent = React.forwardRef((props, ref) => {\n    return <WrappedComponent {...props} ref={ref} />;\n  });\n  \n  EnhancedComponent.displayName = `withEnhancement(${WrappedComponent.name})`;\n  \n  return EnhancedComponent;\n}\n```\n\n**Modern Alternatives to HOCs:**\n\n**1. Custom Hooks (Preferred):**\n```javascript\n// Instead of withApiData HOC\nfunction useApiData(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    // fetch logic\n  }, [url]);\n  \n  return { data, loading, error };\n}\n\n// Usage is cleaner\nfunction UserList() {\n  const { data: users, loading, error } = useApiData('/api/users');\n  \n  if (loading) return <div>Loading...</div>;\n  return <ul>{users?.map(user => <li key={user.id}>{user.name}</li>)}</ul>;\n}\n```\n\n**2. Render Props:**\n```javascript\nfunction DataProvider({ url, children }) {\n  const { data, loading, error } = useApiData(url);\n  return children({ data, loading, error });\n}\n\n// Usage\nfunction App() {\n  return (\n    <DataProvider url=\"/api/users\">\n      {({ data: users, loading, error }) => {\n        if (loading) return <div>Loading...</div>;\n        if (error) return <div>Error: {error}</div>;\n        return <UserList users={users} />;\n      }}\n    </DataProvider>\n  );\n}\n```\n\n**When to Use HOCs:**\n- Cross-cutting concerns (auth, logging, error handling)\n- When you need to wrap multiple components with same logic\n- Legacy codebases where hooks aren't available\n- When you need to manipulate component props before passing them down\n\n**When NOT to Use HOCs:**\n- Simple state logic (use hooks instead)\n- When render props or hooks provide cleaner solutions\n- Performance-critical scenarios (HOCs add extra component layers)",
      "keywords": ["Higher-Order Components", "HOCs", "code reuse", "cross-cutting concerns", "component enhancement", "authentication", "data fetching", "composition", "custom hooks", "render props"],
      "difficulty": "medium"
    },
    {
      "id": 2025,
      "tag": "react",
      "question": "Explain the render props pattern and its advantages over other patterns.",
      "answer": "The render props pattern is a technique for sharing code between React components using a prop whose value is a function. It provides a flexible way to share logic while maintaining component composition.\n\n**Basic Render Props Pattern:**\n```javascript\n// Component that provides logic via render prop\nfunction MouseTracker({ render }) {\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n  \n  useEffect(() => {\n    const handleMouseMove = (event) => {\n      setMousePosition({ x: event.clientX, y: event.clientY });\n    };\n    \n    document.addEventListener('mousemove', handleMouseMove);\n    return () => document.removeEventListener('mousemove', handleMouseMove);\n  }, []);\n  \n  // Call the render prop function with the shared state\n  return render(mousePosition);\n}\n\n// Usage with render prop\nfunction App() {\n  return (\n    <div>\n      <h1>Mouse Tracker Demo</h1>\n      <MouseTracker render={({ x, y }) => (\n        <div>\n          <h2>Mouse position: ({x}, {y})</h2>\n        </div>\n      )} />\n      \n      {/* Different rendering logic with same data */}\n      <MouseTracker render={({ x, y }) => (\n        <div \n          style={{\n            position: 'absolute',\n            left: x,\n            top: y,\n            width: '10px',\n            height: '10px',\n            background: 'red',\n            borderRadius: '50%'\n          }}\n        />\n      )} />\n    </div>\n  );\n}\n```\n\n**Using Children as Render Prop:**\n```javascript\nfunction DataProvider({ url, children }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  useEffect(() => {\n    const fetchData = async () => {\n      setLoading(true);\n      setError(null);\n      \n      try {\n        const response = await fetch(url);\n        if (!response.ok) throw new Error('Failed to fetch');\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    fetchData();\n  }, [url]);\n  \n  // Children function receives state as arguments\n  return children({ data, loading, error });\n}\n\n// Usage with children as function\nfunction UsersList() {\n  return (\n    <DataProvider url=\"/api/users\">\n      {({ data: users, loading, error }) => {\n        if (loading) return <div className=\"spinner\">Loading users...</div>;\n        if (error) return <div className=\"error\">Error: {error}</div>;\n        if (!users) return <div>No users found</div>;\n        \n        return (\n          <ul className=\"users-list\">\n            {users.map(user => (\n              <li key={user.id} className=\"user-item\">\n                <strong>{user.name}</strong> - {user.email}\n              </li>\n            ))}\n          </ul>\n        );\n      }}\n    </DataProvider>\n  );\n}\n```\n\n**Form Management with Render Props:**\n```javascript\nfunction FormProvider({ initialValues, validationRules, onSubmit, children }) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  const handleChange = (name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: null }));\n    }\n  };\n  \n  const handleBlur = (name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    validateField(name, values[name]);\n  };\n  \n  const validateField = (name, value) => {\n    if (validationRules[name]) {\n      const error = validationRules[name](value, values);\n      setErrors(prev => ({ ...prev, [name]: error }));\n    }\n  };\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    \n    // Validate all fields\n    const newErrors = {};\n    Object.keys(validationRules).forEach(field => {\n      const error = validationRules[field](values[field], values);\n      if (error) newErrors[field] = error;\n    });\n    \n    setErrors(newErrors);\n    \n    if (Object.keys(newErrors).length === 0) {\n      setIsSubmitting(true);\n      try {\n        await onSubmit(values);\n      } finally {\n        setIsSubmitting(false);\n      }\n    }\n  };\n  \n  return children({\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    handleChange,\n    handleBlur,\n    handleSubmit\n  });\n}\n\n// Usage\nfunction LoginForm() {\n  const validationRules = {\n    email: (value) => {\n      if (!value) return 'Email is required';\n      if (!/\\S+@\\S+\\.\\S+/.test(value)) return 'Email is invalid';\n    },\n    password: (value) => {\n      if (!value) return 'Password is required';\n      if (value.length < 6) return 'Password must be at least 6 characters';\n    }\n  };\n  \n  const handleSubmit = async (values) => {\n    console.log('Logging in with:', values);\n    // API call logic\n  };\n  \n  return (\n    <FormProvider \n      initialValues={{ email: '', password: '' }}\n      validationRules={validationRules}\n      onSubmit={handleSubmit}\n    >\n      {({ values, errors, touched, isSubmitting, handleChange, handleBlur, handleSubmit }) => (\n        <form onSubmit={handleSubmit}>\n          <div>\n            <input\n              type=\"email\"\n              placeholder=\"Email\"\n              value={values.email}\n              onChange={(e) => handleChange('email', e.target.value)}\n              onBlur={() => handleBlur('email')}\n            />\n            {touched.email && errors.email && (\n              <span className=\"error\">{errors.email}</span>\n            )}\n          </div>\n          \n          <div>\n            <input\n              type=\"password\"\n              placeholder=\"Password\"\n              value={values.password}\n              onChange={(e) => handleChange('password', e.target.value)}\n              onBlur={() => handleBlur('password')}\n            />\n            {touched.password && errors.password && (\n              <span className=\"error\">{errors.password}</span>\n            )}\n          </div>\n          \n          <button type=\"submit\" disabled={isSubmitting}>\n            {isSubmitting ? 'Logging in...' : 'Login'}\n          </button>\n        </form>\n      )}\n    </FormProvider>\n  );\n}\n```\n\n**Toggle Component with Render Props:**\n```javascript\nfunction Toggle({ initial = false, children }) {\n  const [isOn, setIsOn] = useState(initial);\n  \n  const toggle = () => setIsOn(prev => !prev);\n  const turnOn = () => setIsOn(true);\n  const turnOff = () => setIsOn(false);\n  \n  return children({ isOn, toggle, turnOn, turnOff });\n}\n\n// Multiple use cases with same logic\nfunction App() {\n  return (\n    <div>\n      {/* Modal toggle */}\n      <Toggle>\n        {({ isOn, toggle }) => (\n          <div>\n            <button onClick={toggle}>Show Modal</button>\n            {isOn && (\n              <div className=\"modal\">\n                <div className=\"modal-content\">\n                  <h2>Modal Title</h2>\n                  <button onClick={toggle}>Close</button>\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </Toggle>\n      \n      {/* Theme toggle */}\n      <Toggle initial={false}>\n        {({ isOn: isDark, toggle }) => (\n          <div className={isDark ? 'dark-theme' : 'light-theme'}>\n            <button onClick={toggle}>\n              Switch to {isDark ? 'Light' : 'Dark'} Theme\n            </button>\n            <p>Current theme: {isDark ? 'Dark' : 'Light'}</p>\n          </div>\n        )}\n      </Toggle>\n    </div>\n  );\n}\n```\n\n**Advantages of Render Props:**\n\n**1. Maximum Flexibility:**\n- Complete control over rendering logic\n- Can use same logic with different UI implementations\n- Easy to compose and combine\n\n**2. Clear Separation of Concerns:**\n- Logic provider components focus only on state/behavior\n- Rendering components focus only on presentation\n- Clear interface through function parameters\n\n**3. No Prop Naming Conflicts:**\n- Consumer controls prop names through destructuring\n- No need to worry about prop collision\n\n**4. Better TypeScript Support:**\n```typescript\ninterface DataProviderProps {\n  url: string;\n  children: (state: {\n    data: any;\n    loading: boolean;\n    error: string | null;\n  }) => React.ReactNode;\n}\n```\n\n**Comparison with Other Patterns:**\n\n**Render Props vs HOCs:**\n```javascript\n// HOC - less flexible, wraps component\nconst EnhancedComponent = withData('/api/users')(UserList);\n\n// Render Props - more flexible, explicit\n<DataProvider url=\"/api/users\">\n  {({ data, loading, error }) => (\n    <UserList users={data} loading={loading} error={error} />\n  )}\n</DataProvider>\n```\n\n**Render Props vs Custom Hooks:**\n```javascript\n// Custom Hook - cleaner for simple cases\nfunction UserList() {\n  const { data: users, loading, error } = useApiData('/api/users');\n  return <div>{/* render logic */}</div>;\n}\n\n// Render Props - better for complex composition\n<DataProvider url=\"/api/users\">\n  {({ data: users, loading, error }) => (\n    <ErrorBoundary>\n      <LoadingSpinner show={loading} />\n      <UserList users={users} />\n    </ErrorBoundary>\n  )}\n</DataProvider>\n```\n\n**Best Practices:**\n- Use descriptive names for render prop functions\n- Provide TypeScript interfaces for better DX\n- Consider performance implications (new functions on each render)\n- Use children prop for single render prop scenarios\n- Combine with other patterns when beneficial\n\n**When to Use Render Props:**\n- Complex logic sharing scenarios\n- When you need maximum rendering flexibility\n- Building reusable utility components\n- When HOCs feel too restrictive\n- Component libraries that need customizable rendering",
      "keywords": ["render props", "function as children", "code sharing", "composition", "flexibility", "separation of concerns", "reusability", "HOCs comparison", "custom hooks", "TypeScript"],
      "difficulty": "medium"
    },
    {
      "id": 2026,
      "tag": "react",
      "question": "What is React Suspense and how does lazy loading work?",
      "answer": "React Suspense is a feature that allows components to 'wait' for something before rendering, providing a declarative way to handle loading states. It's commonly used with lazy loading for code splitting.\n\n**Basic Suspense with Lazy Loading:**\n```javascript\nimport React, { Suspense, lazy } from 'react';\n\n// Lazy load components\nconst LazyHome = lazy(() => import('./components/Home'));\nconst LazyAbout = lazy(() => import('./components/About'));\nconst LazyDashboard = lazy(() => import('./components/Dashboard'));\n\nfunction App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <Link to=\"/\">Home</Link>\n          <Link to=\"/about\">About</Link>\n          <Link to=\"/dashboard\">Dashboard</Link>\n        </nav>\n        \n        {/* Suspense provides fallback UI while components load */}\n        <Suspense fallback={<div className=\"loading\">Loading page...</div>}>\n          <Routes>\n            <Route path=\"/\" element={<LazyHome />} />\n            <Route path=\"/about\" element={<LazyAbout />} />\n            <Route path=\"/dashboard\" element={<LazyDashboard />} />\n          </Routes>\n        </Suspense>\n      </div>\n    </Router>\n  );\n}\n```\n\n**Advanced Lazy Loading Patterns:**\n```javascript\n// Lazy load with named exports\nconst LazyComponent = lazy(() => \n  import('./components/MyComponent').then(module => ({\n    default: module.MyComponent // Wrap named export as default\n  }))\n);\n\n// Conditional lazy loading\nconst LazyAdminPanel = lazy(() => {\n  // Could add authentication checks here\n  return import('./components/AdminPanel');\n});\n\n// Lazy loading with dynamic imports\nfunction DynamicComponentLoader({ componentName }) {\n  const [Component, setComponent] = useState(null);\n  \n  useEffect(() => {\n    const loadComponent = async () => {\n      try {\n        const module = await import(`./components/${componentName}`);\n        setComponent(() => module.default);\n      } catch (error) {\n        console.error('Failed to load component:', error);\n      }\n    };\n    \n    loadComponent();\n  }, [componentName]);\n  \n  if (!Component) {\n    return <div>Loading component...</div>;\n  }\n  \n  return <Component />;\n}\n```\n\n**Nested Suspense Boundaries:**\n```javascript\nfunction App() {\n  return (\n    <div className=\"app\">\n      <Header />\n      \n      {/* Top-level Suspense for route-level components */}\n      <Suspense fallback={<PageSkeleton />}>\n        <main>\n          <Routes>\n            <Route path=\"/\" element={<Home />} />\n            <Route path=\"/dashboard\" element={\n              // Nested Suspense for dashboard-specific components\n              <Suspense fallback={<DashboardSkeleton />}>\n                <Dashboard />\n              </Suspense>\n            } />\n          </Routes>\n        </main>\n      </Suspense>\n      \n      <Footer />\n    </div>\n  );\n}\n\nfunction Dashboard() {\n  return (\n    <div className=\"dashboard\">\n      <h1>Dashboard</h1>\n      \n      {/* More nested Suspense for individual widgets */}\n      <div className=\"widgets\">\n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyChart />\n        </Suspense>\n        \n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyAnalytics />\n        </Suspense>\n        \n        <Suspense fallback={<WidgetSkeleton />}>\n          <LazyReports />\n        </Suspense>\n      </div>\n    </div>\n  );\n}\n```\n\n**Error Boundaries with Suspense:**\n```javascript\nclass LazyLoadErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Lazy loading error:', error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Failed to load component</h2>\n          <p>Please try refreshing the page.</p>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try Again\n          </button>\n        </div>\n      );\n    }\n    \n    return this.props.children;\n  }\n}\n\n// Usage with error boundary\nfunction App() {\n  return (\n    <LazyLoadErrorBoundary>\n      <Suspense fallback={<LoadingSpinner />}>\n        <Router>\n          <Routes>\n            <Route path=\"/\" element={<LazyHome />} />\n            <Route path=\"/about\" element={<LazyAbout />} />\n          </Routes>\n        </Router>\n      </Suspense>\n    </LazyLoadErrorBoundary>\n  );\n}\n```\n\n**Custom Suspense Hook:**\n```javascript\nfunction useSuspenseQuery(queryFn, deps = []) {\n  const [promise, setPromise] = useState(null);\n  const [data, setData] = useState(null);\n  \n  useEffect(() => {\n    let cancelled = false;\n    \n    const executeQuery = async () => {\n      const queryPromise = queryFn();\n      setPromise(queryPromise);\n      \n      try {\n        const result = await queryPromise;\n        if (!cancelled) {\n          setData(result);\n          setPromise(null);\n        }\n      } catch (error) {\n        if (!cancelled) {\n          setPromise(null);\n          throw error;\n        }\n      }\n    };\n    \n    executeQuery();\n    \n    return () => {\n      cancelled = true;\n    };\n  }, deps);\n  \n  if (promise) {\n    throw promise; // Suspense will catch this\n  }\n  \n  return data;\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const user = useSuspenseQuery(() => \n    fetch(`/api/users/${userId}`).then(r => r.json()),\n    [userId]\n  );\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <Suspense fallback={<div>Loading user...</div>}>\n      <UserProfile userId=\"123\" />\n    </Suspense>\n  );\n}\n```\n\n**Preloading Components:**\n```javascript\n// Preload components on user interaction\nconst LazyDashboard = lazy(() => import('./Dashboard'));\n\nfunction HomePage() {\n  const handleMouseEnterDashboardLink = () => {\n    // Preload the dashboard component on hover\n    import('./Dashboard');\n  };\n  \n  return (\n    <div>\n      <h1>Welcome to Home</h1>\n      <Link \n        to=\"/dashboard\"\n        onMouseEnter={handleMouseEnterDashboardLink}\n      >\n        Go to Dashboard\n      </Link>\n    </div>\n  );\n}\n\n// Preload based on route prefetch\nfunction useRoutePreload() {\n  useEffect(() => {\n    // Preload likely next routes after initial page load\n    const timer = setTimeout(() => {\n      import('./Dashboard');\n      import('./Profile');\n    }, 2000);\n    \n    return () => clearTimeout(timer);\n  }, []);\n}\n```\n\n**Suspense with Data Fetching (React 18+):**\n```javascript\n// Note: This is experimental and requires special data fetching libraries\nfunction SuspenseDataExample() {\n  return (\n    <ErrorBoundary>\n      <Suspense fallback={<PostSkeleton />}>\n        <PostList />\n        <Suspense fallback={<CommentsSkeleton />}>\n          <CommentsList />\n        </Suspense>\n      </Suspense>\n    </ErrorBoundary>\n  );\n}\n\n// With libraries like SWR or React Query that support Suspense\nfunction PostList() {\n  const { data: posts } = useSWR('/api/posts', fetcher, {\n    suspense: true\n  });\n  \n  return (\n    <div>\n      {posts.map(post => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <p>{post.excerpt}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n**Skeleton Loading Components:**\n```javascript\nfunction PostSkeleton() {\n  return (\n    <div className=\"post-skeleton\">\n      {Array(5).fill().map((_, i) => (\n        <div key={i} className=\"skeleton-item\">\n          <div className=\"skeleton-title\"></div>\n          <div className=\"skeleton-text\"></div>\n          <div className=\"skeleton-text short\"></div>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// CSS for skeleton loading\n/*\n.skeleton-item {\n  margin-bottom: 20px;\n  padding: 15px;\n  border: 1px solid #e1e1e1;\n  border-radius: 4px;\n}\n\n.skeleton-title,\n.skeleton-text {\n  height: 20px;\n  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);\n  background-size: 200% 100%;\n  animation: loading 1.5s infinite;\n  margin-bottom: 10px;\n  border-radius: 4px;\n}\n\n.skeleton-title {\n  height: 24px;\n  width: 60%;\n}\n\n.skeleton-text.short {\n  width: 40%;\n}\n\n@keyframes loading {\n  0% { background-position: 200% 0; }\n  100% { background-position: -200% 0; }\n}\n*/\n```\n\n**Benefits of Suspense and Lazy Loading:**\n- **Code Splitting:** Smaller initial bundle sizes\n- **Better Performance:** Only load code when needed\n- **Improved UX:** Smooth loading states\n- **Declarative Loading:** No need to manually manage loading states\n- **Nested Loading:** Different loading states for different parts of the app\n- **Error Handling:** Works well with error boundaries\n\n**Best Practices:**\n- Use meaningful fallback components (skeletons, spinners)\n- Combine with error boundaries for robust error handling\n- Consider preloading for better user experience\n- Use nested Suspense boundaries for granular loading states\n- Monitor bundle sizes to ensure effective code splitting\n- Test loading states and error scenarios thoroughly",
      "keywords": ["Suspense", "lazy loading", "code splitting", "dynamic imports", "loading states", "error boundaries", "preloading", "skeleton loading", "bundle optimization", "React.lazy"],
      "difficulty": "medium"
    },
    {
      "id": 2027,
      "tag": "react",
      "question": "What are React 18's concurrent features and how do they improve performance?",
      "answer": "React 18 introduces concurrent features that allow React to interrupt, pause, resume, or abandon rendering work to keep the main thread responsive and improve user experience.\n\n**Key Concurrent Features:**\n\n**1. Concurrent Rendering:**\n```javascript\n// React 18: createRoot enables concurrent features\nimport { createRoot } from 'react-dom/client';\n\nconst container = document.getElementById('root');\nconst root = createRoot(container);\nroot.render(<App />);\n\n// Legacy (React 17): Blocking rendering\n// import ReactDOM from 'react-dom';\n// ReactDOM.render(<App />, document.getElementById('root'));\n```\n\n**2. Automatic Batching:**\n```javascript\n// React 18: Automatic batching in all scenarios\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n  \n  function handleClick() {\n    // These updates are automatically batched (single re-render)\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }\n  \n  async function handleAsyncClick() {\n    await fetch('/api/data');\n    // React 18: These are also batched!\n    // React 17: These would cause separate re-renders\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }\n  \n  setTimeout(() => {\n    // React 18: Batched\n    // React 17: Separate re-renders\n    setCount(c => c + 1);\n    setFlag(f => !f);\n  }, 1000);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <p>Flag: {flag.toString()}</p>\n      <button onClick={handleClick}>Sync Update</button>\n      <button onClick={handleAsyncClick}>Async Update</button>\n    </div>\n  );\n}\n\n// Opt out of automatic batching if needed\nimport { flushSync } from 'react-dom';\n\nfunction handleClick() {\n  flushSync(() => {\n    setCount(c => c + 1);\n  });\n  // React will re-render here\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React will re-render again here\n}\n```\n\n**3. useTransition Hook:**\n```javascript\nimport { useState, useTransition, useDeferredValue } from 'react';\n\nfunction SearchApp() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  const [isPending, startTransition] = useTransition();\n  \n  const handleSearch = (value) => {\n    setQuery(value); // Urgent: update input immediately\n    \n    // Non-urgent: mark expensive search as transition\n    startTransition(() => {\n      // This update can be interrupted if user types again\n      const filteredResults = performExpensiveSearch(value);\n      setResults(filteredResults);\n    });\n  };\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => handleSearch(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      \n      {isPending && <div className=\"loading\">Searching...</div>}\n      \n      <SearchResults results={results} />\n    </div>\n  );\n}\n\nfunction performExpensiveSearch(query) {\n  // Simulate expensive operation\n  const results = [];\n  for (let i = 0; i < 10000; i++) {\n    if (mockData[i]?.name.toLowerCase().includes(query.toLowerCase())) {\n      results.push(mockData[i]);\n    }\n  }\n  return results;\n}\n```\n\n**4. useDeferredValue Hook:**\n```javascript\nfunction SearchWithDeferredValue() {\n  const [query, setQuery] = useState('');\n  const deferredQuery = useDeferredValue(query);\n  \n  // Expensive component that depends on deferred value\n  const results = useMemo(() => {\n    return performExpensiveSearch(deferredQuery);\n  }, [deferredQuery]);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      \n      {/* Show loading indicator when values don't match */}\n      {query !== deferredQuery && <div>Updating results...</div>}\n      \n      <SearchResults results={results} />\n    </div>\n  );\n}\n\n// Alternative: Wrap expensive component with useDeferredValue\nfunction DeferredSearchResults({ query }) {\n  const deferredQuery = useDeferredValue(query);\n  const results = useMemo(() => performExpensiveSearch(deferredQuery), [deferredQuery]);\n  \n  return <SearchResults results={results} />;\n}\n```\n\n**5. useId Hook for Accessibility:**\n```javascript\nfunction FormField({ label, type = 'text' }) {\n  // Generates unique, stable IDs for server/client rendering\n  const id = useId();\n  \n  return (\n    <div>\n      <label htmlFor={id}>{label}</label>\n      <input id={id} type={type} />\n    </div>\n  );\n}\n\n// Multiple IDs in same component\nfunction MultiFieldForm() {\n  const baseId = useId();\n  \n  return (\n    <form>\n      <label htmlFor={`${baseId}-name`}>Name</label>\n      <input id={`${baseId}-name`} />\n      \n      <label htmlFor={`${baseId}-email`}>Email</label>\n      <input id={`${baseId}-email`} type=\"email\" />\n      \n      <fieldset>\n        <legend>Preferences</legend>\n        <label htmlFor={`${baseId}-notifications`}>Enable notifications</label>\n        <input id={`${baseId}-notifications`} type=\"checkbox\" />\n      </fieldset>\n    </form>\n  );\n}\n```\n\n**6. Suspense Improvements:**\n```javascript\n// React 18: Improved Suspense with concurrent features\nfunction App() {\n  return (\n    <div>\n      <Header />\n      <Suspense fallback={<MainContentSkeleton />}>\n        <MainContent />\n        <Suspense fallback={<SidebarSkeleton />}>\n          <Sidebar />\n        </Suspense>\n      </Suspense>\n    </div>\n  );\n}\n\n// Suspense with transitions\nfunction TabsWithSuspense() {\n  const [tab, setTab] = useState('posts');\n  const [isPending, startTransition] = useTransition();\n  \n  function selectTab(nextTab) {\n    startTransition(() => {\n      setTab(nextTab);\n    });\n  }\n  \n  return (\n    <div>\n      <div className=\"tabs\">\n        <button \n          className={tab === 'posts' ? 'active' : ''}\n          onClick={() => selectTab('posts')}\n        >\n          Posts {isPending && tab === 'posts' && '(Loading...)'}\n        </button>\n        <button \n          className={tab === 'contact' ? 'active' : ''}\n          onClick={() => selectTab('contact')}\n        >\n          Contact {isPending && tab === 'contact' && '(Loading...)'}\n        </button>\n      </div>\n      \n      <Suspense fallback={<TabContentSkeleton />}>\n        {tab === 'posts' && <PostsTab />}\n        {tab === 'contact' && <ContactTab />}\n      </Suspense>\n    </div>\n  );\n}\n```\n\n**7. startTransition API:**\n```javascript\nimport { startTransition } from 'react';\n\n// Use without hook when you don't need isPending\nfunction updateWithoutHook() {\n  startTransition(() => {\n    // Mark this update as non-urgent\n    setExpensiveState(computeExpensiveValue());\n  });\n}\n\n// Prioritizing user interactions\nfunction TodoApp() {\n  const [todos, setTodos] = useState([]);\n  const [filter, setFilter] = useState('all');\n  \n  const addTodo = (text) => {\n    // Urgent: Adding todo should be immediate\n    setTodos(prev => [...prev, { id: Date.now(), text, completed: false }]);\n  };\n  \n  const updateFilter = (newFilter) => {\n    // Non-urgent: Filtering can be delayed\n    startTransition(() => {\n      setFilter(newFilter);\n    });\n  };\n  \n  return (\n    <div>\n      <AddTodoForm onAdd={addTodo} />\n      <FilterButtons onFilterChange={updateFilter} currentFilter={filter} />\n      <TodoList todos={todos} filter={filter} />\n    </div>\n  );\n}\n```\n\n**Performance Benefits:**\n\n**1. Interruptible Rendering:**\n```javascript\n// React can pause rendering expensive components\n// to handle urgent updates like user input\nfunction ExpensiveList({ items, searchTerm }) {\n  const [isPending, startTransition] = useTransition();\n  const [filteredItems, setFilteredItems] = useState(items);\n  \n  useEffect(() => {\n    startTransition(() => {\n      // This expensive filtering can be interrupted\n      const filtered = items.filter(item => {\n        // Simulate expensive operation\n        for (let i = 0; i < 1000; i++) {\n          Math.random();\n        }\n        return item.name.includes(searchTerm);\n      });\n      setFilteredItems(filtered);\n    });\n  }, [items, searchTerm]);\n  \n  return (\n    <div>\n      {isPending && <div>Filtering...</div>}\n      {filteredItems.map(item => <ExpensiveItem key={item.id} item={item} />)}\n    </div>\n  );\n}\n```\n\n**2. Better CPU Utilization:**\n```javascript\n// React 18 yields control back to browser between work\nfunction LargeTable({ data }) {\n  const deferredData = useDeferredValue(data);\n  \n  return (\n    <table>\n      <tbody>\n        {deferredData.map(row => (\n          <TableRow key={row.id} data={row} />\n        ))}\n      </tbody>\n    </table>\n  );\n}\n\n// Component can update smoothly even with large datasets\nfunction TableRow({ data }) {\n  return (\n    <tr>\n      {Object.entries(data).map(([key, value]) => (\n        <td key={key}>{value}</td>\n      ))}\n    </tr>\n  );\n}\n```\n\n**Migration Considerations:**\n\n**1. Gradual Adoption:**\n```javascript\n// Start with createRoot\nconst root = createRoot(container);\nroot.render(<App />);\n\n// Then gradually add concurrent features\nfunction App() {\n  return (\n    <div>\n      {/* Use useTransition for non-urgent updates */}\n      <SearchWithTransition />\n      \n      {/* Use useDeferredValue for expensive components */}\n      <ExpensiveChart data={deferredData} />\n    </div>\n  );\n}\n```\n\n**2. Testing Concurrent Features:**\n```javascript\n// Test that transitions don't break functionality\nimport { act } from '@testing-library/react';\n\ntest('search with transition', async () => {\n  render(<SearchApp />);\n  \n  const input = screen.getByPlaceholderText('Search...');\n  \n  await act(async () => {\n    fireEvent.change(input, { target: { value: 'test' } });\n    // Wait for transition to complete\n    await waitFor(() => {\n      expect(screen.getByText('Results for: test')).toBeInTheDocument();\n    });\n  });\n});\n```\n\n**Benefits Summary:**\n- **Improved Responsiveness:** UI stays responsive during heavy computations\n- **Better UX:** Smooth interactions even with large datasets\n- **Automatic Optimization:** React handles prioritization automatically\n- **Backward Compatible:** Existing code continues to work\n- **Granular Control:** Choose what updates are urgent vs non-urgent\n- **Better Performance:** More efficient use of CPU and memory",
      "keywords": ["React 18", "concurrent features", "useTransition", "useDeferredValue", "useId", "automatic batching", "startTransition", "concurrent rendering", "Suspense improvements", "performance optimization"],
      "difficulty": "medium"
    },
    {
      "id": 2028,
      "tag": "react",
      "question": "Explain React's reconciliation algorithm and Fiber architecture.",
      "answer": "React's reconciliation is the process of comparing (diffing) the new virtual DOM tree with the previous one to determine what changes need to be made to the actual DOM. Fiber is React's reconciliation engine that enables concurrent features and better performance.\n\n**Pre-Fiber Reconciliation (React 15 and earlier):**\n```javascript\n// The old stack reconciler was synchronous and blocking\nfunction oldReconciliation() {\n  // Problems with the old approach:\n  // 1. Synchronous - couldn't be interrupted\n  // 2. Recursive - could cause stack overflow\n  // 3. All-or-nothing - had to finish entire tree\n  \n  function reconcileChildren(prevChildren, nextChildren) {\n    // Recursive traversal - blocking main thread\n    for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i++) {\n      reconcileChild(prevChildren[i], nextChildren[i]);\n    }\n  }\n}\n```\n\n**Fiber Architecture Concepts:**\n```javascript\n// Fiber is a unit of work that represents a component instance\nconst FiberNode = {\n  // Component information\n  type: 'div',           // Component type\n  key: null,             // React key\n  props: { className: 'container' },\n  \n  // Tree structure\n  parent: null,          // Parent fiber\n  child: null,           // First child fiber\n  sibling: null,         // Next sibling fiber\n  \n  // Work scheduling\n  pendingProps: {},      // Props for this update\n  memoizedProps: {},     // Props from last render\n  updateQueue: null,     // Queue of state updates\n  \n  // Priority and scheduling\n  lanes: 0,              // Priority lanes\n  childLanes: 0,         // Child priority lanes\n  \n  // Effects\n  flags: 0,              // Effect flags (insertion, deletion, update)\n  subtreeFlags: 0,       // Subtree effect flags\n  \n  // State\n  memoizedState: null,   // State from last render\n  \n  // Alternate for double buffering\n  alternate: null        // Previous/next version of this fiber\n};\n```\n\n**Reconciliation Process:**\n```javascript\n// Simplified reconciliation flow\nfunction reconcileChildren(workInProgress, nextChildren) {\n  const currentFirstChild = workInProgress.child;\n  \n  // Different strategies based on children type\n  if (typeof nextChildren === 'string' || typeof nextChildren === 'number') {\n    return reconcileSingleTextNode(workInProgress, currentFirstChild, nextChildren);\n  }\n  \n  if (typeof nextChildren === 'object' && nextChildren !== null) {\n    switch (nextChildren.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n        return reconcileSingleElement(workInProgress, currentFirstChild, nextChildren);\n      case REACT_FRAGMENT_TYPE:\n        return reconcileChildrenArray(workInProgress, currentFirstChild, nextChildren.props.children);\n    }\n    \n    if (Array.isArray(nextChildren)) {\n      return reconcileChildrenArray(workInProgress, currentFirstChild, nextChildren);\n    }\n  }\n  \n  return deleteRemainingChildren(workInProgress, currentFirstChild);\n}\n\n// Key-based reconciliation for arrays\nfunction reconcileChildrenArray(workInProgress, currentFirstChild, newChildren) {\n  let resultingFirstChild = null;\n  let previousNewFiber = null;\n  let oldFiber = currentFirstChild;\n  let newIdx = 0;\n  \n  // First pass: match by index and key\n  for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n    if (oldFiber.index > newIdx) break;\n    \n    const newFiber = updateSlot(workInProgress, oldFiber, newChildren[newIdx]);\n    if (newFiber === null) break;\n    \n    if (shouldTrackSideEffects && oldFiber && newFiber.alternate === null) {\n      deleteChild(workInProgress, oldFiber);\n    }\n    \n    placeChild(newFiber, newIdx);\n    \n    if (previousNewFiber === null) {\n      resultingFirstChild = newFiber;\n    } else {\n      previousNewFiber.sibling = newFiber;\n    }\n    \n    previousNewFiber = newFiber;\n    oldFiber = oldFiber.sibling;\n  }\n  \n  // Handle remaining children...\n  return resultingFirstChild;\n}\n```\n\n**Work Loop and Scheduling:**\n```javascript\n// Fiber work loop - can be interrupted\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  const current = unitOfWork.alternate;\n  \n  // Begin work phase - reconcile this fiber\n  let next = beginWork(current, unitOfWork, renderLanes);\n  \n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  \n  if (next === null) {\n    // Complete work phase - finish this fiber\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n}\n\n// Priority-based scheduling\nconst priorities = {\n  ImmediatePriority: 1,    // User input, critical updates\n  UserBlockingPriority: 2, // User interactions\n  NormalPriority: 3,       // Network requests, timers\n  LowPriority: 4,          // Analytics, logging\n  IdlePriority: 5          // Background tasks\n};\n\nfunction scheduleUpdateOnFiber(fiber, lane, eventTime) {\n  markUpdateLaneFromFiberToRoot(fiber, lane);\n  \n  if (lane === SyncLane) {\n    // Synchronous update\n    performSyncWorkOnRoot(root);\n  } else {\n    // Concurrent update\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n```\n\n**Double Buffering:**\n```javascript\n// React uses two fiber trees for smooth updates\nfunction commitRoot(root) {\n  const finishedWork = root.finishedWork;\n  \n  // Swap the current and work-in-progress trees\n  root.current = finishedWork;\n  \n  // Apply DOM mutations\n  commitMutationEffects(finishedWork);\n  \n  // Run effects (useEffect, useLayoutEffect)\n  commitLayoutEffects(finishedWork);\n}\n\n// Example of how alternate works\nfunction createFiberAlternate(current, pendingProps) {\n  let workInProgress = current.alternate;\n  \n  if (workInProgress === null) {\n    // Create new fiber\n    workInProgress = createFiber(current.tag, pendingProps, current.key);\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n    \n    // Link alternates\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    // Reuse existing alternate\n    workInProgress.pendingProps = pendingProps;\n    workInProgress.flags = NoFlags;\n    workInProgress.subtreeFlags = NoFlags;\n  }\n  \n  return workInProgress;\n}\n```\n\n**Component Lifecycle with Fiber:**\n```javascript\n// How Fiber handles component updates\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps) {\n  const context = prepareToReadContext(workInProgress);\n  \n  let nextChildren;\n  \n  // Render phase - call the component function\n  prepareToUseHooks(current, workInProgress);\n  nextChildren = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    context,\n    renderLanes\n  );\n  finishHooks();\n  \n  // Reconcile children\n  reconcileChildren(current, workInProgress, nextChildren);\n  \n  return workInProgress.child;\n}\n\n// Hook processing in Fiber\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n  \n  // Reset hooks state\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  \n  // Set current dispatcher (different for mount vs update)\n  ReactCurrentDispatcher.current = \n    current === null || current.memoizedState === null\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  \n  // Call the component function\n  let children = Component(props, secondArg);\n  \n  // Handle re-renders due to state updates during render\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    let numberOfReRenders = 0;\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      numberOfReRenders++;\n      \n      // Reset and re-render\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n      \n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass && numberOfReRenders < RE_RENDER_LIMIT);\n  }\n  \n  return children;\n}\n```\n\n**Time Slicing Implementation:**\n```javascript\n// Fiber enables time slicing for smooth user experience\nconst ENOUGH_TIME = 5; // 5ms time slice\n\nfunction shouldYield() {\n  const timeElapsed = getCurrentTime() - startTime;\n  if (timeElapsed < ENOUGH_TIME) {\n    return false;\n  }\n  \n  // Check if there's a higher priority task waiting\n  if (needsPaint || scheduling.isInputPending()) {\n    return true;\n  }\n  \n  return timeElapsed >= ENOUGH_TIME;\n}\n\n// Resumable work\nfunction workLoopConcurrent() {\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n  \n  if (workInProgress !== null) {\n    // More work to do, yield to browser\n    return RootInProgress;\n  } else {\n    // Work completed\n    return RootCompleted;\n  }\n}\n```\n\n**Error Boundaries with Fiber:**\n```javascript\nfunction handleError(root, thrownValue) {\n  let workInProgress = root.current;\n  \n  // Walk up the fiber tree to find error boundary\n  do {\n    switch (workInProgress.tag) {\n      case ClassComponent:\n        const instance = workInProgress.stateNode;\n        if (typeof instance.componentDidCatch === 'function' ||\n            typeof instance.getDerivedStateFromError === 'function') {\n          // Found error boundary\n          const errorInfo = createCapturedValue(thrownValue, workInProgress);\n          const update = createUpdate(NoLane, eventTime);\n          update.payload = { element: null };\n          update.callback = () => {\n            logCapturedError(root, errorInfo);\n            instance.componentDidCatch(thrownValue, errorInfo);\n          };\n          \n          enqueueUpdate(workInProgress, update);\n          scheduleUpdateOnFiber(workInProgress, SyncLane, eventTime);\n          return;\n        }\n        break;\n    }\n    \n    workInProgress = workInProgress.parent;\n  } while (workInProgress !== null);\n  \n  // No error boundary found, crash the app\n  throw thrownValue;\n}\n```\n\n**Benefits of Fiber:**\n- **Interruptible:** Can pause and resume work\n- **Prioritization:** Handle urgent updates first\n- **Concurrent:** Multiple updates can be prepared simultaneously\n- **Incremental:** Work is broken into small units\n- **Better Error Handling:** More precise error boundaries\n- **Time Slicing:** Maintains 60fps by yielding to browser\n- **Smoother Animations:** Less jank during heavy operations\n- **Better Developer Experience:** React DevTools can show work-in-progress state\n\n**Performance Implications:**\n```javascript\n// Fiber enables these performance optimizations:\n\n// 1. Avoid blocking the main thread\nfunction ExpensiveComponent({ items }) {\n  // This won't block user input anymore\n  const processedItems = items.map(item => expensiveProcessing(item));\n  return <div>{processedItems}</div>;\n}\n\n// 2. Prioritize user interactions\nfunction SearchComponent() {\n  const [query, setQuery] = useState('');\n  const [results, setResults] = useState([]);\n  \n  const handleInputChange = (value) => {\n    setQuery(value); // High priority\n    \n    startTransition(() => {\n      setResults(searchExpensiveData(value)); // Low priority\n    });\n  };\n  \n  return (\n    <div>\n      <input onChange={(e) => handleInputChange(e.target.value)} />\n      <SearchResults results={results} />\n    </div>\n  );\n}\n```\n\nFiber represents a fundamental architectural improvement that enables React's modern concurrent features while maintaining backward compatibility and improving overall performance.",
      "keywords": ["reconciliation", "Fiber architecture", "virtual DOM", "diffing algorithm", "work loop", "time slicing", "priority scheduling", "double buffering", "interruptible rendering", "concurrent features"],
      "difficulty": "hard"
    },
    {
      "id": 2029,
      "tag": "react",
      "question": "What are advanced performance optimization techniques in React?",
      "answer": "Advanced React performance optimization involves multiple strategies including code splitting, memoization, virtual scrolling, tree shaking, and architectural patterns that minimize unnecessary work.\n\n**1. Code Splitting and Bundle Optimization:**\n```javascript\n// Route-based code splitting\nimport { lazy, Suspense } from 'react';\n\nconst Dashboard = lazy(() => import('./Dashboard'));\nconst Profile = lazy(() => import('./Profile'));\nconst Settings = lazy(() => import('./Settings'));\n\n// Component-based code splitting with preloading\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nfunction App() {\n  const [showChart, setShowChart] = useState(false);\n  \n  // Preload component on hover\n  const preloadChart = () => {\n    import('./HeavyChart');\n  };\n  \n  return (\n    <div>\n      <button \n        onMouseEnter={preloadChart}\n        onClick={() => setShowChart(true)}\n      >\n        Show Chart\n      </button>\n      \n      {showChart && (\n        <Suspense fallback={<ChartSkeleton />}>\n          <HeavyChart />\n        </Suspense>\n      )}\n    </div>\n  );\n}\n\n// Dynamic imports with error handling\nconst loadComponentWithRetry = (componentImport, retries = 3) => {\n  return new Promise((resolve, reject) => {\n    componentImport()\n      .then(resolve)\n      .catch((error) => {\n        if (retries > 0) {\n          setTimeout(() => {\n            loadComponentWithRetry(componentImport, retries - 1)\n              .then(resolve)\n              .catch(reject);\n          }, 1000);\n        } else {\n          reject(error);\n        }\n      });\n  });\n};\n\nconst RetryableComponent = lazy(() => \n  loadComponentWithRetry(() => import('./UnreliableComponent'))\n);\n```\n\n**2. Advanced Memoization Patterns:**\n```javascript\n// Memoization with complex dependency tracking\nfunction useStableMemo(factory, deps) {\n  const memoRef = useRef();\n  \n  if (!memoRef.current || !depsEqual(memoRef.current.deps, deps)) {\n    memoRef.current = {\n      value: factory(),\n      deps: deps.slice()\n    };\n  }\n  \n  return memoRef.current.value;\n}\n\nfunction depsEqual(prevDeps, nextDeps) {\n  if (prevDeps.length !== nextDeps.length) return false;\n  return prevDeps.every((dep, i) => Object.is(dep, nextDeps[i]));\n}\n\n// Selective memoization based on props\nconst ExpensiveComponent = React.memo(({ data, config, onAction }) => {\n  const processedData = useMemo(() => {\n    return data.map(item => expensiveTransformation(item, config));\n  }, [data, config.processMode, config.filters]); // Only specific config props\n  \n  const memoizedAction = useCallback((id) => {\n    onAction(id, config.actionType);\n  }, [onAction, config.actionType]);\n  \n  return (\n    <div>\n      {processedData.map(item => (\n        <ItemComponent \n          key={item.id} \n          item={item} \n          onAction={memoizedAction} \n        />\n      ))}\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Custom equality check\n  return (\n    prevProps.data === nextProps.data &&\n    prevProps.config.processMode === nextProps.config.processMode &&\n    prevProps.config.filters === nextProps.config.filters &&\n    prevProps.onAction === nextProps.onAction\n  );\n});\n```\n\n**3. Virtual Scrolling Implementation:**\n```javascript\n// Custom virtual scrolling hook\nfunction useVirtualScrolling({ items, itemHeight, containerHeight, overscan = 5 }) {\n  const [scrollTop, setScrollTop] = useState(0);\n  \n  const totalHeight = items.length * itemHeight;\n  const visibleStart = Math.floor(scrollTop / itemHeight);\n  const visibleEnd = Math.min(\n    visibleStart + Math.ceil(containerHeight / itemHeight),\n    items.length - 1\n  );\n  \n  const start = Math.max(0, visibleStart - overscan);\n  const end = Math.min(items.length - 1, visibleEnd + overscan);\n  \n  const visibleItems = items.slice(start, end + 1).map((item, index) => ({\n    ...item,\n    index: start + index\n  }));\n  \n  const offsetY = start * itemHeight;\n  \n  return {\n    visibleItems,\n    totalHeight,\n    offsetY,\n    onScroll: (e) => setScrollTop(e.target.scrollTop)\n  };\n}\n\n// Virtual list component\nfunction VirtualList({ items, itemHeight = 50, height = 400 }) {\n  const { visibleItems, totalHeight, offsetY, onScroll } = useVirtualScrolling({\n    items,\n    itemHeight,\n    containerHeight: height\n  });\n  \n  return (\n    <div \n      style={{ height, overflow: 'auto' }} \n      onScroll={onScroll}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        <div style={{ transform: `translateY(${offsetY}px)` }}>\n          {visibleItems.map(item => (\n            <div \n              key={item.id} \n              style={{ height: itemHeight }}\n            >\n              <ItemComponent item={item} />\n            </div>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n}\n```\n\n**4. State Management Optimization:**\n```javascript\n// Normalized state shape for better performance\nconst initialState = {\n  users: {\n    byId: {},\n    allIds: []\n  },\n  posts: {\n    byId: {},\n    allIds: []\n  },\n  ui: {\n    selectedUserId: null,\n    loading: false\n  }\n};\n\n// Selector memoization\nconst createMemoizedSelector = (selector) => {\n  let lastArgs = [];\n  let lastResult;\n  \n  return (...args) => {\n    if (!shallowEqual(args, lastArgs)) {\n      lastResult = selector(...args);\n      lastArgs = args;\n    }\n    return lastResult;\n  };\n};\n\nconst getUserPosts = createMemoizedSelector(\n  (state, userId) => {\n    return state.posts.allIds\n      .map(id => state.posts.byId[id])\n      .filter(post => post.authorId === userId);\n  }\n);\n\n// Context splitting to avoid unnecessary re-renders\nconst UserStateContext = createContext();\nconst UserDispatchContext = createContext();\n\nfunction UserProvider({ children }) {\n  const [state, dispatch] = useReducer(userReducer, initialUserState);\n  \n  // Memoize contexts to prevent unnecessary re-renders\n  const stateValue = useMemo(() => state, [state]);\n  const dispatchValue = useMemo(() => dispatch, [dispatch]);\n  \n  return (\n    <UserStateContext.Provider value={stateValue}>\n      <UserDispatchContext.Provider value={dispatchValue}>\n        {children}\n      </UserDispatchContext.Provider>\n    </UserStateContext.Provider>\n  );\n}\n```\n\n**5. Render Optimization Patterns:**\n```javascript\n// Render props with memoization\nfunction DataProvider({ children, url }) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  \n  const memoizedChildren = useMemo(() => {\n    return children({ data, loading });\n  }, [children, data, loading]);\n  \n  return memoizedChildren;\n}\n\n// Compound component pattern for better performance\nfunction Table({ children, data }) {\n  const tableContext = useMemo(() => ({ data }), [data]);\n  \n  return (\n    <TableContext.Provider value={tableContext}>\n      <table>{children}</table>\n    </TableContext.Provider>\n  );\n}\n\nconst TableHeader = React.memo(({ children }) => {\n  return <thead><tr>{children}</tr></thead>;\n});\n\nconst TableRow = React.memo(({ index }) => {\n  const { data } = useContext(TableContext);\n  const rowData = data[index];\n  \n  return (\n    <tr>\n      {Object.values(rowData).map((value, i) => (\n        <td key={i}>{value}</td>\n      ))}\n    </tr>\n  );\n});\n\n// Usage\n<Table data={tableData}>\n  <TableHeader>\n    <th>Name</th>\n    <th>Email</th>\n    <th>Role</th>\n  </TableHeader>\n  <tbody>\n    {tableData.map((_, index) => (\n      <TableRow key={index} index={index} />\n    ))}\n  </tbody>\n</Table>\n```\n\n**6. Web Workers for Heavy Computations:**\n```javascript\n// Web Worker for CPU-intensive tasks\n// worker.js\nself.onmessage = function(e) {\n  const { type, data } = e.data;\n  \n  switch (type) {\n    case 'PROCESS_DATA':\n      const result = processLargeDataset(data);\n      self.postMessage({ type: 'DATA_PROCESSED', result });\n      break;\n    case 'SORT_DATA':\n      const sorted = expensiveSort(data);\n      self.postMessage({ type: 'DATA_SORTED', result: sorted });\n      break;\n  }\n};\n\n// Hook to use web workers\nfunction useWebWorker(workerScript) {\n  const workerRef = useRef();\n  const [isLoading, setIsLoading] = useState(false);\n  \n  useEffect(() => {\n    workerRef.current = new Worker(workerScript);\n    \n    workerRef.current.onmessage = (e) => {\n      setIsLoading(false);\n    };\n    \n    return () => {\n      workerRef.current.terminate();\n    };\n  }, [workerScript]);\n  \n  const postMessage = useCallback((message) => {\n    setIsLoading(true);\n    workerRef.current.postMessage(message);\n  }, []);\n  \n  return { postMessage, isLoading };\n}\n\n// Component using web worker\nfunction DataProcessor({ data }) {\n  const [processedData, setProcessedData] = useState(null);\n  const { postMessage, isLoading } = useWebWorker('./worker.js');\n  \n  const processData = useCallback(() => {\n    postMessage({ type: 'PROCESS_DATA', data });\n  }, [data, postMessage]);\n  \n  useEffect(() => {\n    const handleMessage = (e) => {\n      if (e.data.type === 'DATA_PROCESSED') {\n        setProcessedData(e.data.result);\n      }\n    };\n    \n    if ('Worker' in window) {\n      const worker = new Worker('./worker.js');\n      worker.onmessage = handleMessage;\n      return () => worker.terminate();\n    }\n  }, []);\n  \n  return (\n    <div>\n      <button onClick={processData} disabled={isLoading}>\n        {isLoading ? 'Processing...' : 'Process Data'}\n      </button>\n      {processedData && <DataVisualization data={processedData} />}\n    </div>\n  );\n}\n```\n\n**7. Memory Leak Prevention:**\n```javascript\n// Cleanup patterns to prevent memory leaks\nfunction useCleanupEffect(effect, deps) {\n  useEffect(() => {\n    const cleanup = effect();\n    \n    return () => {\n      if (typeof cleanup === 'function') {\n        cleanup();\n      }\n    };\n  }, deps);\n}\n\n// Automatic cleanup for subscriptions\nfunction useSubscription(subscribeFn) {\n  const [data, setData] = useState(null);\n  const subscriptionRef = useRef();\n  \n  useEffect(() => {\n    subscriptionRef.current = subscribeFn((newData) => {\n      setData(newData);\n    });\n    \n    return () => {\n      if (subscriptionRef.current && subscriptionRef.current.unsubscribe) {\n        subscriptionRef.current.unsubscribe();\n      }\n    };\n  }, [subscribeFn]);\n  \n  return data;\n}\n\n// Memory-efficient event listeners\nfunction useEventListener(event, handler, element = window) {\n  const savedHandler = useRef();\n  \n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n  \n  useEffect(() => {\n    const eventListener = (event) => savedHandler.current(event);\n    element.addEventListener(event, eventListener);\n    \n    return () => {\n      element.removeEventListener(event, eventListener);\n    };\n  }, [event, element]);\n}\n```\n\n**8. Bundle Analysis and Tree Shaking:**\n```javascript\n// Analyze bundle with webpack-bundle-analyzer\n// package.json\n{\n  \"scripts\": {\n    \"analyze\": \"npm run build && npx webpack-bundle-analyzer build/static/js/*.js\"\n  }\n}\n\n// Tree shaking optimization\n// Instead of importing entire library\n// import _ from 'lodash'; // Bad - imports entire library\n\n// Import only what you need\nimport debounce from 'lodash/debounce'; // Good - only imports debounce\nimport { debounce } from 'lodash'; // Still good with proper tree-shaking\n\n// Use ES modules for better tree shaking\nexport { default as Button } from './Button';\nexport { default as Modal } from './Modal';\nexport { default as Form } from './Form';\n\n// Dynamic imports for unused code paths\nif (process.env.NODE_ENV === 'development') {\n  import('./DevTools').then(({ DevTools }) => {\n    // Only load dev tools in development\n  });\n}\n```\n\n**Performance Monitoring:**\n```javascript\n// Performance monitoring hooks\nfunction usePerformanceMonitor(componentName) {\n  useEffect(() => {\n    const startTime = performance.now();\n    \n    return () => {\n      const endTime = performance.now();\n      console.log(`${componentName} render time: ${endTime - startTime}ms`);\n    };\n  });\n}\n\n// React DevTools Profiler API\nfunction ProfiledComponent({ children }) {\n  const onRenderCallback = (id, phase, actualDuration) => {\n    console.log('Render:', { id, phase, actualDuration });\n  };\n  \n  return (\n    <Profiler id=\"ProfiledComponent\" onRender={onRenderCallback}>\n      {children}\n    </Profiler>\n  );\n}\n```\n\n**Key Optimization Strategies:**\n- **Measure First:** Use React DevTools Profiler before optimizing\n- **Minimize Bundle Size:** Code splitting, tree shaking, dynamic imports\n- **Reduce Re-renders:** Memoization, stable references, context splitting\n- **Optimize Heavy Operations:** Web workers, virtual scrolling, debouncing\n- **Memory Management:** Proper cleanup, avoid memory leaks\n- **Network Optimization:** Prefetching, caching, compression\n- **State Shape:** Normalized data, efficient selectors\n- **Component Architecture:** Smart composition, render props, compound components",
      "keywords": ["performance optimization", "code splitting", "memoization", "virtual scrolling", "web workers", "tree shaking", "bundle analysis", "memory leaks", "state normalization", "React Profiler"],
      "difficulty": "hard"
    },
    {
      "id": 2030,
      "tag": "react",
      "question": "Explain the useCallback hook and how it differs from useMemo. When should you use each?",
      "answer": "useCallback memoizes functions to prevent unnecessary re-creations, while useMemo memoizes computed values. Both help optimize performance by preventing unnecessary work when dependencies haven't changed.\n\n**useCallback vs useMemo Comparison:**\n```javascript\n// useCallback - memoizes functions\nconst memoizedCallback = useCallback(() => {\n  doSomething(a, b);\n}, [a, b]);\n\n// useMemo - memoizes values\nconst memoizedValue = useMemo(() => {\n  return expensiveCalculation(a, b);\n}, [a, b]);\n\n// useCallback is equivalent to:\nconst memoizedCallback = useMemo(() => {\n  return () => doSomething(a, b);\n}, [a, b]);\n```\n\n**useCallback Use Cases:**\n```javascript\n// 1. Preventing child re-renders\nfunction Parent({ items }) {\n  const [filter, setFilter] = useState('');\n  \n  // ❌ Without useCallback - new function on every render\n  const handleItemClick = (id) => {\n    console.log('Clicked item:', id);\n  };\n  \n  // ✅ With useCallback - stable function reference\n  const handleItemClick = useCallback((id) => {\n    console.log('Clicked item:', id);\n    // If this function needs to access state, include it in dependencies\n  }, []); // Empty dependencies since function doesn't use any state\n  \n  const handleItemDelete = useCallback((id) => {\n    setItems(prev => prev.filter(item => item.id !== id));\n  }, []); // setItems is stable, so no dependencies needed\n  \n  return (\n    <div>\n      <input \n        value={filter} \n        onChange={(e) => setFilter(e.target.value)}\n        placeholder=\"Filter items...\"\n      />\n      {/* MemoizedChild only re-renders when handleItemClick changes */}\n      <MemoizedChild \n        items={items} \n        onItemClick={handleItemClick}\n        onItemDelete={handleItemDelete}\n      />\n    </div>\n  );\n}\n\nconst MemoizedChild = React.memo(({ items, onItemClick, onItemDelete }) => {\n  console.log('Child rendered'); // This won't log unnecessarily\n  \n  return (\n    <div>\n      {items.map(item => (\n        <div key={item.id}>\n          <span onClick={() => onItemClick(item.id)}>{item.name}</span>\n          <button onClick={() => onItemDelete(item.id)}>Delete</button>\n        </div>\n      ))}\n    </div>\n  );\n});\n```\n\n**Advanced useCallback Patterns:**\n```javascript\n// 2. Event handlers with dependencies\nfunction SearchComponent({ onSearchResults }) {\n  const [query, setQuery] = useState('');\n  const [loading, setLoading] = useState(false);\n  \n  // Function depends on query and onSearchResults\n  const handleSearch = useCallback(async () => {\n    if (!query.trim()) return;\n    \n    setLoading(true);\n    try {\n      const results = await searchAPI(query);\n      onSearchResults(results);\n    } catch (error) {\n      console.error('Search failed:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [query, onSearchResults]); // Include all dependencies\n  \n  // Debounced search\n  const debouncedSearch = useCallback(\n    debounce(handleSearch, 300),\n    [handleSearch]\n  );\n  \n  useEffect(() => {\n    debouncedSearch();\n    return () => debouncedSearch.cancel();\n  }, [debouncedSearch]);\n  \n  return (\n    <div>\n      <input\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n        placeholder=\"Search...\"\n      />\n      {loading && <div>Searching...</div>}\n    </div>\n  );\n}\n\n// 3. Custom hooks with useCallback\nfunction useAPI(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(url);\n      if (!response.ok) throw new Error('Network response was not ok');\n      const result = await response.json();\n      setData(result);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  }, [url]);\n  \n  const refetch = useCallback(() => {\n    fetchData();\n  }, [fetchData]);\n  \n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n  \n  return { data, loading, error, refetch };\n}\n```\n\n**useMemo Use Cases:**\n```javascript\n// 1. Expensive calculations\nfunction ExpensiveCalculation({ numbers, multiplier }) {\n  // ❌ Without useMemo - recalculates on every render\n  const expensiveResult = numbers.reduce((acc, num) => {\n    // Simulate expensive operation\n    for (let i = 0; i < 1000000; i++) {\n      // Heavy computation\n    }\n    return acc + (num * multiplier);\n  }, 0);\n  \n  // ✅ With useMemo - only recalculates when dependencies change\n  const expensiveResult = useMemo(() => {\n    console.log('Calculating expensive result...');\n    return numbers.reduce((acc, num) => {\n      // Simulate expensive operation\n      for (let i = 0; i < 1000000; i++) {\n        // Heavy computation\n      }\n      return acc + (num * multiplier);\n    }, 0);\n  }, [numbers, multiplier]);\n  \n  return <div>Result: {expensiveResult}</div>;\n}\n\n// 2. Object/Array dependencies to prevent re-renders\nfunction UserProfile({ user, settings }) {\n  // ❌ New object created on every render\n  const userConfig = {\n    theme: settings.theme,\n    language: settings.language,\n    notifications: settings.notifications\n  };\n  \n  // ✅ Memoized object - only new when settings change\n  const userConfig = useMemo(() => ({\n    theme: settings.theme,\n    language: settings.language,\n    notifications: settings.notifications\n  }), [settings.theme, settings.language, settings.notifications]);\n  \n  // Complex filtering and sorting\n  const processedData = useMemo(() => {\n    return user.posts\n      .filter(post => post.published)\n      .sort((a, b) => new Date(b.date) - new Date(a.date))\n      .slice(0, 10);\n  }, [user.posts]);\n  \n  return (\n    <div>\n      <UserSettings config={userConfig} />\n      <RecentPosts posts={processedData} />\n    </div>\n  );\n}\n```\n\n**Common Pitfalls and Solutions:**\n```javascript\n// ❌ Pitfall 1: Missing dependencies\nfunction BuggyComponent({ userId, onUserUpdate }) {\n  const [userData, setUserData] = useState(null);\n  \n  const fetchUser = useCallback(async () => {\n    const user = await api.getUser(userId);\n    setUserData(user);\n    onUserUpdate(user); // Missing from dependencies!\n  }, [userId]); // Should include onUserUpdate\n  \n  // ✅ Correct version\n  const fetchUser = useCallback(async () => {\n    const user = await api.getUser(userId);\n    setUserData(user);\n    onUserUpdate(user);\n  }, [userId, onUserUpdate]);\n}\n\n// ❌ Pitfall 2: Over-memoization\nfunction OverMemoized() {\n  const [count, setCount] = useState(0);\n  \n  // Unnecessary - simple primitive operation\n  const incrementCount = useCallback(() => {\n    setCount(c => c + 1);\n  }, []); // No benefit since setState is stable\n  \n  // Unnecessary - simple calculation\n  const doubleCount = useMemo(() => count * 2, [count]);\n  \n  // ✅ Better - just use regular functions for simple operations\n  const incrementCount = () => setCount(c => c + 1);\n  const doubleCount = count * 2;\n}\n\n// ❌ Pitfall 3: Inline object/array dependencies\nfunction BadDependencies({ config }) {\n  const processData = useCallback(() => {\n    // Process data based on config\n  }, [config.options]); // If config.options is always a new object, this will always change\n  \n  // ✅ Better - destructure specific values\n  const processData = useCallback(() => {\n    // Process data\n  }, [config.options.sortBy, config.options.filterBy]);\n  \n  // Or memoize the config object\n  const stableConfig = useMemo(() => config.options, [\n    config.options.sortBy,\n    config.options.filterBy\n  ]);\n  \n  const processData = useCallback(() => {\n    // Process data\n  }, [stableConfig]);\n}\n```\n\n**Performance Testing:**\n```javascript\n// Test component to verify optimization\nfunction PerformanceTest() {\n  const [count, setCount] = useState(0);\n  const [items] = useState(Array.from({ length: 1000 }, (_, i) => ({ id: i, name: `Item ${i}` })));\n  \n  // Memoized callback\n  const handleItemClick = useCallback((id) => {\n    console.log('Clicked:', id);\n  }, []);\n  \n  // Memoized expensive calculation\n  const expensiveSum = useMemo(() => {\n    console.log('Calculating sum...');\n    return items.reduce((sum, item) => sum + item.id, 0);\n  }, [items]);\n  \n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>Count: {count}</button>\n      <div>Expensive Sum: {expensiveSum}</div>\n      <MemoizedList items={items} onItemClick={handleItemClick} />\n    </div>\n  );\n}\n\nconst MemoizedList = React.memo(({ items, onItemClick }) => {\n  console.log('List rendered'); // Should only log when items or onItemClick change\n  return (\n    <ul>\n      {items.slice(0, 10).map(item => (\n        <li key={item.id} onClick={() => onItemClick(item.id)}>\n          {item.name}\n        </li>\n      ))}\n    </ul>\n  );\n});\n```\n\n**When to Use Each:**\n\n**useCallback:**\n- Passing callbacks to memoized child components\n- Event handlers that are dependencies of other hooks\n- Functions passed to custom hooks\n- Debounced or throttled functions\n- Functions used in useEffect dependencies\n\n**useMemo:**\n- Expensive calculations or transformations\n- Creating objects/arrays to prevent referential inequality\n- Filtering, sorting, or mapping large datasets\n- Complex derived state\n- Breaking dependency chains in effects\n\n**Don't Use When:**\n- Simple operations (primitive calculations, basic functions)\n- Values that change on every render anyway\n- Dependencies change frequently\n- The computation/function creation cost is negligible\n\n**Best Practices:**\n- Always include all dependencies in the dependency array\n- Use ESLint plugin react-hooks/exhaustive-deps\n- Measure performance impact before and after optimization\n- Profile with React DevTools to identify actual bottlenecks\n- Consider if React.memo is needed for the optimization to be effective",
      "keywords": ["useCallback", "useMemo", "memoization", "performance optimization", "dependency array", "React.memo", "referential equality", "expensive calculations", "callback functions"],
      "difficulty": "medium"
    },
    {
      "id": 2031,
      "tag": "react",
      "question": "What are custom hooks and how do you create reusable logic with them? Provide advanced examples.",
      "answer": "Custom hooks are JavaScript functions that start with 'use' and allow you to extract component logic into reusable functions. They enable sharing stateful logic between components while keeping each component's state separate.\n\n**Basic Custom Hook Structure:**\n```javascript\n// Custom hook follows the 'use' naming convention\nfunction useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n  \n  const increment = useCallback(() => setCount(c => c + 1), []);\n  const decrement = useCallback(() => setCount(c => c - 1), []);\n  const reset = useCallback(() => setCount(initialValue), [initialValue]);\n  \n  return {\n    count,\n    increment,\n    decrement,\n    reset\n  };\n}\n\n// Usage in components\nfunction CounterA() {\n  const { count, increment, decrement, reset } = useCounter(0);\n  \n  return (\n    <div>\n      <p>Counter A: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n\nfunction CounterB() {\n  const { count, increment, decrement, reset } = useCounter(10);\n  \n  return (\n    <div>\n      <p>Counter B: {count}</p>\n      <button onClick={increment}>+</button>\n      <button onClick={decrement}>-</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n```\n\n**Advanced Custom Hooks:**\n\n**1. Data Fetching Hook:**\n```javascript\nfunction useAPI(url, options = {}) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n  \n  const { autoFetch = true, dependencies = [] } = options;\n  \n  const fetchData = useCallback(async (customUrl) => {\n    const targetUrl = customUrl || url;\n    setLoading(true);\n    setError(null);\n    \n    try {\n      const response = await fetch(targetUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n          ...options.headers\n        },\n        ...options.fetchOptions\n      });\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      setData(result);\n      return result;\n    } catch (err) {\n      setError(err.message);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [url, options.headers, options.fetchOptions]);\n  \n  const refetch = useCallback(() => fetchData(), [fetchData]);\n  \n  const mutate = useCallback((newData) => {\n    setData(newData);\n  }, []);\n  \n  useEffect(() => {\n    if (autoFetch && url) {\n      fetchData();\n    }\n  }, [fetchData, autoFetch, ...dependencies]);\n  \n  return {\n    data,\n    loading,\n    error,\n    refetch,\n    mutate,\n    fetchData\n  };\n}\n\n// Usage\nfunction UserProfile({ userId }) {\n  const { \n    data: user, \n    loading, \n    error, \n    refetch \n  } = useAPI(`/api/users/${userId}`, {\n    dependencies: [userId]\n  });\n  \n  const {\n    data: posts,\n    loading: postsLoading\n  } = useAPI(user ? `/api/users/${userId}/posts` : null, {\n    autoFetch: !!user,\n    dependencies: [user]\n  });\n  \n  if (loading) return <div>Loading user...</div>;\n  if (error) return <div>Error: {error}</div>;\n  \n  return (\n    <div>\n      <h1>{user?.name}</h1>\n      <button onClick={refetch}>Refresh</button>\n      {postsLoading ? (\n        <div>Loading posts...</div>\n      ) : (\n        <PostsList posts={posts} />\n      )}\n    </div>\n  );\n}\n```\n\n**2. Local Storage Hook:**\n```javascript\nfunction useLocalStorage(key, initialValue) {\n  // Get initial value from localStorage or use provided initial value\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading localStorage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n  \n  // Return a wrapped version of useState's setter function\n  const setValue = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have the same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting localStorage key \"${key}\":`, error);\n    }\n  }, [key, storedValue]);\n  \n  // Remove item from localStorage\n  const removeValue = useCallback(() => {\n    try {\n      window.localStorage.removeItem(key);\n      setStoredValue(initialValue);\n    } catch (error) {\n      console.error(`Error removing localStorage key \"${key}\":`, error);\n    }\n  }, [key, initialValue]);\n  \n  return [storedValue, setValue, removeValue];\n}\n\n// Usage\nfunction UserPreferences() {\n  const [theme, setTheme, removeTheme] = useLocalStorage('theme', 'light');\n  const [language, setLanguage] = useLocalStorage('language', 'en');\n  const [notifications, setNotifications] = useLocalStorage('notifications', true);\n  \n  return (\n    <div>\n      <div>\n        Theme: \n        <select value={theme} onChange={(e) => setTheme(e.target.value)}>\n          <option value=\"light\">Light</option>\n          <option value=\"dark\">Dark</option>\n        </select>\n        <button onClick={removeTheme}>Reset Theme</button>\n      </div>\n      \n      <div>\n        Language:\n        <select value={language} onChange={(e) => setLanguage(e.target.value)}>\n          <option value=\"en\">English</option>\n          <option value=\"es\">Spanish</option>\n          <option value=\"fr\">French</option>\n        </select>\n      </div>\n      \n      <div>\n        <label>\n          <input\n            type=\"checkbox\"\n            checked={notifications}\n            onChange={(e) => setNotifications(e.target.checked)}\n          />\n          Enable Notifications\n        </label>\n      </div>\n    </div>\n  );\n}\n```\n\n**3. Form Validation Hook:**\n```javascript\nfunction useFormValidation(initialValues, validationRules) {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n  const [touched, setTouched] = useState({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n  \n  // Validate a single field\n  const validateField = useCallback((name, value) => {\n    const rules = validationRules[name];\n    if (!rules) return null;\n    \n    for (const rule of rules) {\n      const error = rule(value, values);\n      if (error) return error;\n    }\n    return null;\n  }, [validationRules, values]);\n  \n  // Validate all fields\n  const validateAll = useCallback(() => {\n    const newErrors = {};\n    \n    Object.keys(validationRules).forEach(name => {\n      const error = validateField(name, values[name]);\n      if (error) {\n        newErrors[name] = error;\n      }\n    });\n    \n    setErrors(newErrors);\n    return Object.keys(newErrors).length === 0;\n  }, [validationRules, values, validateField]);\n  \n  // Handle field change\n  const handleChange = useCallback((name, value) => {\n    setValues(prev => ({ ...prev, [name]: value }));\n    \n    // Clear error when user starts typing\n    if (errors[name]) {\n      setErrors(prev => ({ ...prev, [name]: null }));\n    }\n  }, [errors]);\n  \n  // Handle field blur\n  const handleBlur = useCallback((name) => {\n    setTouched(prev => ({ ...prev, [name]: true }));\n    \n    const error = validateField(name, values[name]);\n    setErrors(prev => ({ ...prev, [name]: error }));\n  }, [validateField, values]);\n  \n  // Handle form submission\n  const handleSubmit = useCallback(async (onSubmit) => {\n    setIsSubmitting(true);\n    \n    // Mark all fields as touched\n    const allTouched = Object.keys(validationRules).reduce((acc, key) => {\n      acc[key] = true;\n      return acc;\n    }, {});\n    setTouched(allTouched);\n    \n    // Validate all fields\n    const isValid = validateAll();\n    \n    if (isValid) {\n      try {\n        await onSubmit(values);\n      } catch (error) {\n        console.error('Form submission error:', error);\n      }\n    }\n    \n    setIsSubmitting(false);\n  }, [values, validationRules, validateAll]);\n  \n  // Reset form\n  const reset = useCallback(() => {\n    setValues(initialValues);\n    setErrors({});\n    setTouched({});\n    setIsSubmitting(false);\n  }, [initialValues]);\n  \n  // Check if form is valid\n  const isValid = Object.keys(errors).every(key => !errors[key]);\n  \n  return {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset\n  };\n}\n\n// Validation rules\nconst required = (value) => {\n  return !value || value.trim() === '' ? 'This field is required' : null;\n};\n\nconst email = (value) => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return value && !emailRegex.test(value) ? 'Invalid email address' : null;\n};\n\nconst minLength = (min) => (value) => {\n  return value && value.length < min ? `Must be at least ${min} characters` : null;\n};\n\nconst confirmPassword = (value, allValues) => {\n  return value !== allValues.password ? 'Passwords do not match' : null;\n};\n\n// Usage\nfunction SignupForm() {\n  const {\n    values,\n    errors,\n    touched,\n    isSubmitting,\n    isValid,\n    handleChange,\n    handleBlur,\n    handleSubmit,\n    reset\n  } = useFormValidation(\n    {\n      email: '',\n      password: '',\n      confirmPassword: '',\n      name: ''\n    },\n    {\n      email: [required, email],\n      password: [required, minLength(8)],\n      confirmPassword: [required, confirmPassword],\n      name: [required]\n    }\n  );\n  \n  const onSubmit = async (data) => {\n    console.log('Submitting:', data);\n    // API call here\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    reset();\n  };\n  \n  return (\n    <form onSubmit={(e) => {\n      e.preventDefault();\n      handleSubmit(onSubmit);\n    }}>\n      <div>\n        <input\n          type=\"text\"\n          placeholder=\"Name\"\n          value={values.name}\n          onChange={(e) => handleChange('name', e.target.value)}\n          onBlur={() => handleBlur('name')}\n        />\n        {touched.name && errors.name && (\n          <span className=\"error\">{errors.name}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          type=\"email\"\n          placeholder=\"Email\"\n          value={values.email}\n          onChange={(e) => handleChange('email', e.target.value)}\n          onBlur={() => handleBlur('email')}\n        />\n        {touched.email && errors.email && (\n          <span className=\"error\">{errors.email}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          type=\"password\"\n          placeholder=\"Password\"\n          value={values.password}\n          onChange={(e) => handleChange('password', e.target.value)}\n          onBlur={() => handleBlur('password')}\n        />\n        {touched.password && errors.password && (\n          <span className=\"error\">{errors.password}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          type=\"password\"\n          placeholder=\"Confirm Password\"\n          value={values.confirmPassword}\n          onChange={(e) => handleChange('confirmPassword', e.target.value)}\n          onBlur={() => handleBlur('confirmPassword')}\n        />\n        {touched.confirmPassword && errors.confirmPassword && (\n          <span className=\"error\">{errors.confirmPassword}</span>\n        )}\n      </div>\n      \n      <button type=\"submit\" disabled={!isValid || isSubmitting}>\n        {isSubmitting ? 'Signing up...' : 'Sign Up'}\n      </button>\n    </form>\n  );\n}\n```\n\n**4. Intersection Observer Hook:**\n```javascript\nfunction useIntersectionObserver(options = {}) {\n  const [isIntersecting, setIsIntersecting] = useState(false);\n  const [entry, setEntry] = useState(null);\n  const elementRef = useRef(null);\n  \n  const { threshold = 0, root = null, rootMargin = '0%' } = options;\n  \n  useEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n    \n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsIntersecting(entry.isIntersecting);\n        setEntry(entry);\n      },\n      { threshold, root, rootMargin }\n    );\n    \n    observer.observe(element);\n    \n    return () => {\n      observer.unobserve(element);\n    };\n  }, [threshold, root, rootMargin]);\n  \n  return [elementRef, isIntersecting, entry];\n}\n\n// Lazy loading hook using intersection observer\nfunction useLazyLoading() {\n  const [isLoaded, setIsLoaded] = useState(false);\n  const [elementRef, isIntersecting] = useIntersectionObserver({\n    threshold: 0.1\n  });\n  \n  useEffect(() => {\n    if (isIntersecting && !isLoaded) {\n      setIsLoaded(true);\n    }\n  }, [isIntersecting, isLoaded]);\n  \n  return [elementRef, isLoaded];\n}\n\n// Usage\nfunction LazyImage({ src, alt, ...props }) {\n  const [ref, isLoaded] = useLazyLoading();\n  \n  return (\n    <div ref={ref} {...props}>\n      {isLoaded ? (\n        <img src={src} alt={alt} />\n      ) : (\n        <div className=\"image-placeholder\">Loading...</div>\n      )}\n    </div>\n  );\n}\n\nfunction InfiniteScrollList({ items, loadMore, hasMore }) {\n  const [sentinelRef, isIntersecting] = useIntersectionObserver({\n    threshold: 1.0\n  });\n  \n  useEffect(() => {\n    if (isIntersecting && hasMore) {\n      loadMore();\n    }\n  }, [isIntersecting, hasMore, loadMore]);\n  \n  return (\n    <div>\n      {items.map(item => (\n        <div key={item.id}>{item.name}</div>\n      ))}\n      {hasMore && (\n        <div ref={sentinelRef} className=\"loading-sentinel\">\n          Loading more...\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**5. Complex State Management Hook:**\n```javascript\nfunction useReducerWithMiddleware(reducer, initialState, middleware = []) {\n  const [state, dispatch] = useReducer(\n    (state, action) => {\n      // Apply middleware\n      let finalAction = action;\n      for (const mw of middleware) {\n        finalAction = mw(state, finalAction) || finalAction;\n      }\n      return reducer(state, finalAction);\n    },\n    initialState\n  );\n  \n  return [state, dispatch];\n}\n\n// Middleware examples\nconst logger = (state, action) => {\n  console.log('Previous State:', state);\n  console.log('Action:', action);\n};\n\nconst crashReporter = (state, action) => {\n  try {\n    return action;\n  } catch (error) {\n    console.error('Action crashed:', action, error);\n    // Report to error tracking service\n  }\n};\n\n// Usage\nfunction useShoppingCart() {\n  const cartReducer = (state, action) => {\n    switch (action.type) {\n      case 'ADD_ITEM':\n        const existingItem = state.items.find(item => item.id === action.payload.id);\n        if (existingItem) {\n          return {\n            ...state,\n            items: state.items.map(item =>\n              item.id === action.payload.id\n                ? { ...item, quantity: item.quantity + 1 }\n                : item\n            )\n          };\n        }\n        return {\n          ...state,\n          items: [...state.items, { ...action.payload, quantity: 1 }]\n        };\n      \n      case 'REMOVE_ITEM':\n        return {\n          ...state,\n          items: state.items.filter(item => item.id !== action.payload)\n        };\n      \n      case 'UPDATE_QUANTITY':\n        return {\n          ...state,\n          items: state.items.map(item =>\n            item.id === action.payload.id\n              ? { ...item, quantity: action.payload.quantity }\n              : item\n          )\n        };\n      \n      case 'CLEAR_CART':\n        return { ...state, items: [] };\n      \n      default:\n        return state;\n    }\n  };\n  \n  const [state, dispatch] = useReducerWithMiddleware(\n    cartReducer,\n    { items: [], total: 0 },\n    [logger, crashReporter]\n  );\n  \n  // Computed values\n  const total = useMemo(() => {\n    return state.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);\n  }, [state.items]);\n  \n  const itemCount = useMemo(() => {\n    return state.items.reduce((count, item) => count + item.quantity, 0);\n  }, [state.items]);\n  \n  // Actions\n  const addItem = useCallback((item) => {\n    dispatch({ type: 'ADD_ITEM', payload: item });\n  }, [dispatch]);\n  \n  const removeItem = useCallback((id) => {\n    dispatch({ type: 'REMOVE_ITEM', payload: id });\n  }, [dispatch]);\n  \n  const updateQuantity = useCallback((id, quantity) => {\n    if (quantity <= 0) {\n      removeItem(id);\n    } else {\n      dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });\n    }\n  }, [dispatch, removeItem]);\n  \n  const clearCart = useCallback(() => {\n    dispatch({ type: 'CLEAR_CART' });\n  }, [dispatch]);\n  \n  return {\n    items: state.items,\n    total,\n    itemCount,\n    addItem,\n    removeItem,\n    updateQuantity,\n    clearCart\n  };\n}\n```\n\n**Best Practices for Custom Hooks:**\n\n1. **Always start with 'use'** - This tells React it's a hook\n2. **Keep them focused** - Each hook should have a single responsibility\n3. **Return consistent interfaces** - Use objects or arrays consistently\n4. **Handle cleanup** - Always clean up side effects\n5. **Memoize when appropriate** - Use useCallback and useMemo for performance\n6. **Include dependencies** - Follow the rules of hooks\n7. **Test thoroughly** - Custom hooks should be well-tested\n8. **Document well** - Explain parameters, return values, and use cases\n\n**Benefits of Custom Hooks:**\n- **Reusability** - Share logic across components\n- **Separation of Concerns** - Keep components focused on rendering\n- **Testability** - Easier to test logic in isolation\n- **Readability** - Makes components cleaner and more declarative\n- **Composition** - Combine multiple hooks for complex functionality",
      "keywords": ["custom hooks", "reusable logic", "useAPI", "useLocalStorage", "useFormValidation", "useIntersectionObserver", "hook composition", "state management", "side effects", "separation of concerns"],
      "difficulty": "medium"
    },
    {
      "id": 2032,
      "tag": "react",
      "question": "What is useLayoutEffect and how does it differ from useEffect? When should you use each?",
      "answer": "useLayoutEffect is a hook that fires synchronously after all DOM mutations but before the browser paints, while useEffect fires asynchronously after the browser has painted. This timing difference makes useLayoutEffect crucial for DOM measurements and preventing visual flickering.\n\n**Execution Timing Comparison:**\n```javascript\nfunction TimingExample() {\n  const [count, setCount] = useState(0);\n  \n  // useEffect - fires AFTER browser paint (asynchronous)\n  useEffect(() => {\n    console.log('useEffect - count:', count);\n    // This runs after the DOM has been painted\n    // User might see intermediate state\n  }, [count]);\n  \n  // useLayoutEffect - fires BEFORE browser paint (synchronous)\n  useLayoutEffect(() => {\n    console.log('useLayoutEffect - count:', count);\n    // This runs before the DOM is painted\n    // Blocks painting until complete\n  }, [count]);\n  \n  console.log('Render - count:', count);\n  \n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(c => c + 1)}>Increment</button>\n    </div>\n  );\n}\n\n// Execution order:\n// 1. Render - count: 1\n// 2. useLayoutEffect - count: 1 (before paint)\n// 3. Browser paints the updated DOM\n// 4. useEffect - count: 1 (after paint)\n```\n\n**DOM Measurements with useLayoutEffect:**\n```javascript\n// ❌ Problem with useEffect - causes flickering\nfunction FlickeringTooltip({ children, tooltip }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [showTooltip, setShowTooltip] = useState(false);\n  const tooltipRef = useRef(null);\n  const triggerRef = useRef(null);\n  \n  useEffect(() => {\n    if (showTooltip && tooltipRef.current && triggerRef.current) {\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n      \n      // This causes flickering because tooltip is already painted\n      setPosition({\n        x: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\n        y: triggerRect.top - tooltipRect.height - 8\n      });\n    }\n  }, [showTooltip]);\n  \n  return (\n    <div>\n      <div\n        ref={triggerRef}\n        onMouseEnter={() => setShowTooltip(true)}\n        onMouseLeave={() => setShowTooltip(false)}\n      >\n        {children}\n      </div>\n      {showTooltip && (\n        <div\n          ref={tooltipRef}\n          style={{\n            position: 'fixed',\n            left: position.x,\n            top: position.y,\n            background: 'black',\n            color: 'white',\n            padding: '4px 8px',\n            borderRadius: '4px',\n            pointerEvents: 'none',\n            zIndex: 1000\n          }}\n        >\n          {tooltip}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// ✅ Solution with useLayoutEffect - no flickering\nfunction SmoothTooltip({ children, tooltip }) {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [showTooltip, setShowTooltip] = useState(false);\n  const tooltipRef = useRef(null);\n  const triggerRef = useRef(null);\n  \n  useLayoutEffect(() => {\n    if (showTooltip && tooltipRef.current && triggerRef.current) {\n      const triggerRect = triggerRef.current.getBoundingClientRect();\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n      \n      // Position is set before browser paints - no flickering\n      setPosition({\n        x: triggerRect.left + triggerRect.width / 2 - tooltipRect.width / 2,\n        y: triggerRect.top - tooltipRect.height - 8\n      });\n    }\n  }, [showTooltip]);\n  \n  return (\n    <div>\n      <div\n        ref={triggerRef}\n        onMouseEnter={() => setShowTooltip(true)}\n        onMouseLeave={() => setShowTooltip(false)}\n      >\n        {children}\n      </div>\n      {showTooltip && (\n        <div\n          ref={tooltipRef}\n          style={{\n            position: 'fixed',\n            left: position.x,\n            top: position.y,\n            background: 'black',\n            color: 'white',\n            padding: '4px 8px',\n            borderRadius: '4px',\n            pointerEvents: 'none',\n            zIndex: 1000\n          }}\n        >\n          {tooltip}\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n**Dynamic Height Adjustments:**\n```javascript\nfunction AutoResizeTextarea({ value, onChange, ...props }) {\n  const textareaRef = useRef(null);\n  \n  useLayoutEffect(() => {\n    const textarea = textareaRef.current;\n    if (textarea) {\n      // Reset height to get the correct scrollHeight\n      textarea.style.height = 'auto';\n      // Set height to scrollHeight to fit content\n      textarea.style.height = `${textarea.scrollHeight}px`;\n    }\n  }, [value]); // Runs before paint, prevents height jumping\n  \n  return (\n    <textarea\n      ref={textareaRef}\n      value={value}\n      onChange={onChange}\n      style={{\n        resize: 'none',\n        overflow: 'hidden',\n        minHeight: '40px'\n      }}\n      {...props}\n    />\n  );\n}\n\n// Modal focus management\nfunction Modal({ isOpen, onClose, children }) {\n  const modalRef = useRef(null);\n  const previousActiveElement = useRef(null);\n  \n  useLayoutEffect(() => {\n    if (isOpen) {\n      // Store the currently focused element\n      previousActiveElement.current = document.activeElement;\n      \n      // Focus the modal immediately before paint\n      if (modalRef.current) {\n        modalRef.current.focus();\n      }\n    } else {\n      // Restore focus when modal closes\n      if (previousActiveElement.current) {\n        previousActiveElement.current.focus();\n      }\n    }\n  }, [isOpen]);\n  \n  if (!isOpen) return null;\n  \n  return (\n    <div\n      ref={modalRef}\n      tabIndex={-1}\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        background: 'rgba(0, 0, 0, 0.5)',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center'\n      }}\n      onClick={(e) => {\n        if (e.target === e.currentTarget) {\n          onClose();\n        }\n      }}\n    >\n      <div\n        style={{\n          background: 'white',\n          padding: '20px',\n          borderRadius: '8px',\n          maxWidth: '500px',\n          width: '90%'\n        }}\n      >\n        {children}\n      </div>\n    </div>\n  );\n}\n```\n\n**Custom Hooks with useLayoutEffect:**\n```javascript\n// Hook for measuring element dimensions\nfunction useElementSize() {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  const elementRef = useRef(null);\n  \n  useLayoutEffect(() => {\n    const updateSize = () => {\n      if (elementRef.current) {\n        const { offsetWidth, offsetHeight } = elementRef.current;\n        setSize({ width: offsetWidth, height: offsetHeight });\n      }\n    };\n    \n    updateSize(); // Initial measurement\n    \n    // Set up resize observer for dynamic updates\n    const resizeObserver = new ResizeObserver(updateSize);\n    if (elementRef.current) {\n      resizeObserver.observe(elementRef.current);\n    }\n    \n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n  \n  return [elementRef, size];\n}\n\n// Hook for scroll-based animations\nfunction useScrollAnimation(threshold = 0) {\n  const [isVisible, setIsVisible] = useState(false);\n  const elementRef = useRef(null);\n  \n  useLayoutEffect(() => {\n    const element = elementRef.current;\n    if (!element) return;\n    \n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry.isIntersecting) {\n          setIsVisible(true);\n          // Apply animation class immediately before paint\n          element.classList.add('animate-in');\n        }\n      },\n      { threshold }\n    );\n    \n    observer.observe(element);\n    return () => observer.unobserve(element);\n  }, [threshold]);\n  \n  return [elementRef, isVisible];\n}\n\n// Usage\nfunction AnimatedCard({ children }) {\n  const [ref, isVisible] = useScrollAnimation(0.2);\n  \n  return (\n    <div\n      ref={ref}\n      className={`card ${isVisible ? 'animate-in' : ''}`}\n      style={{\n        opacity: isVisible ? 1 : 0,\n        transform: isVisible ? 'translateY(0)' : 'translateY(20px)',\n        transition: 'opacity 0.6s, transform 0.6s'\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n**Performance Considerations:**\n```javascript\nfunction PerformanceExample() {\n  const [items, setItems] = useState([]);\n  const [measurements, setMeasurements] = useState([]);\n  \n  // ❌ useLayoutEffect for non-critical operations blocks painting\n  useLayoutEffect(() => {\n    // This expensive operation blocks painting\n    const expensiveCalculation = items.map(item => {\n      // Simulate expensive computation\n      let result = 0;\n      for (let i = 0; i < 100000; i++) {\n        result += Math.random();\n      }\n      return result;\n    });\n    setMeasurements(expensiveCalculation);\n  }, [items]);\n  \n  // ✅ Use useEffect for expensive operations that don't affect layout\n  useEffect(() => {\n    // This doesn't block painting\n    const expensiveCalculation = items.map(item => {\n      let result = 0;\n      for (let i = 0; i < 100000; i++) {\n        result += Math.random();\n      }\n      return result;\n    });\n    setMeasurements(expensiveCalculation);\n  }, [items]);\n  \n  return (\n    <div>\n      {items.map((item, index) => (\n        <div key={item.id}>\n          {item.name} - {measurements[index]}\n        </div>\n      ))}\n    </div>\n  );\n}\n```\n\n**SSR Considerations:**\n```javascript\n// Hook to safely use layout effects in SSR\nfunction useIsomorphicLayoutEffect(effect, deps) {\n  // Use useEffect on server, useLayoutEffect on client\n  const useIsomorphic = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n  return useIsomorphic(effect, deps);\n}\n\n// Usage in components that need SSR compatibility\nfunction SSRSafeComponent() {\n  const [height, setHeight] = useState(0);\n  const elementRef = useRef(null);\n  \n  useIsomorphicLayoutEffect(() => {\n    if (elementRef.current) {\n      setHeight(elementRef.current.offsetHeight);\n    }\n  }, []);\n  \n  return (\n    <div>\n      <div ref={elementRef}>Content here</div>\n      <p>Height: {height}px</p>\n    </div>\n  );\n}\n```\n\n**Advanced Pattern - Layout Effect with Cleanup:**\n```javascript\nfunction useWindowSize() {\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  \n  useLayoutEffect(() => {\n    const updateSize = () => {\n      setSize({\n        width: window.innerWidth,\n        height: window.innerHeight\n      });\n    };\n    \n    // Initial measurement\n    updateSize();\n    \n    // Listen for resize events\n    window.addEventListener('resize', updateSize);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', updateSize);\n    };\n  }, []);\n  \n  return size;\n}\n\n// Responsive component that adjusts layout based on window size\nfunction ResponsiveGrid({ children }) {\n  const { width } = useWindowSize();\n  const [columns, setColumns] = useState(1);\n  \n  useLayoutEffect(() => {\n    // Calculate columns based on width before paint\n    const newColumns = Math.floor(width / 300) || 1;\n    setColumns(newColumns);\n  }, [width]);\n  \n  return (\n    <div\n      style={{\n        display: 'grid',\n        gridTemplateColumns: `repeat(${columns}, 1fr)`,\n        gap: '16px'\n      }}\n    >\n      {children}\n    </div>\n  );\n}\n```\n\n**When to Use Each:**\n\n**Use useLayoutEffect when:**\n- Measuring DOM elements (dimensions, positions)\n- Synchronizing with external layout systems\n- Preventing visual flickering\n- Setting focus or scroll position\n- Calculating element positions for tooltips, dropdowns\n- Animations that depend on layout measurements\n- Reading layout properties before browser paint\n\n**Use useEffect when:**\n- Data fetching and API calls\n- Setting up subscriptions\n- Timers and intervals\n- Logging and analytics\n- Side effects that don't affect visual layout\n- Most general side effects\n- Operations that can happen after paint\n\n**Key Differences:**\n\n| Aspect | useEffect | useLayoutEffect |\n|--------|-----------|----------------|\n| **Timing** | After browser paint | Before browser paint |\n| **Blocking** | Non-blocking | Blocks painting |\n| **Use Case** | General side effects | DOM measurements/mutations |\n| **Performance** | Better for most cases | Can hurt performance if overused |\n| **SSR** | Works normally | Needs special handling |\n| **Flickering** | May cause flickering | Prevents flickering |\n\n**Best Practices:**\n- Use useEffect by default\n- Only use useLayoutEffect when you need synchronous DOM access\n- Keep useLayoutEffect operations fast to avoid blocking\n- Consider SSR compatibility when using useLayoutEffect\n- Measure performance impact when switching between the two\n- Use useIsomorphicLayoutEffect for SSR-compatible components",
      "keywords": ["useLayoutEffect", "useEffect", "DOM measurements", "synchronous", "asynchronous", "browser paint", "visual flickering", "layout effects", "timing", "SSR compatibility"],
      "difficulty": "medium"
    },
    {
      "id": 2033,
      "tag": "react",
      "question": "What are React portals and how do you use them? Explain advanced portal patterns and use cases.",
      "answer": "React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This is useful for modals, tooltips, dropdowns, and other components that need to break out of their container's styling constraints.\n\n**Basic Portal Usage:**\n```javascript\nimport { createPortal } from 'react-dom';\n\n// Basic portal example\nfunction Modal({ isOpen, onClose, children }) {\n  if (!isOpen) return null;\n  \n  // Render into a different DOM node\n  return createPortal(\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div className=\"modal-content\" onClick={(e) => e.stopPropagation()}>\n        <button className=\"close-button\" onClick={onClose}>×</button>\n        {children}\n      </div>\n    </div>,\n    document.getElementById('modal-root') // Target DOM node\n  );\n}\n\n// HTML structure needed\n// <div id=\"root\"><!-- Main React app --></div>\n// <div id=\"modal-root\"><!-- Portals render here --></div>\n\n// Usage\nfunction App() {\n  const [showModal, setShowModal] = useState(false);\n  \n  return (\n    <div className=\"app\">\n      <h1>My App</h1>\n      <button onClick={() => setShowModal(true)}>Open Modal</button>\n      \n      <Modal isOpen={showModal} onClose={() => setShowModal(false)}>\n        <h2>Modal Content</h2>\n        <p>This renders outside the main DOM tree!</p>\n      </Modal>\n    </div>\n  );\n}\n```\n\n**Portal Hook for Reusability:**\n```javascript\nfunction usePortal(id = 'portal-root') {\n  const [portalElement, setPortalElement] = useState(null);\n  \n  useEffect(() => {\n    // Find existing portal element or create one\n    let element = document.getElementById(id);\n    \n    if (!element) {\n      element = document.createElement('div');\n      element.id = id;\n      document.body.appendChild(element);\n    }\n    \n    setPortalElement(element);\n    \n    // Cleanup function to remove element if it was created\n    return () => {\n      // Only remove if we created it and it's empty\n      if (element && element.childNodes.length === 0 && element.parentNode) {\n        element.parentNode.removeChild(element);\n      }\n    };\n  }, [id]);\n  \n  return portalElement;\n}\n\n// Portal wrapper component\nfunction Portal({ children, id = 'portal-root' }) {\n  const portalElement = usePortal(id);\n  \n  if (!portalElement) return null;\n  \n  return createPortal(children, portalElement);\n}\n\n// Usage\nfunction Tooltip({ children, content, show }) {\n  if (!show) return children;\n  \n  return (\n    <>\n      {children}\n      <Portal id=\"tooltip-root\">\n        <div className=\"tooltip\">{content}</div>\n      </Portal>\n    </>\n  );\n}\n```\n\n**Advanced Modal System:**\n```javascript\nconst ModalContext = createContext();\n\n// Modal provider with stack management\nfunction ModalProvider({ children }) {\n  const [modals, setModals] = useState([]);\n  \n  const openModal = useCallback((id, component, props = {}) => {\n    setModals(prev => [\n      ...prev,\n      { id, component, props, timestamp: Date.now() }\n    ]);\n  }, []);\n  \n  const closeModal = useCallback((id) => {\n    setModals(prev => prev.filter(modal => modal.id !== id));\n  }, []);\n  \n  const closeTopModal = useCallback(() => {\n    setModals(prev => prev.slice(0, -1));\n  }, []);\n  \n  const closeAllModals = useCallback(() => {\n    setModals([]);\n  }, []);\n  \n  // Handle escape key\n  useEffect(() => {\n    const handleEscape = (e) => {\n      if (e.key === 'Escape' && modals.length > 0) {\n        closeTopModal();\n      }\n    };\n    \n    document.addEventListener('keydown', handleEscape);\n    return () => document.removeEventListener('keydown', handleEscape);\n  }, [modals.length, closeTopModal]);\n  \n  const value = {\n    modals,\n    openModal,\n    closeModal,\n    closeTopModal,\n    closeAllModals\n  };\n  \n  return (\n    <ModalContext.Provider value={value}>\n      {children}\n      <ModalRenderer />\n    </ModalContext.Provider>\n  );\n}\n\n// Modal renderer component\nfunction ModalRenderer() {\n  const { modals } = useContext(ModalContext);\n  const portalElement = usePortal('modal-root');\n  \n  if (!portalElement || modals.length === 0) return null;\n  \n  return createPortal(\n    <div className=\"modal-stack\">\n      {modals.map((modal, index) => {\n        const ModalComponent = modal.component;\n        return (\n          <div\n            key={modal.id}\n            className=\"modal-layer\"\n            style={{\n              zIndex: 1000 + index,\n              backgroundColor: index === modals.length - 1 \n                ? 'rgba(0, 0, 0, 0.5)' \n                : 'transparent'\n            }}\n          >\n            <ModalComponent\n              modalId={modal.id}\n              isTop={index === modals.length - 1}\n              {...modal.props}\n            />\n          </div>\n        );\n      })}\n    </div>,\n    portalElement\n  );\n}\n\n// Hook to use modal context\nfunction useModal() {\n  const context = useContext(ModalContext);\n  if (!context) {\n    throw new Error('useModal must be used within ModalProvider');\n  }\n  return context;\n}\n\n// Modal component example\nfunction ConfirmationModal({ modalId, title, message, onConfirm, onCancel }) {\n  const { closeModal } = useModal();\n  \n  const handleConfirm = () => {\n    onConfirm?.();\n    closeModal(modalId);\n  };\n  \n  const handleCancel = () => {\n    onCancel?.();\n    closeModal(modalId);\n  };\n  \n  return (\n    <div className=\"modal-overlay\" onClick={handleCancel}>\n      <div className=\"modal-content\" onClick={(e) => e.stopPropagation()}>\n        <h2>{title}</h2>\n        <p>{message}</p>\n        <div className=\"modal-actions\">\n          <button onClick={handleCancel}>Cancel</button>\n          <button onClick={handleConfirm} className=\"primary\">Confirm</button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Usage\nfunction MyComponent() {\n  const { openModal } = useModal();\n  \n  const handleDelete = () => {\n    openModal('delete-confirmation', ConfirmationModal, {\n      title: 'Delete Item',\n      message: 'Are you sure you want to delete this item?',\n      onConfirm: () => console.log('Deleted!'),\n      onCancel: () => console.log('Cancelled')\n    });\n  };\n  \n  return (\n    <button onClick={handleDelete}>Delete Item</button>\n  );\n}\n```\n\n**Dropdown/Popover with Positioning:**\n```javascript\nfunction usePopoverPosition(triggerRef, popoverRef, placement = 'bottom') {\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [actualPlacement, setActualPlacement] = useState(placement);\n  \n  const updatePosition = useCallback(() => {\n    if (!triggerRef.current || !popoverRef.current) return;\n    \n    const triggerRect = triggerRef.current.getBoundingClientRect();\n    const popoverRect = popoverRef.current.getBoundingClientRect();\n    const viewport = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    \n    let x, y, finalPlacement = placement;\n    \n    // Calculate position based on placement\n    switch (placement) {\n      case 'top':\n        x = triggerRect.left + triggerRect.width / 2 - popoverRect.width / 2;\n        y = triggerRect.top - popoverRect.height - 8;\n        \n        // Check if it fits above\n        if (y < 0) {\n          finalPlacement = 'bottom';\n          y = triggerRect.bottom + 8;\n        }\n        break;\n        \n      case 'bottom':\n        x = triggerRect.left + triggerRect.width / 2 - popoverRect.width / 2;\n        y = triggerRect.bottom + 8;\n        \n        // Check if it fits below\n        if (y + popoverRect.height > viewport.height) {\n          finalPlacement = 'top';\n          y = triggerRect.top - popoverRect.height - 8;\n        }\n        break;\n        \n      case 'left':\n        x = triggerRect.left - popoverRect.width - 8;\n        y = triggerRect.top + triggerRect.height / 2 - popoverRect.height / 2;\n        \n        if (x < 0) {\n          finalPlacement = 'right';\n          x = triggerRect.right + 8;\n        }\n        break;\n        \n      case 'right':\n        x = triggerRect.right + 8;\n        y = triggerRect.top + triggerRect.height / 2 - popoverRect.height / 2;\n        \n        if (x + popoverRect.width > viewport.width) {\n          finalPlacement = 'left';\n          x = triggerRect.left - popoverRect.width - 8;\n        }\n        break;\n    }\n    \n    // Ensure popover stays within viewport horizontally\n    if (x < 8) x = 8;\n    if (x + popoverRect.width > viewport.width - 8) {\n      x = viewport.width - popoverRect.width - 8;\n    }\n    \n    // Ensure popover stays within viewport vertically\n    if (y < 8) y = 8;\n    if (y + popoverRect.height > viewport.height - 8) {\n      y = viewport.height - popoverRect.height - 8;\n    }\n    \n    setPosition({ x, y });\n    setActualPlacement(finalPlacement);\n  }, [placement]);\n  \n  useLayoutEffect(() => {\n    updatePosition();\n  });\n  \n  useEffect(() => {\n    window.addEventListener('scroll', updatePosition);\n    window.addEventListener('resize', updatePosition);\n    \n    return () => {\n      window.removeEventListener('scroll', updatePosition);\n      window.removeEventListener('resize', updatePosition);\n    };\n  }, [updatePosition]);\n  \n  return { position, actualPlacement, updatePosition };\n}\n\nfunction Popover({ trigger, children, placement = 'bottom', isOpen, onClose }) {\n  const triggerRef = useRef(null);\n  const popoverRef = useRef(null);\n  const { position, actualPlacement } = usePopoverPosition(\n    triggerRef, \n    popoverRef, \n    placement\n  );\n  \n  // Close on outside click\n  useEffect(() => {\n    if (!isOpen) return;\n    \n    const handleClickOutside = (event) => {\n      if (\n        popoverRef.current && \n        !popoverRef.current.contains(event.target) &&\n        triggerRef.current &&\n        !triggerRef.current.contains(event.target)\n      ) {\n        onClose();\n      }\n    };\n    \n    document.addEventListener('mousedown', handleClickOutside);\n    return () => document.removeEventListener('mousedown', handleClickOutside);\n  }, [isOpen, onClose]);\n  \n  return (\n    <>\n      <div ref={triggerRef}>\n        {trigger}\n      </div>\n      \n      {isOpen && (\n        <Portal>\n          <div\n            ref={popoverRef}\n            className={`popover popover--${actualPlacement}`}\n            style=\n              position: 'fixed',\n              left: position.x,\n              top: position.y,\n              zIndex: 1000\n            }}\n          >\n            {children}\n          </div>\n        </Portal>\n      )}\n    </>\n  );\n}\n\n// Usage\nfunction DropdownExample() {\n  const [isOpen, setIsOpen] = useState(false);\n  \n  return (\n    <Popover\n      trigger={\n        <button onClick={() => setIsOpen(!isOpen)}>\n          Open Menu\n        </button>\n      }\n      isOpen={isOpen}\n      onClose={() => setIsOpen(false)}\n      placement=\"bottom\"\n    >\n      <div className=\"dropdown-menu\">\n        <button onClick={() => console.log('Edit')}>Edit</button>\n        <button onClick={() => console.log('Delete')}>Delete</button>\n        <button onClick={() => console.log('Share')}>Share</button>\n      </div>\n    </Popover>\n  );\n}\n```\n\n**Toast Notification System:**\n```javascript\nconst ToastContext = createContext();\n\nfunction ToastProvider({ children }) {\n  const [toasts, setToasts] = useState([]);\n  \n  const addToast = useCallback((message, type = 'info', duration = 5000) => {\n    const id = Date.now() + Math.random();\n    const toast = { id, message, type, duration };\n    \n    setToasts(prev => [...prev, toast]);\n    \n    // Auto remove toast\n    if (duration > 0) {\n      setTimeout(() => {\n        removeToast(id);\n      }, duration);\n    }\n    \n    return id;\n  }, []);\n  \n  const removeToast = useCallback((id) => {\n    setToasts(prev => prev.filter(toast => toast.id !== id));\n  }, []);\n  \n  return (\n    <ToastContext.Provider value={{ addToast, removeToast }}>\n      {children}\n      <ToastContainer toasts={toasts} onRemove={removeToast} />\n    </ToastContext.Provider>\n  );\n}\n\nfunction ToastContainer({ toasts, onRemove }) {\n  const portalElement = usePortal('toast-root');\n  \n  if (!portalElement) return null;\n  \n  return createPortal(\n    <div className=\"toast-container\">\n      {toasts.map(toast => (\n        <Toast\n          key={toast.id}\n          toast={toast}\n          onRemove={onRemove}\n        />\n      ))}\n    </div>,\n    portalElement\n  );\n}\n\nfunction Toast({ toast, onRemove }) {\n  const [isVisible, setIsVisible] = useState(false);\n  \n  useEffect(() => {\n    // Trigger entrance animation\n    setIsVisible(true);\n  }, []);\n  \n  const handleRemove = () => {\n    setIsVisible(false);\n    setTimeout(() => onRemove(toast.id), 300); // Wait for exit animation\n  };\n  \n  return (\n    <div\n      className={`toast toast--${toast.type} ${isVisible ? 'toast--visible' : ''}`}\n      onClick={handleRemove}\n    >\n      <span>{toast.message}</span>\n      <button onClick={handleRemove}>×</button>\n    </div>\n  );\n}\n\n// Hook to use toasts\nfunction useToast() {\n  const context = useContext(ToastContext);\n  if (!context) {\n    throw new Error('useToast must be used within ToastProvider');\n  }\n  return context;\n}\n\n// Usage\nfunction MyApp() {\n  const { addToast } = useToast();\n  \n  return (\n    <div>\n      <button onClick={() => addToast('Success!', 'success')}>Success Toast</button>\n      <button onClick={() => addToast('Error occurred', 'error')}>Error Toast</button>\n      <button onClick={() => addToast('Info message', 'info')}>Info Toast</button>\n    </div>\n  );\n}\n```\n\n**Portal Event Handling:**\n```javascript\n// Events bubble through React component tree, not DOM tree\nfunction PortalEventExample() {\n  const handleClick = (event) => {\n    console.log('Parent clicked', event.target);\n  };\n  \n  return (\n    <div onClick={handleClick} style={{ padding: '20px', border: '1px solid blue' }}>\n      <h2>Parent Component</h2>\n      \n      <Portal>\n        <div \n          style={{ \n            position: 'fixed', \n            top: '50px', \n            right: '50px', \n            padding: '10px', \n            background: 'red', \n            color: 'white' \n          }}\n        >\n          {/* This click will bubble to parent even though it's in a portal */}\n          <button onClick={() => console.log('Portal button clicked')}>Portal Button</button>\n        </div>\n      </Portal>\n      \n      <button>Regular Button</button>\n    </div>\n  );\n}\n```\n\n**Use Cases for Portals:**\n\n1. **Modals and Dialogs** - Break out of parent z-index and positioning\n2. **Tooltips and Popovers** - Position relative to viewport, not parent\n3. **Dropdown Menus** - Avoid overflow: hidden issues\n4. **Toast Notifications** - Global positioning and stacking\n5. **Context Menus** - Fixed positioning anywhere on screen\n6. **Overlays and Backdrops** - Full-screen coverage\n7. **Drag and Drop Previews** - Follow mouse cursor globally\n8. **Loading Spinners** - Cover entire application\n\n**Benefits of Portals:**\n- Break out of CSS containment (overflow, z-index, transform)\n- Maintain React event bubbling despite DOM separation\n- Clean separation of concerns\n- Better accessibility with proper focus management\n- Easier testing and component isolation\n\n**Best Practices:**\n- Create dedicated portal containers in HTML\n- Clean up portal containers when no longer needed\n- Handle focus management properly for accessibility\n- Use context for complex portal management\n- Consider SSR implications (portals don't work during SSR)\n- Implement proper event handling and cleanup",
      "keywords": ["React portals", "createPortal", "DOM hierarchy", "modals", "tooltips", "dropdowns", "z-index", "event bubbling", "positioning", "overlay components"],
      "difficulty": "medium"
    },
    {
      "id": 2034,
      "tag": "react",
      "question": "What are React Server Components (RSC) and how do they differ from traditional components? Explain the benefits and implementation patterns.",
      "answer": "React Server Components (RSC) are a new type of component that runs on the server and can access server-side resources directly, without sending their code to the client. They enable better performance, smaller bundle sizes, and direct access to backend data sources.\n\n**Traditional Components vs Server Components:**\n```javascript\n// Traditional Client Component (runs in browser)\n'use client'; // This directive marks it as a client component\n\nimport { useState, useEffect } from 'react';\n\nfunction TraditionalUserProfile({ userId }) {\n  const [user, setUser] = useState(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    // Client-side data fetching\n    fetch(`/api/users/${userId}`)\n      .then(res => res.json())\n      .then(data => {\n        setUser(data);\n        setLoading(false);\n      });\n  }, [userId]);\n  \n  if (loading) return <div>Loading...</div>;\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n\n// Server Component (runs on server)\n// No 'use client' directive - this is a server component by default\n\nimport { db } from '@/lib/database';\n\n// This is an async component - only possible with Server Components\nasync function ServerUserProfile({ userId }) {\n  // Direct database access - no API needed\n  const user = await db.user.findUnique({\n    where: { id: userId },\n    include: { posts: true, profile: true }\n  });\n  \n  if (!user) {\n    return <div>User not found</div>;\n  }\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n      <UserPosts posts={user.posts} />\n      <UserProfile profile={user.profile} />\n    </div>\n  );\n}\n\n// Server Component can render other Server Components\nasync function UserPosts({ posts }) {\n  return (\n    <div>\n      <h2>Posts</h2>\n      {posts.map(post => (\n        <PostCard key={post.id} post={post} />\n      ))}\n    </div>\n  );\n}\n```\n\n**Server Component Features:**\n```javascript\n// 1. Direct backend access\nasync function ProductCatalog({ category, page = 1 }) {\n  // Direct database queries\n  const products = await db.product.findMany({\n    where: { category },\n    skip: (page - 1) * 20,\n    take: 20,\n    include: { images: true, reviews: true }\n  });\n  \n  // Access environment variables securely\n  const apiKey = process.env.INTERNAL_API_KEY;\n  \n  // Call internal APIs\n  const analytics = await fetch(`https://internal.analytics.com/products/${category}`, {\n    headers: { 'Authorization': `Bearer ${apiKey}` }\n  }).then(res => res.json());\n  \n  return (\n    <div>\n      <h1>Products in {category}</h1>\n      <AnalyticsSummary data={analytics} />\n      <ProductGrid products={products} />\n    </div>\n  );\n}\n\n// 2. File system access\nimport fs from 'fs/promises';\nimport path from 'path';\n\nasync function BlogPost({ slug }) {\n  // Read markdown files directly\n  const filePath = path.join(process.cwd(), 'content', 'blog', `${slug}.md`);\n  const fileContent = await fs.readFile(filePath, 'utf-8');\n  \n  // Process markdown\n  const { content, metadata } = processMarkdown(fileContent);\n  \n  return (\n    <article>\n      <h1>{metadata.title}</h1>\n      <time>{metadata.publishDate}</time>\n      <div dangerouslySetInnerHTML={{ __html: content }} />\n    </article>\n  );\n}\n\n// 3. External API calls without exposing keys\nasync function WeatherWidget({ location }) {\n  // API key stays on server\n  const weatherData = await fetch(\n    `https://api.weather.com/current?location=${location}&key=${process.env.WEATHER_API_KEY}`\n  ).then(res => res.json());\n  \n  return (\n    <div className=\"weather-widget\">\n      <h3>Weather in {location}</h3>\n      <p>{weatherData.temperature}°F</p>\n      <p>{weatherData.description}</p>\n    </div>\n  );\n}\n```\n\n**Mixing Server and Client Components:**\n```javascript\n// Server Component (parent)\nimport { InteractiveChart } from './InteractiveChart'; // Client Component\nimport { DataSummary } from './DataSummary'; // Server Component\n\nasync function DashboardPage({ userId }) {\n  // Server-side data fetching\n  const userData = await getUserData(userId);\n  const chartData = await getChartData(userId);\n  \n  return (\n    <div>\n      <h1>Dashboard</h1>\n      \n      {/* Server Component - rendered on server */}\n      <DataSummary data={userData} />\n      \n      {/* Client Component - hydrated on client */}\n      <InteractiveChart \n        data={chartData} \n        userId={userId}\n      />\n    </div>\n  );\n}\n\n// Client Component (marked with 'use client')\n'use client';\n\nimport { useState } from 'react';\n\nfunction InteractiveChart({ data, userId }) {\n  const [selectedPeriod, setSelectedPeriod] = useState('week');\n  const [isLoading, setIsLoading] = useState(false);\n  \n  const handlePeriodChange = async (period) => {\n    setIsLoading(true);\n    setSelectedPeriod(period);\n    \n    // Client-side API call for interactivity\n    const newData = await fetch(`/api/chart-data?userId=${userId}&period=${period}`);\n    // Update chart...\n    setIsLoading(false);\n  };\n  \n  return (\n    <div>\n      <select \n        value={selectedPeriod} \n        onChange={(e) => handlePeriodChange(e.target.value)}\n      >\n        <option value=\"week\">This Week</option>\n        <option value=\"month\">This Month</option>\n        <option value=\"year\">This Year</option>\n      </select>\n      \n      {isLoading ? (\n        <div>Loading chart...</div>\n      ) : (\n        <Chart data={data} period={selectedPeriod} />\n      )}\n    </div>\n  );\n}\n```\n\n**Data Fetching Patterns:**\n```javascript\n// 1. Parallel data fetching in Server Components\nasync function UserDashboard({ userId }) {\n  // These fetch concurrently\n  const [user, posts, analytics] = await Promise.all([\n    getUserById(userId),\n    getUserPosts(userId),\n    getUserAnalytics(userId)\n  ]);\n  \n  return (\n    <div>\n      <UserHeader user={user} />\n      <UserPosts posts={posts} />\n      <UserAnalytics data={analytics} />\n    </div>\n  );\n}\n\n// 2. Streaming with Suspense\nimport { Suspense } from 'react';\n\nfunction BlogPage({ slug }) {\n  return (\n    <div>\n      <h1>Blog</h1>\n      \n      {/* Fast content loads immediately */}\n      <BlogHeader />\n      \n      {/* Slow content streams in */}\n      <Suspense fallback={<ArticleSkeleton />}>\n        <BlogArticle slug={slug} />\n      </Suspense>\n      \n      <Suspense fallback={<CommentsSkeleton />}>\n        <BlogComments slug={slug} />\n      </Suspense>\n    </div>\n  );\n}\n\n// Slow Server Component\nasync function BlogComments({ slug }) {\n  // Simulate slow API\n  await new Promise(resolve => setTimeout(resolve, 2000));\n  \n  const comments = await getComments(slug);\n  \n  return (\n    <div>\n      <h3>Comments</h3>\n      {comments.map(comment => (\n        <CommentCard key={comment.id} comment={comment} />\n      ))}\n    </div>\n  );\n}\n\n// 3. Nested data fetching\nasync function PostList({ category }) {\n  const posts = await getPosts(category);\n  \n  return (\n    <div>\n      {posts.map(post => (\n        <Suspense key={post.id} fallback={<PostSkeleton />}>\n          <PostWithComments post={post} />\n        </Suspense>\n      ))}\n    </div>\n  );\n}\n\nasync function PostWithComments({ post }) {\n  // Each post fetches its own comments\n  const comments = await getCommentsForPost(post.id);\n  \n  return (\n    <article>\n      <h2>{post.title}</h2>\n      <p>{post.excerpt}</p>\n      <CommentsList comments={comments} />\n    </article>\n  );\n}\n```\n\n**Server Actions (Data Mutations):**\n```javascript\n// Server Action - runs on server\nimport { revalidatePath } from 'next/cache';\n\nasync function createPost(formData) {\n  'use server'; // This marks it as a server action\n  \n  const title = formData.get('title');\n  const content = formData.get('content');\n  \n  // Server-side validation\n  if (!title || !content) {\n    throw new Error('Title and content are required');\n  }\n  \n  // Direct database operation\n  const post = await db.post.create({\n    data: { title, content, authorId: getCurrentUserId() }\n  });\n  \n  // Revalidate cached data\n  revalidatePath('/posts');\n  \n  return post;\n}\n\n// Using Server Action in a Client Component\n'use client';\n\nimport { useFormStatus } from 'react-dom';\n\nfunction CreatePostForm() {\n  return (\n    <form action={createPost}>\n      <input name=\"title\" placeholder=\"Post title\" required />\n      <textarea name=\"content\" placeholder=\"Post content\" required />\n      <SubmitButton />\n    </form>\n  );\n}\n\nfunction SubmitButton() {\n  const { pending } = useFormStatus();\n  \n  return (\n    <button type=\"submit\" disabled={pending}>\n      {pending ? 'Creating...' : 'Create Post'}\n    </button>\n  );\n}\n\n// Using Server Action with useFormState\nimport { useFormState } from 'react-dom';\n\nfunction ContactForm() {\n  const [state, formAction] = useFormState(submitContact, {\n    message: '',\n    errors: {}\n  });\n  \n  return (\n    <form action={formAction}>\n      <input name=\"email\" type=\"email\" required />\n      {state.errors?.email && <span>{state.errors.email}</span>}\n      \n      <textarea name=\"message\" required />\n      {state.errors?.message && <span>{state.errors.message}</span>}\n      \n      <button type=\"submit\">Send Message</button>\n      \n      {state.message && <div>{state.message}</div>}\n    </form>\n  );\n}\n\nasync function submitContact(prevState, formData) {\n  'use server';\n  \n  const email = formData.get('email');\n  const message = formData.get('message');\n  \n  // Validation\n  const errors = {};\n  if (!email || !email.includes('@')) {\n    errors.email = 'Valid email is required';\n  }\n  if (!message || message.length < 10) {\n    errors.message = 'Message must be at least 10 characters';\n  }\n  \n  if (Object.keys(errors).length > 0) {\n    return { errors, message: '' };\n  }\n  \n  // Send email\n  await sendEmail({ to: 'contact@example.com', from: email, message });\n  \n  return {\n    errors: {},\n    message: 'Thank you! Your message has been sent.'\n  };\n}\n```\n\n**Caching and Performance:**\n```javascript\n// 1. Request memoization (automatic deduplication)\nasync function UserProfile({ userId }) {\n  // These calls are automatically deduplicated\n  const user = await getUser(userId);\n  const permissions = await getUserPermissions(userId);\n  \n  return (\n    <div>\n      <UserInfo user={user} />\n      <UserSettings userId={userId} /> {/* Will reuse getUser call */}\n    </div>\n  );\n}\n\nasync function UserSettings({ userId }) {\n  const user = await getUser(userId); // Deduplicated - uses cached result\n  \n  return (\n    <div>\n      <h2>Settings for {user.name}</h2>\n      {/* Settings UI */}\n    </div>\n  );\n}\n\n// 2. Data cache with Next.js\nimport { cache } from 'react';\n\n// Cache function across requests\nconst getUser = cache(async (userId) => {\n  const user = await db.user.findUnique({ where: { id: userId } });\n  return user;\n});\n\n// 3. Time-based caching\nasync function getWeatherData(location) {\n  const response = await fetch(\n    `https://api.weather.com/current?location=${location}`,\n    {\n      next: { revalidate: 3600 } // Cache for 1 hour\n    }\n  );\n  return response.json();\n}\n\n// 4. Tag-based caching\nasync function getPosts() {\n  const response = await fetch('https://api.example.com/posts', {\n    next: { tags: ['posts'] }\n  });\n  return response.json();\n}\n\n// Revalidate tagged cache\nimport { revalidateTag } from 'next/cache';\n\nasync function createPost(formData) {\n  'use server';\n  \n  // Create post...\n  \n  // Invalidate posts cache\n  revalidateTag('posts');\n}\n```\n\n**Benefits of Server Components:**\n\n1. **Better Performance:**\n   - Smaller JavaScript bundles\n   - Faster initial page loads\n   - Reduced client-side processing\n\n2. **Direct Backend Access:**\n   - No API layer needed\n   - Direct database queries\n   - Secure environment variable access\n\n3. **Improved SEO:**\n   - Fully rendered HTML\n   - Better search engine indexing\n   - Faster time to first contentful paint\n\n4. **Enhanced Security:**\n   - Sensitive code stays on server\n   - API keys not exposed to client\n   - Business logic protected\n\n5. **Better Developer Experience:**\n   - Async components\n   - Simplified data fetching\n   - No useEffect for initial data\n\n**Limitations and Considerations:**\n\n1. **No Client-Side Interactivity:**\n   - Can't use useState, useEffect, event handlers\n   - Need Client Components for interactivity\n\n2. **Framework Support:**\n   - Currently best supported in Next.js 13+\n   - Requires specific bundler configuration\n\n3. **Debugging Complexity:**\n   - Server and client code mixing\n   - Different execution environments\n\n4. **Learning Curve:**\n   - New mental model\n   - Understanding server/client boundaries\n\n**Best Practices:**\n- Use Server Components by default\n- Add 'use client' only when needed\n- Keep Client Components small and focused\n- Leverage Suspense for streaming\n- Use Server Actions for mutations\n- Implement proper error boundaries\n- Cache expensive operations appropriately",
      "keywords": ["React Server Components", "RSC", "server-side rendering", "client components", "server actions", "data fetching", "performance optimization", "bundle size", "caching", "Suspense"],
      "difficulty": "hard"
    }
  ]
}