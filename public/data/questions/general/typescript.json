{
  "technology": "typescript",
  "questions": [
    {
      "id": 1000,
      "tag": "typescript",
      "question": "What are the main benefits of using TypeScript over JavaScript?",
      "answer": "**Type Safety:**\n- Catch errors at compile-time instead of runtime\n- Prevent common bugs like undefined properties\n- Better code reliability\n\n**Developer Experience:**\n- Excellent IDE support with autocomplete\n- Intelligent refactoring\n- Better documentation through types\n\n**Code Quality:**\n- Self-documenting code\n- Easier maintenance and debugging\n- Better team collaboration\n\n**Modern JavaScript Features:**\n- Latest ECMAScript features\n- Compiles to older JavaScript versions\n- Optional static typing\n\n**Tooling:**\n- Better build tools integration\n- Enhanced testing capabilities\n- Rich ecosystem support\n\n**Example:**\n```typescript\n// TypeScript catches this error at compile time\ninterface User {\n  name: string;\n  age: number;\n}\n\nfunction greetUser(user: User) {\n  return `Hello, ${user.name}!`;\n}\n\ngreetUser({ name: 'John' }); // Error: missing 'age' property\n```",
      "keywords": ["type safety", "compile-time", "static typing", "IDE support", "autocomplete", "refactoring", "ECMAScript", "transpilation", "interfaces", "type checking"],
      "difficulty": "easy"
    },
    {
      "id": 1001,
      "tag": "typescript",
      "question": "Explain TypeScript interfaces and how they differ from types.",
      "answer": "**Interfaces:**\nDefine the structure of objects and can be extended or implemented.\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\n// Can be extended\ninterface AdminUser extends User {\n  permissions: string[];\n}\n\n// Can be merged (declaration merging)\ninterface User {\n  email?: string; // Adds email to existing User interface\n}\n```\n\n**Types:**\nMore flexible, can represent any type including primitives, unions, and computed types.\n\n```typescript\ntype User = {\n  name: string;\n  age: number;\n};\n\n// Union types\ntype Status = 'loading' | 'success' | 'error';\n\n// Computed types\ntype UserKeys = keyof User; // 'name' | 'age'\n```\n\n**Key Differences:**\n- **Extensibility:** Interfaces can be extended and merged, types cannot\n- **Flexibility:** Types can represent unions, primitives, computed types\n- **Performance:** Interfaces are slightly better for object shapes\n- **Use Cases:** Interfaces for object shapes, types for everything else",
      "keywords": ["interfaces", "types", "type aliases", "extends", "declaration merging", "union types", "intersection types", "keyof", "computed types", "object shapes", "primitives"],
      "difficulty": "medium"
    },
    {
      "id": 1002,
      "tag": "typescript",
      "question": "What are generics in TypeScript and why are they useful?",
      "answer": "Generics allow you to create reusable components that work with multiple types while maintaining type safety.\n\n**Basic Generic Function:**\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst result1 = identity<string>('hello'); // string\nconst result2 = identity<number>(42); // number\nconst result3 = identity('hello'); // Type inferred as string\n```\n\n**Generic Interfaces:**\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ntype UserResponse = ApiResponse<User>;\ntype ProductResponse = ApiResponse<Product[]>;\n```\n\n**Generic Classes:**\n```typescript\nclass DataStore<T> {\n  private data: T[] = [];\n  \n  add(item: T): void {\n    this.data.push(item);\n  }\n  \n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n}\n\nconst userStore = new DataStore<User>();\nconst productStore = new DataStore<Product>();\n```\n\n**Benefits:**\n- Type safety without sacrificing flexibility\n- Code reusability\n- Better IntelliSense and error detection\n- Self-documenting APIs",
      "keywords": ["generics", "type parameters", "type inference", "generic functions", "generic interfaces", "generic classes", "type constraints", "reusability", "polymorphism", "type safety"],
      "difficulty": "medium"
    },
    {
      "id": 1003,
      "tag": "typescript",
      "question": "What is the difference between type annotations and type inference in TypeScript?",
      "answer": "**Type Annotations:**\nExplicitly specify the type of a variable, parameter, or return value.\n\n```typescript\n// Explicit type annotations\nlet name: string = 'John';\nlet age: number = 30;\nlet isActive: boolean = true;\n\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n```\n\n**Type Inference:**\nTypeScript automatically determines the type based on the assigned value.\n\n```typescript\n// TypeScript infers types\nlet name = 'John'; // inferred as string\nlet age = 30; // inferred as number\nlet isActive = true; // inferred as boolean\n\nfunction add(a: number, b: number) {\n  return a + b; // return type inferred as number\n}\n```\n\n**When to Use Each:**\n- **Use annotations** when TypeScript can't infer the correct type\n- **Use annotations** for function parameters (required)\n- **Use inference** for simple variable assignments\n- **Use annotations** for better code documentation\n\n**Best Practice:**\nLet TypeScript infer types when possible, but add annotations for clarity in complex scenarios or public APIs.",
      "keywords": ["type annotations", "type inference", "explicit types", "implicit types", "variable declaration", "function signatures", "return types", "type checking"],
      "difficulty": "easy"
    },
    {
      "id": 1004,
      "tag": "typescript",
      "question": "How do union types work in TypeScript? Provide examples.",
      "answer": "Union types allow a variable to have one of several types, separated by the pipe (`|`) operator.\n\n**Basic Union Types:**\n```typescript\nlet value: string | number;\nvalue = 'hello'; // Valid\nvalue = 42; // Valid\n// value = true; // Error: boolean not in union\n\ntype Status = 'loading' | 'success' | 'error';\nlet currentStatus: Status = 'loading';\n```\n\n**Function Parameters:**\n```typescript\nfunction formatId(id: string | number): string {\n  // Type narrowing required\n  if (typeof id === 'string') {\n    return id.toUpperCase();\n  }\n  return id.toString();\n}\n\nformatId('abc123'); // 'ABC123'\nformatId(123); // '123'\n```\n\n**Array Union Types:**\n```typescript\nlet items: (string | number)[] = ['hello', 42, 'world', 100];\n```\n\n**Object Union Types:**\n```typescript\ntype Cat = { type: 'cat'; meow: () => void };\ntype Dog = { type: 'dog'; bark: () => void };\ntype Pet = Cat | Dog;\n\nfunction handlePet(pet: Pet) {\n  if (pet.type === 'cat') {\n    pet.meow(); // TypeScript knows it's a Cat\n  } else {\n    pet.bark(); // TypeScript knows it's a Dog\n  }\n}\n```\n\n**Benefits:**\n- Flexible type definitions\n- Type safety with multiple possibilities\n- Enables type narrowing",
      "keywords": ["union types", "pipe operator", "type narrowing", "typeof", "discriminated unions", "flexible types", "multiple types", "type guards"],
      "difficulty": "easy"
    },
    {
      "id": 1005,
      "tag": "typescript",
      "question": "What are intersection types and when would you use them?",
      "answer": "Intersection types combine multiple types into one using the ampersand (`&`) operator. The result must satisfy all combined types.\n\n**Basic Intersection:**\n```typescript\ntype Name = { name: string };\ntype Age = { age: number };\ntype Person = Name & Age;\n\nconst person: Person = {\n  name: 'John',\n  age: 30\n}; // Must have both properties\n```\n\n**Mixing Interfaces:**\n```typescript\ninterface Flyable {\n  fly(): void;\n}\n\ninterface Swimmable {\n  swim(): void;\n}\n\ntype FlyingFish = Flyable & Swimmable;\n\nclass Duck implements FlyingFish {\n  fly() { console.log('Flying!'); }\n  swim() { console.log('Swimming!'); }\n}\n```\n\n**Function Intersections:**\n```typescript\ntype EventHandler = {\n  onClick: (event: MouseEvent) => void;\n};\n\ntype FormHandler = {\n  onSubmit: (data: FormData) => void;\n};\n\ntype Component = EventHandler & FormHandler;\n// Must implement both onClick and onSubmit\n```\n\n**Use Cases:**\n- **Mixins:** Combining multiple behaviors\n- **Configuration objects:** Merging multiple option sets\n- **API responses:** Combining base response with specific data\n- **Component props:** Combining different prop interfaces\n\n**vs Union Types:**\n- **Intersection (`&`):** Must satisfy ALL types\n- **Union (`|`):** Must satisfy ONE of the types",
      "keywords": ["intersection types", "ampersand operator", "type combination", "mixins", "multiple inheritance", "interface merging", "type composition", "and operator"],
      "difficulty": "easy"
    },
    {
      "id": 1006,
      "tag": "typescript",
      "question": "Explain TypeScript enums and their different types with use cases.",
      "answer": "Enums allow you to define a set of named constants, making code more readable and maintainable.\n\n**Numeric Enums:**\n```typescript\nenum Direction {\n  Up,    // 0\n  Down,  // 1\n  Left,  // 2\n  Right  // 3\n}\n\n// Custom starting value\nenum Status {\n  Pending = 1,\n  Approved,  // 2\n  Rejected   // 3\n}\n\nconsole.log(Direction.Up); // 0\nconsole.log(Status.Approved); // 2\n```\n\n**String Enums:**\n```typescript\nenum Theme {\n  Light = 'light',\n  Dark = 'dark',\n  Auto = 'auto'\n}\n\n// More readable and debuggable\nconsole.log(Theme.Dark); // 'dark'\n```\n\n**Const Enums (Compile-time):**\n```typescript\nconst enum Colors {\n  Red = '#ff0000',\n  Green = '#00ff00',\n  Blue = '#0000ff'\n}\n\n// Inlined at compile time for better performance\nconst redColor = Colors.Red; // becomes const redColor = '#ff0000';\n```\n\n**Computed Enums:**\n```typescript\nenum FileAccess {\n  None,\n  Read = 1 << 1,     // 2\n  Write = 1 << 2,    // 4\n  ReadWrite = Read | Write  // 6\n}\n```\n\n**Use Cases:**\n- **API status codes**\n- **Configuration options**\n- **State management**\n- **Error codes**\n- **UI themes and modes**\n\n**Best Practices:**\n- Use string enums for better debugging\n- Use const enums for performance-critical code\n- Prefer union types for simple string literals",
      "keywords": ["enums", "numeric enums", "string enums", "const enums", "computed enums", "named constants", "configuration", "state management", "compile time"],
      "difficulty": "easy"
    },
    {
      "id": 1007,
      "tag": "typescript",
      "question": "What are type assertions in TypeScript and when should you use the 'as' keyword?",
      "answer": "Type assertions tell TypeScript to treat a value as a specific type when you know more about the type than TypeScript can infer.\n\n**Basic Type Assertions:**\n```typescript\n// Using 'as' keyword (preferred)\nlet someValue: unknown = 'Hello World';\nlet strLength: number = (someValue as string).length;\n\n// Angle bracket syntax (avoid in JSX)\nlet strLength2: number = (<string>someValue).length;\n```\n\n**DOM Element Assertions:**\n```typescript\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d'); // TypeScript knows canvas is HTMLCanvasElement\n\n// Without assertion\nconst element = document.getElementById('canvas'); // HTMLElement | null\n// element.getContext('2d'); // Error: Property doesn't exist on HTMLElement\n```\n\n**API Response Assertions:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\n\nasync function fetchUser(): Promise<User> {\n  const response = await fetch('/api/user');\n  const data = await response.json();\n  return data as User; // Assert API response shape\n}\n```\n\n**Non-null Assertion (!):**\n```typescript\nfunction processUser(user: User | null) {\n  // When you're certain user is not null\n  console.log(user!.name); // ! asserts non-null\n}\n```\n\n**When to Use:**\n- Working with DOM elements\n- API responses with known structure\n- Type narrowing when TypeScript can't infer\n- Legacy code integration\n\n**Warnings:**\n- Bypasses TypeScript's type checking\n- Use sparingly and only when necessary\n- Can hide potential runtime errors\n- Prefer type guards when possible",
      "keywords": ["type assertions", "as keyword", "type casting", "angle bracket syntax", "non-null assertion", "DOM elements", "API responses", "type narrowing", "unknown type"],
      "difficulty": "easy"
    },
    {
      "id": 1008,
      "tag": "typescript",
      "question": "How do optional properties and parameters work in TypeScript?",
      "answer": "Optional properties and parameters are marked with `?` and can be undefined or omitted.\n\n**Optional Object Properties:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email?: string; // Optional property\n  phone?: string;\n}\n\nconst user1: User = {\n  id: 1,\n  name: 'John'\n  // email and phone can be omitted\n};\n\nconst user2: User = {\n  id: 2,\n  name: 'Jane',\n  email: 'jane@example.com'\n};\n```\n\n**Optional Function Parameters:**\n```typescript\nfunction greet(name: string, greeting?: string): string {\n  return `${greeting || 'Hello'}, ${name}!`;\n}\n\ngreet('John'); // 'Hello, John!'\ngreet('John', 'Hi'); // 'Hi, John!'\n```\n\n**Optional Parameters with Defaults:**\n```typescript\nfunction createUser(name: string, role: string = 'user', active?: boolean) {\n  return {\n    name,\n    role,\n    active: active ?? true // Use nullish coalescing\n  };\n}\n\ncreateUser('John'); // { name: 'John', role: 'user', active: true }\ncreateUser('Jane', 'admin', false);\n```\n\n**Optional Chaining:**\n```typescript\ninterface Address {\n  street?: string;\n  city?: string;\n}\n\ninterface User {\n  name: string;\n  address?: Address;\n}\n\nfunction getCity(user: User): string | undefined {\n  return user.address?.city; // Safe navigation\n}\n```\n\n**Type Guards with Optional Properties:**\n```typescript\nfunction processUser(user: User) {\n  if (user.email) {\n    // TypeScript knows email is defined here\n    console.log(user.email.toLowerCase());\n  }\n}\n```\n\n**Important Notes:**\n- Optional parameters must come after required ones\n- Optional properties can be `undefined`\n- Use optional chaining (`?.`) for safe property access",
      "keywords": ["optional properties", "optional parameters", "question mark", "undefined", "optional chaining", "default parameters", "nullish coalescing", "type guards", "safe navigation"],
      "difficulty": "easy"
    },
    {
      "id": 1009,
      "tag": "typescript",
      "question": "Explain function types and signatures in TypeScript with examples.",
      "answer": "Function types define the shape of functions, including parameter types and return types.\n\n**Function Type Annotations:**\n```typescript\n// Function declaration\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Function expression\nconst multiply = (a: number, b: number): number => {\n  return a * b;\n};\n\n// Arrow function\nconst divide = (a: number, b: number): number => a / b;\n```\n\n**Function Type Aliases:**\n```typescript\ntype MathOperation = (a: number, b: number) => number;\n\nconst add: MathOperation = (a, b) => a + b;\nconst subtract: MathOperation = (a, b) => a - b;\n```\n\n**Function Interfaces:**\n```typescript\ninterface Calculator {\n  (a: number, b: number): number;\n}\n\n// Or with call signature\ninterface AdvancedCalculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n}\n```\n\n**Higher-Order Functions:**\n```typescript\ntype Predicate<T> = (item: T) => boolean;\ntype Mapper<T, U> = (item: T) => U;\n\nfunction filter<T>(items: T[], predicate: Predicate<T>): T[] {\n  return items.filter(predicate);\n}\n\nfunction map<T, U>(items: T[], mapper: Mapper<T, U>): U[] {\n  return items.map(mapper);\n}\n```\n\n**Function Overloads:**\n```typescript\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: boolean): string;\nfunction format(value: string | number | boolean): string {\n  return String(value);\n}\n```\n\n**Callback Types:**\n```typescript\ntype EventCallback = (event: Event) => void;\ntype ErrorCallback = (error: Error) => void;\n\nfunction fetchData(\n  url: string,\n  onSuccess: (data: any) => void,\n  onError: ErrorCallback\n) {\n  // Implementation\n}\n```\n\n**Benefits:**\n- Type safety for function parameters and returns\n- Better IDE support and autocomplete\n- Clear API contracts\n- Reusable function signatures",
      "keywords": ["function types", "function signatures", "type aliases", "call signatures", "higher-order functions", "function overloads", "callback types", "arrow functions", "type safety"],
      "difficulty": "easy"
    },
    {
      "id": 1010,
      "tag": "typescript",
      "question": "What are literal types and const assertions in TypeScript?",
      "answer": "Literal types represent exact values rather than general types, and const assertions help create more specific types.\n\n**String Literal Types:**\n```typescript\ntype Theme = 'light' | 'dark' | 'auto';\ntype ButtonSize = 'small' | 'medium' | 'large';\n\nfunction setTheme(theme: Theme) {\n  // Only accepts exact string values\n}\n\nsetTheme('light'); // ✓ Valid\nsetTheme('blue'); // ✗ Error\n```\n\n**Number Literal Types:**\n```typescript\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\ntype HttpStatus = 200 | 404 | 500;\n\nfunction handleStatus(status: HttpStatus) {\n  switch (status) {\n    case 200: return 'Success';\n    case 404: return 'Not Found';\n    case 500: return 'Server Error';\n  }\n}\n```\n\n**Boolean Literal Types:**\n```typescript\ntype IsEnabled = true; // Only accepts true\ntype IsDisabled = false; // Only accepts false\n```\n\n**Const Assertions:**\n```typescript\n// Without const assertion\nconst colors = ['red', 'green', 'blue']; // string[]\n\n// With const assertion\nconst colors = ['red', 'green', 'blue'] as const;\n// readonly ['red', 'green', 'blue']\n\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n```\n\n**Object Const Assertions:**\n```typescript\nconst config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3\n} as const;\n// All properties become readonly and literal types\n\ntype Config = typeof config;\n// {\n//   readonly apiUrl: 'https://api.example.com';\n//   readonly timeout: 5000;\n//   readonly retries: 3;\n// }\n```\n\n**Template Literal Types:**\n```typescript\ntype CSSProperty = `--${string}`;\ntype EventName = `on${Capitalize<string>}`;\n\ntype ButtonEvent = `button-${'click' | 'hover' | 'focus'}`;\n// 'button-click' | 'button-hover' | 'button-focus'\n```\n\n**Use Cases:**\n- Configuration objects\n- Discriminated unions\n- API endpoints and methods\n- CSS classes and IDs\n- State machine states",
      "keywords": ["literal types", "const assertions", "string literals", "number literals", "boolean literals", "template literals", "readonly", "exact values", "immutable", "type narrowing"],
      "difficulty": "easy"
    },
    {
      "id": 1011,
      "tag": "typescript",
      "question": "How do type guards and user-defined type guards work in TypeScript?",
      "answer": "Type guards are expressions that perform runtime checks to narrow types within conditional blocks.\n\n**Built-in Type Guards:**\n```typescript\nfunction processValue(value: string | number) {\n  if (typeof value === 'string') {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  } else {\n    // TypeScript knows value is number here\n    console.log(value.toFixed(2));\n  }\n}\n\n// instanceof guard\nclass Dog { bark() {} }\nclass Cat { meow() {} }\n\nfunction handlePet(pet: Dog | Cat) {\n  if (pet instanceof Dog) {\n    pet.bark(); // TypeScript knows it's a Dog\n  } else {\n    pet.meow(); // TypeScript knows it's a Cat\n  }\n}\n```\n\n**User-Defined Type Guards:**\n```typescript\ninterface Fish {\n  swim(): void;\n}\n\ninterface Bird {\n  fly(): void;\n}\n\n// Type predicate function\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n\nfunction handleAnimal(pet: Fish | Bird) {\n  if (isFish(pet)) {\n    pet.swim(); // TypeScript knows it's Fish\n  } else {\n    pet.fly(); // TypeScript knows it's Bird\n  }\n}\n```\n\n**Discriminated Unions with Type Guards:**\n```typescript\ninterface LoadingState {\n  status: 'loading';\n}\n\ninterface SuccessState {\n  status: 'success';\n  data: any;\n}\n\ninterface ErrorState {\n  status: 'error';\n  error: string;\n}\n\ntype AppState = LoadingState | SuccessState | ErrorState;\n\nfunction handleState(state: AppState) {\n  switch (state.status) {\n    case 'loading':\n      // TypeScript knows it's LoadingState\n      console.log('Loading...');\n      break;\n    case 'success':\n      // TypeScript knows it's SuccessState\n      console.log(state.data);\n      break;\n    case 'error':\n      // TypeScript knows it's ErrorState\n      console.log(state.error);\n      break;\n  }\n}\n```\n\n**Advanced Type Guards:**\n```typescript\n// Null/undefined guards\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\n// Array type guard\nfunction isStringArray(value: unknown): value is string[] {\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\n}\n```\n\n**Benefits:**\n- Runtime type safety\n- Automatic type narrowing\n- Better error handling\n- Cleaner conditional logic",
      "keywords": ["type guards", "user-defined type guards", "type predicates", "typeof", "instanceof", "discriminated unions", "type narrowing", "runtime checks", "conditional types", "is keyword"],
      "difficulty": "medium"
    },
    {
      "id": 1012,
      "tag": "typescript",
      "question": "Explain discriminated unions in TypeScript with practical examples.",
      "answer": "Discriminated unions (tagged unions) use a common property to distinguish between different types in a union, enabling type-safe pattern matching.\n\n**Basic Discriminated Union:**\n```typescript\ninterface Circle {\n  kind: 'circle'; // Discriminant property\n  radius: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';\n  width: number;\n  height: number;\n}\n\ninterface Square {\n  kind: 'square';\n  size: number;\n}\n\ntype Shape = Circle | Rectangle | Square;\n\nfunction calculateArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      // TypeScript knows it's Circle\n      return Math.PI * shape.radius ** 2;\n    case 'rectangle':\n      // TypeScript knows it's Rectangle\n      return shape.width * shape.height;\n    case 'square':\n      // TypeScript knows it's Square\n      return shape.size ** 2;\n    default:\n      // Exhaustiveness check\n      const _exhaustive: never = shape;\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n```\n\n**API Response Pattern:**\n```typescript\ninterface LoadingResponse {\n  status: 'loading';\n}\n\ninterface SuccessResponse {\n  status: 'success';\n  data: any;\n  timestamp: number;\n}\n\ninterface ErrorResponse {\n  status: 'error';\n  error: string;\n  code: number;\n}\n\ntype ApiResponse = LoadingResponse | SuccessResponse | ErrorResponse;\n\nfunction handleResponse(response: ApiResponse) {\n  switch (response.status) {\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Data: ${response.data} at ${response.timestamp}`;\n    case 'error':\n      return `Error ${response.code}: ${response.error}`;\n  }\n}\n```\n\n**Redux Action Pattern:**\n```typescript\ninterface IncrementAction {\n  type: 'INCREMENT';\n  payload?: number;\n}\n\ninterface DecrementAction {\n  type: 'DECREMENT';\n  payload?: number;\n}\n\ninterface ResetAction {\n  type: 'RESET';\n}\n\ntype CounterAction = IncrementAction | DecrementAction | ResetAction;\n\nfunction counterReducer(state: number, action: CounterAction): number {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + (action.payload ?? 1);\n    case 'DECREMENT':\n      return state - (action.payload ?? 1);\n    case 'RESET':\n      return 0;\n    default:\n      return state;\n  }\n}\n```\n\n**Form Validation Example:**\n```typescript\ninterface ValidField {\n  status: 'valid';\n  value: string;\n}\n\ninterface InvalidField {\n  status: 'invalid';\n  value: string;\n  errors: string[];\n}\n\ninterface PendingField {\n  status: 'pending';\n  value: string;\n}\n\ntype FieldState = ValidField | InvalidField | PendingField;\n\nfunction renderField(field: FieldState) {\n  switch (field.status) {\n    case 'valid':\n      return `✓ ${field.value}`;\n    case 'invalid':\n      return `✗ ${field.value}: ${field.errors.join(', ')}`;\n    case 'pending':\n      return `⏳ ${field.value}`;\n  }\n}\n```\n\n**Advantages:**\n- Exhaustive type checking\n- Compile-time safety\n- Clear state modeling\n- Eliminates impossible states\n- Better refactoring support",
      "keywords": ["discriminated unions", "tagged unions", "discriminant property", "pattern matching", "exhaustiveness checking", "never type", "state modeling", "type safety", "switch statements"],
      "difficulty": "medium"
    },
    {
      "id": 1013,
      "tag": "typescript",
      "question": "What are index signatures and mapped types in TypeScript? Provide basic examples.",
      "answer": "Index signatures define types for object properties when you don't know all property names ahead of time. Mapped types create new types by transforming existing ones.\n\n**Index Signatures:**\n```typescript\n// String index signature\ninterface StringDictionary {\n  [key: string]: string;\n}\n\nconst colors: StringDictionary = {\n  red: '#ff0000',\n  green: '#00ff00',\n  blue: '#0000ff'\n};\n\n// Number index signature\ninterface NumberArray {\n  [index: number]: string;\n}\n\nconst fruits: NumberArray = {\n  0: 'apple',\n  1: 'banana',\n  2: 'orange'\n};\n```\n\n**Mixed Index Signatures:**\n```typescript\ninterface MixedDictionary {\n  [key: string]: string | number;\n  length: number; // Must be compatible with index signature\n}\n\nconst data: MixedDictionary = {\n  name: 'John',\n  age: 30,\n  length: 2\n};\n```\n\n**Basic Mapped Types:**\n```typescript\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n};\n\n// Make all properties optional\ntype PartialUser = {\n  [K in keyof User]?: User[K];\n};\n// Equivalent to: { id?: number; name?: string; email?: string; }\n\n// Make all properties readonly\ntype ReadonlyUser = {\n  readonly [K in keyof User]: User[K];\n};\n```\n\n**Property Transformation:**\n```typescript\ntype StringifyValues<T> = {\n  [K in keyof T]: string;\n};\n\ntype UserStrings = StringifyValues<User>;\n// { id: string; name: string; email: string; }\n\n// Add prefix to keys\ntype PrefixKeys<T> = {\n  [K in keyof T as `prefix_${string & K}`]: T[K];\n};\n\ntype PrefixedUser = PrefixKeys<User>;\n// { prefix_id: number; prefix_name: string; prefix_email: string; }\n```\n\n**Record Type (Built-in Mapped Type):**\n```typescript\ntype Theme = 'light' | 'dark';\ntype ThemeConfig = Record<Theme, { background: string; text: string }>;\n\nconst themes: ThemeConfig = {\n  light: { background: 'white', text: 'black' },\n  dark: { background: 'black', text: 'white' }\n};\n```\n\n**Practical Use Cases:**\n```typescript\n// Configuration objects\ninterface ApiEndpoints {\n  [endpoint: string]: string;\n}\n\nconst endpoints: ApiEndpoints = {\n  users: '/api/users',\n  posts: '/api/posts',\n  comments: '/api/comments'\n};\n\n// Dynamic form fields\ninterface FormData {\n  [fieldName: string]: string | number | boolean;\n}\n```\n\n**Benefits:**\n- Flexible object shapes\n- Type safety for dynamic properties\n- Code reuse through transformation\n- Better API modeling",
      "keywords": ["index signatures", "mapped types", "dynamic properties", "keyof operator", "property transformation", "Record type", "string index", "number index", "type transformation"],
      "difficulty": "medium"
    },
    {
      "id": 1014,
      "tag": "typescript",
      "question": "Explain the keyof operator and lookup types in TypeScript with examples.",
      "answer": "The `keyof` operator extracts property names as a union of string literals, while lookup types access property types from other types.\n\n**keyof Operator:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  isActive: boolean;\n}\n\n// Extract all property names\ntype UserKeys = keyof User; // 'id' | 'name' | 'email' | 'isActive'\n\n// Use in function parameters\nfunction getProperty(user: User, key: keyof User) {\n  return user[key]; // Type-safe property access\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com', isActive: true };\nconst name = getProperty(user, 'name'); // string\nconst id = getProperty(user, 'id'); // number\n```\n\n**Lookup Types (Indexed Access Types):**\n```typescript\n// Access specific property type\ntype UserName = User['name']; // string\ntype UserId = User['id']; // number\n\n// Access multiple property types\ntype UserNameOrEmail = User['name' | 'email']; // string\n\n// Access all property types\ntype UserValue = User[keyof User]; // string | number | boolean\n```\n\n**Generic Property Access:**\n```typescript\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst userName = getValue(user, 'name'); // Inferred as string\nconst userId = getValue(user, 'id'); // Inferred as number\n// getValue(user, 'invalid'); // Error: Argument not assignable\n```\n\n**Nested Property Access:**\n```typescript\ninterface Address {\n  street: string;\n  city: string;\n  zipCode: string;\n}\n\ninterface Profile {\n  user: User;\n  address: Address;\n  preferences: {\n    theme: 'light' | 'dark';\n    language: string;\n  };\n}\n\n// Deep property access\ntype ProfileCity = Profile['address']['city']; // string\ntype ThemeType = Profile['preferences']['theme']; // 'light' | 'dark'\n```\n\n**Array and Tuple Lookups:**\n```typescript\ntype StringArray = string[];\ntype ArrayElement = StringArray[number]; // string\n\ntype Tuple = [string, number, boolean];\ntype FirstElement = Tuple[0]; // string\ntype SecondElement = Tuple[1]; // number\ntype AnyElement = Tuple[number]; // string | number | boolean\n```\n\n**Practical Examples:**\n```typescript\n// Type-safe object manipulation\nfunction pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n}\n\nconst partialUser = pick(user, ['name', 'email']);\n// Type: { name: string; email: string; }\n\n// Dynamic property validation\nfunction hasProperty<T, K extends keyof T>(obj: T, key: K): obj is T & Record<K, NonNullable<T[K]>> {\n  return obj[key] != null;\n}\n\nif (hasProperty(user, 'email')) {\n  // TypeScript knows email is not null/undefined\n  console.log(user.email.toLowerCase());\n}\n```\n\n**Benefits:**\n- Type-safe property access\n- Generic utility functions\n- Dynamic property handling\n- Compile-time property validation\n- Better refactoring support",
      "keywords": ["keyof operator", "lookup types", "indexed access types", "property names", "property types", "type-safe access", "generic constraints", "nested properties", "array indexing"],
      "difficulty": "medium"
    },
    {
      "id": 1015,
      "tag": "typescript",
      "question": "What are TypeScript utility types? Explain Partial, Required, Pick, and Omit with examples.",
      "answer": "Utility types are built-in generic types that facilitate common type transformations. They help create new types based on existing ones.\n\n**Partial<T>:**\nMakes all properties optional.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype PartialUser = Partial<User>;\n// Equivalent to: { id?: number; name?: string; email?: string; age?: number; }\n\n// Use case: Update functions\nfunction updateUser(id: number, updates: Partial<User>) {\n  // Can update any subset of properties\n}\n\nupdateUser(1, { name: 'John' }); // Valid\nupdateUser(2, { email: 'jane@example.com', age: 25 }); // Valid\n```\n\n**Required<T>:**\nMakes all properties required (opposite of Partial).\n\n```typescript\ninterface OptionalConfig {\n  apiUrl?: string;\n  timeout?: number;\n  retries?: number;\n}\n\ntype RequiredConfig = Required<OptionalConfig>;\n// Equivalent to: { apiUrl: string; timeout: number; retries: number; }\n\nfunction initializeApp(config: RequiredConfig) {\n  // All properties are guaranteed to exist\n  console.log(config.apiUrl); // No optional chaining needed\n}\n```\n\n**Pick<T, K>:**\nCreates a type by picking specific properties from T.\n\n```typescript\ntype UserSummary = Pick<User, 'id' | 'name'>;\n// Equivalent to: { id: number; name: string; }\n\ntype UserContact = Pick<User, 'name' | 'email'>;\n// Equivalent to: { name: string; email: string; }\n\n// Use case: API responses\nfunction getUserSummary(): UserSummary {\n  return { id: 1, name: 'John' };\n}\n\n// Use case: Form data\nfunction createUserForm(): Pick<User, 'name' | 'email' | 'age'> {\n  return {\n    name: '',\n    email: '',\n    age: 0\n  };\n}\n```\n\n**Omit<T, K>:**\nCreates a type by omitting specific properties from T.\n\n```typescript\ntype UserWithoutId = Omit<User, 'id'>;\n// Equivalent to: { name: string; email: string; age: number; }\n\ntype PublicUser = Omit<User, 'id' | 'email'>;\n// Equivalent to: { name: string; age: number; }\n\n// Use case: Create operations (without ID)\nfunction createUser(user: Omit<User, 'id'>): User {\n  return {\n    id: Math.random(), // Generated ID\n    ...user\n  };\n}\n\n// Use case: Sensitive data removal\nfunction getPublicProfile(user: User): PublicUser {\n  const { id, email, ...publicData } = user;\n  return publicData;\n}\n```\n\n**Combining Utility Types:**\n```typescript\n// Optional fields except required ones\ntype UserUpdate = Partial<User> & Pick<User, 'id'>;\n// { id: number; name?: string; email?: string; age?: number; }\n\n// Required creation data (without generated fields)\ntype CreateUserData = Required<Omit<User, 'id'>>;\n// { name: string; email: string; age: number; }\n\n// Partial update excluding certain fields\ntype UserProfileUpdate = Partial<Omit<User, 'id' | 'email'>>;\n// { name?: string; age?: number; }\n```\n\n**Practical Use Cases:**\n```typescript\n// Database operations\ninterface Repository<T> {\n  create(data: Omit<T, 'id'>): Promise<T>;\n  update(id: string, data: Partial<T>): Promise<T>;\n  findById(id: string): Promise<T | null>;\n}\n\n// Form handling\ntype FormState<T> = {\n  values: Partial<T>;\n  errors: Partial<Record<keyof T, string>>;\n  touched: Partial<Record<keyof T, boolean>>;\n};\n```\n\n**Benefits:**\n- Reduce code duplication\n- Type-safe transformations\n- Better API design\n- Consistent data handling\n- Improved maintainability",
      "keywords": ["utility types", "Partial", "Required", "Pick", "Omit", "type transformations", "generic types", "property manipulation", "optional properties", "type safety"],
      "difficulty": "medium"
    },
    {
      "id": 1016,
      "tag": "typescript",
      "question": "What are the 'never' and 'unknown' types in TypeScript? When would you use each?",
      "answer": "**Never Type:**\nRepresents values that never occur. Functions that never return or throw errors have a `never` return type.\n\n```typescript\n// Function that never returns\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\n// Infinite loop function\nfunction infiniteLoop(): never {\n  while (true) {\n    // Never exits\n  }\n}\n\n// Exhaustiveness checking\ntype Shape = 'circle' | 'square';\n\nfunction getArea(shape: Shape): number {\n  switch (shape) {\n    case 'circle': return Math.PI * 5 ** 2;\n    case 'square': return 5 ** 2;\n    default:\n      const _exhaustive: never = shape; // Ensures all cases covered\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n```\n\n**Unknown Type:**\nTop type that's safer than `any`. Requires type checking before use.\n\n```typescript\nlet value: unknown;\n\nvalue = 'hello';\nvalue = 42;\nvalue = true;\nvalue = { name: 'John' };\n\n// Must check type before use\nif (typeof value === 'string') {\n  console.log(value.toUpperCase()); // Safe\n}\n\n// Type guards with unknown\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nif (isString(value)) {\n  console.log(value.length); // TypeScript knows it's string\n}\n```\n\n**Use Cases:**\n- **Never:** Exhaustiveness checking, error functions, impossible states\n- **Unknown:** API responses, user input, safer alternative to `any`\n\n**Key Differences:**\n- `never` is bottom type (no values), `unknown` is top type (all values)\n- `never` used for control flow, `unknown` for type safety\n- Can't assign anything to `never`, can assign anything to `unknown`",
      "keywords": ["never type", "unknown type", "bottom type", "top type", "exhaustiveness checking", "type safety", "type guards", "control flow", "error handling"],
      "difficulty": "easy"
    },
    {
      "id": 1017,
      "tag": "typescript",
      "question": "How do the 'readonly' modifier and 'ReadonlyArray' work in TypeScript?",
      "answer": "The `readonly` modifier prevents modification of properties after initialization, providing immutability at the type level.\n\n**Readonly Properties:**\n```typescript\ninterface User {\n  readonly id: number;\n  name: string;\n  readonly createdAt: Date;\n}\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  createdAt: new Date()\n};\n\nuser.name = 'Jane'; // ✓ Allowed\nuser.id = 2; // ✗ Error: Cannot assign to readonly property\nuser.createdAt = new Date(); // ✗ Error: Cannot assign to readonly property\n```\n\n**ReadonlyArray:**\n```typescript\n// ReadonlyArray type\nconst numbers: ReadonlyArray<number> = [1, 2, 3, 4];\nconst names: readonly string[] = ['Alice', 'Bob', 'Charlie'];\n\n// Reading is allowed\nconsole.log(numbers[0]); // ✓ 1\nconsole.log(numbers.length); // ✓ 4\n\n// Mutation methods are not available\nnumbers.push(5); // ✗ Error: Property 'push' does not exist\nnumbers.pop(); // ✗ Error: Property 'pop' does not exist\nnumbers[0] = 10; // ✗ Error: Index signature only permits reading\n```\n\n**Readonly Utility Type:**\n```typescript\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n  features: string[];\n}\n\ntype ReadonlyConfig = Readonly<Config>;\n// {\n//   readonly apiUrl: string;\n//   readonly timeout: number;\n//   readonly features: readonly string[];\n// }\n\nconst config: ReadonlyConfig = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  features: ['auth', 'logging']\n};\n\nconfig.apiUrl = 'new-url'; // ✗ Error: Cannot assign to readonly property\n```\n\n**Deep Readonly:**\n```typescript\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedConfig {\n  database: {\n    host: string;\n    port: number;\n  };\n  cache: {\n    ttl: number;\n    maxSize: number;\n  };\n}\n\ntype ImmutableConfig = DeepReadonly<NestedConfig>;\n// All nested properties become readonly\n```\n\n**Const Assertions:**\n```typescript\n// Creates readonly arrays and objects\nconst colors = ['red', 'green', 'blue'] as const;\n// readonly ['red', 'green', 'blue']\n\nconst theme = {\n  primary: '#007bff',\n  secondary: '#6c757d'\n} as const;\n// { readonly primary: '#007bff'; readonly secondary: '#6c757d'; }\n```\n\n**Benefits:**\n- Prevents accidental mutations\n- Functional programming support\n- Better API contracts\n- Compile-time immutability guarantees\n- Safer data sharing between components",
      "keywords": ["readonly modifier", "ReadonlyArray", "immutability", "readonly properties", "const assertions", "deep readonly", "mutation prevention", "functional programming"],
      "difficulty": "easy"
    },
    {
      "id": 1018,
      "tag": "typescript",
      "question": "What are tuple types and labeled tuples in TypeScript? Provide examples.",
      "answer": "Tuples are arrays with fixed length and specific types for each element. Labeled tuples provide names for better documentation.\n\n**Basic Tuples:**\n```typescript\n// Fixed-length array with specific types\ntype Point = [number, number];\ntype RGB = [number, number, number];\n\nconst point: Point = [10, 20];\nconst color: RGB = [255, 128, 0];\n\n// Type checking\nconst invalid: Point = [10]; // ✗ Error: Source has 1 elements but target requires 2\nconst wrongType: RGB = [255, '128', 0]; // ✗ Error: string not assignable to number\n```\n\n**Accessing Tuple Elements:**\n```typescript\nconst coordinates: [number, number, string] = [40.7128, -74.0060, 'NYC'];\n\nconst latitude = coordinates[0]; // number\nconst longitude = coordinates[1]; // number\nconst city = coordinates[2]; // string\n\n// Destructuring\nconst [lat, lng, name] = coordinates;\n```\n\n**Optional Tuple Elements:**\n```typescript\ntype HTTPResponse = [number, string, object?];\n\nconst success: HTTPResponse = [200, 'OK'];\nconst withData: HTTPResponse = [200, 'OK', { user: 'John' }];\nconst error: HTTPResponse = [404, 'Not Found'];\n```\n\n**Rest Elements in Tuples:**\n```typescript\ntype StringNumberBooleans = [string, number, ...boolean[]];\n\nconst example1: StringNumberBooleans = ['hello', 42];\nconst example2: StringNumberBooleans = ['world', 100, true, false, true];\n\n// Mixed rest elements\ntype Mixed = [string, ...number[], boolean];\nconst mixed: Mixed = ['start', 1, 2, 3, 4, true];\n```\n\n**Labeled Tuples (TypeScript 4.0+):**\n```typescript\n// Better documentation and IDE support\ntype User = [id: number, name: string, email: string];\ntype Coordinates = [x: number, y: number, z?: number];\ntype Range = [start: number, end: number];\n\nconst user: User = [1, 'John Doe', 'john@example.com'];\nconst point2D: Coordinates = [10, 20];\nconst point3D: Coordinates = [10, 20, 30];\nconst range: Range = [0, 100];\n\n// Function parameters\nfunction drawLine(from: [x: number, y: number], to: [x: number, y: number]) {\n  // Implementation\n}\n\ndrawLine([0, 0], [100, 100]);\n```\n\n**Tuple with Named Properties:**\n```typescript\ninterface Coordinate {\n  0: number; // x\n  1: number; // y\n  length: 2;\n}\n\nfunction distance(point1: Coordinate, point2: Coordinate): number {\n  const dx = point1[0] - point2[0];\n  const dy = point1[1] - point2[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n```\n\n**Practical Use Cases:**\n```typescript\n// React useState pattern\ntype State<T> = [T, (value: T) => void];\n\n// Database query results\ntype QueryResult = [data: any[], count: number, hasMore: boolean];\n\n// API endpoints\ntype Endpoint = [method: 'GET' | 'POST' | 'PUT' | 'DELETE', path: string, handler: Function];\n\nconst endpoints: Endpoint[] = [\n  ['GET', '/users', getUsersHandler],\n  ['POST', '/users', createUserHandler],\n  ['PUT', '/users/:id', updateUserHandler]\n];\n```\n\n**Benefits:**\n- Fixed structure with type safety\n- Better than arrays for known fixed data\n- Improved IDE support with labels\n- Clear function signatures\n- Destructuring support",
      "keywords": ["tuple types", "labeled tuples", "fixed arrays", "destructuring", "optional elements", "rest elements", "type safety", "named parameters", "structured data"],
      "difficulty": "easy"
    },
    {
      "id": 1019,
      "tag": "typescript",
      "question": "What are the key differences between interfaces and type aliases in TypeScript?",
      "answer": "While interfaces and type aliases can often be used interchangeably for object types, they have distinct characteristics and use cases.\n\n**Declaration Merging:**\n```typescript\n// Interfaces support declaration merging\ninterface User {\n  name: string;\n}\n\ninterface User {\n  age: number;\n}\n\n// Merged into: { name: string; age: number; }\nconst user: User = { name: 'John', age: 30 };\n\n// Type aliases cannot be merged\ntype Product = { name: string; };\ntype Product = { price: number; }; // ✗ Error: Duplicate identifier\n```\n\n**Extending vs Intersection:**\n```typescript\n// Interface extending\ninterface Animal {\n  name: string;\n}\n\ninterface Dog extends Animal {\n  breed: string;\n}\n\n// Type alias intersection\ntype Animal = {\n  name: string;\n};\n\ntype Dog = Animal & {\n  breed: string;\n};\n\n// Both work similarly for objects\nconst dog: Dog = { name: 'Buddy', breed: 'Golden Retriever' };\n```\n\n**Flexibility Differences:**\n```typescript\n// Type aliases are more flexible\ntype StringOrNumber = string | number; // Union types\ntype StringArray = string[]; // Array types\ntype StringMap = Record<string, string>; // Utility types\ntype Callback = (value: string) => void; // Function types\n\n// Interfaces are primarily for object shapes\ninterface UserCallback {\n  (value: string): void; // Call signature\n}\n\ninterface StringDictionary {\n  [key: string]: string; // Index signature\n}\n```\n\n**Computed Properties:**\n```typescript\n// Type aliases support computed properties\ntype EventTypes = 'click' | 'hover' | 'focus';\ntype EventHandlers = {\n  [K in EventTypes as `on${Capitalize<K>}`]: () => void;\n};\n// { onClick: () => void; onHover: () => void; onFocus: () => void; }\n\n// Interfaces cannot use computed properties directly\ninterface EventHandlersInterface {\n  onClick: () => void;\n  onHover: () => void;\n  onFocus: () => void;\n}\n```\n\n**Conditional Types:**\n```typescript\n// Type aliases support conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype IsArray<T> = T extends any[] ? true : false;\n\n// Interfaces cannot use conditional logic\n```\n\n**Performance Considerations:**\n```typescript\n// Interfaces are better for object types (slight performance benefit)\ninterface UserInterface {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Type aliases create aliases (indirection)\ntype UserType = {\n  id: number;\n  name: string;\n  email: string;\n};\n```\n\n**Implementation:**\n```typescript\n// Both can be implemented by classes\ninterface Flyable {\n  fly(): void;\n}\n\ntype Swimmable = {\n  swim(): void;\n};\n\nclass Duck implements Flyable, Swimmable {\n  fly() { console.log('Flying'); }\n  swim() { console.log('Swimming'); }\n}\n```\n\n**Error Messages:**\n```typescript\n// Interfaces often provide clearer error messages\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n}\n\ntype ConfigType = {\n  apiUrl: string;\n  timeout: number;\n};\n\n// Error messages may be more readable with interfaces\n```\n\n**Best Practices:**\n- Use **interfaces** for object shapes that might be extended\n- Use **type aliases** for unions, primitives, and complex types\n- Use **interfaces** for public APIs (library authors)\n- Use **type aliases** for internal type manipulation\n- Choose **interfaces** when declaration merging is needed\n- Choose **type aliases** for computed/conditional types",
      "keywords": ["interfaces", "type aliases", "declaration merging", "extending", "intersection types", "computed properties", "conditional types", "performance", "flexibility", "object shapes"],
      "difficulty": "easy"
    },
    {
      "id": 1020,
      "tag": "typescript",
      "question": "How do interface extension and interface merging work in TypeScript?",
      "answer": "TypeScript supports extending interfaces to create hierarchies and merging multiple interface declarations with the same name.\n\n**Interface Extension:**\n```typescript\n// Base interface\ninterface Animal {\n  name: string;\n  age: number;\n}\n\n// Single inheritance\ninterface Dog extends Animal {\n  breed: string;\n  bark(): void;\n}\n\nconst myDog: Dog = {\n  name: 'Buddy',\n  age: 3,\n  breed: 'Golden Retriever',\n  bark() { console.log('Woof!'); }\n};\n```\n\n**Multiple Inheritance:**\n```typescript\ninterface Flyable {\n  fly(): void;\n  altitude: number;\n}\n\ninterface Swimmable {\n  swim(): void;\n  depth: number;\n}\n\n// Extend multiple interfaces\ninterface Duck extends Animal, Flyable, Swimmable {\n  quack(): void;\n}\n\nconst duck: Duck = {\n  name: 'Donald',\n  age: 2,\n  altitude: 100,\n  depth: 5,\n  fly() { console.log('Flying'); },\n  swim() { console.log('Swimming'); },\n  quack() { console.log('Quack!'); }\n};\n```\n\n**Interface Merging (Declaration Merging):**\n```typescript\n// First declaration\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Second declaration - automatically merged\ninterface User {\n  email: string;\n  isActive: boolean;\n}\n\n// Third declaration - merged again\ninterface User {\n  createdAt: Date;\n}\n\n// Final merged interface:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   isActive: boolean;\n//   createdAt: Date;\n// }\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  isActive: true,\n  createdAt: new Date()\n};\n```\n\n**Module Augmentation:**\n```typescript\n// Extending existing modules/libraries\ndeclare global {\n  interface Window {\n    customProperty: string;\n    myCustomMethod(): void;\n  }\n}\n\n// Now available globally\nwindow.customProperty = 'Hello';\nwindow.myCustomMethod = () => console.log('Custom method');\n\n// Extending third-party library types\ndeclare module 'express' {\n  interface Request {\n    user?: {\n      id: number;\n      role: string;\n    };\n  }\n}\n\n// Now req.user is available in Express handlers\n```\n\n**Namespace Merging:**\n```typescript\nnamespace MyNamespace {\n  export interface Config {\n    apiUrl: string;\n  }\n}\n\nnamespace MyNamespace {\n  export interface Config {\n    timeout: number;\n  }\n  \n  export function createConfig(): Config {\n    return {\n      apiUrl: 'https://api.example.com',\n      timeout: 5000\n    };\n  }\n}\n```\n\n**Function Overload Merging:**\n```typescript\ninterface Calculator {\n  add(a: number, b: number): number;\n}\n\ninterface Calculator {\n  add(a: string, b: string): string;\n}\n\n// Merged interface supports both overloads\nclass MyCalculator implements Calculator {\n  add(a: number | string, b: number | string): number | string {\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a + b;\n    }\n    return String(a) + String(b);\n  }\n}\n```\n\n**Practical Use Cases:**\n```typescript\n// Plugin architecture\ninterface PluginAPI {\n  version: string;\n}\n\n// Plugins can extend the API\ninterface PluginAPI {\n  logger: {\n    log(message: string): void;\n  };\n}\n\ninterface PluginAPI {\n  database: {\n    query(sql: string): Promise<any>;\n  };\n}\n\n// Configuration merging\ninterface AppConfig {\n  development: {\n    apiUrl: string;\n  };\n}\n\ninterface AppConfig {\n  production: {\n    apiUrl: string;\n    ssl: boolean;\n  };\n}\n```\n\n**Benefits:**\n- Code organization and reusability\n- Gradual API enhancement\n- Library type augmentation\n- Plugin system support\n- Modular type definitions",
      "keywords": ["interface extension", "interface merging", "declaration merging", "multiple inheritance", "module augmentation", "namespace merging", "function overloads", "plugin architecture", "type hierarchy"],
      "difficulty": "easy"
    },
    {
      "id": 1021,
      "tag": "typescript",
      "question": "How do default parameters and function overloads work in TypeScript?",
      "answer": "TypeScript supports default parameters for cleaner function signatures and function overloads for handling different parameter combinations.\n\n**Default Parameters:**\n```typescript\n// Basic default parameters\nfunction greet(name: string, greeting: string = 'Hello'): string {\n  return `${greeting}, ${name}!`;\n}\n\ngreet('John'); // 'Hello, John!'\ngreet('Jane', 'Hi'); // 'Hi, Jane!'\n\n// Default parameters can reference previous parameters\nfunction createUser(name: string, email: string = `${name.toLowerCase()}@example.com`) {\n  return { name, email };\n}\n\ncreateUser('John'); // { name: 'John', email: 'john@example.com' }\n```\n\n**Default Parameters with Complex Types:**\n```typescript\ninterface Options {\n  timeout: number;\n  retries: number;\n  verbose: boolean;\n}\n\nconst defaultOptions: Options = {\n  timeout: 5000,\n  retries: 3,\n  verbose: false\n};\n\nfunction fetchData(url: string, options: Options = defaultOptions): Promise<any> {\n  // Implementation\n  return Promise.resolve();\n}\n\n// Partial defaults with object merging\nfunction apiCall(endpoint: string, config: Partial<Options> = {}): Promise<any> {\n  const finalConfig = { ...defaultOptions, ...config };\n  return fetchData(endpoint, finalConfig);\n}\n```\n\n**Function Overloads:**\n```typescript\n// Multiple function signatures\nfunction combine(a: string, b: string): string;\nfunction combine(a: number, b: number): number;\nfunction combine(a: string[], b: string[]): string[];\n\n// Implementation signature (not part of public API)\nfunction combine(a: any, b: any): any {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a + b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  throw new Error('Invalid arguments');\n}\n\nconst str = combine('Hello', ' World'); // string\nconst num = combine(5, 10); // number\nconst arr = combine(['a'], ['b']); // string[]\n```\n\n**Method Overloads in Classes:**\n```typescript\nclass Calculator {\n  // Overload signatures\n  multiply(a: number, b: number): number;\n  multiply(a: string, times: number): string;\n  \n  // Implementation\n  multiply(a: number | string, b: number): number | string {\n    if (typeof a === 'number') {\n      return a * b;\n    }\n    return a.repeat(b);\n  }\n}\n\nconst calc = new Calculator();\nconst result1 = calc.multiply(5, 3); // 15\nconst result2 = calc.multiply('Hello', 3); // 'HelloHelloHello'\n```\n\n**Optional Parameters vs Overloads:**\n```typescript\n// Using optional parameters\nfunction format1(value: number, decimals?: number): string {\n  return decimals ? value.toFixed(decimals) : value.toString();\n}\n\n// Using overloads for different behavior\nfunction format2(value: number): string;\nfunction format2(value: number, decimals: number): string;\nfunction format2(value: number, decimals?: number): string {\n  if (decimals === undefined) {\n    return value.toString();\n  }\n  return value.toFixed(decimals);\n}\n```\n\n**Complex Overload Patterns:**\n```typescript\n// Event listener overloads\ninterface EventMap {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  load: Event;\n}\n\nfunction addEventListener<K extends keyof EventMap>(\n  type: K,\n  listener: (event: EventMap[K]) => void\n): void;\nfunction addEventListener(\n  type: string,\n  listener: (event: Event) => void\n): void;\nfunction addEventListener(\n  type: string,\n  listener: (event: any) => void\n): void {\n  // Implementation\n}\n\n// Type-safe event handling\naddEventListener('click', (e) => {\n  console.log(e.clientX); // MouseEvent properties available\n});\n\naddEventListener('keydown', (e) => {\n  console.log(e.key); // KeyboardEvent properties available\n});\n```\n\n**Constructor Overloads:**\n```typescript\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(coordinates: { x: number; y: number });\n  constructor(xOrCoords: number | { x: number; y: number }, y?: number) {\n    if (typeof xOrCoords === 'number') {\n      this.x = xOrCoords;\n      this.y = y!;\n    } else {\n      this.x = xOrCoords.x;\n      this.y = xOrCoords.y;\n    }\n  }\n}\n\nconst point1 = new Point(10, 20);\nconst point2 = new Point({ x: 10, y: 20 });\n```\n\n**Best Practices:**\n- Use default parameters when the default value is simple and commonly used\n- Use overloads when different parameter types require different logic\n- Keep overloads simple and well-documented\n- Consider union types instead of overloads when possible\n- Place most specific overloads first",
      "keywords": ["default parameters", "function overloads", "optional parameters", "method overloads", "constructor overloads", "parameter types", "function signatures", "type safety", "API design"],
      "difficulty": "easy"
    },
    {
      "id": 1022,
      "tag": "typescript",
      "question": "What are abstract classes and abstract methods in TypeScript? Provide examples.",
      "answer": "Abstract classes are base classes that cannot be instantiated directly and may contain abstract methods that must be implemented by subclasses.\n\n**Basic Abstract Class:**\n```typescript\nabstract class Animal {\n  name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  // Concrete method\n  move(): void {\n    console.log(`${this.name} is moving`);\n  }\n  \n  // Abstract method - must be implemented by subclasses\n  abstract makeSound(): void;\n  abstract getSpecies(): string;\n}\n\n// Cannot instantiate abstract class\n// const animal = new Animal('Generic'); // ✗ Error\n```\n\n**Implementing Abstract Classes:**\n```typescript\nclass Dog extends Animal {\n  breed: string;\n  \n  constructor(name: string, breed: string) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  // Must implement abstract methods\n  makeSound(): void {\n    console.log(`${this.name} barks: Woof!`);\n  }\n  \n  getSpecies(): string {\n    return 'Canis familiaris';\n  }\n  \n  // Additional method specific to Dog\n  fetch(): void {\n    console.log(`${this.name} fetches the ball`);\n  }\n}\n\nclass Cat extends Animal {\n  indoor: boolean;\n  \n  constructor(name: string, indoor: boolean = true) {\n    super(name);\n    this.indoor = indoor;\n  }\n  \n  makeSound(): void {\n    console.log(`${this.name} meows: Meow!`);\n  }\n  \n  getSpecies(): string {\n    return 'Felis catus';\n  }\n}\n\nconst dog = new Dog('Buddy', 'Golden Retriever');\nconst cat = new Cat('Whiskers');\n\ndog.makeSound(); // 'Buddy barks: Woof!'\ncat.makeSound(); // 'Whiskers meows: Meow!'\n```\n\n**Abstract Properties:**\n```typescript\nabstract class Shape {\n  abstract readonly name: string;\n  abstract area: number;\n  \n  // Abstract getter/setter\n  abstract get perimeter(): number;\n  abstract set color(value: string);\n  \n  // Concrete method using abstract properties\n  describe(): string {\n    return `This ${this.name} has an area of ${this.area}`;\n  }\n}\n\nclass Rectangle extends Shape {\n  readonly name = 'Rectangle';\n  private _color: string = 'black';\n  \n  constructor(public width: number, public height: number) {\n    super();\n  }\n  \n  get area(): number {\n    return this.width * this.height;\n  }\n  \n  get perimeter(): number {\n    return 2 * (this.width + this.height);\n  }\n  \n  set color(value: string) {\n    this._color = value;\n  }\n  \n  get color(): string {\n    return this._color;\n  }\n}\n```\n\n**Abstract Classes with Generics:**\n```typescript\nabstract class Repository<T> {\n  protected items: T[] = [];\n  \n  // Concrete methods\n  findAll(): T[] {\n    return this.items;\n  }\n  \n  findById(id: string): T | undefined {\n    return this.items.find(item => this.getId(item) === id);\n  }\n  \n  // Abstract methods\n  abstract getId(item: T): string;\n  abstract validate(item: T): boolean;\n  abstract save(item: T): Promise<T>;\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nclass UserRepository extends Repository<User> {\n  getId(user: User): string {\n    return user.id;\n  }\n  \n  validate(user: User): boolean {\n    return user.name.length > 0 && user.email.includes('@');\n  }\n  \n  async save(user: User): Promise<User> {\n    if (!this.validate(user)) {\n      throw new Error('Invalid user data');\n    }\n    this.items.push(user);\n    return user;\n  }\n}\n```\n\n**Factory Pattern with Abstract Classes:**\n```typescript\nabstract class DatabaseConnection {\n  abstract connect(): Promise<void>;\n  abstract disconnect(): Promise<void>;\n  abstract query(sql: string): Promise<any[]>;\n  \n  // Template method pattern\n  async executeTransaction<T>(operation: () => Promise<T>): Promise<T> {\n    await this.connect();\n    try {\n      const result = await operation();\n      return result;\n    } finally {\n      await this.disconnect();\n    }\n  }\n}\n\nclass PostgreSQLConnection extends DatabaseConnection {\n  async connect(): Promise<void> {\n    console.log('Connecting to PostgreSQL...');\n  }\n  \n  async disconnect(): Promise<void> {\n    console.log('Disconnecting from PostgreSQL...');\n  }\n  \n  async query(sql: string): Promise<any[]> {\n    console.log(`Executing PostgreSQL query: ${sql}`);\n    return [];\n  }\n}\n\nclass MySQLConnection extends DatabaseConnection {\n  async connect(): Promise<void> {\n    console.log('Connecting to MySQL...');\n  }\n  \n  async disconnect(): Promise<void> {\n    console.log('Disconnecting from MySQL...');\n  }\n  \n  async query(sql: string): Promise<any[]> {\n    console.log(`Executing MySQL query: ${sql}`);\n    return [];\n  }\n}\n```\n\n**Use Cases:**\n- Template Method pattern implementation\n- Enforcing consistent APIs across subclasses\n- Sharing common functionality while requiring specific implementations\n- Plugin architectures\n- Framework base classes\n\n**Benefits:**\n- Code reuse through inheritance\n- Enforced implementation contracts\n- Type safety with polymorphism\n- Clear separation of common and specific behavior\n- Better API design for extensible systems",
      "keywords": ["abstract classes", "abstract methods", "inheritance", "polymorphism", "template method", "base classes", "subclasses", "cannot instantiate", "must implement", "design patterns"],
      "difficulty": "easy"
    },
    {
      "id": 1023,
      "tag": "typescript",
      "question": "Explain conditional types (T extends U ? X : Y) in TypeScript with practical examples.",
      "answer": "Conditional types enable type-level logic, allowing types to be chosen based on whether one type extends another.\n\n**Basic Conditional Types:**\n```typescript\n// Basic syntax: T extends U ? X : Y\ntype IsString<T> = T extends string ? true : false;\n\ntype Test1 = IsString<string>; // true\ntype Test2 = IsString<number>; // false\ntype Test3 = IsString<'hello'>; // true (string literal extends string)\n\n// Conditional return types\ntype ApiResponse<T> = T extends string \n  ? { message: T; status: 'success' }\n  : { error: T; status: 'error' };\n\ntype SuccessResponse = ApiResponse<string>; // { message: string; status: 'success' }\ntype ErrorResponse = ApiResponse<Error>; // { error: Error; status: 'error' }\n```\n\n**Infer Keyword:**\n```typescript\n// Extract return type from function\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype FuncReturn = ReturnType<() => string>; // string\ntype ComplexReturn = ReturnType<(x: number) => Promise<User>>; // Promise<User>\n\n// Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringArrayElement = ArrayElement<string[]>; // string\ntype NumberArrayElement = ArrayElement<number[]>; // number\n\n// Extract promise value type\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\ntype PromiseValue = Awaited<Promise<string>>; // string\ntype NonPromiseValue = Awaited<number>; // number\n```\n\n**Nested Conditional Types:**\n```typescript\n// Deep readonly implementation\ntype DeepReadonly<T> = T extends (infer U)[]\n  ? ReadonlyArray<DeepReadonly<U>>\n  : T extends object\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : T;\n\ninterface User {\n  name: string;\n  hobbies: string[];\n  profile: {\n    age: number;\n    settings: { theme: string };\n  };\n}\n\ntype ReadonlyUser = DeepReadonly<User>;\n// {\n//   readonly name: string;\n//   readonly hobbies: readonly string[];\n//   readonly profile: {\n//     readonly age: number;\n//     readonly settings: { readonly theme: string };\n//   };\n// }\n```\n\n**Distributive Conditional Types:**\n```typescript\n// Conditional types distribute over union types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype CleanUnion = NonNullable<string | number | null | undefined>; // string | number\n\n// Extract function types from union\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ninterface Example {\n  name: string;\n  age: number;\n  getName(): string;\n  setAge(age: number): void;\n}\n\ntype FuncNames = FunctionPropertyNames<Example>; // 'getName' | 'setAge'\n```\n\n**Conditional Type Chains:**\n```typescript\n// Chain multiple conditions\ntype TypeName<T> = T extends string\n  ? 'string'\n  : T extends number\n  ? 'number'\n  : T extends boolean\n  ? 'boolean'\n  : T extends undefined\n  ? 'undefined'\n  : T extends Function\n  ? 'function'\n  : 'object';\n\ntype StringType = TypeName<string>; // 'string'\ntype NumberType = TypeName<42>; // 'number'\ntype FunctionType = TypeName<() => void>; // 'function'\ntype ObjectType = TypeName<{ x: number }>; // 'object'\n```\n\n**Practical Examples:**\n```typescript\n// Smart flatten type\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\ntype FlatString = Flatten<string>; // string\ntype FlatArray = Flatten<string[]>; // string\ntype FlatNested = Flatten<string[][]>; // string[]\n\n// Conditional props based on discriminated unions\ntype ButtonProps<T extends 'button' | 'link'> = {\n  children: React.ReactNode;\n} & (T extends 'button'\n  ? { onClick: () => void; type?: 'button' | 'submit' }\n  : { href: string; target?: '_blank' });\n\n// Usage:\nconst button: ButtonProps<'button'> = {\n  children: 'Click me',\n  onClick: () => {}\n};\n\nconst link: ButtonProps<'link'> = {\n  children: 'Visit',\n  href: 'https://example.com'\n};\n\n// API response type based on method\ntype ApiCall<Method extends 'GET' | 'POST'> = Method extends 'GET'\n  ? { method: 'GET'; params?: Record<string, string> }\n  : { method: 'POST'; body: any; headers?: Record<string, string> };\n\nfunction makeRequest<M extends 'GET' | 'POST'>(config: ApiCall<M>) {\n  // Implementation based on method type\n}\n\nmakeRequest({ method: 'GET', params: { id: '1' } });\nmakeRequest({ method: 'POST', body: { name: 'John' } });\n```\n\n**Advanced Pattern Matching:**\n```typescript\n// Pattern matching for complex types\ntype PathValue<T, P> = P extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? PathValue<T[Key], Rest>\n    : never\n  : P extends keyof T\n  ? T[P]\n  : never;\n\ninterface NestedData {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n  };\n}\n\ntype UserName = PathValue<NestedData, 'user.profile.name'>; // string\ntype UserAge = PathValue<NestedData, 'user.profile.age'>; // number\n```\n\n**Benefits:**\n- Type-level programming and logic\n- Dynamic type generation\n- Better API design\n- Compile-time optimizations\n- Advanced type transformations",
      "keywords": ["conditional types", "extends keyword", "infer keyword", "type-level logic", "distributive types", "pattern matching", "type transformation", "generic constraints", "compile-time logic"],
      "difficulty": "medium"
    },
    {
      "id": 1024,
      "tag": "typescript",
      "question": "What are template literal types in TypeScript? Provide examples of their usage.",
      "answer": "Template literal types use template literal syntax to create types based on string manipulation and pattern matching.\n\n**Basic Template Literal Types:**\n```typescript\n// Basic template literal type\ntype World = 'world';\ntype Greeting = `hello ${World}`; // 'hello world'\n\n// With union types\ntype Color = 'red' | 'green' | 'blue';\ntype HexColor = `#${string}`;\ntype CSSColor = Color | HexColor;\n\n// Generate multiple combinations\ntype Size = 'small' | 'medium' | 'large';\ntype ButtonClass = `btn-${Size}`; // 'btn-small' | 'btn-medium' | 'btn-large'\n```\n\n**CSS-in-JS Patterns:**\n```typescript\n// CSS property patterns\ntype CSSProperty = \n  | `margin-${string}`\n  | `padding-${string}`\n  | `border-${string}`\n  | `background-${string}`;\n\ntype MarginProperty = `margin-${'top' | 'right' | 'bottom' | 'left'}`;\n// 'margin-top' | 'margin-right' | 'margin-bottom' | 'margin-left'\n\n// CSS units\ntype CSSUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';\ntype CSSValue<T extends number> = `${T}${CSSUnit}`;\n\ntype Width = CSSValue<100>; // '100px' | '100em' | '100rem' | '100%' | '100vh' | '100vw'\n\n// Styled components pattern\ntype StyledProps = {\n  [K in MarginProperty]?: string;\n};\n\nconst styles: StyledProps = {\n  'margin-top': '10px',\n  'margin-left': '20px'\n};\n```\n\n**Event Handling Patterns:**\n```typescript\n// Event handler naming convention\ntype EventType = 'click' | 'hover' | 'focus' | 'blur';\ntype EventHandler = `on${Capitalize<EventType>}`;\n// 'onClick' | 'onHover' | 'onFocus' | 'onBlur'\n\n// Component props with event handlers\ntype ButtonProps = {\n  [K in EventHandler]?: () => void;\n} & {\n  children: React.ReactNode;\n};\n\nconst button: ButtonProps = {\n  onClick: () => console.log('clicked'),\n  onHover: () => console.log('hovered'),\n  children: 'Click me'\n};\n```\n\n**API Endpoint Generation:**\n```typescript\n// REST API patterns\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype APIVersion = 'v1' | 'v2';\ntype Resource = 'users' | 'posts' | 'comments';\n\ntype APIEndpoint = `/api/${APIVersion}/${Resource}`;\n// '/api/v1/users' | '/api/v1/posts' | '/api/v1/comments' | '/api/v2/users' | ...\n\n// With ID patterns\ntype ResourceWithId = `${APIEndpoint}/${string}`;\ntype SpecificEndpoint = '/api/v1/users/123' | '/api/v2/posts/abc';\n\n// Query parameters\ntype QueryParam = `?${string}=${string}`;\ntype EndpointWithQuery = `${APIEndpoint}${QueryParam}`;\n```\n\n**String Manipulation Utilities:**\n```typescript\n// Built-in string manipulation types\ntype UppercaseExample = Uppercase<'hello'>; // 'HELLO'\ntype LowercaseExample = Lowercase<'WORLD'>; // 'world'\ntype CapitalizeExample = Capitalize<'typescript'>; // 'Typescript'\ntype UncapitalizeExample = Uncapitalize<'TypeScript'>; // 'typeScript'\n\n// Custom string transformations\ntype KebabCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? '-' : ''}${Lowercase<T>}${KebabCase<U>}`\n  : S;\n\ntype CamelToKebab = KebabCase<'userName'>; // 'user-name'\ntype PascalToKebab = KebabCase<'UserProfile'>; // 'user-profile'\n```\n\n**Path and Route Patterns:**\n```typescript\n// URL path patterns\ntype Route = '/home' | '/about' | '/contact';\ntype DynamicRoute = `/user/${string}` | `/post/${string}`;\ntype AllRoutes = Route | DynamicRoute;\n\n// Nested route patterns\ntype AdminRoute = `/admin/${string}`;\ntype APIRoute = `/api/${string}`;\ntype AppRoute = Route | AdminRoute | APIRoute;\n\n// Path parameter extraction\ntype ExtractPathParams<T extends string> = \n  T extends `${string}:${infer Param}/${infer Rest}`\n    ? { [K in Param]: string } & ExtractPathParams<Rest>\n    : T extends `${string}:${infer Param}`\n    ? { [K in Param]: string }\n    : {};\n\ntype UserRouteParams = ExtractPathParams<'/user/:id/post/:postId'>;\n// { id: string; postId: string }\n```\n\n**Database and SQL Patterns:**\n```typescript\n// SQL query patterns\ntype SQLCommand = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';\ntype TableName = 'users' | 'posts' | 'comments';\ntype SQLQuery = `${SQLCommand} * FROM ${TableName}`;\n\n// Column patterns\ntype UserColumn = 'id' | 'name' | 'email' | 'created_at';\ntype SelectQuery = `SELECT ${UserColumn} FROM users`;\n// 'SELECT id FROM users' | 'SELECT name FROM users' | ...\n\n// Join patterns\ntype JoinType = 'INNER' | 'LEFT' | 'RIGHT';\ntype JoinQuery = `${SelectQuery} ${JoinType} JOIN ${TableName} ON ${string}`;\n```\n\n**Validation and Parsing:**\n```typescript\n// Email validation pattern\ntype Email = `${string}@${string}.${string}`;\n\n// URL validation pattern\ntype Protocol = 'http' | 'https';\ntype URL = `${Protocol}://${string}`;\n\n// Version pattern\ntype Version = `${number}.${number}.${number}`;\ntype SemVer = `${Version}${'alpha' | 'beta' | 'rc' | ''}`;\n\n// File extension patterns\ntype ImageExt = 'jpg' | 'png' | 'gif' | 'webp';\ntype ImageFile = `${string}.${ImageExt}`;\n\n// Environment variable patterns\ntype EnvPrefix = 'REACT_APP' | 'NEXT_PUBLIC';\ntype EnvVar = `${EnvPrefix}_${Uppercase<string>}`;\n```\n\n**Advanced Pattern Matching:**\n```typescript\n// Complex pattern extraction\ntype ParseJSON<T extends string> = T extends `{${infer Content}}`\n  ? ParseObject<Content>\n  : T extends `[${infer Content}]`\n  ? ParseArray<Content>\n  : T extends `\"${infer Content}\"`\n  ? Content\n  : T extends 'true' | 'false'\n  ? boolean\n  : T extends `${number}`\n  ? number\n  : never;\n\ntype ParseObject<T extends string> = {\n  // Complex object parsing logic\n};\n\ntype ParseArray<T extends string> = {\n  // Complex array parsing logic\n};\n```\n\n**Benefits:**\n- Type-safe string manipulation\n- API contract enforcement\n- CSS-in-JS type safety\n- Route and path validation\n- Template and pattern generation\n- Compile-time string validation",
      "keywords": ["template literal types", "string manipulation", "template literals", "string patterns", "CSS-in-JS", "API endpoints", "route patterns", "string validation", "pattern matching", "type generation"],
      "difficulty": "medium"
    },
    {
      "id": 1025,
      "tag": "typescript",
      "question": "What are branded types and nominal typing in TypeScript? How do you implement them?",
      "answer": "Branded types (nominal typing) create distinct types that are structurally identical but semantically different, preventing accidental mixing of similar types.\n\n**Basic Branded Types:**\n```typescript\n// Create a brand using intersection with unique symbol\ntype Brand<T, U> = T & { readonly __brand: unique symbol };\n\n// Define branded types\ntype UserId = Brand<string, 'UserId'>;\ntype Email = Brand<string, 'Email'>;\ntype ProductId = Brand<string, 'ProductId'>;\n\n// Constructor functions\nfunction createUserId(id: string): UserId {\n  // Validation logic here\n  if (!id || id.length < 3) {\n    throw new Error('Invalid user ID');\n  }\n  return id as UserId;\n}\n\nfunction createEmail(email: string): Email {\n  if (!email.includes('@')) {\n    throw new Error('Invalid email format');\n  }\n  return email as Email;\n}\n\n// Usage\nconst userId = createUserId('user123');\nconst email = createEmail('user@example.com');\nconst productId = createProductId('prod456');\n\n// Type safety - prevents mixing\nfunction getUserProfile(id: UserId): UserProfile {\n  // Implementation\n}\n\ngetUserProfile(userId); // ✓ Valid\ngetUserProfile(email); // ✗ Error: Email not assignable to UserId\ngetUserProfile('user123'); // ✗ Error: string not assignable to UserId\n```\n\n**Numeric Branded Types:**\n```typescript\n// Numeric brands with units\ntype Meters = Brand<number, 'Meters'>;\ntype Feet = Brand<number, 'Feet'>;\ntype Seconds = Brand<number, 'Seconds'>;\ntype Milliseconds = Brand<number, 'Milliseconds'>;\n\n// Constructor functions with validation\nfunction meters(value: number): Meters {\n  if (value < 0) throw new Error('Meters cannot be negative');\n  return value as Meters;\n}\n\nfunction feet(value: number): Feet {\n  if (value < 0) throw new Error('Feet cannot be negative');\n  return value as Feet;\n}\n\nfunction seconds(value: number): Seconds {\n  if (value < 0) throw new Error('Seconds cannot be negative');\n  return value as Seconds;\n}\n\n// Conversion functions\nfunction metersToFeet(m: Meters): Feet {\n  return feet((m as number) * 3.28084);\n}\n\nfunction secondsToMilliseconds(s: Seconds): Milliseconds {\n  return (s as number * 1000) as Milliseconds;\n}\n\n// Usage\nconst distance = meters(100);\nconst height = feet(6);\nconst duration = seconds(30);\n\n// Type-safe operations\nfunction calculateSpeed(distance: Meters, time: Seconds): number {\n  return (distance as number) / (time as number);\n}\n\ncalculateSpeed(distance, duration); // ✓ Valid\ncalculateSpeed(height, duration); // ✗ Error: Feet not assignable to Meters\n```\n\n**Advanced Branded Types with Validation:**\n```typescript\n// More sophisticated branding with runtime validation\ntype PositiveInteger = Brand<number, 'PositiveInteger'>;\ntype NonEmptyString = Brand<string, 'NonEmptyString'>;\ntype ValidatedEmail = Brand<string, 'ValidatedEmail'>;\n\n// Validation predicates\nfunction isPositiveInteger(value: number): value is PositiveInteger {\n  return Number.isInteger(value) && value > 0;\n}\n\nfunction isNonEmptyString(value: string): value is NonEmptyString {\n  return value.length > 0;\n}\n\nfunction isValidEmail(value: string): value is ValidatedEmail {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(value);\n}\n\n// Safe constructors\nfunction positiveInteger(value: number): PositiveInteger {\n  if (!isPositiveInteger(value)) {\n    throw new Error(`${value} is not a positive integer`);\n  }\n  return value;\n}\n\nfunction nonEmptyString(value: string): NonEmptyString {\n  if (!isNonEmptyString(value)) {\n    throw new Error('String cannot be empty');\n  }\n  return value;\n}\n\nfunction validatedEmail(value: string): ValidatedEmail {\n  if (!isValidEmail(value)) {\n    throw new Error(`${value} is not a valid email`);\n  }\n  return value;\n}\n```\n\n**Branded Types for Database IDs:**\n```typescript\n// Database entity IDs\ntype UserID = Brand<number, 'UserID'>;\ntype PostID = Brand<number, 'PostID'>;\ntype CommentID = Brand<number, 'CommentID'>;\n\n// Repository pattern with branded types\ninterface UserRepository {\n  findById(id: UserID): Promise<User | null>;\n  create(userData: CreateUserData): Promise<UserID>;\n  update(id: UserID, data: UpdateUserData): Promise<void>;\n  delete(id: UserID): Promise<void>;\n}\n\ninterface PostRepository {\n  findById(id: PostID): Promise<Post | null>;\n  findByAuthor(authorId: UserID): Promise<Post[]>;\n  create(postData: CreatePostData): Promise<PostID>;\n}\n\n// Usage prevents ID mixing\nclass BlogService {\n  constructor(\n    private userRepo: UserRepository,\n    private postRepo: PostRepository\n  ) {}\n  \n  async getAuthorPosts(userId: UserID): Promise<Post[]> {\n    return this.postRepo.findByAuthor(userId);\n  }\n  \n  async getPostAuthor(postId: PostID): Promise<User | null> {\n    const post = await this.postRepo.findById(postId);\n    if (!post) return null;\n    \n    return this.userRepo.findById(post.authorId);\n    // return this.userRepo.findById(postId); // ✗ Error: PostID not assignable to UserID\n  }\n}\n```\n\n**Branded Types for API Contracts:**\n```typescript\n// API versioning with branded types\ntype APIv1Response<T> = Brand<T, 'APIv1'>;\ntype APIv2Response<T> = Brand<T, 'APIv2'>;\n\ninterface UserV1 {\n  id: number;\n  name: string;\n}\n\ninterface UserV2 {\n  id: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n}\n\n// Version-specific handlers\nfunction handleV1Response(response: APIv1Response<UserV1[]>) {\n  // Handle v1 format\n}\n\nfunction handleV2Response(response: APIv2Response<UserV2[]>) {\n  // Handle v2 format\n}\n\n// Prevents version mixing\nconst v1Data = fetchV1Users(); // Returns APIv1Response<UserV1[]>\nconst v2Data = fetchV2Users(); // Returns APIv2Response<UserV2[]>\n\nhandleV1Response(v1Data); // ✓ Valid\nhandleV2Response(v2Data); // ✓ Valid\nhandleV1Response(v2Data); // ✗ Error: Version mismatch\n```\n\n**Money and Currency Brands:**\n```typescript\n// Currency-specific money types\ntype USD = Brand<number, 'USD'>;\ntype EUR = Brand<number, 'EUR'>;\ntype GBP = Brand<number, 'GBP'>;\n\nfunction usd(amount: number): USD {\n  return Math.round(amount * 100) / 100 as USD; // Round to 2 decimal places\n}\n\nfunction eur(amount: number): EUR {\n  return Math.round(amount * 100) / 100 as EUR;\n}\n\n// Currency conversion with exchange rates\nfunction usdToEur(amount: USD, rate: number): EUR {\n  return eur((amount as number) * rate);\n}\n\n// Type-safe calculations\nfunction calculateTotal(prices: USD[]): USD {\n  const total = prices.reduce((sum, price) => sum + (price as number), 0);\n  return usd(total);\n}\n\nconst price1 = usd(19.99);\nconst price2 = usd(29.50);\nconst euroPrice = eur(25.00);\n\nconst total = calculateTotal([price1, price2]); // ✓ Valid\nconst invalid = calculateTotal([price1, euroPrice]); // ✗ Error: EUR not assignable to USD\n```\n\n**Benefits:**\n- Prevents accidental type mixing\n- Adds semantic meaning to primitive types\n- Enforces domain-specific validation\n- Better API design and documentation\n- Compile-time safety for business logic\n- Clear intent and reduced bugs\n\n**When to Use:**\n- IDs that shouldn't be mixed (UserID vs ProductID)\n- Units of measurement (meters vs feet)\n- Currency types\n- Validated input types (Email, Phone)\n- API versioning\n- Security tokens and credentials",
      "keywords": ["branded types", "nominal typing", "type safety", "unique symbol", "type branding", "validation", "semantic types", "domain modeling", "type distinction", "runtime validation"],
      "difficulty": "medium"
    },
    {
      "id": 1026,
      "tag": "typescript",
      "question": "How do recursive types and the 'infer' keyword work in TypeScript? Provide examples.",
      "answer": "Recursive types reference themselves in their definition, while `infer` allows extracting and capturing types within conditional type expressions.\n\n**Basic Recursive Types:**\n```typescript\n// Recursive data structures\ntype LinkedList<T> = {\n  value: T;\n  next: LinkedList<T> | null;\n};\n\n// Tree structure\ntype BinaryTree<T> = {\n  value: T;\n  left: BinaryTree<T> | null;\n  right: BinaryTree<T> | null;\n};\n\n// JSON-like recursive type\ntype JSONValue = \n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\nconst data: JSONValue = {\n  name: 'John',\n  age: 30,\n  hobbies: ['reading', 'coding'],\n  address: {\n    street: '123 Main St',\n    coordinates: [40.7128, -74.0060]\n  }\n};\n```\n\n**The 'infer' Keyword:**\n```typescript\n// Extract return type from function\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype FuncReturn = ReturnType<() => string>; // string\ntype AsyncReturn = ReturnType<() => Promise<number>>; // Promise<number>\n\n// Extract parameters from function\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\ntype FuncParams = Parameters<(a: string, b: number) => void>; // [string, number]\n\n// Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringElement = ArrayElement<string[]>; // string\ntype NumberElement = ArrayElement<number[]>; // number\n\n// Extract Promise value type\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\ntype PromiseString = Awaited<Promise<string>>; // string\ntype NonPromise = Awaited<number>; // number\n```\n\n**Recursive Type with 'infer':**\n```typescript\n// Deep flatten array type\ntype DeepFlatten<T> = T extends (infer U)[]\n  ? U extends any[]\n    ? DeepFlatten<U>\n    : U\n  : T;\n\ntype NestedArray = string[][][];\ntype Flattened = DeepFlatten<NestedArray>; // string\n\ntype MixedNested = (string | number[])[];\ntype MixedFlattened = DeepFlatten<MixedNested>; // string | number\n```\n\n**Complex Recursive Operations:**\n```typescript\n// Deep readonly implementation\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\ninterface NestedObject {\n  user: {\n    profile: {\n      name: string;\n      settings: {\n        theme: string;\n        notifications: boolean;\n      };\n    };\n    posts: Array<{\n      title: string;\n      content: string;\n    }>;\n  };\n}\n\ntype ReadonlyNested = DeepReadonly<NestedObject>;\n// All properties become readonly recursively\n```\n\n**Path Navigation Types:**\n```typescript\n// Extract value type at nested path\ntype PathValue<T, Path> = Path extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? PathValue<T[Key], Rest>\n    : never\n  : Path extends keyof T\n  ? T[Path]\n  : never;\n\n// Set value type at nested path\ntype SetPath<T, Path, Value> = Path extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? {\n        [K in keyof T]: K extends Key\n          ? SetPath<T[K], Rest, Value>\n          : T[K]\n      }\n    : never\n  : Path extends keyof T\n  ? {\n      [K in keyof T]: K extends Path ? Value : T[K]\n    }\n  : never;\n\ninterface AppState {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n  };\n  settings: {\n    theme: string;\n  };\n}\n\ntype UserName = PathValue<AppState, 'user.profile.name'>; // string\ntype UserAge = PathValue<AppState, 'user.profile.age'>; // number\n\ntype UpdatedState = SetPath<AppState, 'user.profile.name', 'John'>;\n// Updates the name field type while preserving structure\n```\n\n**Recursive String Operations:**\n```typescript\n// String length calculation (compile-time)\ntype StringLength<S extends string, Acc extends any[] = []> = \n  S extends `${string}${infer Rest}`\n    ? StringLength<Rest, [...Acc, any]>\n    : Acc['length'];\n\ntype Length = StringLength<'hello'>; // 5\n\n// String reversal\ntype Reverse<S extends string, Result extends string = ''> = \n  S extends `${infer First}${infer Rest}`\n    ? Reverse<Rest, `${First}${Result}`>\n    : Result;\n\ntype Reversed = Reverse<'hello'>; // 'olleh'\n\n// Join array of strings\ntype Join<T extends string[], Delimiter extends string = ''> = \n  T extends [infer First, ...infer Rest]\n    ? First extends string\n      ? Rest extends string[]\n        ? Rest['length'] extends 0\n          ? First\n          : `${First}${Delimiter}${Join<Rest, Delimiter>}`\n        : never\n      : never\n    : '';\n\ntype Joined = Join<['hello', 'world', 'typescript'], ' '>; // 'hello world typescript'\n```\n\n**Tree Traversal Types:**\n```typescript\n// Extract all leaf values from nested object\ntype LeafPaths<T, K extends keyof T = keyof T> = K extends string\n  ? T[K] extends object\n    ? T[K] extends any[]\n      ? K\n      : `${K}.${LeafPaths<T[K]>}`\n    : K\n  : never;\n\ntype AllPaths = LeafPaths<{\n  a: string;\n  b: {\n    c: number;\n    d: {\n      e: boolean;\n    };\n  };\n}>; // 'a' | 'b.c' | 'b.d.e'\n```\n\n**Function Composition Types:**\n```typescript\n// Compose function types\ntype Compose<F, G> = F extends (arg: infer A) => infer B\n  ? G extends (arg: B) => infer C\n    ? (arg: A) => C\n    : never\n  : never;\n\ntype Pipe<T extends any[], R = {}> = T extends [\n  (...args: any[]) => infer A,\n  ...infer Rest\n]\n  ? Rest extends []\n    ? (...args: any[]) => A\n    : Rest extends [any, ...any[]]\n    ? Pipe<Rest> extends (arg: A) => infer B\n      ? (...args: any[]) => B\n      : never\n    : never\n  : never;\n\n// Usage\nconst f1 = (x: number) => x.toString();\nconst f2 = (x: string) => x.length;\nconst f3 = (x: number) => x > 5;\n\ntype ComposedType = Pipe<[typeof f1, typeof f2, typeof f3]>;\n// (x: number) => boolean\n```\n\n**Practical Applications:**\n```typescript\n// Form validation with recursive error types\ntype ValidationErrors<T> = {\n  [K in keyof T]?: T[K] extends object\n    ? T[K] extends any[]\n      ? string\n      : ValidationErrors<T[K]>\n    : string;\n};\n\ninterface UserForm {\n  personal: {\n    firstName: string;\n    lastName: string;\n  };\n  contact: {\n    email: string;\n    phone: string;\n  };\n}\n\ntype FormErrors = ValidationErrors<UserForm>;\n// {\n//   personal?: {\n//     firstName?: string;\n//     lastName?: string;\n//   };\n//   contact?: {\n//     email?: string;\n//     phone?: string;\n//   };\n// }\n```\n\n**Benefits:**\n- Handle complex nested data structures\n- Type-safe operations on recursive data\n- Advanced type transformations\n- Compile-time computations\n- Better API design for nested objects\n- Type extraction and manipulation",
      "keywords": ["recursive types", "infer keyword", "type extraction", "nested types", "conditional types", "type manipulation", "tree structures", "path types", "type composition", "compile-time computation"],
      "difficulty": "medium"
    },
    {
      "id": 1027,
      "tag": "typescript",
      "question": "What is module augmentation and declaration merging in TypeScript? Provide practical examples.",
      "answer": "Module augmentation allows extending existing modules by adding new declarations, while declaration merging combines multiple declarations of the same name into a single definition.\n\n**Global Augmentation:**\n```typescript\n// Extending global interfaces\ndeclare global {\n  interface Window {\n    customAnalytics: {\n      track(event: string, data?: any): void;\n      identify(userId: string): void;\n    };\n    myAppConfig: {\n      apiUrl: string;\n      version: string;\n    };\n  }\n  \n  interface Array<T> {\n    last(): T | undefined;\n    first(): T | undefined;\n  }\n}\n\n// Implementation (in a separate file or module)\nWindow.prototype.customAnalytics = {\n  track(event: string, data?: any) {\n    console.log('Tracking:', event, data);\n  },\n  identify(userId: string) {\n    console.log('Identifying user:', userId);\n  }\n};\n\nArray.prototype.last = function<T>(this: T[]): T | undefined {\n  return this[this.length - 1];\n};\n\nArray.prototype.first = function<T>(this: T[]): T | undefined {\n  return this[0];\n};\n\n// Now available globally\nwindow.customAnalytics.track('page_view');\nconst numbers = [1, 2, 3];\nconst lastNumber = numbers.last(); // 3\n```\n\n**Third-Party Library Augmentation:**\n```typescript\n// Extending Express Request interface\nimport express from 'express';\n\ndeclare module 'express-serve-static-core' {\n  interface Request {\n    user?: {\n      id: string;\n      email: string;\n      role: 'admin' | 'user';\n    };\n    requestId: string;\n    startTime: number;\n  }\n  \n  interface Response {\n    sendSuccess<T>(data: T, message?: string): Response;\n    sendError(error: string, code?: number): Response;\n  }\n}\n\n// Middleware that uses the augmented types\nfunction authMiddleware(req: express.Request, res: express.Response, next: express.NextFunction) {\n  // Authenticate user and set req.user\n  req.user = {\n    id: '123',\n    email: 'user@example.com',\n    role: 'user'\n  };\n  req.requestId = Math.random().toString(36);\n  req.startTime = Date.now();\n  next();\n}\n\n// Route handlers can now use the extended interface\napp.get('/profile', (req, res) => {\n  if (!req.user) {\n    return res.sendError('Unauthorized', 401);\n  }\n  \n  res.sendSuccess({\n    user: req.user,\n    requestId: req.requestId\n  });\n});\n```\n\n**Module Augmentation for Libraries:**\n```typescript\n// Extending lodash with custom utilities\nimport _ from 'lodash';\n\ndeclare module 'lodash' {\n  interface LoDashStatic {\n    randomString(length?: number): string;\n    deepFreeze<T>(obj: T): T;\n    isValidEmail(email: string): boolean;\n  }\n}\n\n// Add custom methods to lodash\n_.mixin({\n  randomString(length: number = 10): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    return _.times(length, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');\n  },\n  \n  deepFreeze<T>(obj: T): T {\n    Object.getOwnPropertyNames(obj).forEach(prop => {\n      const value = (obj as any)[prop];\n      if (value && typeof value === 'object') {\n        _.deepFreeze(value);\n      }\n    });\n    return Object.freeze(obj);\n  },\n  \n  isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n});\n\n// Now available with type safety\nconst randomId = _.randomString(8);\nconst isValid = _.isValidEmail('test@example.com');\nconst frozenObj = _.deepFreeze({ name: 'John', age: 30 });\n```\n\n**Declaration Merging - Interface Merging:**\n```typescript\n// Multiple interface declarations are automatically merged\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface User {\n  email: string;\n  createdAt: Date;\n}\n\ninterface User {\n  lastLoginAt?: Date;\n  isActive: boolean;\n}\n\n// Merged interface:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   createdAt: Date;\n//   lastLoginAt?: Date;\n//   isActive: boolean;\n// }\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  createdAt: new Date(),\n  isActive: true\n};\n```\n\n**Namespace Merging:**\n```typescript\n// Namespace declarations can be merged\nnamespace Utilities {\n  export function formatDate(date: Date): string {\n    return date.toISOString().split('T')[0];\n  }\n}\n\nnamespace Utilities {\n  export function formatCurrency(amount: number, currency = 'USD'): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency\n    }).format(amount);\n  }\n}\n\nnamespace Utilities {\n  export interface FormatOptions {\n    locale?: string;\n    timezone?: string;\n  }\n  \n  export function formatDateTime(date: Date, options?: FormatOptions): string {\n    return new Intl.DateTimeFormat(options?.locale || 'en-US', {\n      timeZone: options?.timezone\n    }).format(date);\n  }\n}\n\n// All declarations are merged\nconst formattedDate = Utilities.formatDate(new Date());\nconst formattedPrice = Utilities.formatCurrency(99.99);\nconst formattedDateTime = Utilities.formatDateTime(new Date(), { locale: 'fr-FR' });\n```\n\n**Function Overload Merging:**\n```typescript\n// Function overloads can be merged across declarations\nfunction parseValue(value: string): string;\nfunction parseValue(value: number): number;\nfunction parseValue(value: string | number): string | number {\n  return typeof value === 'string' ? value.trim() : Math.round(value);\n}\n\n// Additional overloads in another declaration\nfunction parseValue(value: boolean): boolean;\nfunction parseValue(value: Date): string;\nfunction parseValue(value: any): any {\n  if (typeof value === 'boolean') return value;\n  if (value instanceof Date) return value.toISOString();\n  return typeof value === 'string' ? value.trim() : Math.round(value);\n}\n\n// All overloads are now available\nconst str = parseValue('  hello  '); // string\nconst num = parseValue(3.14); // number\nconst bool = parseValue(true); // boolean\nconst date = parseValue(new Date()); // string\n```\n\n**Practical Plugin System:**\n```typescript\n// Base plugin interface\ninterface PluginRegistry {\n  // Initially empty\n}\n\n// Core plugin system\nclass PluginManager {\n  private plugins: PluginRegistry = {} as PluginRegistry;\n  \n  register<K extends keyof PluginRegistry>(name: K, plugin: PluginRegistry[K]) {\n    this.plugins[name] = plugin;\n  }\n  \n  get<K extends keyof PluginRegistry>(name: K): PluginRegistry[K] {\n    return this.plugins[name];\n  }\n}\n\n// Plugins extend the registry through module augmentation\ndeclare global {\n  interface PluginRegistry {\n    logger: {\n      log(message: string): void;\n      error(message: string): void;\n    };\n  }\n}\n\ndeclare global {\n  interface PluginRegistry {\n    cache: {\n      get(key: string): any;\n      set(key: string, value: any): void;\n      clear(): void;\n    };\n  }\n}\n\ndeclare global {\n  interface PluginRegistry {\n    validator: {\n      isEmail(value: string): boolean;\n      isUrl(value: string): boolean;\n    };\n  }\n}\n\n// Type-safe plugin usage\nconst pluginManager = new PluginManager();\n\npluginManager.register('logger', {\n  log: (msg) => console.log(msg),\n  error: (msg) => console.error(msg)\n});\n\nconst logger = pluginManager.get('logger'); // Fully typed\nlogger.log('Hello, world!'); // Type-safe method call\n```\n\n**Benefits:**\n- Extend existing libraries safely\n- Add custom functionality to global objects\n- Create type-safe plugin systems\n- Gradual API enhancement\n- Better integration with third-party code\n- Maintain type safety while extending functionality",
      "keywords": ["module augmentation", "declaration merging", "interface merging", "namespace merging", "global augmentation", "third-party libraries", "plugin systems", "type extension", "library augmentation", "API enhancement"],
      "difficulty": "medium"
    },
    {
      "id": 1028,
      "tag": "typescript",
      "question": "Explain advanced mapped types with template literals and provide complex transformation examples.",
      "answer": "Advanced mapped types combine template literal types with mapping operations to create sophisticated type transformations and manipulations.\n\n**Template Literal Key Mapping:**\n```typescript\n// Transform keys with prefixes/suffixes\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype Setters<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype UserGetters = Getters<User>;\n// {\n//   getName: () => string;\n//   getAge: () => number;\n//   getEmail: () => string;\n// }\n\ntype UserSetters = Setters<User>;\n// {\n//   setName: (value: string) => void;\n//   setAge: (value: number) => void;\n//   setEmail: (value: string) => void;\n// }\n\n// Combine getters and setters\ntype AccessorPattern<T> = Getters<T> & Setters<T>;\ntype UserAccessors = AccessorPattern<User>;\n```\n\n**Event Handler Pattern Generation:**\n```typescript\n// Generate event handler types from event names\ntype EventHandlers<T extends Record<string, any>> = {\n  [K in keyof T as `on${Capitalize<string & K>}`]: (event: T[K]) => void;\n} & {\n  [K in keyof T as `${string & K}Listener`]: (event: T[K]) => void;\n};\n\ninterface DOMEvents {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  load: Event;\n  error: ErrorEvent;\n}\n\ntype DOMEventHandlers = EventHandlers<DOMEvents>;\n// {\n//   onClick: (event: MouseEvent) => void;\n//   onKeydown: (event: KeyboardEvent) => void;\n//   onLoad: (event: Event) => void;\n//   onError: (event: ErrorEvent) => void;\n//   clickListener: (event: MouseEvent) => void;\n//   keydownListener: (event: KeyboardEvent) => void;\n//   loadListener: (event: Event) => void;\n//   errorListener: (event: ErrorEvent) => void;\n// }\n```\n\n**API Endpoint Type Generation:**\n```typescript\n// Generate API client methods from endpoint definitions\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\ntype EndpointConfig = {\n  [endpoint: string]: {\n    method: HTTPMethod;\n    request?: any;\n    response: any;\n  };\n};\n\ntype APIClient<T extends EndpointConfig> = {\n  [K in keyof T as T[K]['method'] extends 'GET'\n    ? `get${Capitalize<string & K>}`\n    : T[K]['method'] extends 'POST'\n    ? `create${Capitalize<string & K>}`\n    : T[K]['method'] extends 'PUT'\n    ? `update${Capitalize<string & K>}`\n    : T[K]['method'] extends 'DELETE'\n    ? `delete${Capitalize<string & K>}`\n    : `${Lowercase<T[K]['method']>}${Capitalize<string & K>}`\n  ]: T[K]['request'] extends undefined\n    ? () => Promise<T[K]['response']>\n    : (data: T[K]['request']) => Promise<T[K]['response']>;\n};\n\ninterface APIEndpoints extends EndpointConfig {\n  users: {\n    method: 'GET';\n    response: User[];\n  };\n  user: {\n    method: 'POST';\n    request: CreateUserRequest;\n    response: User;\n  };\n  profile: {\n    method: 'PUT';\n    request: UpdateProfileRequest;\n    response: Profile;\n  };\n}\n\ntype GeneratedAPIClient = APIClient<APIEndpoints>;\n// {\n//   getUsers: () => Promise<User[]>;\n//   createUser: (data: CreateUserRequest) => Promise<User>;\n//   updateProfile: (data: UpdateProfileRequest) => Promise<Profile>;\n// }\n```\n\n**Database Query Builder Types:**\n```typescript\n// Generate query builder methods from schema\ntype QueryMethods<T> = {\n  [K in keyof T as `findBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<T | null>;\n} & {\n  [K in keyof T as `findAllBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<T[]>;\n} & {\n  [K in keyof T as `deleteBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<boolean>;\n};\n\ninterface UserSchema {\n  id: number;\n  email: string;\n  username: string;\n  status: 'active' | 'inactive';\n}\n\ntype UserQueryMethods = QueryMethods<UserSchema>;\n// {\n//   findById: (value: number) => Promise<UserSchema | null>;\n//   findAllById: (value: number) => Promise<UserSchema[]>;\n//   deleteById: (value: number) => Promise<boolean>;\n//   findByEmail: (value: string) => Promise<UserSchema | null>;\n//   findAllByEmail: (value: string) => Promise<UserSchema[]>;\n//   deleteByEmail: (value: string) => Promise<boolean>;\n//   // ... and so on\n// }\n```\n\n**Form Validation Type Generation:**\n```typescript\n// Generate validation rules and error types\ntype ValidationRules<T> = {\n  [K in keyof T]?: {\n    required?: boolean;\n    minLength?: number;\n    maxLength?: number;\n    pattern?: RegExp;\n    custom?: (value: T[K]) => boolean;\n  };\n};\n\ntype ValidationErrors<T> = {\n  [K in keyof T as `${string & K}Error`]?: string;\n} & {\n  [K in keyof T as `is${Capitalize<string & K>}Valid`]: boolean;\n};\n\ntype FormState<T> = T & ValidationErrors<T> & {\n  isValid: boolean;\n  isDirty: boolean;\n  errors: Partial<Record<keyof T, string>>;\n};\n\ninterface RegisterForm {\n  username: string;\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ntype RegisterFormState = FormState<RegisterForm>;\n// {\n//   username: string;\n//   email: string;\n//   password: string;\n//   confirmPassword: string;\n//   usernameError?: string;\n//   emailError?: string;\n//   passwordError?: string;\n//   confirmPasswordError?: string;\n//   isUsernameValid: boolean;\n//   isEmailValid: boolean;\n//   isPasswordValid: boolean;\n//   isConfirmPasswordValid: boolean;\n//   isValid: boolean;\n//   isDirty: boolean;\n//   errors: Partial<Record<keyof RegisterForm, string>>;\n// }\n```\n\n**CSS-in-JS Type Generation:**\n```typescript\n// Generate CSS property types with vendor prefixes\ntype CSSProperties = {\n  color?: string;\n  backgroundColor?: string;\n  fontSize?: string;\n  margin?: string;\n  padding?: string;\n};\n\ntype VendorPrefixes = 'webkit' | 'moz' | 'ms' | 'o';\n\ntype VendorPrefixedCSS<T> = T & {\n  [K in keyof T as `-${VendorPrefixes}-${string & K}`]?: T[K];\n};\n\ntype PrefixedCSS = VendorPrefixedCSS<CSSProperties>;\n// Includes properties like:\n// -webkit-color, -moz-color, -ms-color, -o-color, etc.\n\n// Responsive design type generation\ntype Breakpoints = 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n\ntype ResponsiveCSS<T> = T & {\n  [K in keyof T as `${string & K}@${Breakpoints}`]?: T[K];\n};\n\ntype ResponsiveProperties = ResponsiveCSS<{\n  fontSize: string;\n  margin: string;\n  display: string;\n}>;\n// {\n//   fontSize?: string;\n//   margin?: string;\n//   display?: string;\n//   'fontSize@xs'?: string;\n//   'fontSize@sm'?: string;\n//   // ... and so on\n// }\n```\n\n**State Management Pattern:**\n```typescript\n// Generate Redux-style action creators and reducers\ntype ActionCreators<T extends Record<string, any>> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (\n    payload: T[K]\n  ) => { type: `SET_${Uppercase<string & K>}`; payload: T[K] };\n} & {\n  [K in keyof T as `reset${Capitalize<string & K>}`]: () => {\n    type: `RESET_${Uppercase<string & K>}`;\n  };\n};\n\ntype ActionTypes<T> = {\n  [K in keyof T as `SET_${Uppercase<string & K>}`]: T[K];\n} & {\n  [K in keyof T as `RESET_${Uppercase<string & K>}`]: undefined;\n};\n\ninterface AppState {\n  user: User | null;\n  theme: 'light' | 'dark';\n  loading: boolean;\n}\n\ntype AppActionCreators = ActionCreators<AppState>;\n// {\n//   setUser: (payload: User | null) => { type: 'SET_USER'; payload: User | null };\n//   resetUser: () => { type: 'RESET_USER' };\n//   setTheme: (payload: 'light' | 'dark') => { type: 'SET_THEME'; payload: 'light' | 'dark' };\n//   resetTheme: () => { type: 'RESET_THEME' };\n//   setLoading: (payload: boolean) => { type: 'SET_LOADING'; payload: boolean };\n//   resetLoading: () => { type: 'RESET_LOADING' };\n// }\n\ntype AppActionTypes = ActionTypes<AppState>;\n// Union of all possible action types with their payloads\n```\n\n**Advanced Path Navigation:**\n```typescript\n// Deep path manipulation with template literals\ntype PathsToStringProps<T> = T extends string\n  ? []\n  : {\n      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>];\n    }[Extract<keyof T, string>];\n\ntype Join<T extends string[], D extends string> = T extends []\n  ? never\n  : T extends [infer F]\n  ? F\n  : T extends [infer F, ...infer R]\n  ? F extends string\n    ? `${F}${D}${Join<Extract<R, string[]>, D>}`\n    : never\n  : string;\n\ntype PathsToString<T> = Join<PathsToStringProps<T>, '.'>;\n\ninterface NestedConfig {\n  database: {\n    host: string;\n    port: number;\n    credentials: {\n      username: string;\n      password: string;\n    };\n  };\n  api: {\n    baseUrl: string;\n    timeout: number;\n  };\n}\n\ntype ConfigPaths = PathsToString<NestedConfig>;\n// 'database.host' | 'database.credentials.username' | 'database.credentials.password' | 'api.baseUrl'\n```\n\n**Benefits:**\n- Automatic API generation from schemas\n- Type-safe code generation\n- Reduced boilerplate code\n- Consistent naming conventions\n- Compile-time validation\n- Enhanced developer experience\n- Better refactoring support",
      "keywords": ["advanced mapped types", "template literals", "key mapping", "type transformation", "code generation", "API generation", "pattern generation", "type manipulation", "compile-time generation", "developer experience"],
      "difficulty": "hard"
    },
    {
      "id": 1029,
      "tag": "typescript",
      "question": "How do you work with the TypeScript Compiler API and AST manipulation? Provide examples.",
      "answer": "The TypeScript Compiler API provides programmatic access to the TypeScript compiler, enabling AST (Abstract Syntax Tree) analysis, transformation, and code generation.\n\n**Setting Up the Compiler API:**\n```typescript\nimport * as ts from 'typescript';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Create a program from source files\nfunction createProgram(filePaths: string[]): ts.Program {\n  const compilerOptions: ts.CompilerOptions = {\n    target: ts.ScriptTarget.ES2020,\n    module: ts.ModuleKind.CommonJS,\n    strict: true,\n    esModuleInterop: true\n  };\n  \n  return ts.createProgram(filePaths, compilerOptions);\n}\n\n// Parse a single source file\nfunction parseSourceFile(filePath: string): ts.SourceFile {\n  const sourceText = fs.readFileSync(filePath, 'utf8');\n  return ts.createSourceFile(\n    filePath,\n    sourceText,\n    ts.ScriptTarget.ES2020,\n    true\n  );\n}\n```\n\n**AST Traversal and Analysis:**\n```typescript\n// Visitor pattern for AST traversal\nfunction visitNode(node: ts.Node, sourceFile: ts.SourceFile): void {\n  switch (node.kind) {\n    case ts.SyntaxKind.FunctionDeclaration:\n      analyzeFunctionDeclaration(node as ts.FunctionDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.ClassDeclaration:\n      analyzeClassDeclaration(node as ts.ClassDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.InterfaceDeclaration:\n      analyzeInterfaceDeclaration(node as ts.InterfaceDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.VariableStatement:\n      analyzeVariableStatement(node as ts.VariableStatement, sourceFile);\n      break;\n  }\n  \n  // Recursively visit child nodes\n  ts.forEachChild(node, (child) => visitNode(child, sourceFile));\n}\n\n// Function analysis\nfunction analyzeFunctionDeclaration(\n  node: ts.FunctionDeclaration,\n  sourceFile: ts.SourceFile\n): void {\n  const name = node.name?.text || 'anonymous';\n  const parameters = node.parameters.map(param => ({\n    name: param.name.getText(sourceFile),\n    type: param.type?.getText(sourceFile) || 'any',\n    optional: !!param.questionToken\n  }));\n  \n  const returnType = node.type?.getText(sourceFile) || 'void';\n  const isAsync = !!(node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.AsyncKeyword));\n  const isExported = !!(node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));\n  \n  console.log({\n    type: 'function',\n    name,\n    parameters,\n    returnType,\n    isAsync,\n    isExported,\n    lineNumber: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1\n  });\n}\n\n// Class analysis\nfunction analyzeClassDeclaration(\n  node: ts.ClassDeclaration,\n  sourceFile: ts.SourceFile\n): void {\n  const name = node.name?.text || 'anonymous';\n  const members = node.members.map(member => {\n    if (ts.isMethodDeclaration(member)) {\n      return {\n        type: 'method',\n        name: member.name?.getText(sourceFile),\n        isStatic: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword)),\n        isPrivate: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.PrivateKeyword))\n      };\n    } else if (ts.isPropertyDeclaration(member)) {\n      return {\n        type: 'property',\n        name: member.name?.getText(sourceFile),\n        propertyType: member.type?.getText(sourceFile) || 'any',\n        isReadonly: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ReadonlyKeyword))\n      };\n    }\n    return { type: 'unknown' };\n  });\n  \n  console.log({\n    type: 'class',\n    name,\n    members,\n    lineNumber: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1\n  });\n}\n```\n\n**Code Generation and Transformation:**\n```typescript\n// Create TypeScript AST nodes programmatically\nfunction createInterface(\n  name: string,\n  properties: Array<{ name: string; type: string; optional?: boolean }>\n): ts.InterfaceDeclaration {\n  const propertySignatures = properties.map(prop => \n    ts.factory.createPropertySignature(\n      undefined, // modifiers\n      prop.name,\n      prop.optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,\n      ts.factory.createTypeReferenceNode(prop.type)\n    )\n  );\n  \n  return ts.factory.createInterfaceDeclaration(\n    [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)], // modifiers\n    name,\n    undefined, // type parameters\n    undefined, // heritage clauses\n    propertySignatures\n  );\n}\n\n// Generate a complete source file\nfunction generateApiTypes(endpoints: ApiEndpoint[]): string {\n  const statements: ts.Statement[] = [];\n  \n  // Generate request/response interfaces for each endpoint\n  endpoints.forEach(endpoint => {\n    if (endpoint.requestBody) {\n      const requestInterface = createInterface(\n        `${endpoint.name}Request`,\n        endpoint.requestBody.properties\n      );\n      statements.push(requestInterface);\n    }\n    \n    const responseInterface = createInterface(\n      `${endpoint.name}Response`,\n      endpoint.response.properties\n    );\n    statements.push(responseInterface);\n  });\n  \n  // Create source file\n  const sourceFile = ts.factory.createSourceFile(\n    statements,\n    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),\n    ts.NodeFlags.None\n  );\n  \n  // Print to string\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed\n  });\n  \n  return printer.printFile(sourceFile);\n}\n```\n\n**Custom Transformer:**\n```typescript\n// Transform TypeScript AST\nfunction createLoggerTransformer(): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile) => {\n      function visit(node: ts.Node): ts.Node {\n        // Add console.log to function entries\n        if (ts.isFunctionDeclaration(node) && node.name) {\n          const functionName = node.name.text;\n          const logStatement = ts.factory.createExpressionStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier('console'),\n                'log'\n              ),\n              undefined,\n              [ts.factory.createStringLiteral(`Entering function: ${functionName}`)]\n            )\n          );\n          \n          const newBody = ts.factory.createBlock([\n            logStatement,\n            ...(node.body?.statements || [])\n          ]);\n          \n          return ts.factory.updateFunctionDeclaration(\n            node,\n            node.modifiers,\n            node.asteriskToken,\n            node.name,\n            node.typeParameters,\n            node.parameters,\n            node.type,\n            newBody\n          );\n        }\n        \n        return ts.visitEachChild(node, visit, context);\n      }\n      \n      return ts.visitNode(sourceFile, visit) as ts.SourceFile;\n    };\n  };\n}\n\n// Apply transformation\nfunction transformCode(sourceCode: string): string {\n  const sourceFile = ts.createSourceFile(\n    'temp.ts',\n    sourceCode,\n    ts.ScriptTarget.ES2020,\n    true\n  );\n  \n  const transformationResult = ts.transform(\n    sourceFile,\n    [createLoggerTransformer()]\n  );\n  \n  const printer = ts.createPrinter();\n  return printer.printFile(transformationResult.transformed[0]);\n}\n```\n\n**Type Checker Integration:**\n```typescript\n// Use the type checker for advanced analysis\nfunction analyzeWithTypeChecker(\n  program: ts.Program,\n  sourceFile: ts.SourceFile\n): void {\n  const typeChecker = program.getTypeChecker();\n  \n  function visitWithTypeInfo(node: ts.Node): void {\n    if (ts.isVariableDeclaration(node)) {\n      const symbol = typeChecker.getSymbolAtLocation(node.name);\n      const type = typeChecker.getTypeOfSymbolAtLocation(symbol!, node);\n      const typeString = typeChecker.typeToString(type);\n      \n      console.log({\n        variableName: node.name.getText(),\n        inferredType: typeString,\n        hasInitializer: !!node.initializer\n      });\n    }\n    \n    if (ts.isCallExpression(node)) {\n      const signature = typeChecker.getResolvedSignature(node);\n      if (signature) {\n        const returnType = typeChecker.getReturnTypeOfSignature(signature);\n        console.log({\n          callExpression: node.expression.getText(),\n          returnType: typeChecker.typeToString(returnType)\n        });\n      }\n    }\n    \n    ts.forEachChild(node, visitWithTypeInfo);\n  }\n  \n  visitWithTypeInfo(sourceFile);\n}\n```\n\n**Practical Applications:**\n```typescript\n// Code metrics analyzer\nfunction analyzeCodeMetrics(sourceFile: ts.SourceFile): CodeMetrics {\n  let functionCount = 0;\n  let classCount = 0;\n  let interfaceCount = 0;\n  let totalLines = 0;\n  let complexityScore = 0;\n  \n  function calculateComplexity(node: ts.Node): number {\n    let complexity = 1; // Base complexity\n    \n    ts.forEachChild(node, (child) => {\n      if (ts.isIfStatement(child) || \n          ts.isForStatement(child) || \n          ts.isWhileStatement(child) ||\n          ts.isSwitchStatement(child) ||\n          ts.isConditionalExpression(child)) {\n        complexity += 1;\n      }\n      complexity += calculateComplexity(child);\n    });\n    \n    return complexity;\n  }\n  \n  function visit(node: ts.Node): void {\n    switch (node.kind) {\n      case ts.SyntaxKind.FunctionDeclaration:\n        functionCount++;\n        complexityScore += calculateComplexity(node);\n        break;\n      case ts.SyntaxKind.ClassDeclaration:\n        classCount++;\n        break;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        interfaceCount++;\n        break;\n    }\n    \n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n  totalLines = sourceFile.getLineAndCharacterOfPosition(sourceFile.end).line + 1;\n  \n  return {\n    functionCount,\n    classCount,\n    interfaceCount,\n    totalLines,\n    complexityScore,\n    averageComplexity: complexityScore / Math.max(functionCount, 1)\n  };\n}\n\n// Documentation generator\nfunction generateDocumentation(sourceFile: ts.SourceFile): Documentation {\n  const docs: Documentation = {\n    fileName: sourceFile.fileName,\n    functions: [],\n    classes: [],\n    interfaces: []\n  };\n  \n  function extractJSDocComment(node: ts.Node): string | undefined {\n    const jsDoc = (node as any).jsDoc;\n    if (jsDoc && jsDoc.length > 0) {\n      return jsDoc[0].comment;\n    }\n    return undefined;\n  }\n  \n  function visit(node: ts.Node): void {\n    if (ts.isFunctionDeclaration(node) && node.name) {\n      docs.functions.push({\n        name: node.name.text,\n        parameters: node.parameters.map(p => p.name.getText()),\n        returnType: node.type?.getText() || 'void',\n        documentation: extractJSDocComment(node)\n      });\n    }\n    \n    // Similar processing for classes and interfaces...\n    \n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n  return docs;\n}\n```\n\n**Build Tool Integration:**\n```typescript\n// Custom TypeScript plugin\nfunction createCustomPlugin(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile): ts.SourceFile => {\n      // Custom transformations based on compiler options or external config\n      const customConfig = getCustomConfig();\n      \n      if (customConfig.addRuntimeChecks) {\n        return addRuntimeTypeChecks(sourceFile, context);\n      }\n      \n      if (customConfig.optimizeBundle) {\n        return optimizeForBundle(sourceFile, context);\n      }\n      \n      return sourceFile;\n    };\n  };\n}\n```\n\n**Benefits:**\n- Programmatic code analysis\n- Custom code transformations\n- Build-time optimizations\n- Code generation from schemas\n- Static analysis tools\n- Custom linting rules\n- Documentation generation\n- Advanced refactoring tools",
      "keywords": ["TypeScript Compiler API", "AST manipulation", "Abstract Syntax Tree", "code generation", "type checker", "transformers", "static analysis", "build tools", "code metrics", "documentation generation"],
      "difficulty": "hard"
    },
    {
      "id": 1030,
      "tag": "typescript",
      "question": "What is the difference between Type and Interface in TypeScript? When should you use each?",
      "answer": "Types and interfaces are both ways to define object shapes in TypeScript, but they have different capabilities and use cases.\n\n**Key Differences:**\n\n**Interface Characteristics:**\n```typescript\n// Interfaces are extensible through declaration merging\ninterface User {\n  name: string;\n  age: number;\n}\n\ninterface User {\n  email: string; // Merges with the above interface\n}\n\n// Interface inheritance\ninterface AdminUser extends User {\n  permissions: string[];\n  role: 'admin';\n}\n\n// Multiple inheritance\ninterface Readable {\n  read(): string;\n}\n\ninterface Writable {\n  write(data: string): void;\n}\n\ninterface ReadWritable extends Readable, Writable {\n  // Inherits both read() and write() methods\n}\n\n// Interface implementation in classes\nclass FileManager implements ReadWritable {\n  read(): string {\n    return 'file content';\n  }\n  \n  write(data: string): void {\n    console.log('Writing:', data);\n  }\n}\n```\n\n**Type Alias Characteristics:**\n```typescript\n// Types are more flexible and can represent any type\ntype User = {\n  name: string;\n  age: number;\n};\n\n// Union types\ntype Status = 'loading' | 'success' | 'error';\ntype ID = string | number;\n\n// Intersection types\ntype AdminUser = User & {\n  permissions: string[];\n  role: 'admin';\n};\n\n// Function types\ntype EventHandler = (event: Event) => void;\ntype AsyncFunction<T> = () => Promise<T>;\n\n// Conditional types\ntype ApiResponse<T> = T extends string \n  ? { message: T } \n  : { data: T };\n\n// Mapped types\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Template literal types\ntype EventName = `on${Capitalize<string>}`;\ntype CSSProperty = `--${string}`;\n```\n\n**Declaration Merging (Interface Only):**\n```typescript\n// Multiple interface declarations merge automatically\ninterface Window {\n  customProperty: string;\n}\n\ninterface Window {\n  anotherProperty: number;\n}\n\n// Window now has both properties\nwindow.customProperty = 'value';\nwindow.anotherProperty = 42;\n\n// This is useful for extending global types or third-party libraries\ndeclare global {\n  interface Array<T> {\n    customMethod(): T[];\n  }\n}\n\nArray.prototype.customMethod = function() {\n  return [...this];\n};\n```\n\n**Performance Considerations:**\n```typescript\n// Interfaces are slightly more performant for object shapes\ninterface UserInterface {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Types need to be resolved/computed\ntype UserType = {\n  id: number;\n  name: string;\n  email: string;\n};\n\n// Complex computed types can be more expensive\ntype ComplexType<T> = {\n  [K in keyof T]: T[K] extends Function ? T[K] : never;\n};\n```\n\n**Advanced Type Operations:**\n```typescript\n// Types excel at complex transformations\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\ntype SplitRequired<T> = {\n  required: Pick<T, RequiredKeys<T>>;\n  optional: Pick<T, OptionalKeys<T>>;\n};\n\ninterface UserProfile {\n  id: number;\n  name: string;\n  email?: string;\n  phone?: string;\n}\n\ntype SplitUserProfile = SplitRequired<UserProfile>;\n// {\n//   required: { id: number; name: string; };\n//   optional: { email?: string; phone?: string; };\n// }\n```\n\n**When to Use Interface:**\n\n**1. Object Shape Definitions:**\n```typescript\n// Public APIs and contracts\ninterface ApiConfig {\n  baseUrl: string;\n  timeout: number;\n  retries: number;\n}\n\n// Component props in React\ninterface ButtonProps {\n  children: React.ReactNode;\n  onClick: () => void;\n  disabled?: boolean;\n  variant?: 'primary' | 'secondary';\n}\n```\n\n**2. Extensible APIs:**\n```typescript\n// Plugin systems\ninterface Plugin {\n  name: string;\n  version: string;\n  init(): void;\n}\n\n// Users can extend this interface\ninterface CustomPlugin extends Plugin {\n  customMethod(): void;\n}\n```\n\n**3. Class Contracts:**\n```typescript\ninterface Serializable {\n  serialize(): string;\n  deserialize(data: string): void;\n}\n\nclass User implements Serializable {\n  constructor(public name: string, public age: number) {}\n  \n  serialize(): string {\n    return JSON.stringify({ name: this.name, age: this.age });\n  }\n  \n  deserialize(data: string): void {\n    const parsed = JSON.parse(data);\n    this.name = parsed.name;\n    this.age = parsed.age;\n  }\n}\n```\n\n**When to Use Type:**\n\n**1. Union and Intersection Types:**\n```typescript\n// Complex type combinations\ntype Theme = 'light' | 'dark' | 'auto';\ntype Size = 'small' | 'medium' | 'large';\ntype ButtonVariant = `${Theme}-${Size}`;\n\ntype ApiError = {\n  code: number;\n  message: string;\n} & (\n  | { type: 'validation'; field: string }\n  | { type: 'auth'; token?: string }\n  | { type: 'network'; retryAfter?: number }\n);\n```\n\n**2. Computed and Conditional Types:**\n```typescript\n// Dynamic type generation\ntype EventMap = {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  submit: SubmitEvent;\n};\n\ntype EventHandlerMap<T> = {\n  [K in keyof T as `on${Capitalize<string & K>}`]: (event: T[K]) => void;\n};\n\ntype Handlers = EventHandlerMap<EventMap>;\n// {\n//   onClick: (event: MouseEvent) => void;\n//   onKeydown: (event: KeyboardEvent) => void;\n//   onSubmit: (event: SubmitEvent) => void;\n// }\n```\n\n**3. Function and Primitive Types:**\n```typescript\n// Function signatures\ntype Middleware<T = any> = (\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => T;\n\ntype AsyncMiddleware = Middleware<Promise<void>>;\ntype SyncMiddleware = Middleware<void>;\n\n// Utility types\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n```\n\n**Practical Examples:**\n\n**API Design with Interfaces:**\n```typescript\n// Extensible configuration interface\ninterface DatabaseConfig {\n  host: string;\n  port: number;\n  database: string;\n}\n\n// Third-party packages can extend this\ninterface PostgreSQLConfig extends DatabaseConfig {\n  ssl?: boolean;\n  schema?: string;\n}\n\ninterface MongoDBConfig extends DatabaseConfig {\n  authSource?: string;\n  replicaSet?: string;\n}\n```\n\n**Complex Types for State Management:**\n```typescript\n// Redux-style action types\ntype Action<T extends string, P = void> = P extends void\n  ? { type: T }\n  : { type: T; payload: P };\n\ntype UserActions = \n  | Action<'USER_LOGIN', { email: string; token: string }>\n  | Action<'USER_LOGOUT'>\n  | Action<'USER_UPDATE', Partial<User>>\n  | Action<'USER_DELETE', { id: string }>;\n\n// Type-safe reducer\ntype Reducer<S, A> = (state: S, action: A) => S;\n\nconst userReducer: Reducer<UserState, UserActions> = (state, action) => {\n  switch (action.type) {\n    case 'USER_LOGIN':\n      return { ...state, user: action.payload, isLoggedIn: true };\n    case 'USER_LOGOUT':\n      return { ...state, user: null, isLoggedIn: false };\n    case 'USER_UPDATE':\n      return { ...state, user: { ...state.user!, ...action.payload } };\n    default:\n      return state;\n  }\n};\n```\n\n**Best Practices:**\n\n1. **Use interfaces for object shapes** that might be extended or implemented\n2. **Use types for unions, intersections,** and computed types\n3. **Use interfaces for public APIs** to allow declaration merging\n4. **Use types for internal implementations** and complex transformations\n5. **Prefer interfaces for React props** and component contracts\n6. **Use types for utility functions** and generic constraints\n\n**Migration Strategy:**\n```typescript\n// You can convert between them when needed\ninterface UserInterface {\n  name: string;\n  age: number;\n}\n\n// Convert interface to type\ntype UserType = UserInterface;\n\n// Convert type to interface (for object types)\ntype UserTypeAlias = {\n  name: string;\n  age: number;\n};\n\ninterface UserFromType extends UserTypeAlias {}\n```",
      "keywords": ["interface", "type alias", "declaration merging", "inheritance", "union types", "intersection types", "extends", "implements", "object shapes", "performance"],
      "difficulty": "medium"
    },
    {
      "id": 1031,
      "tag": "typescript",
      "question": "Explain Object-Relational Mapping (ORM) in TypeScript. What are the popular libraries and their advantages/disadvantages?",
      "answer": "Object-Relational Mapping (ORM) bridges the gap between object-oriented programming and relational databases by mapping database tables to TypeScript classes and providing type-safe database operations.\n\n**Core ORM Concepts:**\n```typescript\n// Entity definition (represents a database table)\n@Entity('users')\nclass User {\n  @PrimaryGeneratedColumn()\n  id: number;\n  \n  @Column({ type: 'varchar', length: 255 })\n  email: string;\n  \n  @Column({ type: 'varchar', length: 100 })\n  firstName: string;\n  \n  @Column({ type: 'varchar', length: 100 })\n  lastName: string;\n  \n  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })\n  createdAt: Date;\n  \n  @OneToMany(() => Post, post => post.author)\n  posts: Post[];\n  \n  @ManyToMany(() => Role, role => role.users)\n  @JoinTable()\n  roles: Role[];\n}\n\n// Repository pattern for database operations\nconst userRepository = getRepository(User);\n\n// Type-safe queries\nconst users = await userRepository.find({\n  where: { email: 'user@example.com' },\n  relations: ['posts', 'roles']\n});\n```\n\n**Popular TypeScript ORMs:**\n\n**1. TypeORM:**\n```typescript\nimport { Entity, PrimaryGeneratedColumn, Column, Repository, getRepository } from 'typeorm';\n\n// Entity with decorators\n@Entity()\nclass Product {\n  @PrimaryGeneratedColumn()\n  id: number;\n  \n  @Column()\n  name: string;\n  \n  @Column('decimal', { precision: 10, scale: 2 })\n  price: number;\n  \n  @Column({ nullable: true })\n  description?: string;\n  \n  @ManyToOne(() => Category, category => category.products)\n  category: Category;\n}\n\n// Query builder\nconst products = await getRepository(Product)\n  .createQueryBuilder('product')\n  .leftJoinAndSelect('product.category', 'category')\n  .where('product.price > :price', { price: 100 })\n  .orderBy('product.name', 'ASC')\n  .getMany();\n\n// Custom repository\n@EntityRepository(Product)\nclass ProductRepository extends Repository<Product> {\n  async findByPriceRange(min: number, max: number): Promise<Product[]> {\n    return this.createQueryBuilder('product')\n      .where('product.price BETWEEN :min AND :max', { min, max })\n      .getMany();\n  }\n  \n  async findExpensiveProducts(): Promise<Product[]> {\n    return this.find({\n      where: {\n        price: MoreThan(1000)\n      },\n      relations: ['category']\n    });\n  }\n}\n```\n\n**2. Prisma:**\n```typescript\n// Schema definition (schema.prisma)\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  firstName String\n  lastName  String\n  createdAt DateTime @default(now())\n  posts     Post[]\n  profile   Profile?\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String\n  content   String?\n  published Boolean  @default(false)\n  authorId  Int\n  author    User     @relation(fields: [authorId], references: [id])\n  createdAt DateTime @default(now())\n}\n\n// Generated client with full type safety\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n\n// Type-safe queries\nconst users = await prisma.user.findMany({\n  include: {\n    posts: {\n      where: {\n        published: true\n      },\n      orderBy: {\n        createdAt: 'desc'\n      }\n    },\n    profile: true\n  }\n});\n\n// Transactions\nconst result = await prisma.$transaction(async (prisma) => {\n  const user = await prisma.user.create({\n    data: {\n      email: 'user@example.com',\n      firstName: 'John',\n      lastName: 'Doe'\n    }\n  });\n  \n  const post = await prisma.post.create({\n    data: {\n      title: 'Hello World',\n      content: 'This is my first post',\n      authorId: user.id\n    }\n  });\n  \n  return { user, post };\n});\n```\n\n**3. Sequelize:**\n```typescript\nimport { Sequelize, DataTypes, Model, Association } from 'sequelize';\n\nconst sequelize = new Sequelize('database', 'username', 'password', {\n  host: 'localhost',\n  dialect: 'postgres'\n});\n\n// Model definition\nclass User extends Model {\n  public id!: number;\n  public email!: string;\n  public firstName!: string;\n  public lastName!: string;\n  public createdAt!: Date;\n  public updatedAt!: Date;\n  \n  public readonly posts?: Post[];\n  \n  public static associations: {\n    posts: Association<User, Post>;\n  };\n}\n\nUser.init({\n  id: {\n    type: DataTypes.INTEGER,\n    autoIncrement: true,\n    primaryKey: true\n  },\n  email: {\n    type: DataTypes.STRING(255),\n    allowNull: false,\n    unique: true\n  },\n  firstName: DataTypes.STRING(100),\n  lastName: DataTypes.STRING(100)\n}, {\n  sequelize,\n  modelName: 'User',\n  tableName: 'users'\n});\n\n// Associations\nUser.hasMany(Post, { foreignKey: 'authorId', as: 'posts' });\nPost.belongsTo(User, { foreignKey: 'authorId', as: 'author' });\n\n// Queries with includes\nconst users = await User.findAll({\n  include: [{\n    model: Post,\n    as: 'posts',\n    where: { published: true }\n  }],\n  order: [['createdAt', 'DESC']]\n});\n```\n\n**4. MikroORM:**\n```typescript\nimport { Entity, PrimaryKey, Property, OneToMany, Collection } from '@mikro-orm/core';\n\n@Entity()\nclass User {\n  @PrimaryKey()\n  id!: number;\n  \n  @Property({ unique: true })\n  email!: string;\n  \n  @Property()\n  firstName!: string;\n  \n  @Property()\n  lastName!: string;\n  \n  @Property()\n  createdAt = new Date();\n  \n  @OneToMany(() => Post, post => post.author)\n  posts = new Collection<Post>(this);\n}\n\n// Unit of Work pattern\nconst user = new User();\nuser.email = 'user@example.com';\nuser.firstName = 'John';\nuser.lastName = 'Doe';\n\nem.persistAndFlush(user);\n\n// Query with populate\nconst users = await em.find(User, {}, {\n  populate: ['posts'],\n  orderBy: { createdAt: 'DESC' }\n});\n```\n\n**5. Drizzle ORM:**\n```typescript\nimport { pgTable, serial, varchar, timestamp, integer } from 'drizzle-orm/pg-core';\nimport { drizzle } from 'drizzle-orm/postgres-js';\nimport { eq, and, gte } from 'drizzle-orm';\n\n// Schema definition\nexport const users = pgTable('users', {\n  id: serial('id').primaryKey(),\n  email: varchar('email', { length: 255 }).notNull().unique(),\n  firstName: varchar('first_name', { length: 100 }).notNull(),\n  lastName: varchar('last_name', { length: 100 }).notNull(),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\nexport const posts = pgTable('posts', {\n  id: serial('id').primaryKey(),\n  title: varchar('title', { length: 255 }).notNull(),\n  content: varchar('content'),\n  authorId: integer('author_id').references(() => users.id),\n  createdAt: timestamp('created_at').defaultNow()\n});\n\n// Type-safe queries\nconst db = drizzle(postgres(connectionString));\n\nconst allUsers = await db.select().from(users);\n\nconst userWithPosts = await db\n  .select()\n  .from(users)\n  .leftJoin(posts, eq(users.id, posts.authorId))\n  .where(eq(users.email, 'user@example.com'));\n\n// Prepared statements\nconst getUserById = db\n  .select()\n  .from(users)\n  .where(eq(users.id, $1))\n  .prepare();\n\nconst user = await getUserById.execute(123);\n```\n\n**Advantages and Disadvantages:**\n\n**TypeORM:**\n```typescript\n// Advantages:\n// ✅ Decorator-based, familiar to Angular/NestJS developers\n// ✅ Active Record and Data Mapper patterns\n// ✅ Migration system\n// ✅ Multiple database support\n// ✅ Query builder and raw SQL support\n\n// Disadvantages:\n// ❌ Heavy runtime overhead\n// ❌ Complex configuration\n// ❌ Performance issues with large datasets\n// ❌ TypeScript support can be inconsistent\n\n// Example performance issue:\nconst users = await userRepository.find({ relations: ['posts', 'roles'] });\n// This can generate N+1 queries without proper optimization\n```\n\n**Prisma:**\n```typescript\n// Advantages:\n// ✅ Excellent TypeScript integration\n// ✅ Generated client with full type safety\n// ✅ Great developer experience\n// ✅ Built-in migration system\n// ✅ Query optimization\n// ✅ Excellent documentation\n\n// Disadvantages:\n// ❌ Schema-first approach (less flexibility)\n// ❌ Large generated client size\n// ❌ Limited customization options\n// ❌ Vendor lock-in to Prisma ecosystem\n\n// Generated types are very precise:\ntype UserWithPosts = Prisma.UserGetPayload<{\n  include: { posts: true }\n}>;\n```\n\n**Sequelize:**\n```typescript\n// Advantages:\n// ✅ Mature and stable\n// ✅ Extensive feature set\n// ✅ Good documentation\n// ✅ Multiple database support\n// ✅ Flexible configuration\n\n// Disadvantages:\n// ❌ TypeScript support is an afterthought\n// ❌ Verbose syntax\n// ❌ Complex association definitions\n// ❌ Performance can be inconsistent\n\n// TypeScript integration requires manual work:\ninterface UserAttributes {\n  id: number;\n  email: string;\n  firstName: string;\n  lastName: string;\n}\n\ninterface UserCreationAttributes extends Optional<UserAttributes, 'id'> {}\n```\n\n**MikroORM:**\n```typescript\n// Advantages:\n// ✅ Unit of Work pattern\n// ✅ Identity map\n// ✅ Good TypeScript support\n// ✅ Flexible entity definition\n// ✅ Performance optimizations\n\n// Disadvantages:\n// ❌ Smaller community\n// ❌ Learning curve for Unit of Work\n// ❌ Less tooling compared to others\n// ❌ Documentation gaps\n\n// Unit of Work pattern:\nem.persist(user); // Stage for persistence\nem.persist(post);\nfem.flush(); // Execute all changes in a transaction\n```\n\n**Drizzle:**\n```typescript\n// Advantages:\n// ✅ Lightweight and fast\n// ✅ SQL-like syntax\n// ✅ Excellent TypeScript inference\n// ✅ No runtime overhead\n// ✅ Tree-shakeable\n\n// Disadvantages:\n// ❌ Newer library (less mature)\n// ❌ Smaller ecosystem\n// ❌ Limited advanced features\n// ❌ Less abstraction (more SQL knowledge required)\n\n// SQL-like syntax:\nconst result = await db\n  .select({ id: users.id, email: users.email })\n  .from(users)\n  .where(and(\n    eq(users.active, true),\n    gte(users.createdAt, new Date('2023-01-01'))\n  ));\n```\n\n**Choosing the Right ORM:**\n\n**Use Prisma when:**\n- Building new applications\n- Want excellent TypeScript support\n- Need great developer experience\n- Schema-first approach works for your team\n\n**Use TypeORM when:**\n- Working with NestJS\n- Need decorator-based entities\n- Require extensive database feature support\n- Team is familiar with Active Record pattern\n\n**Use Drizzle when:**\n- Performance is critical\n- Want minimal runtime overhead\n- Comfortable with SQL\n- Building lightweight applications\n\n**Use Sequelize when:**\n- Working with legacy systems\n- Need maximum database compatibility\n- Team is already familiar with Sequelize\n- Require extensive customization options",
      "keywords": ["ORM", "Object-Relational Mapping", "TypeORM", "Prisma", "Sequelize", "MikroORM", "Drizzle", "database", "entities", "migrations", "query builder", "type safety"],
      "difficulty": "medium"
    },
    {
      "id": 1032,
      "tag": "typescript",
      "question": "How does concurrency work in TypeScript? Explain async patterns, Promise management, and parallel execution strategies.",
      "answer": "TypeScript inherits JavaScript's event-driven, non-blocking concurrency model while adding type safety to asynchronous operations.\n\n**Basic Async/Await Patterns:**\n```typescript\n// Basic async function\nasync function fetchUser(id: string): Promise<User> {\n  const response = await fetch(`/api/users/${id}`);\n  \n  if (!response.ok) {\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n  \n  return response.json() as Promise<User>;\n}\n\n// Error handling with try-catch\nasync function safeUserFetch(id: string): Promise<User | null> {\n  try {\n    const user = await fetchUser(id);\n    return user;\n  } catch (error) {\n    console.error('Failed to fetch user:', error);\n    return null;\n  }\n}\n\n// Generic async function with proper typing\nasync function apiRequest<T>(\n  url: string,\n  options?: RequestInit\n): Promise<T> {\n  const response = await fetch(url, options);\n  \n  if (!response.ok) {\n    throw new Error(`API Error: ${response.status}`);\n  }\n  \n  return response.json();\n}\n```\n\n**Promise Composition and Chaining:**\n```typescript\n// Promise utilities with proper typing\nclass PromiseUtils {\n  // Retry with exponential backoff\n  static async retry<T>(\n    fn: () => Promise<T>,\n    maxAttempts: number = 3,\n    baseDelay: number = 1000\n  ): Promise<T> {\n    let lastError: Error;\n    \n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        return await fn();\n      } catch (error) {\n        lastError = error as Error;\n        \n        if (attempt === maxAttempts) {\n          throw lastError;\n        }\n        \n        const delay = baseDelay * Math.pow(2, attempt - 1);\n        await this.delay(delay);\n      }\n    }\n    \n    throw lastError!;\n  }\n  \n  // Timeout wrapper\n  static timeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n    return Promise.race([\n      promise,\n      new Promise<never>((_, reject) => \n        setTimeout(() => reject(new Error('Operation timed out')), ms)\n      )\n    ]);\n  }\n  \n  // Delay utility\n  static delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n  \n  // Batch processing with concurrency limit\n  static async batch<T, R>(\n    items: T[],\n    processor: (item: T) => Promise<R>,\n    concurrency: number = 5\n  ): Promise<R[]> {\n    const results: R[] = [];\n    \n    for (let i = 0; i < items.length; i += concurrency) {\n      const batch = items.slice(i, i + concurrency);\n      const batchResults = await Promise.all(\n        batch.map(processor)\n      );\n      results.push(...batchResults);\n    }\n    \n    return results;\n  }\n}\n```\n\n**Parallel Execution Strategies:**\n```typescript\n// Sequential vs Parallel execution\nclass DataProcessor {\n  // Sequential execution (slower but memory efficient)\n  async processSequentially<T, R>(\n    items: T[],\n    processor: (item: T) => Promise<R>\n  ): Promise<R[]> {\n    const results: R[] = [];\n    \n    for (const item of items) {\n      const result = await processor(item);\n      results.push(result);\n    }\n    \n    return results;\n  }\n  \n  // Parallel execution (faster but uses more memory)\n  async processInParallel<T, R>(\n    items: T[],\n    processor: (item: T) => Promise<R>\n  ): Promise<R[]> {\n    const promises = items.map(processor);\n    return Promise.all(promises);\n  }\n  \n  // Controlled concurrency\n  async processWithConcurrency<T, R>(\n    items: T[],\n    processor: (item: T) => Promise<R>,\n    maxConcurrency: number = 5\n  ): Promise<R[]> {\n    const results: R[] = new Array(items.length);\n    const executing: Promise<void>[] = [];\n    \n    for (let i = 0; i < items.length; i++) {\n      const promise = processor(items[i]).then(result => {\n        results[i] = result;\n      });\n      \n      executing.push(promise);\n      \n      if (executing.length >= maxConcurrency) {\n        await Promise.race(executing);\n        // Remove completed promises\n        executing.splice(\n          executing.findIndex(p => p === promise), 1\n        );\n      }\n    }\n    \n    await Promise.all(executing);\n    return results;\n  }\n}\n```\n\n**Advanced Promise Patterns:**\n```typescript\n// Promise pool for resource management\nclass PromisePool {\n  private active = 0;\n  private queue: Array<() => void> = [];\n  \n  constructor(private maxConcurrency: number) {}\n  \n  async execute<T>(task: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          this.active++;\n          const result = await task();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        } finally {\n          this.active--;\n          this.processQueue();\n        }\n      });\n      \n      this.processQueue();\n    });\n  }\n  \n  private processQueue(): void {\n    if (this.active < this.maxConcurrency && this.queue.length > 0) {\n      const task = this.queue.shift()!;\n      task();\n    }\n  }\n}\n\n// Usage\nconst pool = new PromisePool(3);\n\nconst tasks = urls.map(url => \n  () => pool.execute(() => fetch(url).then(r => r.json()))\n);\n\nconst results = await Promise.all(tasks.map(task => task()));\n```\n\n**Event-Driven Concurrency:**\n```typescript\n// TypeScript EventEmitter with proper typing\ninterface EventMap {\n  data: { id: string; payload: any };\n  error: { message: string; code?: number };\n  complete: void;\n}\n\nclass TypedEventEmitter<T extends Record<string, any>> {\n  private listeners: {\n    [K in keyof T]?: Array<(data: T[K]) => void>;\n  } = {};\n  \n  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(listener);\n  }\n  \n  emit<K extends keyof T>(event: K, data: T[K]): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(data));\n    }\n  }\n  \n  off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      const index = eventListeners.indexOf(listener);\n      if (index > -1) {\n        eventListeners.splice(index, 1);\n      }\n    }\n  }\n}\n\n// Usage with async processing\nclass AsyncDataProcessor extends TypedEventEmitter<EventMap> {\n  async processData(items: any[]): Promise<void> {\n    try {\n      for (const item of items) {\n        const processed = await this.processItem(item);\n        this.emit('data', { id: item.id, payload: processed });\n      }\n      this.emit('complete', undefined);\n    } catch (error) {\n      this.emit('error', { \n        message: error instanceof Error ? error.message : 'Unknown error' \n      });\n    }\n  }\n  \n  private async processItem(item: any): Promise<any> {\n    // Simulate async processing\n    await PromiseUtils.delay(100);\n    return { ...item, processed: true };\n  }\n}\n```\n\n**Worker Threads for CPU-Intensive Tasks:**\n```typescript\n// worker.ts\nimport { parentPort, workerData } from 'worker_threads';\n\ninterface WorkerInput {\n  type: 'process';\n  data: number[];\n}\n\ninterface WorkerOutput {\n  type: 'result' | 'error';\n  data: any;\n}\n\nfunction processData(numbers: number[]): number[] {\n  // CPU-intensive operation\n  return numbers.map(n => {\n    let result = n;\n    for (let i = 0; i < 1000000; i++) {\n      result = Math.sqrt(result + i) * Math.PI;\n    }\n    return result;\n  });\n}\n\nparentPort?.on('message', (message: WorkerInput) => {\n  try {\n    if (message.type === 'process') {\n      const result = processData(message.data);\n      const response: WorkerOutput = { type: 'result', data: result };\n      parentPort?.postMessage(response);\n    }\n  } catch (error) {\n    const response: WorkerOutput = {\n      type: 'error',\n      data: error instanceof Error ? error.message : 'Unknown error'\n    };\n    parentPort?.postMessage(response);\n  }\n});\n\n// main.ts\nimport { Worker } from 'worker_threads';\nimport * as path from 'path';\n\nclass WorkerPool {\n  private workers: Worker[] = [];\n  private queue: Array<{\n    data: any;\n    resolve: (value: any) => void;\n    reject: (error: any) => void;\n  }> = [];\n  \n  constructor(private poolSize: number, private workerScript: string) {\n    this.initializeWorkers();\n  }\n  \n  private initializeWorkers(): void {\n    for (let i = 0; i < this.poolSize; i++) {\n      const worker = new Worker(this.workerScript);\n      worker.on('message', this.handleWorkerMessage.bind(this));\n      this.workers.push(worker);\n    }\n  }\n  \n  async execute(data: any): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ data, resolve, reject });\n      this.processQueue();\n    });\n  }\n  \n  private processQueue(): void {\n    if (this.queue.length === 0) return;\n    \n    const availableWorker = this.workers.find(w => !w.busy);\n    if (availableWorker) {\n      const task = this.queue.shift()!;\n      (availableWorker as any).busy = true;\n      (availableWorker as any).currentTask = task;\n      availableWorker.postMessage({ type: 'process', data: task.data });\n    }\n  }\n  \n  private handleWorkerMessage(message: WorkerOutput): void {\n    const worker = this.workers.find(w => (w as any).busy);\n    if (worker) {\n      const task = (worker as any).currentTask;\n      (worker as any).busy = false;\n      (worker as any).currentTask = null;\n      \n      if (message.type === 'result') {\n        task.resolve(message.data);\n      } else {\n        task.reject(new Error(message.data));\n      }\n      \n      this.processQueue();\n    }\n  }\n  \n  terminate(): Promise<void[]> {\n    return Promise.all(this.workers.map(worker => worker.terminate()));\n  }\n}\n```\n\n**Async Generators and Streams:**\n```typescript\n// Async generators for streaming data\nasync function* fetchDataStream(\n  urls: string[]\n): AsyncGenerator<{ url: string; data: any }, void, unknown> {\n  for (const url of urls) {\n    try {\n      const response = await fetch(url);\n      const data = await response.json();\n      yield { url, data };\n    } catch (error) {\n      console.error(`Failed to fetch ${url}:`, error);\n    }\n  }\n}\n\n// Consuming async generators\nasync function processDataStream(urls: string[]): Promise<void> {\n  for await (const { url, data } of fetchDataStream(urls)) {\n    console.log(`Processed data from ${url}:`, data);\n    // Process data as it arrives\n  }\n}\n\n// Async iterator with backpressure\nclass AsyncQueue<T> {\n  private queue: T[] = [];\n  private resolvers: Array<(value: T) => void> = [];\n  private closed = false;\n  \n  enqueue(item: T): void {\n    if (this.closed) throw new Error('Queue is closed');\n    \n    if (this.resolvers.length > 0) {\n      const resolve = this.resolvers.shift()!;\n      resolve(item);\n    } else {\n      this.queue.push(item);\n    }\n  }\n  \n  async dequeue(): Promise<T | undefined> {\n    if (this.queue.length > 0) {\n      return this.queue.shift();\n    }\n    \n    if (this.closed) {\n      return undefined;\n    }\n    \n    return new Promise<T>(resolve => {\n      this.resolvers.push(resolve);\n    });\n  }\n  \n  close(): void {\n    this.closed = true;\n    this.resolvers.forEach(resolve => resolve(undefined as any));\n    this.resolvers.length = 0;\n  }\n  \n  async *[Symbol.asyncIterator](): AsyncIterator<T> {\n    let item: T | undefined;\n    while ((item = await this.dequeue()) !== undefined) {\n      yield item;\n    }\n  }\n}\n```\n\n**Error Handling and Recovery:**\n```typescript\n// Circuit breaker pattern for resilient async operations\nclass CircuitBreaker {\n  private failures = 0;\n  private lastFailureTime = 0;\n  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';\n  \n  constructor(\n    private failureThreshold: number = 5,\n    private timeout: number = 60000\n  ) {}\n  \n  async execute<T>(operation: () => Promise<T>): Promise<T> {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'HALF_OPEN';\n      } else {\n        throw new Error('Circuit breaker is OPEN');\n      }\n    }\n    \n    try {\n      const result = await operation();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  private onSuccess(): void {\n    this.failures = 0;\n    this.state = 'CLOSED';\n  }\n  \n  private onFailure(): void {\n    this.failures++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failures >= this.failureThreshold) {\n      this.state = 'OPEN';\n    }\n  }\n}\n```\n\n**Best Practices:**\n\n1. **Use proper typing** for async operations\n2. **Handle errors gracefully** with try-catch\n3. **Implement timeouts** for network operations\n4. **Use Promise.all()** for parallel operations\n5. **Consider memory usage** in concurrent operations\n6. **Implement backpressure** for data streams\n7. **Use circuit breakers** for resilience\n8. **Monitor and log** async operations",
      "keywords": ["concurrency", "async await", "promises", "parallel execution", "Promise.all", "workers", "event emitters", "async generators", "circuit breaker", "error handling", "streaming", "backpressure"],
      "difficulty": "hard"
    },
    {
      "id": 1033,
      "tag": "typescript",
      "question": "What are Conditional Types and how do you use them for advanced type manipulation?",
      "answer": "Conditional types enable creating types that depend on a condition, using the syntax `T extends U ? X : Y` to perform type-level logic and transformations.\n\n**Basic Conditional Types:**\n```typescript\n// Basic conditional type syntax\ntype IsString<T> = T extends string ? true : false;\n\ntype Test1 = IsString<string>; // true\ntype Test2 = IsString<number>; // false\ntype Test3 = IsString<'hello'>; // true\n\n// Practical example: Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringArray = ArrayElement<string[]>; // string\ntype NumberArray = ArrayElement<number[]>; // number\ntype NotArray = ArrayElement<string>; // never\n\n// Function return type extraction\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype FuncReturn = ReturnType<() => string>; // string\ntype AsyncReturn = ReturnType<() => Promise<number>>; // Promise<number>\n```\n\n**Distributed Conditional Types:**\n```typescript\n// When applied to union types, conditionals distribute\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype UnionArrays = ToArray<string | number>; \n// string[] | number[] (not (string | number)[])\n\n// Filtering union types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype Filtered = NonNullable<string | null | number | undefined>; \n// string | number\n\n// Extract function types from union\ntype ExtractFunctions<T> = T extends (...args: any[]) => any ? T : never;\n\ntype Functions = ExtractFunctions<\n  string | ((x: number) => string) | number | ((y: string) => number)\n>; \n// ((x: number) => string) | ((y: string) => number)\n```\n\n**Complex Conditional Logic:**\n```typescript\n// Nested conditional types\ntype TypeName<T> = \n  T extends string ? 'string' :\n  T extends number ? 'number' :\n  T extends boolean ? 'boolean' :\n  T extends undefined ? 'undefined' :\n  T extends null ? 'null' :\n  T extends Function ? 'function' :\n  T extends object ? 'object' :\n  'unknown';\n\ntype T1 = TypeName<string>; // 'string'\ntype T2 = TypeName<() => void>; // 'function'\ntype T3 = TypeName<{}>; // 'object'\n\n// Multiple condition checking\ntype IsStringOrNumber<T> = T extends string \n  ? true \n  : T extends number \n    ? true \n    : false;\n\n// Complex type transformation\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\ninterface User {\n  name: string;\n  settings: {\n    theme: string;\n    notifications: {\n      email: boolean;\n      push: boolean;\n    };\n  };\n  updateProfile: (data: any) => void;\n}\n\ntype ReadonlyUser = DeepReadonly<User>;\n// All properties become readonly recursively, except functions\n```\n\n**Practical Utility Types:**\n```typescript\n// Required vs Optional properties\ntype RequiredKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? never : K;\n}[keyof T];\n\ntype OptionalKeys<T> = {\n  [K in keyof T]-?: {} extends Pick<T, K> ? K : never;\n}[keyof T];\n\ninterface UserProfile {\n  id: number;\n  name: string;\n  email?: string;\n  phone?: string;\n}\n\ntype Required = RequiredKeys<UserProfile>; // 'id' | 'name'\ntype Optional = OptionalKeys<UserProfile>; // 'email' | 'phone'\n\n// Split interface into required and optional parts\ntype SplitRequiredOptional<T> = {\n  required: Pick<T, RequiredKeys<T>>;\n  optional: Pick<T, OptionalKeys<T>>;\n};\n\ntype SplitUser = SplitRequiredOptional<UserProfile>;\n// {\n//   required: { id: number; name: string; };\n//   optional: { email?: string; phone?: string; };\n// }\n```\n\n**Function Signature Manipulation:**\n```typescript\n// Extract function parameters\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\n// Create overloaded function types\ntype OverloadedFunction<T> = T extends {\n  (...args: infer A1): infer R1;\n  (...args: infer A2): infer R2;\n}\n  ? {\n    (...args: A1): R1;\n    (...args: A2): R2;\n  }\n  : T extends (...args: infer A): infer R\n    ? (...args: A) => R\n    : never;\n\n// Async function transformation\ntype AsyncFunction<T> = T extends (...args: infer P) => infer R\n  ? (...args: P) => Promise<R>\n  : never;\n\ntype SyncFunc = (x: number, y: string) => boolean;\ntype AsyncFunc = AsyncFunction<SyncFunc>;\n// (x: number, y: string) => Promise<boolean>\n\n// Curry function type\ntype Curry<P extends readonly unknown[], R> = P extends readonly [\n  infer Head,\n  ...infer Tail\n]\n  ? (arg: Head) => Curry<Tail, R>\n  : R;\n\ntype CurriedAdd = Curry<[number, number, number], number>;\n// (arg: number) => (arg: number) => (arg: number) => number\n```\n\n**API Response Type Generation:**\n```typescript\n// Transform API response types\ntype APIResponse<T> = {\n  data: T;\n  status: number;\n  message: string;\n};\n\ntype ErrorResponse = {\n  error: string;\n  code: number;\n};\n\n// Conditional response type based on success\ntype ConditionalResponse<T, S extends boolean> = S extends true\n  ? APIResponse<T>\n  : ErrorResponse;\n\n// Extract data type from API response\ntype ExtractData<T> = T extends APIResponse<infer D> \n  ? D \n  : T extends { data: infer D }\n    ? D\n    : never;\n\ntype UserData = ExtractData<APIResponse<User>>; // User\ntype ProductData = ExtractData<{ data: Product; meta: any }>; // Product\n\n// Transform endpoint definitions to client methods\ntype EndpointToMethod<T> = T extends {\n  method: infer M;\n  path: infer P;\n  request?: infer Req;\n  response: infer Res;\n}\n  ? M extends 'GET'\n    ? P extends string\n      ? () => Promise<Res>\n      : never\n    : M extends 'POST' | 'PUT' | 'PATCH'\n      ? Req extends undefined\n        ? () => Promise<Res>\n        : (data: Req) => Promise<Res>\n      : never\n  : never;\n\ninterface UserEndpoint {\n  method: 'GET';\n  path: '/users';\n  response: User[];\n}\n\ninterface CreateUserEndpoint {\n  method: 'POST';\n  path: '/users';\n  request: CreateUserRequest;\n  response: User;\n}\n\ntype GetUsers = EndpointToMethod<UserEndpoint>; // () => Promise<User[]>\ntype CreateUser = EndpointToMethod<CreateUserEndpoint>; // (data: CreateUserRequest) => Promise<User>\n```\n\n**String Manipulation with Conditionals:**\n```typescript\n// String starts with check\ntype StartsWith<S extends string, T extends string> = S extends `${T}${string}` \n  ? true \n  : false;\n\ntype Test1 = StartsWith<'hello world', 'hello'>; // true\ntype Test2 = StartsWith<'hello world', 'world'>; // false\n\n// Extract file extension\ntype GetFileExtension<S extends string> = S extends `${string}.${infer Ext}`\n  ? Ext\n  : never;\n\ntype JSExt = GetFileExtension<'file.js'>; // 'js'\ntype TSExt = GetFileExtension<'component.tsx'>; // 'tsx'\n\n// Convert camelCase to kebab-case\ntype CamelToKebab<S extends string> = S extends `${infer First}${infer Rest}`\n  ? First extends Uppercase<First>\n    ? `-${Lowercase<First>}${CamelToKebab<Rest>}`\n    : `${First}${CamelToKebab<Rest>}`\n  : S;\n\ntype Kebab1 = CamelToKebab<'userName'>; // 'user-name'\ntype Kebab2 = CamelToKebab<'backgroundColor'>; // 'background-color'\n\n// URL path parameter extraction\ntype ExtractPathParams<T extends string> = T extends `${string}:${infer Param}/${infer Rest}`\n  ? { [K in Param]: string } & ExtractPathParams<Rest>\n  : T extends `${string}:${infer Param}`\n    ? { [K in Param]: string }\n    : {};\n\ntype RouteParams = ExtractPathParams<'/users/:userId/posts/:postId'>;\n// { userId: string; postId: string }\n```\n\n**Form and Validation Types:**\n```typescript\n// Generate form field types\ntype FormField<T> = {\n  value: T;\n  error?: string;\n  touched: boolean;\n  valid: boolean;\n};\n\ntype FormFields<T> = {\n  [K in keyof T]: FormField<T[K]>;\n};\n\n// Generate validation rules\ntype ValidationRule<T> = T extends string\n  ? {\n      required?: boolean;\n      minLength?: number;\n      maxLength?: number;\n      pattern?: RegExp;\n    }\n  : T extends number\n    ? {\n        required?: boolean;\n        min?: number;\n        max?: number;\n      }\n    : T extends boolean\n      ? {\n          required?: boolean;\n        }\n      : {\n          required?: boolean;\n          custom?: (value: T) => boolean;\n        };\n\ntype ValidationRules<T> = {\n  [K in keyof T]?: ValidationRule<T[K]>;\n};\n\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n  isActive: boolean;\n}\n\ntype UserForm = FormFields<User>;\ntype UserValidation = ValidationRules<User>;\n```\n\n**React Component Prop Inference:**\n```typescript\n// Extract component props\ntype ComponentProps<T> = T extends React.ComponentType<infer P> ? P : never;\n\n// Make certain props optional for HOC\ntype WithOptionalProps<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\n// Conditional props based on variant\ntype ButtonProps<T extends 'button' | 'link'> = {\n  children: React.ReactNode;\n  variant: T;\n} & (T extends 'button'\n  ? {\n      onClick: () => void;\n      type?: 'button' | 'submit' | 'reset';\n    }\n  : {\n      href: string;\n      target?: '_blank' | '_self';\n    });\n\nconst Button = <T extends 'button' | 'link'>(props: ButtonProps<T>) => {\n  if (props.variant === 'button') {\n    // TypeScript knows onClick is available\n    return <button onClick={props.onClick}>{props.children}</button>;\n  } else {\n    // TypeScript knows href is available\n    return <a href={props.href}>{props.children}</a>;\n  }\n};\n```\n\n**Advanced Type Inference:**\n```typescript\n// Infer tuple length\ntype Length<T extends readonly any[]> = T['length'];\n\ntype ArrayLength = Length<[1, 2, 3, 4]>; // 4\n\n// Reverse tuple\ntype Reverse<T extends readonly any[]> = T extends readonly [...infer Rest, infer Last]\n  ? [Last, ...Reverse<Rest>]\n  : [];\n\ntype Reversed = Reverse<[1, 2, 3, 4]>; // [4, 3, 2, 1]\n\n// Zip two tuples\ntype Zip<T extends readonly any[], U extends readonly any[]> = T extends readonly [\n  infer THead,\n  ...infer TTail\n]\n  ? U extends readonly [infer UHead, ...infer UTail]\n    ? [[THead, UHead], ...Zip<TTail, UTail>]\n    : []\n  : [];\n\ntype Zipped = Zip<[1, 2, 3], ['a', 'b', 'c']>; \n// [[1, 'a'], [2, 'b'], [3, 'c']]\n```\n\n**Performance Considerations:**\n```typescript\n// Avoid deeply recursive conditional types\n// Bad: Can cause TypeScript to hit recursion limits\ntype DeepFlatten<T> = T extends (infer U)[]\n  ? DeepFlatten<U>\n  : T;\n\n// Better: Limit recursion depth\ntype DeepFlattenSafe<T, Depth extends number = 5> = Depth extends 0\n  ? T\n  : T extends (infer U)[]\n    ? DeepFlattenSafe<U, Prev<Depth>>\n    : T;\n\ntype Prev<T extends number> = T extends 1 ? 0 : T extends 2 ? 1 : T extends 3 ? 2 : T extends 4 ? 3 : T extends 5 ? 4 : never;\n```\n\n**Benefits:**\n- Type-safe conditional logic\n- Dynamic type generation\n- Advanced type inference\n- Better API design\n- Compile-time validation\n- Improved developer experience",
      "keywords": ["conditional types", "type inference", "infer keyword", "distributed conditionals", "type manipulation", "utility types", "template literals", "recursive types", "advanced types", "type-level programming"],
      "difficulty": "hard"
    },
    {
      "id": 1034,
      "tag": "typescript",
      "question": "How do you implement and use Decorators in TypeScript? Explain different types and practical applications.",
      "answer": "Decorators are a stage 2 proposal for JavaScript and experimental TypeScript feature that provide a way to add metadata and modify classes, methods, properties, and parameters at design time.\n\n**Enabling Decorators:**\n```typescript\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"target\": \"ES2020\",\n    \"lib\": [\"ES2020\", \"DOM\"]\n  }\n}\n\n// Install reflect-metadata for runtime type information\n// npm install reflect-metadata\nimport 'reflect-metadata';\n```\n\n**Class Decorators:**\n```typescript\n// Basic class decorator\nfunction Sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n// Decorator factory with parameters\nfunction Component(options: { selector: string; template: string }) {\n  return function <T extends { new (...args: any[]): {} }>(constructor: T) {\n    return class extends constructor {\n      selector = options.selector;\n      template = options.template;\n      \n      render() {\n        console.log(`Rendering ${this.selector}: ${this.template}`);\n      }\n    };\n  };\n}\n\n// Advanced class decorator with metadata\nfunction Entity(tableName: string) {\n  return function <T extends { new (...args: any[]): {} }>(constructor: T) {\n    // Store metadata\n    Reflect.defineMetadata('tableName', tableName, constructor);\n    Reflect.defineMetadata('isEntity', true, constructor);\n    \n    // Add static methods\n    (constructor as any).getTableName = () => tableName;\n    \n    return constructor;\n  };\n}\n\n@Sealed\n@Component({ selector: 'app-user', template: '<div>User Component</div>' })\nclass UserComponent {\n  constructor(public name: string) {}\n}\n\n@Entity('users')\nclass User {\n  constructor(public id: number, public name: string) {}\n}\n```\n\n**Method Decorators:**\n```typescript\n// Method decorator signature\ntype MethodDecorator = (\n  target: any,\n  propertyKey: string | symbol,\n  descriptor: PropertyDescriptor\n) => PropertyDescriptor | void;\n\n// Logging decorator\nfunction Log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling ${propertyKey} with args:`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`${propertyKey} returned:`, result);\n    return result;\n  };\n  \n  return descriptor;\n}\n\n// Performance measurement decorator\nfunction Measure(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = async function (...args: any[]) {\n    const start = performance.now();\n    try {\n      const result = await originalMethod.apply(this, args);\n      const end = performance.now();\n      console.log(`${propertyKey} took ${end - start} milliseconds`);\n      return result;\n    } catch (error) {\n      const end = performance.now();\n      console.log(`${propertyKey} failed after ${end - start} milliseconds`);\n      throw error;\n    }\n  };\n  \n  return descriptor;\n}\n\n// Retry decorator\nfunction Retry(attempts: number = 3, delay: number = 1000) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      let lastError: Error;\n      \n      for (let attempt = 1; attempt <= attempts; attempt++) {\n        try {\n          return await originalMethod.apply(this, args);\n        } catch (error) {\n          lastError = error as Error;\n          \n          if (attempt === attempts) {\n            throw lastError;\n          }\n          \n          console.log(`Attempt ${attempt} failed, retrying in ${delay}ms...`);\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n      \n      throw lastError!;\n    };\n    \n    return descriptor;\n  };\n}\n\nclass ApiService {\n  @Log\n  @Measure\n  async fetchUser(id: number): Promise<User> {\n    const response = await fetch(`/api/users/${id}`);\n    return response.json();\n  }\n  \n  @Retry(3, 2000)\n  async unreliableOperation(): Promise<string> {\n    if (Math.random() < 0.7) {\n      throw new Error('Random failure');\n    }\n    return 'Success!';\n  }\n}\n```\n\n**Property Decorators:**\n```typescript\n// Property decorator signature\ntype PropertyDecorator = (\n  target: any,\n  propertyKey: string | symbol\n) => void;\n\n// Validation decorators\nfunction Required(target: any, propertyKey: string) {\n  const validators = Reflect.getMetadata('validators', target) || {};\n  validators[propertyKey] = validators[propertyKey] || [];\n  validators[propertyKey].push((value: any) => {\n    if (value === undefined || value === null || value === '') {\n      return `${propertyKey} is required`;\n    }\n    return null;\n  });\n  Reflect.defineMetadata('validators', validators, target);\n}\n\nfunction MinLength(length: number) {\n  return function (target: any, propertyKey: string) {\n    const validators = Reflect.getMetadata('validators', target) || {};\n    validators[propertyKey] = validators[propertyKey] || [];\n    validators[propertyKey].push((value: string) => {\n      if (value && value.length < length) {\n        return `${propertyKey} must be at least ${length} characters`;\n      }\n      return null;\n    });\n    Reflect.defineMetadata('validators', validators, target);\n  };\n}\n\nfunction Email(target: any, propertyKey: string) {\n  const validators = Reflect.getMetadata('validators', target) || {};\n  validators[propertyKey] = validators[propertyKey] || [];\n  validators[propertyKey].push((value: string) => {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (value && !emailRegex.test(value)) {\n      return `${propertyKey} must be a valid email`;\n    }\n    return null;\n  });\n  Reflect.defineMetadata('validators', validators, target);\n}\n\n// Observable property decorator\nfunction Observable(target: any, propertyKey: string) {\n  const privateKey = `_${propertyKey}`;\n  const callbacks = `_${propertyKey}Callbacks`;\n  \n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[privateKey];\n    },\n    set(value) {\n      const oldValue = this[privateKey];\n      this[privateKey] = value;\n      \n      if (this[callbacks]) {\n        this[callbacks].forEach((callback: Function) => {\n          callback(value, oldValue);\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  \n  // Add subscription method\n  target[`on${propertyKey.charAt(0).toUpperCase() + propertyKey.slice(1)}Change`] = function(\n    callback: (newValue: any, oldValue: any) => void\n  ) {\n    this[callbacks] = this[callbacks] || [];\n    this[callbacks].push(callback);\n  };\n}\n\nclass UserModel {\n  @Required\n  @MinLength(2)\n  name: string;\n  \n  @Required\n  @Email\n  email: string;\n  \n  @Observable\n  status: 'active' | 'inactive' = 'active';\n  \n  constructor(name: string, email: string) {\n    this.name = name;\n    this.email = email;\n  }\n  \n  validate(): string[] {\n    const validators = Reflect.getMetadata('validators', this);\n    const errors: string[] = [];\n    \n    for (const [property, validatorList] of Object.entries(validators || {})) {\n      const value = (this as any)[property];\n      for (const validator of validatorList as Function[]) {\n        const error = validator(value);\n        if (error) {\n          errors.push(error);\n        }\n      }\n    }\n    \n    return errors;\n  }\n}\n```\n\n**Parameter Decorators:**\n```typescript\n// Parameter decorator signature\ntype ParameterDecorator = (\n  target: any,\n  propertyKey: string | symbol | undefined,\n  parameterIndex: number\n) => void;\n\n// Dependency injection parameter decorator\nfunction Inject(token: string) {\n  return function (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {\n    const existingTokens = Reflect.getMetadata('inject-tokens', target) || [];\n    existingTokens[parameterIndex] = token;\n    Reflect.defineMetadata('inject-tokens', existingTokens, target);\n  };\n}\n\n// Validation parameter decorator\nfunction Validate(validatorFn: (value: any) => boolean) {\n  return function (target: any, propertyKey: string | symbol | undefined, parameterIndex: number) {\n    const existingValidators = Reflect.getMetadata('param-validators', target, propertyKey!) || [];\n    existingValidators[parameterIndex] = validatorFn;\n    Reflect.defineMetadata('param-validators', existingValidators, target, propertyKey!);\n  };\n}\n\n// Auto-validation method decorator\nfunction ValidateParams(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  \n  descriptor.value = function (...args: any[]) {\n    const validators = Reflect.getMetadata('param-validators', target, propertyKey) || [];\n    \n    for (let i = 0; i < args.length; i++) {\n      const validator = validators[i];\n      if (validator && !validator(args[i])) {\n        throw new Error(`Invalid parameter at index ${i}`);\n      }\n    }\n    \n    return originalMethod.apply(this, args);\n  };\n  \n  return descriptor;\n}\n\nclass UserService {\n  constructor(\n    @Inject('logger') private logger: Logger,\n    @Inject('database') private db: Database\n  ) {}\n  \n  @ValidateParams\n  createUser(\n    @Validate((value) => typeof value === 'string' && value.length > 0)\n    name: string,\n    \n    @Validate((value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value))\n    email: string\n  ): User {\n    // Method implementation\n    return new User(1, name);\n  }\n}\n```\n\n**Practical Applications:**\n\n**1. HTTP API Decorators:**\n```typescript\n// Route decorators\nfunction Controller(basePath: string) {\n  return function <T extends { new (...args: any[]): {} }>(constructor: T) {\n    Reflect.defineMetadata('basePath', basePath, constructor);\n    return constructor;\n  };\n}\n\nfunction Get(path: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    Reflect.defineMetadata('route', { method: 'GET', path }, target, propertyKey);\n    return descriptor;\n  };\n}\n\nfunction Post(path: string) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    Reflect.defineMetadata('route', { method: 'POST', path }, target, propertyKey);\n    return descriptor;\n  };\n}\n\n@Controller('/api/users')\nclass UserController {\n  @Get('/')\n  getAllUsers(): User[] {\n    return [];\n  }\n  \n  @Get('/:id')\n  getUserById(@Param('id') id: string): User | null {\n    return null;\n  }\n  \n  @Post('/')\n  createUser(@Body() userData: CreateUserRequest): User {\n    return new User(1, userData.name);\n  }\n}\n```\n\n**2. Database ORM Decorators:**\n```typescript\n// ORM decorators\nfunction Table(name: string) {\n  return function <T extends { new (...args: any[]): {} }>(constructor: T) {\n    Reflect.defineMetadata('table', name, constructor);\n    return constructor;\n  };\n}\n\nfunction Column(options?: { type?: string; nullable?: boolean; unique?: boolean }) {\n  return function (target: any, propertyKey: string) {\n    const columns = Reflect.getMetadata('columns', target) || [];\n    columns.push({ property: propertyKey, ...options });\n    Reflect.defineMetadata('columns', columns, target);\n  };\n}\n\nfunction PrimaryKey(target: any, propertyKey: string) {\n  Reflect.defineMetadata('primaryKey', propertyKey, target);\n}\n\n@Table('users')\nclass User {\n  @PrimaryKey\n  @Column({ type: 'integer' })\n  id: number;\n  \n  @Column({ type: 'varchar', nullable: false })\n  name: string;\n  \n  @Column({ type: 'varchar', unique: true })\n  email: string;\n  \n  constructor(id: number, name: string) {\n    this.id = id;\n    this.name = name;\n  }\n}\n```\n\n**3. Caching Decorator:**\n```typescript\ninterface CacheOptions {\n  ttl?: number; // Time to live in milliseconds\n  key?: (args: any[]) => string;\n}\n\nfunction Cache(options: CacheOptions = {}) {\n  const cache = new Map<string, { value: any; expires: number }>();\n  \n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = async function (...args: any[]) {\n      const cacheKey = options.key \n        ? options.key(args) \n        : `${propertyKey}-${JSON.stringify(args)}`;\n      \n      const cached = cache.get(cacheKey);\n      const now = Date.now();\n      \n      if (cached && now < cached.expires) {\n        console.log(`Cache hit for ${cacheKey}`);\n        return cached.value;\n      }\n      \n      console.log(`Cache miss for ${cacheKey}`);\n      const result = await originalMethod.apply(this, args);\n      \n      const ttl = options.ttl || 60000; // Default 1 minute\n      cache.set(cacheKey, {\n        value: result,\n        expires: now + ttl\n      });\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n\nclass DataService {\n  @Cache({ ttl: 300000, key: (args) => `user-${args[0]}` })\n  async fetchUser(id: number): Promise<User> {\n    // Expensive operation\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    return new User(id, `User ${id}`);\n  }\n}\n```\n\n**Benefits:**\n- Clean separation of concerns\n- Reusable cross-cutting functionality\n- Declarative programming style\n- Metadata-driven development\n- Aspect-oriented programming\n- Better code organization",
      "keywords": ["decorators", "metadata", "reflect-metadata", "class decorators", "method decorators", "property decorators", "parameter decorators", "dependency injection", "validation", "caching", "AOP"],
      "difficulty": "hard"
    },
    {
      "id": 1035,
      "tag": "typescript",
      "question": "What are Utility Types in TypeScript? Explain built-in utilities and how to create custom ones.",
      "answer": "Utility types are predefined generic types that help transform and manipulate existing types, providing common type transformations without rewriting type definitions.\n\n**Built-in Utility Types:**\n\n**1. Partial<T> - Makes all properties optional:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype PartialUser = Partial<User>;\n// {\n//   id?: number;\n//   name?: string;\n//   email?: string;\n//   age?: number;\n// }\n\n// Useful for update operations\nfunction updateUser(id: number, updates: Partial<User>): User {\n  const existingUser = getUser(id);\n  return { ...existingUser, ...updates };\n}\n\nupdateUser(1, { name: 'John Doe' }); // Only name is required\n```\n\n**2. Required<T> - Makes all properties required:**\n```typescript\ninterface UserProfile {\n  name?: string;\n  email?: string;\n  avatar?: string;\n}\n\ntype RequiredProfile = Required<UserProfile>;\n// {\n//   name: string;\n//   email: string;\n//   avatar: string;\n// }\n\nfunction createProfile(profile: RequiredProfile): UserProfile {\n  return profile; // All fields must be provided\n}\n```\n\n**3. Readonly<T> - Makes all properties readonly:**\n```typescript\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n  retries: number;\n}\n\ntype ReadonlyConfig = Readonly<Config>;\n// {\n//   readonly apiUrl: string;\n//   readonly timeout: number;\n//   readonly retries: number;\n// }\n\nconst config: ReadonlyConfig = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3\n};\n\n// config.apiUrl = 'new-url'; // Error: Cannot assign to readonly property\n```\n\n**4. Pick<T, K> - Selects specific properties:**\n```typescript\ninterface Employee {\n  id: number;\n  name: string;\n  email: string;\n  department: string;\n  salary: number;\n  startDate: Date;\n}\n\ntype PublicEmployee = Pick<Employee, 'id' | 'name' | 'department'>;\n// {\n//   id: number;\n//   name: string;\n//   department: string;\n// }\n\ntype ContactInfo = Pick<Employee, 'name' | 'email'>;\n// {\n//   name: string;\n//   email: string;\n// }\n\nfunction getPublicProfile(employee: Employee): PublicEmployee {\n  return {\n    id: employee.id,\n    name: employee.name,\n    department: employee.department\n  };\n}\n```\n\n**5. Omit<T, K> - Excludes specific properties:**\n```typescript\ntype EmployeeWithoutSalary = Omit<Employee, 'salary' | 'startDate'>;\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   department: string;\n// }\n\ntype CreateEmployeeRequest = Omit<Employee, 'id' | 'startDate'> & {\n  startDate?: Date;\n};\n// {\n//   name: string;\n//   email: string;\n//   department: string;\n//   salary: number;\n//   startDate?: Date;\n// }\n\nfunction createEmployee(data: CreateEmployeeRequest): Employee {\n  return {\n    id: generateId(),\n    startDate: data.startDate || new Date(),\n    ...data\n  };\n}\n```\n\n**6. Record<K, T> - Creates object type with specific keys:**\n```typescript\ntype Status = 'pending' | 'approved' | 'rejected';\ntype StatusConfig = Record<Status, { color: string; label: string }>;\n// {\n//   pending: { color: string; label: string };\n//   approved: { color: string; label: string };\n//   rejected: { color: string; label: string };\n// }\n\nconst statusConfig: StatusConfig = {\n  pending: { color: 'yellow', label: 'Pending Review' },\n  approved: { color: 'green', label: 'Approved' },\n  rejected: { color: 'red', label: 'Rejected' }\n};\n\n// Dynamic record types\ntype UserRoles = Record<string, boolean>;\nconst userPermissions: UserRoles = {\n  canRead: true,\n  canWrite: false,\n  canDelete: false\n};\n```\n\n**7. Exclude<T, U> - Removes types from union:**\n```typescript\ntype AllColors = 'red' | 'green' | 'blue' | 'yellow' | 'purple';\ntype PrimaryColors = Exclude<AllColors, 'yellow' | 'purple'>;\n// 'red' | 'green' | 'blue'\n\ntype NonFunctionKeys<T> = Exclude<keyof T, symbol>;\ntype StringKeys = NonFunctionKeys<{ name: string; age: number; id: symbol }>;\n// 'name' | 'age'\n```\n\n**8. Extract<T, U> - Extracts matching types:**\n```typescript\ntype StringOrNumber = Extract<string | number | boolean, string | number>;\n// string | number\n\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ntype FunctionProperties<T> = Extract<FunctionPropertyNames<T>, string>;\n\nclass MyClass {\n  name: string = '';\n  age: number = 0;\n  getName(): string { return this.name; }\n  setAge(age: number): void { this.age = age; }\n}\n\ntype MyClassMethods = FunctionProperties<MyClass>;\n// 'getName' | 'setAge'\n```\n\n**9. NonNullable<T> - Removes null and undefined:**\n```typescript\ntype MaybeString = string | null | undefined;\ntype DefinitelyString = NonNullable<MaybeString>;\n// string\n\nfunction processValue(value: string | null | undefined): string {\n  const nonNullValue: NonNullable<typeof value> = value!;\n  return nonNullValue.toUpperCase();\n}\n```\n\n**10. ReturnType<T> - Gets function return type:**\n```typescript\nfunction getUser(): { id: number; name: string } {\n  return { id: 1, name: 'John' };\n}\n\nasync function fetchUsers(): Promise<User[]> {\n  return [];\n}\n\ntype UserType = ReturnType<typeof getUser>;\n// { id: number; name: string }\n\ntype UsersType = ReturnType<typeof fetchUsers>;\n// Promise<User[]>\n\n// Extract the resolved type from Promise\ntype ResolvedUsersType = Awaited<ReturnType<typeof fetchUsers>>;\n// User[]\n```\n\n**Custom Utility Types:**\n\n**1. Deep Readonly:**\n```typescript\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\ninterface NestedConfig {\n  database: {\n    host: string;\n    port: number;\n    credentials: {\n      username: string;\n      password: string;\n    };\n  };\n  cache: {\n    ttl: number;\n    maxSize: number;\n  };\n}\n\ntype ImmutableConfig = DeepReadonly<NestedConfig>;\n// All properties at all levels become readonly\n```\n\n**2. Optional by Keys:**\n```typescript\ntype OptionalByKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype UserWithOptionalEmail = OptionalByKeys<User, 'email' | 'age'>;\n// {\n//   id: number;\n//   name: string;\n//   email?: string;\n//   age?: number;\n// }\n\nfunction createUser(data: UserWithOptionalEmail): User {\n  return {\n    email: '',\n    age: 0,\n    ...data\n  };\n}\n```\n\n**3. Required by Keys:**\n```typescript\ntype RequiredByKeys<T, K extends keyof T> = T & Required<Pick<T, K>>;\n\ninterface PartialUser {\n  id?: number;\n  name?: string;\n  email?: string;\n}\n\ntype UserWithRequiredName = RequiredByKeys<PartialUser, 'name'>;\n// {\n//   id?: number;\n//   name: string; // Required\n//   email?: string;\n// }\n```\n\n**4. Mutable (opposite of Readonly):**\n```typescript\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\ninterface ReadonlyUser {\n  readonly id: number;\n  readonly name: string;\n  readonly email: string;\n}\n\ntype MutableUser = Mutable<ReadonlyUser>;\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n// }\n```\n\n**5. Deep Partial:**\n```typescript\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepPartial<T[P]>\n    : T[P];\n};\n\ntype PartialNestedConfig = DeepPartial<NestedConfig>;\n// All properties at all levels become optional\n\nfunction updateConfig(updates: DeepPartial<NestedConfig>): void {\n  // Can update any nested property without providing all fields\n}\n\nupdateConfig({\n  database: {\n    port: 5432 // Only port needs to be specified\n  }\n});\n```\n\n**6. Function Property Names:**\n```typescript\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];\n\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\n\nclass Calculator {\n  value: number = 0;\n  history: number[] = [];\n  \n  add(n: number): this {\n    this.value += n;\n    return this;\n  }\n  \n  multiply(n: number): this {\n    this.value *= n;\n    return this;\n  }\n  \n  reset(): void {\n    this.value = 0;\n    this.history = [];\n  }\n}\n\ntype CalculatorMethods = FunctionProperties<Calculator>;\n// { add: (n: number) => Calculator; multiply: (n: number) => Calculator; reset: () => void; }\n\ntype CalculatorData = NonFunctionProperties<Calculator>;\n// { value: number; history: number[]; }\n```\n\n**7. Conditional Properties:**\n```typescript\ntype ConditionalPick<T, C> = {\n  [K in keyof T as T[K] extends C ? K : never]: T[K];\n};\n\ntype ConditionalOmit<T, C> = {\n  [K in keyof T as T[K] extends C ? never : K]: T[K];\n};\n\ninterface MixedInterface {\n  id: number;\n  name: string;\n  isActive: boolean;\n  callback: () => void;\n  onClick: (event: Event) => void;\n  data: any[];\n}\n\ntype OnlyFunctions = ConditionalPick<MixedInterface, Function>;\n// { callback: () => void; onClick: (event: Event) => void; }\n\ntype NoFunctions = ConditionalOmit<MixedInterface, Function>;\n// { id: number; name: string; isActive: boolean; data: any[]; }\n```\n\n**8. Awaited (for Promise resolution):**\n```typescript\n// Built-in in newer TypeScript versions, custom implementation:\ntype MyAwaited<T> = T extends Promise<infer U>\n  ? U extends Promise<any>\n    ? MyAwaited<U>\n    : U\n  : T;\n\ntype AsyncFunction = () => Promise<Promise<string>>;\ntype ResolvedType = MyAwaited<ReturnType<AsyncFunction>>;\n// string\n```\n\n**Practical Applications:**\n\n**API Response Transformations:**\n```typescript\ntype ApiResponse<T> = {\n  data: T;\n  status: number;\n  message: string;\n  timestamp: string;\n};\n\ntype ClientData<T> = Omit<ApiResponse<T>, 'status' | 'timestamp'> & {\n  isSuccess: boolean;\n};\n\n// Transform API response to client data\nfunction transformResponse<T>(response: ApiResponse<T>): ClientData<T> {\n  return {\n    data: response.data,\n    message: response.message,\n    isSuccess: response.status >= 200 && response.status < 300\n  };\n}\n```\n\n**Form Validation:**\n```typescript\ntype ValidationErrors<T> = Partial<Record<keyof T, string>>;\ntype FormState<T> = {\n  values: T;\n  errors: ValidationErrors<T>;\n  touched: Partial<Record<keyof T, boolean>>;\n  isValid: boolean;\n};\n\ntype UserFormState = FormState<User>;\n// {\n//   values: User;\n//   errors: Partial<Record<keyof User, string>>;\n//   touched: Partial<Record<keyof User, boolean>>;\n//   isValid: boolean;\n// }\n```\n\n**Benefits:**\n- Reduces code duplication\n- Provides type safety\n- Enables flexible type transformations\n- Improves code maintainability\n- Creates reusable type patterns\n- Enhances developer experience",
      "keywords": ["utility types", "Partial", "Required", "Readonly", "Pick", "Omit", "Record", "Exclude", "Extract", "NonNullable", "ReturnType", "custom utilities", "type transformation", "generic types"],
      "difficulty": "medium"
    },
    {
      "id": 1036,
      "tag": "typescript",
      "question": "How do you handle complex generic constraints and type relationships in TypeScript?",
      "answer": "Generic constraints allow you to restrict generic type parameters and establish relationships between types, enabling powerful type-safe abstractions while maintaining flexibility.\n\n**Basic Generic Constraints:**\n```typescript\n// Constraint with extends keyword\ninterface Lengthwise {\n  length: number;\n}\n\nfunction logLength<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // Now we know arg has a length property\n  return arg;\n}\n\nlogLength('hello'); // string has length\nlogLength([1, 2, 3]); // array has length\nlogLength({ length: 10, value: 3 }); // object with length\n// logLength(123); // Error: number doesn't have length\n\n// Multiple constraints\ninterface Drawable {\n  draw(): void;\n}\n\ninterface Movable {\n  move(x: number, y: number): void;\n}\n\nfunction animate<T extends Drawable & Movable>(obj: T): T {\n  obj.draw();\n  obj.move(10, 10);\n  return obj;\n}\n```\n\n**Keyof Constraints:**\n```typescript\n// Constrain to keys of another type\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst person = { name: 'John', age: 30, email: 'john@example.com' };\n\nconst name = getProperty(person, 'name'); // string\nconst age = getProperty(person, 'age'); // number\n// const invalid = getProperty(person, 'height'); // Error: 'height' not in person\n\n// Multiple key constraints\nfunction pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    result[key] = obj[key];\n  }\n  return result;\n}\n\nconst subset = pick(person, 'name', 'age');\n// { name: string; age: number }\n```\n\n**Conditional Type Constraints:**\n```typescript\n// Constraint based on conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\nfunction assertNonNull<T>(value: T): NonNullable<T> {\n  if (value === null || value === undefined) {\n    throw new Error('Value is null or undefined');\n  }\n  return value as NonNullable<T>;\n}\n\nconst maybeString: string | null = Math.random() > 0.5 ? 'hello' : null;\nconst definiteString = assertNonNull(maybeString); // string\n\n// Function constraint\ntype AsyncFunction<T extends (...args: any[]) => any> = (\n  ...args: Parameters<T>\n) => Promise<ReturnType<T>>;\n\nfunction makeAsync<T extends (...args: any[]) => any>(\n  fn: T\n): AsyncFunction<T> {\n  return async (...args) => {\n    return fn(...args);\n  };\n}\n\nconst syncAdd = (a: number, b: number): number => a + b;\nconst asyncAdd = makeAsync(syncAdd);\n// (a: number, b: number) => Promise<number>\n```\n\n**Advanced Generic Relationships:**\n```typescript\n// Related generic parameters\ninterface Repository<T, ID> {\n  findById(id: ID): Promise<T | null>;\n  save(entity: T): Promise<T>;\n  delete(id: ID): Promise<void>;\n}\n\n// Constraint relationships between generics\ninterface Entity {\n  id: string | number;\n}\n\ninterface TypedRepository<T extends Entity> extends Repository<T, T['id']> {\n  findByProperty<K extends keyof T>(property: K, value: T[K]): Promise<T[]>;\n}\n\nclass UserRepository implements TypedRepository<User> {\n  async findById(id: string): Promise<User | null> {\n    // Implementation\n    return null;\n  }\n  \n  async save(user: User): Promise<User> {\n    // Implementation\n    return user;\n  }\n  \n  async delete(id: string): Promise<void> {\n    // Implementation\n  }\n  \n  async findByProperty<K extends keyof User>(\n    property: K, \n    value: User[K]\n  ): Promise<User[]> {\n    // Type-safe property search\n    return [];\n  }\n}\n\ninterface User extends Entity {\n  id: string;\n  name: string;\n  email: string;\n  age: number;\n}\n```\n\n**Generic Factory Patterns:**\n```typescript\n// Constructor constraint\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\n// Mixin pattern with constraints\nfunction Timestamped<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    timestamp = Date.now();\n    \n    getAge(): number {\n      return Date.now() - this.timestamp;\n    }\n  };\n}\n\nfunction Serializable<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    serialize(): string {\n      return JSON.stringify(this);\n    }\n    \n    static deserialize(data: string): InstanceType<TBase> {\n      return Object.assign(new Base(), JSON.parse(data));\n    }\n  };\n}\n\nclass User {\n  constructor(public name: string, public email: string) {}\n}\n\n// Compose mixins with proper typing\nconst TimestampedUser = Timestamped(User);\nconst SerializableTimestampedUser = Serializable(Timestamped(User));\n\nconst user = new SerializableTimestampedUser('John', 'john@example.com');\nconsole.log(user.getAge()); // From Timestamped\nconsole.log(user.serialize()); // From Serializable\n```\n\n**Mapped Type Constraints:**\n```typescript\n// Constraint on mapped types\ntype Nullable<T> = {\n  [P in keyof T]: T[P] | null;\n};\n\ntype Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\ntype StringifyProperties<T> = {\n  [K in keyof T]: T[K] extends string ? T[K] : string;\n};\n\n// Conditional property mapping\ntype ApiResponse<T> = {\n  [K in keyof T]: T[K] extends Date \n    ? string \n    : T[K] extends object \n      ? ApiResponse<T[K]>\n      : T[K];\n};\n\ninterface UserData {\n  id: number;\n  name: string;\n  createdAt: Date;\n  profile: {\n    bio: string;\n    birthDate: Date;\n  };\n}\n\ntype UserApiResponse = ApiResponse<UserData>;\n// {\n//   id: number;\n//   name: string;\n//   createdAt: string;\n//   profile: {\n//     bio: string;\n//     birthDate: string;\n//   };\n// }\n```\n\n**Complex Validation Constraints:**\n```typescript\n// Schema validation with constraints\ninterface ValidationSchema<T> {\n  [K in keyof T]: T[K] extends string\n    ? StringValidation\n    : T[K] extends number\n      ? NumberValidation\n      : T[K] extends boolean\n        ? BooleanValidation\n        : T[K] extends object\n          ? ValidationSchema<T[K]>\n          : never;\n}\n\ninterface StringValidation {\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n}\n\ninterface NumberValidation {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  integer?: boolean;\n}\n\ninterface BooleanValidation {\n  required?: boolean;\n}\n\n// Type-safe validator\nclass Validator<T> {\n  constructor(private schema: ValidationSchema<T>) {}\n  \n  validate(data: Partial<T>): ValidationResult<T> {\n    const errors: Partial<Record<keyof T, string>> = {};\n    \n    // Implementation would validate each property based on its schema\n    \n    return {\n      isValid: Object.keys(errors).length === 0,\n      errors,\n      data: data as T\n    };\n  }\n}\n\ninterface ValidationResult<T> {\n  isValid: boolean;\n  errors: Partial<Record<keyof T, string>>;\n  data: T;\n}\n\n// Usage with full type safety\ninterface UserForm {\n  name: string;\n  age: number;\n  email: string;\n  isActive: boolean;\n}\n\nconst userValidator = new Validator<UserForm>({\n  name: { required: true, minLength: 2 },\n  age: { required: true, min: 0, max: 120 },\n  email: { required: true, pattern: /^[^@]+@[^@]+\\.[^@]+$/ },\n  isActive: { required: false }\n});\n```\n\n**Event System with Constraints:**\n```typescript\n// Type-safe event emitter\ninterface EventMap {\n  [event: string]: any;\n}\n\nclass TypedEventEmitter<T extends EventMap> {\n  private listeners: {\n    [K in keyof T]?: Array<(data: T[K]) => void>;\n  } = {};\n  \n  on<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(listener);\n  }\n  \n  emit<K extends keyof T>(event: K, data: T[K]): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      eventListeners.forEach(listener => listener(data));\n    }\n  }\n  \n  off<K extends keyof T>(event: K, listener: (data: T[K]) => void): void {\n    const eventListeners = this.listeners[event];\n    if (eventListeners) {\n      const index = eventListeners.indexOf(listener);\n      if (index > -1) {\n        eventListeners.splice(index, 1);\n      }\n    }\n  }\n}\n\n// Define application events\ninterface AppEvents {\n  'user:login': { userId: string; timestamp: Date };\n  'user:logout': { userId: string };\n  'data:update': { collection: string; id: string; changes: object };\n  'error': { message: string; code?: number };\n}\n\nconst eventEmitter = new TypedEventEmitter<AppEvents>();\n\n// Type-safe event handling\neventEmitter.on('user:login', (data) => {\n  // data is typed as { userId: string; timestamp: Date }\n  console.log(`User ${data.userId} logged in at ${data.timestamp}`);\n});\n\neventEmitter.emit('user:login', {\n  userId: 'user123',\n  timestamp: new Date()\n});\n```\n\n**Database Query Builder:**\n```typescript\n// Type-safe query builder\ninterface Table {\n  [column: string]: any;\n}\n\nclass QueryBuilder<T extends Table> {\n  private selectFields: (keyof T)[] = [];\n  private whereConditions: Array<{\n    field: keyof T;\n    operator: '=' | '!=' | '>' | '<' | '>=' | '<=';\n    value: any;\n  }> = [];\n  \n  select<K extends keyof T>(...fields: K[]): QueryBuilder<Pick<T, K>> {\n    this.selectFields = fields;\n    return this as any;\n  }\n  \n  where<K extends keyof T>(\n    field: K,\n    operator: '=' | '!=' | '>' | '<' | '>=' | '<=',\n    value: T[K]\n  ): this {\n    this.whereConditions.push({ field, operator, value });\n    return this;\n  }\n  \n  async execute(): Promise<T[]> {\n    // Build and execute SQL query\n    return [];\n  }\n}\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n  isActive: boolean;\n}\n\n// Type-safe query building\nconst query = new QueryBuilder<User>()\n  .select('id', 'name', 'email') // Result type is Pick<User, 'id' | 'name' | 'email'>\n  .where('age', '>=', 18)\n  .where('isActive', '=', true);\n\nconst results = await query.execute();\n// results is typed as Array<Pick<User, 'id' | 'name' | 'email'>>\n```\n\n**Best Practices:**\n\n1. **Use meaningful constraint names**\n2. **Keep constraints as specific as possible**\n3. **Combine constraints when needed**\n4. **Use conditional types for complex logic**\n5. **Leverage mapped types for transformations**\n6. **Document complex constraint relationships**\n7. **Test edge cases with unit tests**\n8. **Consider performance implications**",
      "keywords": ["generic constraints", "extends keyword", "keyof constraints", "conditional types", "type relationships", "mapped types", "constructor constraints", "validation schemas", "query builders", "event systems"],
      "difficulty": "hard"
    },
    {
      "id": 1037,
      "tag": "typescript",
      "question": "How do you implement Design Patterns in TypeScript? Show examples of Singleton, Observer, Factory, and Strategy patterns.",
      "answer": "Design patterns in TypeScript leverage the type system to create more robust, type-safe implementations while maintaining the core pattern concepts.\n\n**1. Singleton Pattern:**\n```typescript\n// Classic Singleton with TypeScript\nclass DatabaseConnection {\n  private static instance: DatabaseConnection;\n  private isConnected: boolean = false;\n  \n  private constructor() {\n    // Private constructor prevents external instantiation\n  }\n  \n  public static getInstance(): DatabaseConnection {\n    if (!DatabaseConnection.instance) {\n      DatabaseConnection.instance = new DatabaseConnection();\n    }\n    return DatabaseConnection.instance;\n  }\n  \n  public connect(): void {\n    if (!this.isConnected) {\n      console.log('Connecting to database...');\n      this.isConnected = true;\n    }\n  }\n  \n  public disconnect(): void {\n    if (this.isConnected) {\n      console.log('Disconnecting from database...');\n      this.isConnected = false;\n    }\n  }\n  \n  public query(sql: string): any[] {\n    if (!this.isConnected) {\n      throw new Error('Database not connected');\n    }\n    console.log(`Executing query: ${sql}`);\n    return [];\n  }\n}\n\n// Generic Singleton base class\nabstract class Singleton {\n  private static instances: Map<string, Singleton> = new Map();\n  \n  protected constructor() {\n    const className = this.constructor.name;\n    if (Singleton.instances.has(className)) {\n      throw new Error(`Singleton ${className} already exists`);\n    }\n    Singleton.instances.set(className, this);\n  }\n  \n  public static getInstance<T extends Singleton>(this: new () => T): T {\n    const className = this.name;\n    if (!Singleton.instances.has(className)) {\n      new this();\n    }\n    return Singleton.instances.get(className) as T;\n  }\n}\n\n// Usage with generic singleton\nclass Logger extends Singleton {\n  private logs: string[] = [];\n  \n  public log(message: string): void {\n    this.logs.push(`${new Date().toISOString()}: ${message}`);\n    console.log(message);\n  }\n  \n  public getLogs(): readonly string[] {\n    return [...this.logs];\n  }\n}\n\nclass ConfigManager extends Singleton {\n  private config: Record<string, any> = {};\n  \n  public set(key: string, value: any): void {\n    this.config[key] = value;\n  }\n  \n  public get<T>(key: string): T | undefined {\n    return this.config[key] as T;\n  }\n}\n\n// Usage\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\nconsole.log(logger1 === logger2); // true\n\nconst config = ConfigManager.getInstance();\nconfig.set('apiUrl', 'https://api.example.com');\n```\n\n**2. Observer Pattern:**\n```typescript\n// Type-safe Observer pattern\ninterface Observer<T> {\n  update(data: T): void;\n}\n\ninterface Subject<T> {\n  attach(observer: Observer<T>): void;\n  detach(observer: Observer<T>): void;\n  notify(data: T): void;\n}\n\n// Generic Observable class\nclass Observable<T> implements Subject<T> {\n  private observers: Set<Observer<T>> = new Set();\n  \n  public attach(observer: Observer<T>): void {\n    this.observers.add(observer);\n  }\n  \n  public detach(observer: Observer<T>): void {\n    this.observers.delete(observer);\n  }\n  \n  public notify(data: T): void {\n    this.observers.forEach(observer => observer.update(data));\n  }\n  \n  public getObserverCount(): number {\n    return this.observers.size;\n  }\n}\n\n// Event-based Observer with typed events\ntype EventMap = {\n  userLogin: { userId: string; timestamp: Date };\n  userLogout: { userId: string };\n  dataUpdate: { collection: string; id: string; data: any };\n};\n\nclass EventEmitter {\n  private listeners: {\n    [K in keyof EventMap]?: Set<(data: EventMap[K]) => void>;\n  } = {};\n  \n  public on<K extends keyof EventMap>(\n    event: K, \n    listener: (data: EventMap[K]) => void\n  ): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = new Set();\n    }\n    this.listeners[event]!.add(listener);\n  }\n  \n  public off<K extends keyof EventMap>(\n    event: K, \n    listener: (data: EventMap[K]) => void\n  ): void {\n    this.listeners[event]?.delete(listener);\n  }\n  \n  public emit<K extends keyof EventMap>(event: K, data: EventMap[K]): void {\n    this.listeners[event]?.forEach(listener => listener(data));\n  }\n}\n\n// Practical example: User management with observers\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n  status: 'active' | 'inactive';\n}\n\nclass UserService extends Observable<UserData> {\n  private users: Map<string, UserData> = new Map();\n  \n  public createUser(userData: Omit<UserData, 'id'>): UserData {\n    const user: UserData = {\n      id: Math.random().toString(36),\n      ...userData\n    };\n    \n    this.users.set(user.id, user);\n    this.notify(user);\n    return user;\n  }\n  \n  public updateUser(id: string, updates: Partial<UserData>): UserData | null {\n    const user = this.users.get(id);\n    if (!user) return null;\n    \n    const updatedUser = { ...user, ...updates };\n    this.users.set(id, updatedUser);\n    this.notify(updatedUser);\n    return updatedUser;\n  }\n}\n\n// Observers\nclass EmailNotificationService implements Observer<UserData> {\n  update(user: UserData): void {\n    console.log(`Sending email notification for user: ${user.email}`);\n  }\n}\n\nclass AuditLogger implements Observer<UserData> {\n  update(user: UserData): void {\n    console.log(`Audit log: User ${user.id} was modified`);\n  }\n}\n\n// Usage\nconst userService = new UserService();\nconst emailService = new EmailNotificationService();\nconst auditLogger = new AuditLogger();\n\nuserService.attach(emailService);\nuserService.attach(auditLogger);\n\nconst newUser = userService.createUser({\n  name: 'John Doe',\n  email: 'john@example.com',\n  status: 'active'\n});\n```\n\n**3. Factory Pattern:**\n```typescript\n// Abstract Factory with TypeScript\nabstract class Vehicle {\n  abstract start(): void;\n  abstract stop(): void;\n  abstract getInfo(): string;\n}\n\nclass Car extends Vehicle {\n  constructor(private model: string, private year: number) {\n    super();\n  }\n  \n  start(): void {\n    console.log(`Starting ${this.model} car`);\n  }\n  \n  stop(): void {\n    console.log(`Stopping ${this.model} car`);\n  }\n  \n  getInfo(): string {\n    return `${this.year} ${this.model}`;\n  }\n}\n\nclass Motorcycle extends Vehicle {\n  constructor(private brand: string, private cc: number) {\n    super();\n  }\n  \n  start(): void {\n    console.log(`Starting ${this.brand} motorcycle`);\n  }\n  \n  stop(): void {\n    console.log(`Stopping ${this.brand} motorcycle`);\n  }\n  \n  getInfo(): string {\n    return `${this.brand} ${this.cc}cc`;\n  }\n}\n\n// Factory interface\ninterface VehicleFactory {\n  createVehicle(): Vehicle;\n}\n\n// Concrete factories\nclass CarFactory implements VehicleFactory {\n  constructor(private model: string, private year: number) {}\n  \n  createVehicle(): Vehicle {\n    return new Car(this.model, this.year);\n  }\n}\n\nclass MotorcycleFactory implements VehicleFactory {\n  constructor(private brand: string, private cc: number) {}\n  \n  createVehicle(): Vehicle {\n    return new Motorcycle(this.brand, this.cc);\n  }\n}\n\n// Generic Factory with registry\ntype Constructor<T = {}> = new (...args: any[]) => T;\n\nclass GenericFactory<T> {\n  private registry: Map<string, Constructor<T>> = new Map();\n  \n  public register(name: string, constructor: Constructor<T>): void {\n    this.registry.set(name, constructor);\n  }\n  \n  public create(name: string, ...args: any[]): T {\n    const Constructor = this.registry.get(name);\n    if (!Constructor) {\n      throw new Error(`No constructor registered for ${name}`);\n    }\n    return new Constructor(...args);\n  }\n  \n  public getRegisteredNames(): string[] {\n    return Array.from(this.registry.keys());\n  }\n}\n\n// Usage\nconst vehicleFactory = new GenericFactory<Vehicle>();\nvehicleFactory.register('car', Car);\nvehicleFactory.register('motorcycle', Motorcycle);\n\nconst car = vehicleFactory.create('car', 'Tesla Model 3', 2023);\nconst motorcycle = vehicleFactory.create('motorcycle', 'Harley Davidson', 1200);\n\n// Advanced Factory with configuration\ninterface VehicleConfig {\n  type: 'car' | 'motorcycle';\n  model: string;\n  year?: number;\n  cc?: number;\n  features?: string[];\n}\n\nclass ConfigurableVehicleFactory {\n  public static create(config: VehicleConfig): Vehicle {\n    switch (config.type) {\n      case 'car':\n        if (!config.year) {\n          throw new Error('Year is required for cars');\n        }\n        return new Car(config.model, config.year);\n        \n      case 'motorcycle':\n        if (!config.cc) {\n          throw new Error('CC is required for motorcycles');\n        }\n        return new Motorcycle(config.model, config.cc);\n        \n      default:\n        throw new Error(`Unsupported vehicle type: ${config.type}`);\n    }\n  }\n}\n\n// Usage with configuration\nconst vehicleFromConfig = ConfigurableVehicleFactory.create({\n  type: 'car',\n  model: 'BMW X5',\n  year: 2023,\n  features: ['AWD', 'Leather Seats']\n});\n```\n\n**4. Strategy Pattern:**\n```typescript\n// Strategy interface\ninterface SortingStrategy<T> {\n  sort(data: T[]): T[];\n}\n\n// Concrete strategies\nclass BubbleSortStrategy<T> implements SortingStrategy<T> {\n  sort(data: T[]): T[] {\n    const result = [...data];\n    for (let i = 0; i < result.length; i++) {\n      for (let j = 0; j < result.length - i - 1; j++) {\n        if (result[j] > result[j + 1]) {\n          [result[j], result[j + 1]] = [result[j + 1], result[j]];\n        }\n      }\n    }\n    return result;\n  }\n}\n\nclass QuickSortStrategy<T> implements SortingStrategy<T> {\n  sort(data: T[]): T[] {\n    if (data.length <= 1) return [...data];\n    \n    const pivot = data[0];\n    const left = data.slice(1).filter(x => x <= pivot);\n    const right = data.slice(1).filter(x => x > pivot);\n    \n    return [...this.sort(left), pivot, ...this.sort(right)];\n  }\n}\n\n// Context class\nclass Sorter<T> {\n  private strategy: SortingStrategy<T>;\n  \n  constructor(strategy: SortingStrategy<T>) {\n    this.strategy = strategy;\n  }\n  \n  public setStrategy(strategy: SortingStrategy<T>): void {\n    this.strategy = strategy;\n  }\n  \n  public sort(data: T[]): T[] {\n    return this.strategy.sort(data);\n  }\n}\n\n// Advanced Strategy with type-safe payment processing\ninterface PaymentStrategy {\n  processPayment(amount: number): Promise<PaymentResult>;\n  validatePayment(amount: number): boolean;\n}\n\ninterface PaymentResult {\n  success: boolean;\n  transactionId?: string;\n  error?: string;\n}\n\nclass CreditCardStrategy implements PaymentStrategy {\n  constructor(\n    private cardNumber: string,\n    private expiryDate: string,\n    private cvv: string\n  ) {}\n  \n  validatePayment(amount: number): boolean {\n    return amount > 0 && this.cardNumber.length === 16;\n  }\n  \n  async processPayment(amount: number): Promise<PaymentResult> {\n    if (!this.validatePayment(amount)) {\n      return { success: false, error: 'Invalid payment details' };\n    }\n    \n    // Simulate API call\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    return {\n      success: true,\n      transactionId: `cc_${Math.random().toString(36)}`\n    };\n  }\n}\n\nclass PayPalStrategy implements PaymentStrategy {\n  constructor(private email: string, private password: string) {}\n  \n  validatePayment(amount: number): boolean {\n    return amount > 0 && this.email.includes('@');\n  }\n  \n  async processPayment(amount: number): Promise<PaymentResult> {\n    if (!this.validatePayment(amount)) {\n      return { success: false, error: 'Invalid PayPal credentials' };\n    }\n    \n    // Simulate PayPal API call\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    \n    return {\n      success: true,\n      transactionId: `pp_${Math.random().toString(36)}`\n    };\n  }\n}\n\nclass BankTransferStrategy implements PaymentStrategy {\n  constructor(\n    private accountNumber: string,\n    private routingNumber: string\n  ) {}\n  \n  validatePayment(amount: number): boolean {\n    return amount > 0 && amount <= 10000; // Bank transfer limit\n  }\n  \n  async processPayment(amount: number): Promise<PaymentResult> {\n    if (!this.validatePayment(amount)) {\n      return { success: false, error: 'Amount exceeds bank transfer limit' };\n    }\n    \n    // Simulate bank API call\n    await new Promise(resolve => setTimeout(resolve, 2000));\n    \n    return {\n      success: true,\n      transactionId: `bt_${Math.random().toString(36)}`\n    };\n  }\n}\n\n// Payment processor with strategy\nclass PaymentProcessor {\n  private strategy: PaymentStrategy;\n  \n  constructor(strategy: PaymentStrategy) {\n    this.strategy = strategy;\n  }\n  \n  public setPaymentMethod(strategy: PaymentStrategy): void {\n    this.strategy = strategy;\n  }\n  \n  public async processPayment(amount: number): Promise<PaymentResult> {\n    console.log(`Processing payment of $${amount}`);\n    return await this.strategy.processPayment(amount);\n  }\n}\n\n// Generic Strategy pattern\ninterface Strategy<TInput, TOutput> {\n  execute(input: TInput): TOutput;\n}\n\nclass StrategyContext<TInput, TOutput> {\n  private strategies: Map<string, Strategy<TInput, TOutput>> = new Map();\n  private currentStrategy?: Strategy<TInput, TOutput>;\n  \n  public addStrategy(name: string, strategy: Strategy<TInput, TOutput>): void {\n    this.strategies.set(name, strategy);\n  }\n  \n  public setStrategy(name: string): void {\n    const strategy = this.strategies.get(name);\n    if (!strategy) {\n      throw new Error(`Strategy ${name} not found`);\n    }\n    this.currentStrategy = strategy;\n  }\n  \n  public execute(input: TInput): TOutput {\n    if (!this.currentStrategy) {\n      throw new Error('No strategy set');\n    }\n    return this.currentStrategy.execute(input);\n  }\n  \n  public getAvailableStrategies(): string[] {\n    return Array.from(this.strategies.keys());\n  }\n}\n\n// Usage examples\nconst numbers = [64, 34, 25, 12, 22, 11, 90];\nconst sorter = new Sorter(new QuickSortStrategy<number>());\nconsole.log('Quick sort:', sorter.sort(numbers));\n\nsorter.setStrategy(new BubbleSortStrategy<number>());\nconsole.log('Bubble sort:', sorter.sort(numbers));\n\n// Payment processing\nconst paymentProcessor = new PaymentProcessor(\n  new CreditCardStrategy('1234567890123456', '12/25', '123')\n);\n\npaymentProcessor.processPayment(100).then(result => {\n  console.log('Payment result:', result);\n});\n```\n\n**Benefits of TypeScript Design Patterns:**\n\n1. **Type Safety**: Compile-time error detection\n2. **Better IDE Support**: Autocomplete and refactoring\n3. **Self-Documenting Code**: Types serve as documentation\n4. **Easier Maintenance**: Clear interfaces and contracts\n5. **Generic Patterns**: Reusable across different types\n6. **Runtime Safety**: Reduced runtime errors through type checking",
      "keywords": ["design patterns", "singleton", "observer", "factory", "strategy", "type safety", "generic patterns", "interfaces", "polymorphism", "dependency injection"],
      "difficulty": "medium"
    },
    {
      "id": 1038,
      "tag": "typescript",
      "question": "How do you optimize TypeScript compilation and improve build performance?",
      "answer": "TypeScript compilation performance can be significantly improved through various configuration options, build strategies, and tooling optimizations.\n\n**TypeScript Compiler Configuration:**\n```json\n// tsconfig.json - Performance optimized\n{\n  \"compilerOptions\": {\n    // Target and module settings\n    \"target\": \"ES2020\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \n    // Compilation optimizations\n    \"incremental\": true,\n    \"tsBuildInfoFile\": \".tsbuildinfo\",\n    \"composite\": true,\n    \n    // Skip lib checking for faster builds\n    \"skipLibCheck\": true,\n    \"skipDefaultLibCheck\": true,\n    \n    // Only emit when no errors\n    \"noEmitOnError\": true,\n    \n    // Faster source maps for development\n    \"sourceMap\": true,\n    \"inlineSourceMap\": false,\n    \n    // Declaration files\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \n    // Strict type checking (helps catch errors early)\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \n    // Module resolution optimizations\n    \"resolveJsonModule\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \n    // Remove comments to reduce bundle size\n    \"removeComments\": true,\n    \n    // Import helpers for smaller bundles\n    \"importHelpers\": true,\n    \n    // Base URL for path mapping\n    \"baseUrl\": \"./src\",\n    \"paths\": {\n      \"@/*\": [\"*\"],\n      \"@components/*\": [\"components/*\"],\n      \"@utils/*\": [\"utils/*\"]\n    }\n  },\n  \n  // Include/exclude optimization\n  \"include\": [\n    \"src/**/*\",\n    \"types/**/*\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"**/*.spec.ts\",\n    \"**/*.test.ts\",\n    \"coverage\"\n  ]\n}\n```\n\n**Project References for Large Codebases:**\n```json\n// Root tsconfig.json\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./packages/core\" },\n    { \"path\": \"./packages/ui\" },\n    { \"path\": \"./packages/utils\" },\n    { \"path\": \"./apps/web\" },\n    { \"path\": \"./apps/api\" }\n  ]\n}\n\n// packages/core/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"references\": []\n}\n\n// packages/ui/tsconfig.json\n{\n  \"extends\": \"../../tsconfig.base.json\",\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\"\n  },\n  \"include\": [\"src/**/*\"],\n  \"references\": [\n    { \"path\": \"../core\" },\n    { \"path\": \"../utils\" }\n  ]\n}\n```\n\n**Build Scripts and Task Optimization:**\n```json\n// package.json\n{\n  \"scripts\": {\n    \"build\": \"tsc --build --verbose\",\n    \"build:clean\": \"tsc --build --clean\",\n    \"build:watch\": \"tsc --build --watch\",\n    \"build:incremental\": \"tsc --build --incremental\",\n    \"type-check\": \"tsc --noEmit\",\n    \"type-check:watch\": \"tsc --noEmit --watch\"\n  }\n}\n```\n\n**Webpack Configuration for TypeScript:**\n```javascript\n// webpack.config.js\nconst path = require('path');\nconst ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');\n\nmodule.exports = {\n  mode: 'development',\n  entry: './src/index.ts',\n  \n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: [\n          {\n            loader: 'ts-loader',\n            options: {\n              // Disable type checking in ts-loader\n              transpileOnly: true,\n              // Use experimental features for faster builds\n              experimentalWatchApi: true,\n              // Project references support\n              projectReferences: true\n            }\n          }\n        ],\n        exclude: /node_modules/\n      }\n    ]\n  },\n  \n  plugins: [\n    // Run type checking in separate process\n    new ForkTsCheckerWebpackPlugin({\n      typescript: {\n        configFile: 'tsconfig.json',\n        // Use project references\n        build: true\n      }\n    })\n  ],\n  \n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n    // Alias for faster resolution\n    alias: {\n      '@': path.resolve(__dirname, 'src'),\n      '@components': path.resolve(__dirname, 'src/components'),\n      '@utils': path.resolve(__dirname, 'src/utils')\n    }\n  },\n  \n  // Development optimizations\n  devtool: 'eval-source-map', // Faster than 'source-map'\n  \n  optimization: {\n    // Split chunks for better caching\n    splitChunks: {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all'\n        }\n      }\n    }\n  }\n};\n```\n\n**Esbuild for Faster Development:**\n```javascript\n// esbuild.config.js\nconst esbuild = require('esbuild');\nconst { nodeExternalsPlugin } = require('esbuild-node-externals');\n\n// Development build\nesbuild.build({\n  entryPoints: ['src/index.ts'],\n  bundle: true,\n  outfile: 'dist/index.js',\n  platform: 'node',\n  target: 'node16',\n  format: 'cjs',\n  sourcemap: true,\n  minify: false,\n  watch: {\n    onRebuild(error, result) {\n      if (error) console.error('Build failed:', error);\n      else console.log('Build succeeded');\n    }\n  },\n  plugins: [nodeExternalsPlugin()]\n}).catch(() => process.exit(1));\n\n// Production build\nesbuild.build({\n  entryPoints: ['src/index.ts'],\n  bundle: true,\n  outfile: 'dist/index.js',\n  platform: 'node',\n  target: 'node16',\n  format: 'cjs',\n  minify: true,\n  treeShaking: true,\n  plugins: [nodeExternalsPlugin()]\n});\n```\n\n**SWC Configuration for Ultra-Fast Builds:**\n```json\n// .swcrc\n{\n  \"jsc\": {\n    \"parser\": {\n      \"syntax\": \"typescript\",\n      \"tsx\": true,\n      \"decorators\": true,\n      \"dynamicImport\": true\n    },\n    \"transform\": {\n      \"react\": {\n        \"runtime\": \"automatic\"\n      },\n      \"decoratorMetadata\": true\n    },\n    \"target\": \"es2020\",\n    \"loose\": true,\n    \"externalHelpers\": false\n  },\n  \"module\": {\n    \"type\": \"es6\"\n  },\n  \"minify\": false,\n  \"sourceMaps\": true\n}\n```\n\n**Code Optimization Strategies:**\n\n**1. Efficient Import/Export Patterns:**\n```typescript\n// Avoid barrel exports for better tree shaking\n// ❌ Bad - imports entire module\nimport * as utils from './utils';\n\n// ✅ Good - specific imports\nimport { debounce, throttle } from './utils/timing';\nimport { formatDate } from './utils/date';\n\n// ❌ Bad - barrel export that imports everything\nexport * from './moduleA';\nexport * from './moduleB';\nexport * from './moduleC';\n\n// ✅ Good - specific re-exports\nexport { SpecificFunction } from './moduleA';\nexport type { SpecificType } from './moduleB';\n\n// Use type-only imports when possible\nimport type { User, ApiResponse } from './types';\nimport { processUser } from './userService';\n```\n\n**2. Lazy Loading and Dynamic Imports:**\n```typescript\n// Lazy loading for better build performance\nclass FeatureManager {\n  private features: Map<string, () => Promise<any>> = new Map();\n  \n  constructor() {\n    // Register features without importing them\n    this.features.set('analytics', () => import('./features/analytics'));\n    this.features.set('reporting', () => import('./features/reporting'));\n    this.features.set('dashboard', () => import('./features/dashboard'));\n  }\n  \n  async loadFeature(name: string) {\n    const loader = this.features.get(name);\n    if (!loader) {\n      throw new Error(`Feature ${name} not found`);\n    }\n    \n    const module = await loader();\n    return module.default || module;\n  }\n}\n\n// Route-based code splitting\nconst routeConfig = {\n  '/dashboard': () => import('./pages/Dashboard'),\n  '/profile': () => import('./pages/Profile'),\n  '/settings': () => import('./pages/Settings')\n};\n\n// Component lazy loading\nconst LazyComponent = React.lazy(() => import('./HeavyComponent'));\n```\n\n**3. Type-Only Files:**\n```typescript\n// types.ts - Type-only file\nexport interface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport type UserRole = 'admin' | 'user' | 'guest';\n\nexport interface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\n// Don't include runtime code in type files\n// This helps with compilation speed\n```\n\n**Build Performance Monitoring:**\n```typescript\n// build-monitor.ts\nimport { performance } from 'perf_hooks';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ninterface BuildMetrics {\n  timestamp: number;\n  duration: number;\n  fileCount: number;\n  errorCount: number;\n  warningCount: number;\n}\n\nclass BuildMonitor {\n  private metrics: BuildMetrics[] = [];\n  private startTime: number = 0;\n  \n  startBuild(): void {\n    this.startTime = performance.now();\n    console.log('Build started at', new Date().toISOString());\n  }\n  \n  endBuild(errorCount: number = 0, warningCount: number = 0): void {\n    const duration = performance.now() - this.startTime;\n    const fileCount = this.countTypeScriptFiles();\n    \n    const metrics: BuildMetrics = {\n      timestamp: Date.now(),\n      duration,\n      fileCount,\n      errorCount,\n      warningCount\n    };\n    \n    this.metrics.push(metrics);\n    this.saveMetrics();\n    \n    console.log(`Build completed in ${duration.toFixed(2)}ms`);\n    console.log(`Files processed: ${fileCount}`);\n    \n    if (errorCount > 0) {\n      console.log(`Errors: ${errorCount}`);\n    }\n    \n    if (warningCount > 0) {\n      console.log(`Warnings: ${warningCount}`);\n    }\n  }\n  \n  private countTypeScriptFiles(): number {\n    // Implementation to count .ts/.tsx files\n    return 0;\n  }\n  \n  private saveMetrics(): void {\n    const metricsPath = path.join(process.cwd(), 'build-metrics.json');\n    fs.writeFileSync(metricsPath, JSON.stringify(this.metrics, null, 2));\n  }\n  \n  getAverageBuildTime(): number {\n    if (this.metrics.length === 0) return 0;\n    const total = this.metrics.reduce((sum, m) => sum + m.duration, 0);\n    return total / this.metrics.length;\n  }\n}\n```\n\n**Vite Configuration for Fast Development:**\n```typescript\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react-swc';\nimport { resolve } from 'path';\n\nexport default defineConfig({\n  plugins: [\n    react() // Uses SWC for faster transpilation\n  ],\n  \n  resolve: {\n    alias: {\n      '@': resolve(__dirname, 'src'),\n      '@components': resolve(__dirname, 'src/components'),\n      '@utils': resolve(__dirname, 'src/utils')\n    }\n  },\n  \n  build: {\n    // Target modern browsers for better performance\n    target: 'es2020',\n    \n    // Source maps for production debugging\n    sourcemap: true,\n    \n    // Chunk size warnings\n    chunkSizeWarningLimit: 1000,\n    \n    rollupOptions: {\n      output: {\n        // Manual chunks for better caching\n        manualChunks: {\n          vendor: ['react', 'react-dom'],\n          utils: ['lodash', 'date-fns']\n        }\n      }\n    }\n  },\n  \n  server: {\n    // HMR configuration\n    hmr: {\n      overlay: false\n    }\n  }\n});\n```\n\n**Performance Best Practices:**\n\n**1. Use `skipLibCheck`** - Skips type checking of declaration files\n**2. Enable incremental compilation** - Reuses previous compilation results\n**3. Use project references** - For monorepos and large codebases\n**4. Optimize imports** - Use specific imports instead of barrel exports\n**5. Type-only imports** - Use `import type` when possible\n**6. Exclude unnecessary files** - Configure include/exclude properly\n**7. Use faster build tools** - SWC, esbuild, or Vite for development\n**8. Enable transpileOnly** - Skip type checking during development\n**9. Use fork-ts-checker** - Run type checking in separate process\n**10. Monitor build performance** - Track metrics and optimize bottlenecks",
      "keywords": ["TypeScript compilation", "build performance", "incremental compilation", "project references", "webpack", "esbuild", "SWC", "Vite", "transpileOnly", "skipLibCheck", "optimization"],
      "difficulty": "medium"
    },
    {
      "id": 1039,
      "tag": "typescript",
      "question": "What are the advanced features of TypeScript 5.0+ and how do they improve developer experience?",
      "answer": "TypeScript 5.0+ introduces several advanced features that significantly enhance type safety, performance, and developer productivity.\n\n**1. Decorators (Stage 3 Support):**\n```typescript\n// TypeScript 5.0+ supports the new decorators proposal\nfunction logged(value: any, context: ClassMethodDecoratorContext) {\n  const methodName = String(context.name);\n  \n  function replacementMethod(this: any, ...args: any[]) {\n    console.log(`LOG: Entering method '${methodName}'.`);\n    const result = value.call(this, ...args);\n    console.log(`LOG: Exiting method '${methodName}'.`);\n    return result;\n  }\n  \n  return replacementMethod;\n}\n\nclass Person {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  @logged\n  greet() {\n    console.log(`Hello, my name is ${this.name}.`);\n  }\n}\n\n// Auto-accessor decorators\nclass MyClass {\n  @logged\n  accessor myProperty = 123;\n}\n\n// Class decorator with metadata\nfunction withMetadata(metadata: Record<string, any>) {\n  return function <T extends { new (...args: any[]): {} }>(\n    constructor: T,\n    context: ClassDecoratorContext\n  ) {\n    context.metadata[context.name] = metadata;\n    return constructor;\n  };\n}\n\n@withMetadata({ version: '1.0', author: 'TypeScript Team' })\nclass AnnotatedClass {\n  // Class implementation\n}\n```\n\n**2. const Type Parameters:**\n```typescript\n// Type parameters can now be marked as const\nfunction makeTuple<const T extends readonly unknown[]>(...args: T): T {\n  return args;\n}\n\n// The type is inferred as the exact tuple\nconst tuple = makeTuple(1, 'hello', true);\n// Type: readonly [1, \"hello\", true]\n\n// Works with object literals too\nfunction makeConfig<const T extends Record<string, unknown>>(config: T): T {\n  return config;\n}\n\nconst config = makeConfig({\n  name: 'MyApp',\n  version: '1.0.0',\n  features: ['auth', 'dashboard'] as const\n});\n// Type: {\n//   readonly name: \"MyApp\";\n//   readonly version: \"1.0.0\";\n//   readonly features: readonly [\"auth\", \"dashboard\"];\n// }\n\n// Practical example: Type-safe event emitter\nclass TypedEventEmitter<const T extends Record<string, any[]>> {\n  private listeners: {\n    [K in keyof T]?: Array<(...args: T[K]) => void>;\n  } = {};\n  \n  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event]!.push(listener);\n  }\n  \n  emit<K extends keyof T>(event: K, ...args: T[K]): void {\n    this.listeners[event]?.forEach(listener => listener(...args));\n  }\n}\n\n// Usage with perfect type inference\nconst emitter = new TypedEventEmitter<{\n  userLogin: [userId: string, timestamp: Date];\n  userLogout: [userId: string];\n  dataUpdate: [collection: string, id: string, data: any];\n}>();\n\nemitter.on('userLogin', (userId, timestamp) => {\n  // userId and timestamp are perfectly typed\n  console.log(`User ${userId} logged in at ${timestamp}`);\n});\n```\n\n**3. Multiple Configuration Files (extends array):**\n```json\n// TypeScript 5.0+ supports extending from multiple config files\n// tsconfig.json\n{\n  \"extends\": [\n    \"@company/typescript-config/base\",\n    \"@company/typescript-config/react\",\n    \"./tsconfig.paths.json\"\n  ],\n  \"compilerOptions\": {\n    \"outDir\": \"dist\"\n  }\n}\n\n// tsconfig.paths.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@components/*\": [\"src/components/*\"]\n    }\n  }\n}\n```\n\n**4. Enhanced Enum Support:**\n```typescript\n// Better support for enum patterns\nconst enum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\"\n}\n\n// Union enums with better type inference\ntype Status = 'loading' | 'success' | 'error';\n\nfunction createStatusEnum<const T extends readonly Status[]>(\n  ...statuses: T\n): { [K in T[number]]: K } {\n  const result = {} as any;\n  for (const status of statuses) {\n    result[status] = status;\n  }\n  return result;\n}\n\nconst StatusEnum = createStatusEnum('loading', 'success', 'error');\n// Type: {\n//   readonly loading: \"loading\";\n//   readonly success: \"success\";\n//   readonly error: \"error\";\n// }\n```\n\n**5. Template Literal Types Improvements:**\n```typescript\n// Enhanced template literal type support\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype EventHandler<T extends string> = (event: Event) => void;\n\ntype EventHandlers<T extends Record<string, any>> = {\n  [K in keyof T as EventName<string & K>]: EventHandler<string & K>;\n};\n\ninterface DOMEvents {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  submit: SubmitEvent;\n}\n\ntype DOMEventHandlers = EventHandlers<DOMEvents>;\n// {\n//   onClick: (event: Event) => void;\n//   onKeydown: (event: Event) => void;\n//   onSubmit: (event: Event) => void;\n// }\n\n// CSS property generator\ntype CSSProperty = \n  | 'margin'\n  | 'padding'\n  | 'border'\n  | 'background';\n\ntype CSSDirection = 'top' | 'right' | 'bottom' | 'left';\n\ntype CSSDirectionalProperties = {\n  [P in CSSProperty as `${P}-${CSSDirection}`]: string;\n};\n\n// Generates: margin-top, margin-right, padding-top, etc.\n```\n\n**6. Import Attributes:**\n```typescript\n// TypeScript 5.3+ supports import attributes\nimport data from './data.json' with { type: 'json' };\nimport styles from './styles.css' with { type: 'css' };\n\n// Works with dynamic imports too\nconst config = await import('./config.json', {\n  with: { type: 'json' }\n});\n```\n\n**7. Better Type Narrowing:**\n```typescript\n// Improved control flow analysis\nfunction processValue(value: unknown): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase(); // TypeScript knows value is string\n  }\n  \n  if (typeof value === 'number') {\n    return value.toString(); // TypeScript knows value is number\n  }\n  \n  if (value instanceof Date) {\n    return value.toISOString(); // TypeScript knows value is Date\n  }\n  \n  // Exhaustive checking\n  throw new Error(`Unsupported type: ${typeof value}`);\n}\n\n// Switch statement improvements\ntype Action = \n  | { type: 'SET_NAME'; payload: string }\n  | { type: 'SET_AGE'; payload: number }\n  | { type: 'RESET' };\n\nfunction reducer(state: any, action: Action) {\n  switch (action.type) {\n    case 'SET_NAME':\n      // action.payload is automatically typed as string\n      return { ...state, name: action.payload };\n    \n    case 'SET_AGE':\n      // action.payload is automatically typed as number\n      return { ...state, age: action.payload };\n    \n    case 'RESET':\n      // action has no payload property\n      return {};\n    \n    default:\n      // Exhaustive check - TypeScript ensures all cases are handled\n      const _exhaustive: never = action;\n      return state;\n  }\n}\n```\n\n**8. Performance Improvements:**\n```typescript\n// Better performance with large union types\ntype LargeUnion = \n  | 'option1' | 'option2' | 'option3' | 'option4' | 'option5'\n  | 'option6' | 'option7' | 'option8' | 'option9' | 'option10'\n  | 'option11' | 'option12' | 'option13' | 'option14' | 'option15';\n\n// TypeScript 5.0+ handles these more efficiently\ntype ProcessedUnion<T extends string> = T extends `option${infer N}`\n  ? `processed-${N}`\n  : never;\n\ntype ProcessedOptions = ProcessedUnion<LargeUnion>;\n```\n\n**9. Satisfies Operator Enhancements:**\n```typescript\n// More powerful satisfies operator\ninterface Config {\n  colors: Record<string, string>;\n  sizes: Record<string, number>;\n}\n\nconst theme = {\n  colors: {\n    primary: '#007acc',\n    secondary: '#6c757d',\n    success: '#28a745'\n  },\n  sizes: {\n    small: 12,\n    medium: 16,\n    large: 20\n  }\n} satisfies Config;\n\n// TypeScript preserves the exact structure while ensuring it satisfies Config\ntheme.colors.primary; // Type: string, but value is known to be '#007acc'\ntheme.sizes.small; // Type: number, but value is known to be 12\n\n// Complex satisfies example\ninterface ApiEndpoint {\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  path: string;\n  handler: (req: any, res: any) => void;\n}\n\ntype ApiRoutes = Record<string, ApiEndpoint>;\n\nconst routes = {\n  getUsers: {\n    method: 'GET',\n    path: '/users',\n    handler: (req, res) => {\n      // Implementation\n    }\n  },\n  createUser: {\n    method: 'POST',\n    path: '/users',\n    handler: (req, res) => {\n      // Implementation\n    }\n  }\n} satisfies ApiRoutes;\n\n// routes.getUsers.method is typed as 'GET', not 'GET' | 'POST' | 'PUT' | 'DELETE'\n```\n\n**10. Better Error Messages:**\n```typescript\n// TypeScript 5.0+ provides more helpful error messages\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\nfunction processUsers(users: User[]): void {\n  users.forEach(user => {\n    // More descriptive error if you try to access non-existent property\n    console.log(user.username); // Error with suggestion to use 'name'\n  });\n}\n\n// Better error messages for complex generic constraints\ntype ExtractArrayElement<T> = T extends (infer U)[] ? U : never;\n\n// If you pass a non-array type, you get a clearer error message\ntype ElementType = ExtractArrayElement<string>; // Clear error about string not being an array\n```\n\n**11. Isolated Declarations:**\n```typescript\n// Better support for declaration file generation\n// --isolatedDeclarations flag for faster and more reliable .d.ts generation\n\nexport interface PublicAPI {\n  version: string;\n  createUser(data: UserData): Promise<User>;\n  updateUser(id: string, data: Partial<UserData>): Promise<User>;\n}\n\n// TypeScript can generate declarations more efficiently\nexport const api: PublicAPI = {\n  version: '1.0.0',\n  async createUser(data) {\n    // Implementation\n    return {} as User;\n  },\n  async updateUser(id, data) {\n    // Implementation\n    return {} as User;\n  }\n};\n```\n\n**Benefits of TypeScript 5.0+ Features:**\n\n1. **Enhanced Type Safety**: Better inference and narrowing\n2. **Improved Performance**: Faster compilation and better memory usage\n3. **Better Developer Experience**: More helpful error messages\n4. **Modern JavaScript Support**: Latest ECMAScript features\n5. **Flexible Configuration**: Multiple config file inheritance\n6. **Advanced Decorators**: Stage 3 decorators with metadata\n7. **Const Type Parameters**: More precise type inference\n8. **Template Literal Improvements**: Better string type manipulation",
      "keywords": ["TypeScript 5.0", "decorators", "const type parameters", "template literals", "import attributes", "satisfies operator", "type narrowing", "performance improvements", "isolated declarations", "multiple config"],
      "difficulty": "hard"
    }
  ]
}