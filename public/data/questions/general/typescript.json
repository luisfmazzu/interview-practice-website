{
  "technology": "typescript",
  "questions": [
    {
      "id": 1000,
      "tag": "typescript",
      "question": "What are the main benefits of using TypeScript over JavaScript?",
      "answer": "**Type Safety:**\n- Catch errors at compile-time instead of runtime\n- Prevent common bugs like undefined properties\n- Better code reliability\n\n**Developer Experience:**\n- Excellent IDE support with autocomplete\n- Intelligent refactoring\n- Better documentation through types\n\n**Code Quality:**\n- Self-documenting code\n- Easier maintenance and debugging\n- Better team collaboration\n\n**Modern JavaScript Features:**\n- Latest ECMAScript features\n- Compiles to older JavaScript versions\n- Optional static typing\n\n**Tooling:**\n- Better build tools integration\n- Enhanced testing capabilities\n- Rich ecosystem support\n\n**Example:**\n```typescript\n// TypeScript catches this error at compile time\ninterface User {\n  name: string;\n  age: number;\n}\n\nfunction greetUser(user: User) {\n  return `Hello, ${user.name}!`;\n}\n\ngreetUser({ name: 'John' }); // Error: missing 'age' property\n```",
      "keywords": ["type safety", "compile-time", "static typing", "IDE support", "autocomplete", "refactoring", "ECMAScript", "transpilation", "interfaces", "type checking"],
      "difficulty": "easy"
    },
    {
      "id": 1001,
      "tag": "typescript",
      "question": "Explain TypeScript interfaces and how they differ from types.",
      "answer": "**Interfaces:**\nDefine the structure of objects and can be extended or implemented.\n\n```typescript\ninterface User {\n  name: string;\n  age: number;\n}\n\n// Can be extended\ninterface AdminUser extends User {\n  permissions: string[];\n}\n\n// Can be merged (declaration merging)\ninterface User {\n  email?: string; // Adds email to existing User interface\n}\n```\n\n**Types:**\nMore flexible, can represent any type including primitives, unions, and computed types.\n\n```typescript\ntype User = {\n  name: string;\n  age: number;\n};\n\n// Union types\ntype Status = 'loading' | 'success' | 'error';\n\n// Computed types\ntype UserKeys = keyof User; // 'name' | 'age'\n```\n\n**Key Differences:**\n- **Extensibility:** Interfaces can be extended and merged, types cannot\n- **Flexibility:** Types can represent unions, primitives, computed types\n- **Performance:** Interfaces are slightly better for object shapes\n- **Use Cases:** Interfaces for object shapes, types for everything else",
      "keywords": ["interfaces", "types", "type aliases", "extends", "declaration merging", "union types", "intersection types", "keyof", "computed types", "object shapes", "primitives"],
      "difficulty": "medium"
    },
    {
      "id": 1002,
      "tag": "typescript",
      "question": "What are generics in TypeScript and why are they useful?",
      "answer": "Generics allow you to create reusable components that work with multiple types while maintaining type safety.\n\n**Basic Generic Function:**\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\nconst result1 = identity<string>('hello'); // string\nconst result2 = identity<number>(42); // number\nconst result3 = identity('hello'); // Type inferred as string\n```\n\n**Generic Interfaces:**\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  status: number;\n  message: string;\n}\n\ntype UserResponse = ApiResponse<User>;\ntype ProductResponse = ApiResponse<Product[]>;\n```\n\n**Generic Classes:**\n```typescript\nclass DataStore<T> {\n  private data: T[] = [];\n  \n  add(item: T): void {\n    this.data.push(item);\n  }\n  \n  get(index: number): T | undefined {\n    return this.data[index];\n  }\n}\n\nconst userStore = new DataStore<User>();\nconst productStore = new DataStore<Product>();\n```\n\n**Benefits:**\n- Type safety without sacrificing flexibility\n- Code reusability\n- Better IntelliSense and error detection\n- Self-documenting APIs",
      "keywords": ["generics", "type parameters", "type inference", "generic functions", "generic interfaces", "generic classes", "type constraints", "reusability", "polymorphism", "type safety"],
      "difficulty": "medium"
    },
    {
      "id": 1003,
      "tag": "typescript",
      "question": "What is the difference between type annotations and type inference in TypeScript?",
      "answer": "**Type Annotations:**\nExplicitly specify the type of a variable, parameter, or return value.\n\n```typescript\n// Explicit type annotations\nlet name: string = 'John';\nlet age: number = 30;\nlet isActive: boolean = true;\n\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n```\n\n**Type Inference:**\nTypeScript automatically determines the type based on the assigned value.\n\n```typescript\n// TypeScript infers types\nlet name = 'John'; // inferred as string\nlet age = 30; // inferred as number\nlet isActive = true; // inferred as boolean\n\nfunction add(a: number, b: number) {\n  return a + b; // return type inferred as number\n}\n```\n\n**When to Use Each:**\n- **Use annotations** when TypeScript can't infer the correct type\n- **Use annotations** for function parameters (required)\n- **Use inference** for simple variable assignments\n- **Use annotations** for better code documentation\n\n**Best Practice:**\nLet TypeScript infer types when possible, but add annotations for clarity in complex scenarios or public APIs.",
      "keywords": ["type annotations", "type inference", "explicit types", "implicit types", "variable declaration", "function signatures", "return types", "type checking"],
      "difficulty": "easy"
    },
    {
      "id": 1004,
      "tag": "typescript",
      "question": "How do union types work in TypeScript? Provide examples.",
      "answer": "Union types allow a variable to have one of several types, separated by the pipe (`|`) operator.\n\n**Basic Union Types:**\n```typescript\nlet value: string | number;\nvalue = 'hello'; // Valid\nvalue = 42; // Valid\n// value = true; // Error: boolean not in union\n\ntype Status = 'loading' | 'success' | 'error';\nlet currentStatus: Status = 'loading';\n```\n\n**Function Parameters:**\n```typescript\nfunction formatId(id: string | number): string {\n  // Type narrowing required\n  if (typeof id === 'string') {\n    return id.toUpperCase();\n  }\n  return id.toString();\n}\n\nformatId('abc123'); // 'ABC123'\nformatId(123); // '123'\n```\n\n**Array Union Types:**\n```typescript\nlet items: (string | number)[] = ['hello', 42, 'world', 100];\n```\n\n**Object Union Types:**\n```typescript\ntype Cat = { type: 'cat'; meow: () => void };\ntype Dog = { type: 'dog'; bark: () => void };\ntype Pet = Cat | Dog;\n\nfunction handlePet(pet: Pet) {\n  if (pet.type === 'cat') {\n    pet.meow(); // TypeScript knows it's a Cat\n  } else {\n    pet.bark(); // TypeScript knows it's a Dog\n  }\n}\n```\n\n**Benefits:**\n- Flexible type definitions\n- Type safety with multiple possibilities\n- Enables type narrowing",
      "keywords": ["union types", "pipe operator", "type narrowing", "typeof", "discriminated unions", "flexible types", "multiple types", "type guards"],
      "difficulty": "easy"
    },
    {
      "id": 1005,
      "tag": "typescript",
      "question": "What are intersection types and when would you use them?",
      "answer": "Intersection types combine multiple types into one using the ampersand (`&`) operator. The result must satisfy all combined types.\n\n**Basic Intersection:**\n```typescript\ntype Name = { name: string };\ntype Age = { age: number };\ntype Person = Name & Age;\n\nconst person: Person = {\n  name: 'John',\n  age: 30\n}; // Must have both properties\n```\n\n**Mixing Interfaces:**\n```typescript\ninterface Flyable {\n  fly(): void;\n}\n\ninterface Swimmable {\n  swim(): void;\n}\n\ntype FlyingFish = Flyable & Swimmable;\n\nclass Duck implements FlyingFish {\n  fly() { console.log('Flying!'); }\n  swim() { console.log('Swimming!'); }\n}\n```\n\n**Function Intersections:**\n```typescript\ntype EventHandler = {\n  onClick: (event: MouseEvent) => void;\n};\n\ntype FormHandler = {\n  onSubmit: (data: FormData) => void;\n};\n\ntype Component = EventHandler & FormHandler;\n// Must implement both onClick and onSubmit\n```\n\n**Use Cases:**\n- **Mixins:** Combining multiple behaviors\n- **Configuration objects:** Merging multiple option sets\n- **API responses:** Combining base response with specific data\n- **Component props:** Combining different prop interfaces\n\n**vs Union Types:**\n- **Intersection (`&`):** Must satisfy ALL types\n- **Union (`|`):** Must satisfy ONE of the types",
      "keywords": ["intersection types", "ampersand operator", "type combination", "mixins", "multiple inheritance", "interface merging", "type composition", "and operator"],
      "difficulty": "easy"
    },
    {
      "id": 1006,
      "tag": "typescript",
      "question": "Explain TypeScript enums and their different types with use cases.",
      "answer": "Enums allow you to define a set of named constants, making code more readable and maintainable.\n\n**Numeric Enums:**\n```typescript\nenum Direction {\n  Up,    // 0\n  Down,  // 1\n  Left,  // 2\n  Right  // 3\n}\n\n// Custom starting value\nenum Status {\n  Pending = 1,\n  Approved,  // 2\n  Rejected   // 3\n}\n\nconsole.log(Direction.Up); // 0\nconsole.log(Status.Approved); // 2\n```\n\n**String Enums:**\n```typescript\nenum Theme {\n  Light = 'light',\n  Dark = 'dark',\n  Auto = 'auto'\n}\n\n// More readable and debuggable\nconsole.log(Theme.Dark); // 'dark'\n```\n\n**Const Enums (Compile-time):**\n```typescript\nconst enum Colors {\n  Red = '#ff0000',\n  Green = '#00ff00',\n  Blue = '#0000ff'\n}\n\n// Inlined at compile time for better performance\nconst redColor = Colors.Red; // becomes const redColor = '#ff0000';\n```\n\n**Computed Enums:**\n```typescript\nenum FileAccess {\n  None,\n  Read = 1 << 1,     // 2\n  Write = 1 << 2,    // 4\n  ReadWrite = Read | Write  // 6\n}\n```\n\n**Use Cases:**\n- **API status codes**\n- **Configuration options**\n- **State management**\n- **Error codes**\n- **UI themes and modes**\n\n**Best Practices:**\n- Use string enums for better debugging\n- Use const enums for performance-critical code\n- Prefer union types for simple string literals",
      "keywords": ["enums", "numeric enums", "string enums", "const enums", "computed enums", "named constants", "configuration", "state management", "compile time"],
      "difficulty": "easy"
    },
    {
      "id": 1007,
      "tag": "typescript",
      "question": "What are type assertions in TypeScript and when should you use the 'as' keyword?",
      "answer": "Type assertions tell TypeScript to treat a value as a specific type when you know more about the type than TypeScript can infer.\n\n**Basic Type Assertions:**\n```typescript\n// Using 'as' keyword (preferred)\nlet someValue: unknown = 'Hello World';\nlet strLength: number = (someValue as string).length;\n\n// Angle bracket syntax (avoid in JSX)\nlet strLength2: number = (<string>someValue).length;\n```\n\n**DOM Element Assertions:**\n```typescript\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst ctx = canvas.getContext('2d'); // TypeScript knows canvas is HTMLCanvasElement\n\n// Without assertion\nconst element = document.getElementById('canvas'); // HTMLElement | null\n// element.getContext('2d'); // Error: Property doesn't exist on HTMLElement\n```\n\n**API Response Assertions:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n}\n\nasync function fetchUser(): Promise<User> {\n  const response = await fetch('/api/user');\n  const data = await response.json();\n  return data as User; // Assert API response shape\n}\n```\n\n**Non-null Assertion (!):**\n```typescript\nfunction processUser(user: User | null) {\n  // When you're certain user is not null\n  console.log(user!.name); // ! asserts non-null\n}\n```\n\n**When to Use:**\n- Working with DOM elements\n- API responses with known structure\n- Type narrowing when TypeScript can't infer\n- Legacy code integration\n\n**Warnings:**\n- Bypasses TypeScript's type checking\n- Use sparingly and only when necessary\n- Can hide potential runtime errors\n- Prefer type guards when possible",
      "keywords": ["type assertions", "as keyword", "type casting", "angle bracket syntax", "non-null assertion", "DOM elements", "API responses", "type narrowing", "unknown type"],
      "difficulty": "easy"
    },
    {
      "id": 1008,
      "tag": "typescript",
      "question": "How do optional properties and parameters work in TypeScript?",
      "answer": "Optional properties and parameters are marked with `?` and can be undefined or omitted.\n\n**Optional Object Properties:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email?: string; // Optional property\n  phone?: string;\n}\n\nconst user1: User = {\n  id: 1,\n  name: 'John'\n  // email and phone can be omitted\n};\n\nconst user2: User = {\n  id: 2,\n  name: 'Jane',\n  email: 'jane@example.com'\n};\n```\n\n**Optional Function Parameters:**\n```typescript\nfunction greet(name: string, greeting?: string): string {\n  return `${greeting || 'Hello'}, ${name}!`;\n}\n\ngreet('John'); // 'Hello, John!'\ngreet('John', 'Hi'); // 'Hi, John!'\n```\n\n**Optional Parameters with Defaults:**\n```typescript\nfunction createUser(name: string, role: string = 'user', active?: boolean) {\n  return {\n    name,\n    role,\n    active: active ?? true // Use nullish coalescing\n  };\n}\n\ncreateUser('John'); // { name: 'John', role: 'user', active: true }\ncreateUser('Jane', 'admin', false);\n```\n\n**Optional Chaining:**\n```typescript\ninterface Address {\n  street?: string;\n  city?: string;\n}\n\ninterface User {\n  name: string;\n  address?: Address;\n}\n\nfunction getCity(user: User): string | undefined {\n  return user.address?.city; // Safe navigation\n}\n```\n\n**Type Guards with Optional Properties:**\n```typescript\nfunction processUser(user: User) {\n  if (user.email) {\n    // TypeScript knows email is defined here\n    console.log(user.email.toLowerCase());\n  }\n}\n```\n\n**Important Notes:**\n- Optional parameters must come after required ones\n- Optional properties can be `undefined`\n- Use optional chaining (`?.`) for safe property access",
      "keywords": ["optional properties", "optional parameters", "question mark", "undefined", "optional chaining", "default parameters", "nullish coalescing", "type guards", "safe navigation"],
      "difficulty": "easy"
    },
    {
      "id": 1009,
      "tag": "typescript",
      "question": "Explain function types and signatures in TypeScript with examples.",
      "answer": "Function types define the shape of functions, including parameter types and return types.\n\n**Function Type Annotations:**\n```typescript\n// Function declaration\nfunction add(a: number, b: number): number {\n  return a + b;\n}\n\n// Function expression\nconst multiply = (a: number, b: number): number => {\n  return a * b;\n};\n\n// Arrow function\nconst divide = (a: number, b: number): number => a / b;\n```\n\n**Function Type Aliases:**\n```typescript\ntype MathOperation = (a: number, b: number) => number;\n\nconst add: MathOperation = (a, b) => a + b;\nconst subtract: MathOperation = (a, b) => a - b;\n```\n\n**Function Interfaces:**\n```typescript\ninterface Calculator {\n  (a: number, b: number): number;\n}\n\n// Or with call signature\ninterface AdvancedCalculator {\n  add(a: number, b: number): number;\n  subtract(a: number, b: number): number;\n  multiply(a: number, b: number): number;\n}\n```\n\n**Higher-Order Functions:**\n```typescript\ntype Predicate<T> = (item: T) => boolean;\ntype Mapper<T, U> = (item: T) => U;\n\nfunction filter<T>(items: T[], predicate: Predicate<T>): T[] {\n  return items.filter(predicate);\n}\n\nfunction map<T, U>(items: T[], mapper: Mapper<T, U>): U[] {\n  return items.map(mapper);\n}\n```\n\n**Function Overloads:**\n```typescript\nfunction format(value: string): string;\nfunction format(value: number): string;\nfunction format(value: boolean): string;\nfunction format(value: string | number | boolean): string {\n  return String(value);\n}\n```\n\n**Callback Types:**\n```typescript\ntype EventCallback = (event: Event) => void;\ntype ErrorCallback = (error: Error) => void;\n\nfunction fetchData(\n  url: string,\n  onSuccess: (data: any) => void,\n  onError: ErrorCallback\n) {\n  // Implementation\n}\n```\n\n**Benefits:**\n- Type safety for function parameters and returns\n- Better IDE support and autocomplete\n- Clear API contracts\n- Reusable function signatures",
      "keywords": ["function types", "function signatures", "type aliases", "call signatures", "higher-order functions", "function overloads", "callback types", "arrow functions", "type safety"],
      "difficulty": "easy"
    },
    {
      "id": 1010,
      "tag": "typescript",
      "question": "What are literal types and const assertions in TypeScript?",
      "answer": "Literal types represent exact values rather than general types, and const assertions help create more specific types.\n\n**String Literal Types:**\n```typescript\ntype Theme = 'light' | 'dark' | 'auto';\ntype ButtonSize = 'small' | 'medium' | 'large';\n\nfunction setTheme(theme: Theme) {\n  // Only accepts exact string values\n}\n\nsetTheme('light'); // ✓ Valid\nsetTheme('blue'); // ✗ Error\n```\n\n**Number Literal Types:**\n```typescript\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\ntype HttpStatus = 200 | 404 | 500;\n\nfunction handleStatus(status: HttpStatus) {\n  switch (status) {\n    case 200: return 'Success';\n    case 404: return 'Not Found';\n    case 500: return 'Server Error';\n  }\n}\n```\n\n**Boolean Literal Types:**\n```typescript\ntype IsEnabled = true; // Only accepts true\ntype IsDisabled = false; // Only accepts false\n```\n\n**Const Assertions:**\n```typescript\n// Without const assertion\nconst colors = ['red', 'green', 'blue']; // string[]\n\n// With const assertion\nconst colors = ['red', 'green', 'blue'] as const;\n// readonly ['red', 'green', 'blue']\n\ntype Color = typeof colors[number]; // 'red' | 'green' | 'blue'\n```\n\n**Object Const Assertions:**\n```typescript\nconst config = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  retries: 3\n} as const;\n// All properties become readonly and literal types\n\ntype Config = typeof config;\n// {\n//   readonly apiUrl: 'https://api.example.com';\n//   readonly timeout: 5000;\n//   readonly retries: 3;\n// }\n```\n\n**Template Literal Types:**\n```typescript\ntype CSSProperty = `--${string}`;\ntype EventName = `on${Capitalize<string>}`;\n\ntype ButtonEvent = `button-${'click' | 'hover' | 'focus'}`;\n// 'button-click' | 'button-hover' | 'button-focus'\n```\n\n**Use Cases:**\n- Configuration objects\n- Discriminated unions\n- API endpoints and methods\n- CSS classes and IDs\n- State machine states",
      "keywords": ["literal types", "const assertions", "string literals", "number literals", "boolean literals", "template literals", "readonly", "exact values", "immutable", "type narrowing"],
      "difficulty": "easy"
    },
    {
      "id": 1011,
      "tag": "typescript",
      "question": "How do type guards and user-defined type guards work in TypeScript?",
      "answer": "Type guards are expressions that perform runtime checks to narrow types within conditional blocks.\n\n**Built-in Type Guards:**\n```typescript\nfunction processValue(value: string | number) {\n  if (typeof value === 'string') {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  } else {\n    // TypeScript knows value is number here\n    console.log(value.toFixed(2));\n  }\n}\n\n// instanceof guard\nclass Dog { bark() {} }\nclass Cat { meow() {} }\n\nfunction handlePet(pet: Dog | Cat) {\n  if (pet instanceof Dog) {\n    pet.bark(); // TypeScript knows it's a Dog\n  } else {\n    pet.meow(); // TypeScript knows it's a Cat\n  }\n}\n```\n\n**User-Defined Type Guards:**\n```typescript\ninterface Fish {\n  swim(): void;\n}\n\ninterface Bird {\n  fly(): void;\n}\n\n// Type predicate function\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n\nfunction handleAnimal(pet: Fish | Bird) {\n  if (isFish(pet)) {\n    pet.swim(); // TypeScript knows it's Fish\n  } else {\n    pet.fly(); // TypeScript knows it's Bird\n  }\n}\n```\n\n**Discriminated Unions with Type Guards:**\n```typescript\ninterface LoadingState {\n  status: 'loading';\n}\n\ninterface SuccessState {\n  status: 'success';\n  data: any;\n}\n\ninterface ErrorState {\n  status: 'error';\n  error: string;\n}\n\ntype AppState = LoadingState | SuccessState | ErrorState;\n\nfunction handleState(state: AppState) {\n  switch (state.status) {\n    case 'loading':\n      // TypeScript knows it's LoadingState\n      console.log('Loading...');\n      break;\n    case 'success':\n      // TypeScript knows it's SuccessState\n      console.log(state.data);\n      break;\n    case 'error':\n      // TypeScript knows it's ErrorState\n      console.log(state.error);\n      break;\n  }\n}\n```\n\n**Advanced Type Guards:**\n```typescript\n// Null/undefined guards\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\n// Array type guard\nfunction isStringArray(value: unknown): value is string[] {\n  return Array.isArray(value) && value.every(item => typeof item === 'string');\n}\n```\n\n**Benefits:**\n- Runtime type safety\n- Automatic type narrowing\n- Better error handling\n- Cleaner conditional logic",
      "keywords": ["type guards", "user-defined type guards", "type predicates", "typeof", "instanceof", "discriminated unions", "type narrowing", "runtime checks", "conditional types", "is keyword"],
      "difficulty": "medium"
    },
    {
      "id": 1012,
      "tag": "typescript",
      "question": "Explain discriminated unions in TypeScript with practical examples.",
      "answer": "Discriminated unions (tagged unions) use a common property to distinguish between different types in a union, enabling type-safe pattern matching.\n\n**Basic Discriminated Union:**\n```typescript\ninterface Circle {\n  kind: 'circle'; // Discriminant property\n  radius: number;\n}\n\ninterface Rectangle {\n  kind: 'rectangle';\n  width: number;\n  height: number;\n}\n\ninterface Square {\n  kind: 'square';\n  size: number;\n}\n\ntype Shape = Circle | Rectangle | Square;\n\nfunction calculateArea(shape: Shape): number {\n  switch (shape.kind) {\n    case 'circle':\n      // TypeScript knows it's Circle\n      return Math.PI * shape.radius ** 2;\n    case 'rectangle':\n      // TypeScript knows it's Rectangle\n      return shape.width * shape.height;\n    case 'square':\n      // TypeScript knows it's Square\n      return shape.size ** 2;\n    default:\n      // Exhaustiveness check\n      const _exhaustive: never = shape;\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n```\n\n**API Response Pattern:**\n```typescript\ninterface LoadingResponse {\n  status: 'loading';\n}\n\ninterface SuccessResponse {\n  status: 'success';\n  data: any;\n  timestamp: number;\n}\n\ninterface ErrorResponse {\n  status: 'error';\n  error: string;\n  code: number;\n}\n\ntype ApiResponse = LoadingResponse | SuccessResponse | ErrorResponse;\n\nfunction handleResponse(response: ApiResponse) {\n  switch (response.status) {\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return `Data: ${response.data} at ${response.timestamp}`;\n    case 'error':\n      return `Error ${response.code}: ${response.error}`;\n  }\n}\n```\n\n**Redux Action Pattern:**\n```typescript\ninterface IncrementAction {\n  type: 'INCREMENT';\n  payload?: number;\n}\n\ninterface DecrementAction {\n  type: 'DECREMENT';\n  payload?: number;\n}\n\ninterface ResetAction {\n  type: 'RESET';\n}\n\ntype CounterAction = IncrementAction | DecrementAction | ResetAction;\n\nfunction counterReducer(state: number, action: CounterAction): number {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + (action.payload ?? 1);\n    case 'DECREMENT':\n      return state - (action.payload ?? 1);\n    case 'RESET':\n      return 0;\n    default:\n      return state;\n  }\n}\n```\n\n**Form Validation Example:**\n```typescript\ninterface ValidField {\n  status: 'valid';\n  value: string;\n}\n\ninterface InvalidField {\n  status: 'invalid';\n  value: string;\n  errors: string[];\n}\n\ninterface PendingField {\n  status: 'pending';\n  value: string;\n}\n\ntype FieldState = ValidField | InvalidField | PendingField;\n\nfunction renderField(field: FieldState) {\n  switch (field.status) {\n    case 'valid':\n      return `✓ ${field.value}`;\n    case 'invalid':\n      return `✗ ${field.value}: ${field.errors.join(', ')}`;\n    case 'pending':\n      return `⏳ ${field.value}`;\n  }\n}\n```\n\n**Advantages:**\n- Exhaustive type checking\n- Compile-time safety\n- Clear state modeling\n- Eliminates impossible states\n- Better refactoring support",
      "keywords": ["discriminated unions", "tagged unions", "discriminant property", "pattern matching", "exhaustiveness checking", "never type", "state modeling", "type safety", "switch statements"],
      "difficulty": "medium"
    },
    {
      "id": 1013,
      "tag": "typescript",
      "question": "What are index signatures and mapped types in TypeScript? Provide basic examples.",
      "answer": "Index signatures define types for object properties when you don't know all property names ahead of time. Mapped types create new types by transforming existing ones.\n\n**Index Signatures:**\n```typescript\n// String index signature\ninterface StringDictionary {\n  [key: string]: string;\n}\n\nconst colors: StringDictionary = {\n  red: '#ff0000',\n  green: '#00ff00',\n  blue: '#0000ff'\n};\n\n// Number index signature\ninterface NumberArray {\n  [index: number]: string;\n}\n\nconst fruits: NumberArray = {\n  0: 'apple',\n  1: 'banana',\n  2: 'orange'\n};\n```\n\n**Mixed Index Signatures:**\n```typescript\ninterface MixedDictionary {\n  [key: string]: string | number;\n  length: number; // Must be compatible with index signature\n}\n\nconst data: MixedDictionary = {\n  name: 'John',\n  age: 30,\n  length: 2\n};\n```\n\n**Basic Mapped Types:**\n```typescript\ntype User = {\n  id: number;\n  name: string;\n  email: string;\n};\n\n// Make all properties optional\ntype PartialUser = {\n  [K in keyof User]?: User[K];\n};\n// Equivalent to: { id?: number; name?: string; email?: string; }\n\n// Make all properties readonly\ntype ReadonlyUser = {\n  readonly [K in keyof User]: User[K];\n};\n```\n\n**Property Transformation:**\n```typescript\ntype StringifyValues<T> = {\n  [K in keyof T]: string;\n};\n\ntype UserStrings = StringifyValues<User>;\n// { id: string; name: string; email: string; }\n\n// Add prefix to keys\ntype PrefixKeys<T> = {\n  [K in keyof T as `prefix_${string & K}`]: T[K];\n};\n\ntype PrefixedUser = PrefixKeys<User>;\n// { prefix_id: number; prefix_name: string; prefix_email: string; }\n```\n\n**Record Type (Built-in Mapped Type):**\n```typescript\ntype Theme = 'light' | 'dark';\ntype ThemeConfig = Record<Theme, { background: string; text: string }>;\n\nconst themes: ThemeConfig = {\n  light: { background: 'white', text: 'black' },\n  dark: { background: 'black', text: 'white' }\n};\n```\n\n**Practical Use Cases:**\n```typescript\n// Configuration objects\ninterface ApiEndpoints {\n  [endpoint: string]: string;\n}\n\nconst endpoints: ApiEndpoints = {\n  users: '/api/users',\n  posts: '/api/posts',\n  comments: '/api/comments'\n};\n\n// Dynamic form fields\ninterface FormData {\n  [fieldName: string]: string | number | boolean;\n}\n```\n\n**Benefits:**\n- Flexible object shapes\n- Type safety for dynamic properties\n- Code reuse through transformation\n- Better API modeling",
      "keywords": ["index signatures", "mapped types", "dynamic properties", "keyof operator", "property transformation", "Record type", "string index", "number index", "type transformation"],
      "difficulty": "medium"
    },
    {
      "id": 1014,
      "tag": "typescript",
      "question": "Explain the keyof operator and lookup types in TypeScript with examples.",
      "answer": "The `keyof` operator extracts property names as a union of string literals, while lookup types access property types from other types.\n\n**keyof Operator:**\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  isActive: boolean;\n}\n\n// Extract all property names\ntype UserKeys = keyof User; // 'id' | 'name' | 'email' | 'isActive'\n\n// Use in function parameters\nfunction getProperty(user: User, key: keyof User) {\n  return user[key]; // Type-safe property access\n}\n\nconst user: User = { id: 1, name: 'John', email: 'john@example.com', isActive: true };\nconst name = getProperty(user, 'name'); // string\nconst id = getProperty(user, 'id'); // number\n```\n\n**Lookup Types (Indexed Access Types):**\n```typescript\n// Access specific property type\ntype UserName = User['name']; // string\ntype UserId = User['id']; // number\n\n// Access multiple property types\ntype UserNameOrEmail = User['name' | 'email']; // string\n\n// Access all property types\ntype UserValue = User[keyof User]; // string | number | boolean\n```\n\n**Generic Property Access:**\n```typescript\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst userName = getValue(user, 'name'); // Inferred as string\nconst userId = getValue(user, 'id'); // Inferred as number\n// getValue(user, 'invalid'); // Error: Argument not assignable\n```\n\n**Nested Property Access:**\n```typescript\ninterface Address {\n  street: string;\n  city: string;\n  zipCode: string;\n}\n\ninterface Profile {\n  user: User;\n  address: Address;\n  preferences: {\n    theme: 'light' | 'dark';\n    language: string;\n  };\n}\n\n// Deep property access\ntype ProfileCity = Profile['address']['city']; // string\ntype ThemeType = Profile['preferences']['theme']; // 'light' | 'dark'\n```\n\n**Array and Tuple Lookups:**\n```typescript\ntype StringArray = string[];\ntype ArrayElement = StringArray[number]; // string\n\ntype Tuple = [string, number, boolean];\ntype FirstElement = Tuple[0]; // string\ntype SecondElement = Tuple[1]; // number\ntype AnyElement = Tuple[number]; // string | number | boolean\n```\n\n**Practical Examples:**\n```typescript\n// Type-safe object manipulation\nfunction pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  keys.forEach(key => {\n    result[key] = obj[key];\n  });\n  return result;\n}\n\nconst partialUser = pick(user, ['name', 'email']);\n// Type: { name: string; email: string; }\n\n// Dynamic property validation\nfunction hasProperty<T, K extends keyof T>(obj: T, key: K): obj is T & Record<K, NonNullable<T[K]>> {\n  return obj[key] != null;\n}\n\nif (hasProperty(user, 'email')) {\n  // TypeScript knows email is not null/undefined\n  console.log(user.email.toLowerCase());\n}\n```\n\n**Benefits:**\n- Type-safe property access\n- Generic utility functions\n- Dynamic property handling\n- Compile-time property validation\n- Better refactoring support",
      "keywords": ["keyof operator", "lookup types", "indexed access types", "property names", "property types", "type-safe access", "generic constraints", "nested properties", "array indexing"],
      "difficulty": "medium"
    },
    {
      "id": 1015,
      "tag": "typescript",
      "question": "What are TypeScript utility types? Explain Partial, Required, Pick, and Omit with examples.",
      "answer": "Utility types are built-in generic types that facilitate common type transformations. They help create new types based on existing ones.\n\n**Partial<T>:**\nMakes all properties optional.\n\n```typescript\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n  age: number;\n}\n\ntype PartialUser = Partial<User>;\n// Equivalent to: { id?: number; name?: string; email?: string; age?: number; }\n\n// Use case: Update functions\nfunction updateUser(id: number, updates: Partial<User>) {\n  // Can update any subset of properties\n}\n\nupdateUser(1, { name: 'John' }); // Valid\nupdateUser(2, { email: 'jane@example.com', age: 25 }); // Valid\n```\n\n**Required<T>:**\nMakes all properties required (opposite of Partial).\n\n```typescript\ninterface OptionalConfig {\n  apiUrl?: string;\n  timeout?: number;\n  retries?: number;\n}\n\ntype RequiredConfig = Required<OptionalConfig>;\n// Equivalent to: { apiUrl: string; timeout: number; retries: number; }\n\nfunction initializeApp(config: RequiredConfig) {\n  // All properties are guaranteed to exist\n  console.log(config.apiUrl); // No optional chaining needed\n}\n```\n\n**Pick<T, K>:**\nCreates a type by picking specific properties from T.\n\n```typescript\ntype UserSummary = Pick<User, 'id' | 'name'>;\n// Equivalent to: { id: number; name: string; }\n\ntype UserContact = Pick<User, 'name' | 'email'>;\n// Equivalent to: { name: string; email: string; }\n\n// Use case: API responses\nfunction getUserSummary(): UserSummary {\n  return { id: 1, name: 'John' };\n}\n\n// Use case: Form data\nfunction createUserForm(): Pick<User, 'name' | 'email' | 'age'> {\n  return {\n    name: '',\n    email: '',\n    age: 0\n  };\n}\n```\n\n**Omit<T, K>:**\nCreates a type by omitting specific properties from T.\n\n```typescript\ntype UserWithoutId = Omit<User, 'id'>;\n// Equivalent to: { name: string; email: string; age: number; }\n\ntype PublicUser = Omit<User, 'id' | 'email'>;\n// Equivalent to: { name: string; age: number; }\n\n// Use case: Create operations (without ID)\nfunction createUser(user: Omit<User, 'id'>): User {\n  return {\n    id: Math.random(), // Generated ID\n    ...user\n  };\n}\n\n// Use case: Sensitive data removal\nfunction getPublicProfile(user: User): PublicUser {\n  const { id, email, ...publicData } = user;\n  return publicData;\n}\n```\n\n**Combining Utility Types:**\n```typescript\n// Optional fields except required ones\ntype UserUpdate = Partial<User> & Pick<User, 'id'>;\n// { id: number; name?: string; email?: string; age?: number; }\n\n// Required creation data (without generated fields)\ntype CreateUserData = Required<Omit<User, 'id'>>;\n// { name: string; email: string; age: number; }\n\n// Partial update excluding certain fields\ntype UserProfileUpdate = Partial<Omit<User, 'id' | 'email'>>;\n// { name?: string; age?: number; }\n```\n\n**Practical Use Cases:**\n```typescript\n// Database operations\ninterface Repository<T> {\n  create(data: Omit<T, 'id'>): Promise<T>;\n  update(id: string, data: Partial<T>): Promise<T>;\n  findById(id: string): Promise<T | null>;\n}\n\n// Form handling\ntype FormState<T> = {\n  values: Partial<T>;\n  errors: Partial<Record<keyof T, string>>;\n  touched: Partial<Record<keyof T, boolean>>;\n};\n```\n\n**Benefits:**\n- Reduce code duplication\n- Type-safe transformations\n- Better API design\n- Consistent data handling\n- Improved maintainability",
      "keywords": ["utility types", "Partial", "Required", "Pick", "Omit", "type transformations", "generic types", "property manipulation", "optional properties", "type safety"],
      "difficulty": "medium"
    },
    {
      "id": 1016,
      "tag": "typescript",
      "question": "What are the 'never' and 'unknown' types in TypeScript? When would you use each?",
      "answer": "**Never Type:**\nRepresents values that never occur. Functions that never return or throw errors have a `never` return type.\n\n```typescript\n// Function that never returns\nfunction throwError(message: string): never {\n  throw new Error(message);\n}\n\n// Infinite loop function\nfunction infiniteLoop(): never {\n  while (true) {\n    // Never exits\n  }\n}\n\n// Exhaustiveness checking\ntype Shape = 'circle' | 'square';\n\nfunction getArea(shape: Shape): number {\n  switch (shape) {\n    case 'circle': return Math.PI * 5 ** 2;\n    case 'square': return 5 ** 2;\n    default:\n      const _exhaustive: never = shape; // Ensures all cases covered\n      throw new Error(`Unhandled shape: ${_exhaustive}`);\n  }\n}\n```\n\n**Unknown Type:**\nTop type that's safer than `any`. Requires type checking before use.\n\n```typescript\nlet value: unknown;\n\nvalue = 'hello';\nvalue = 42;\nvalue = true;\nvalue = { name: 'John' };\n\n// Must check type before use\nif (typeof value === 'string') {\n  console.log(value.toUpperCase()); // Safe\n}\n\n// Type guards with unknown\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nif (isString(value)) {\n  console.log(value.length); // TypeScript knows it's string\n}\n```\n\n**Use Cases:**\n- **Never:** Exhaustiveness checking, error functions, impossible states\n- **Unknown:** API responses, user input, safer alternative to `any`\n\n**Key Differences:**\n- `never` is bottom type (no values), `unknown` is top type (all values)\n- `never` used for control flow, `unknown` for type safety\n- Can't assign anything to `never`, can assign anything to `unknown`",
      "keywords": ["never type", "unknown type", "bottom type", "top type", "exhaustiveness checking", "type safety", "type guards", "control flow", "error handling"],
      "difficulty": "easy"
    },
    {
      "id": 1017,
      "tag": "typescript",
      "question": "How do the 'readonly' modifier and 'ReadonlyArray' work in TypeScript?",
      "answer": "The `readonly` modifier prevents modification of properties after initialization, providing immutability at the type level.\n\n**Readonly Properties:**\n```typescript\ninterface User {\n  readonly id: number;\n  name: string;\n  readonly createdAt: Date;\n}\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  createdAt: new Date()\n};\n\nuser.name = 'Jane'; // ✓ Allowed\nuser.id = 2; // ✗ Error: Cannot assign to readonly property\nuser.createdAt = new Date(); // ✗ Error: Cannot assign to readonly property\n```\n\n**ReadonlyArray:**\n```typescript\n// ReadonlyArray type\nconst numbers: ReadonlyArray<number> = [1, 2, 3, 4];\nconst names: readonly string[] = ['Alice', 'Bob', 'Charlie'];\n\n// Reading is allowed\nconsole.log(numbers[0]); // ✓ 1\nconsole.log(numbers.length); // ✓ 4\n\n// Mutation methods are not available\nnumbers.push(5); // ✗ Error: Property 'push' does not exist\nnumbers.pop(); // ✗ Error: Property 'pop' does not exist\nnumbers[0] = 10; // ✗ Error: Index signature only permits reading\n```\n\n**Readonly Utility Type:**\n```typescript\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n  features: string[];\n}\n\ntype ReadonlyConfig = Readonly<Config>;\n// {\n//   readonly apiUrl: string;\n//   readonly timeout: number;\n//   readonly features: readonly string[];\n// }\n\nconst config: ReadonlyConfig = {\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n  features: ['auth', 'logging']\n};\n\nconfig.apiUrl = 'new-url'; // ✗ Error: Cannot assign to readonly property\n```\n\n**Deep Readonly:**\n```typescript\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];\n};\n\ninterface NestedConfig {\n  database: {\n    host: string;\n    port: number;\n  };\n  cache: {\n    ttl: number;\n    maxSize: number;\n  };\n}\n\ntype ImmutableConfig = DeepReadonly<NestedConfig>;\n// All nested properties become readonly\n```\n\n**Const Assertions:**\n```typescript\n// Creates readonly arrays and objects\nconst colors = ['red', 'green', 'blue'] as const;\n// readonly ['red', 'green', 'blue']\n\nconst theme = {\n  primary: '#007bff',\n  secondary: '#6c757d'\n} as const;\n// { readonly primary: '#007bff'; readonly secondary: '#6c757d'; }\n```\n\n**Benefits:**\n- Prevents accidental mutations\n- Functional programming support\n- Better API contracts\n- Compile-time immutability guarantees\n- Safer data sharing between components",
      "keywords": ["readonly modifier", "ReadonlyArray", "immutability", "readonly properties", "const assertions", "deep readonly", "mutation prevention", "functional programming"],
      "difficulty": "easy"
    },
    {
      "id": 1018,
      "tag": "typescript",
      "question": "What are tuple types and labeled tuples in TypeScript? Provide examples.",
      "answer": "Tuples are arrays with fixed length and specific types for each element. Labeled tuples provide names for better documentation.\n\n**Basic Tuples:**\n```typescript\n// Fixed-length array with specific types\ntype Point = [number, number];\ntype RGB = [number, number, number];\n\nconst point: Point = [10, 20];\nconst color: RGB = [255, 128, 0];\n\n// Type checking\nconst invalid: Point = [10]; // ✗ Error: Source has 1 elements but target requires 2\nconst wrongType: RGB = [255, '128', 0]; // ✗ Error: string not assignable to number\n```\n\n**Accessing Tuple Elements:**\n```typescript\nconst coordinates: [number, number, string] = [40.7128, -74.0060, 'NYC'];\n\nconst latitude = coordinates[0]; // number\nconst longitude = coordinates[1]; // number\nconst city = coordinates[2]; // string\n\n// Destructuring\nconst [lat, lng, name] = coordinates;\n```\n\n**Optional Tuple Elements:**\n```typescript\ntype HTTPResponse = [number, string, object?];\n\nconst success: HTTPResponse = [200, 'OK'];\nconst withData: HTTPResponse = [200, 'OK', { user: 'John' }];\nconst error: HTTPResponse = [404, 'Not Found'];\n```\n\n**Rest Elements in Tuples:**\n```typescript\ntype StringNumberBooleans = [string, number, ...boolean[]];\n\nconst example1: StringNumberBooleans = ['hello', 42];\nconst example2: StringNumberBooleans = ['world', 100, true, false, true];\n\n// Mixed rest elements\ntype Mixed = [string, ...number[], boolean];\nconst mixed: Mixed = ['start', 1, 2, 3, 4, true];\n```\n\n**Labeled Tuples (TypeScript 4.0+):**\n```typescript\n// Better documentation and IDE support\ntype User = [id: number, name: string, email: string];\ntype Coordinates = [x: number, y: number, z?: number];\ntype Range = [start: number, end: number];\n\nconst user: User = [1, 'John Doe', 'john@example.com'];\nconst point2D: Coordinates = [10, 20];\nconst point3D: Coordinates = [10, 20, 30];\nconst range: Range = [0, 100];\n\n// Function parameters\nfunction drawLine(from: [x: number, y: number], to: [x: number, y: number]) {\n  // Implementation\n}\n\ndrawLine([0, 0], [100, 100]);\n```\n\n**Tuple with Named Properties:**\n```typescript\ninterface Coordinate {\n  0: number; // x\n  1: number; // y\n  length: 2;\n}\n\nfunction distance(point1: Coordinate, point2: Coordinate): number {\n  const dx = point1[0] - point2[0];\n  const dy = point1[1] - point2[1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n```\n\n**Practical Use Cases:**\n```typescript\n// React useState pattern\ntype State<T> = [T, (value: T) => void];\n\n// Database query results\ntype QueryResult = [data: any[], count: number, hasMore: boolean];\n\n// API endpoints\ntype Endpoint = [method: 'GET' | 'POST' | 'PUT' | 'DELETE', path: string, handler: Function];\n\nconst endpoints: Endpoint[] = [\n  ['GET', '/users', getUsersHandler],\n  ['POST', '/users', createUserHandler],\n  ['PUT', '/users/:id', updateUserHandler]\n];\n```\n\n**Benefits:**\n- Fixed structure with type safety\n- Better than arrays for known fixed data\n- Improved IDE support with labels\n- Clear function signatures\n- Destructuring support",
      "keywords": ["tuple types", "labeled tuples", "fixed arrays", "destructuring", "optional elements", "rest elements", "type safety", "named parameters", "structured data"],
      "difficulty": "easy"
    },
    {
      "id": 1019,
      "tag": "typescript",
      "question": "What are the key differences between interfaces and type aliases in TypeScript?",
      "answer": "While interfaces and type aliases can often be used interchangeably for object types, they have distinct characteristics and use cases.\n\n**Declaration Merging:**\n```typescript\n// Interfaces support declaration merging\ninterface User {\n  name: string;\n}\n\ninterface User {\n  age: number;\n}\n\n// Merged into: { name: string; age: number; }\nconst user: User = { name: 'John', age: 30 };\n\n// Type aliases cannot be merged\ntype Product = { name: string; };\ntype Product = { price: number; }; // ✗ Error: Duplicate identifier\n```\n\n**Extending vs Intersection:**\n```typescript\n// Interface extending\ninterface Animal {\n  name: string;\n}\n\ninterface Dog extends Animal {\n  breed: string;\n}\n\n// Type alias intersection\ntype Animal = {\n  name: string;\n};\n\ntype Dog = Animal & {\n  breed: string;\n};\n\n// Both work similarly for objects\nconst dog: Dog = { name: 'Buddy', breed: 'Golden Retriever' };\n```\n\n**Flexibility Differences:**\n```typescript\n// Type aliases are more flexible\ntype StringOrNumber = string | number; // Union types\ntype StringArray = string[]; // Array types\ntype StringMap = Record<string, string>; // Utility types\ntype Callback = (value: string) => void; // Function types\n\n// Interfaces are primarily for object shapes\ninterface UserCallback {\n  (value: string): void; // Call signature\n}\n\ninterface StringDictionary {\n  [key: string]: string; // Index signature\n}\n```\n\n**Computed Properties:**\n```typescript\n// Type aliases support computed properties\ntype EventTypes = 'click' | 'hover' | 'focus';\ntype EventHandlers = {\n  [K in EventTypes as `on${Capitalize<K>}`]: () => void;\n};\n// { onClick: () => void; onHover: () => void; onFocus: () => void; }\n\n// Interfaces cannot use computed properties directly\ninterface EventHandlersInterface {\n  onClick: () => void;\n  onHover: () => void;\n  onFocus: () => void;\n}\n```\n\n**Conditional Types:**\n```typescript\n// Type aliases support conditional types\ntype NonNullable<T> = T extends null | undefined ? never : T;\ntype IsArray<T> = T extends any[] ? true : false;\n\n// Interfaces cannot use conditional logic\n```\n\n**Performance Considerations:**\n```typescript\n// Interfaces are better for object types (slight performance benefit)\ninterface UserInterface {\n  id: number;\n  name: string;\n  email: string;\n}\n\n// Type aliases create aliases (indirection)\ntype UserType = {\n  id: number;\n  name: string;\n  email: string;\n};\n```\n\n**Implementation:**\n```typescript\n// Both can be implemented by classes\ninterface Flyable {\n  fly(): void;\n}\n\ntype Swimmable = {\n  swim(): void;\n};\n\nclass Duck implements Flyable, Swimmable {\n  fly() { console.log('Flying'); }\n  swim() { console.log('Swimming'); }\n}\n```\n\n**Error Messages:**\n```typescript\n// Interfaces often provide clearer error messages\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n}\n\ntype ConfigType = {\n  apiUrl: string;\n  timeout: number;\n};\n\n// Error messages may be more readable with interfaces\n```\n\n**Best Practices:**\n- Use **interfaces** for object shapes that might be extended\n- Use **type aliases** for unions, primitives, and complex types\n- Use **interfaces** for public APIs (library authors)\n- Use **type aliases** for internal type manipulation\n- Choose **interfaces** when declaration merging is needed\n- Choose **type aliases** for computed/conditional types",
      "keywords": ["interfaces", "type aliases", "declaration merging", "extending", "intersection types", "computed properties", "conditional types", "performance", "flexibility", "object shapes"],
      "difficulty": "easy"
    },
    {
      "id": 1020,
      "tag": "typescript",
      "question": "How do interface extension and interface merging work in TypeScript?",
      "answer": "TypeScript supports extending interfaces to create hierarchies and merging multiple interface declarations with the same name.\n\n**Interface Extension:**\n```typescript\n// Base interface\ninterface Animal {\n  name: string;\n  age: number;\n}\n\n// Single inheritance\ninterface Dog extends Animal {\n  breed: string;\n  bark(): void;\n}\n\nconst myDog: Dog = {\n  name: 'Buddy',\n  age: 3,\n  breed: 'Golden Retriever',\n  bark() { console.log('Woof!'); }\n};\n```\n\n**Multiple Inheritance:**\n```typescript\ninterface Flyable {\n  fly(): void;\n  altitude: number;\n}\n\ninterface Swimmable {\n  swim(): void;\n  depth: number;\n}\n\n// Extend multiple interfaces\ninterface Duck extends Animal, Flyable, Swimmable {\n  quack(): void;\n}\n\nconst duck: Duck = {\n  name: 'Donald',\n  age: 2,\n  altitude: 100,\n  depth: 5,\n  fly() { console.log('Flying'); },\n  swim() { console.log('Swimming'); },\n  quack() { console.log('Quack!'); }\n};\n```\n\n**Interface Merging (Declaration Merging):**\n```typescript\n// First declaration\ninterface User {\n  id: number;\n  name: string;\n}\n\n// Second declaration - automatically merged\ninterface User {\n  email: string;\n  isActive: boolean;\n}\n\n// Third declaration - merged again\ninterface User {\n  createdAt: Date;\n}\n\n// Final merged interface:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   isActive: boolean;\n//   createdAt: Date;\n// }\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  isActive: true,\n  createdAt: new Date()\n};\n```\n\n**Module Augmentation:**\n```typescript\n// Extending existing modules/libraries\ndeclare global {\n  interface Window {\n    customProperty: string;\n    myCustomMethod(): void;\n  }\n}\n\n// Now available globally\nwindow.customProperty = 'Hello';\nwindow.myCustomMethod = () => console.log('Custom method');\n\n// Extending third-party library types\ndeclare module 'express' {\n  interface Request {\n    user?: {\n      id: number;\n      role: string;\n    };\n  }\n}\n\n// Now req.user is available in Express handlers\n```\n\n**Namespace Merging:**\n```typescript\nnamespace MyNamespace {\n  export interface Config {\n    apiUrl: string;\n  }\n}\n\nnamespace MyNamespace {\n  export interface Config {\n    timeout: number;\n  }\n  \n  export function createConfig(): Config {\n    return {\n      apiUrl: 'https://api.example.com',\n      timeout: 5000\n    };\n  }\n}\n```\n\n**Function Overload Merging:**\n```typescript\ninterface Calculator {\n  add(a: number, b: number): number;\n}\n\ninterface Calculator {\n  add(a: string, b: string): string;\n}\n\n// Merged interface supports both overloads\nclass MyCalculator implements Calculator {\n  add(a: number | string, b: number | string): number | string {\n    if (typeof a === 'number' && typeof b === 'number') {\n      return a + b;\n    }\n    return String(a) + String(b);\n  }\n}\n```\n\n**Practical Use Cases:**\n```typescript\n// Plugin architecture\ninterface PluginAPI {\n  version: string;\n}\n\n// Plugins can extend the API\ninterface PluginAPI {\n  logger: {\n    log(message: string): void;\n  };\n}\n\ninterface PluginAPI {\n  database: {\n    query(sql: string): Promise<any>;\n  };\n}\n\n// Configuration merging\ninterface AppConfig {\n  development: {\n    apiUrl: string;\n  };\n}\n\ninterface AppConfig {\n  production: {\n    apiUrl: string;\n    ssl: boolean;\n  };\n}\n```\n\n**Benefits:**\n- Code organization and reusability\n- Gradual API enhancement\n- Library type augmentation\n- Plugin system support\n- Modular type definitions",
      "keywords": ["interface extension", "interface merging", "declaration merging", "multiple inheritance", "module augmentation", "namespace merging", "function overloads", "plugin architecture", "type hierarchy"],
      "difficulty": "easy"
    },
    {
      "id": 1021,
      "tag": "typescript",
      "question": "How do default parameters and function overloads work in TypeScript?",
      "answer": "TypeScript supports default parameters for cleaner function signatures and function overloads for handling different parameter combinations.\n\n**Default Parameters:**\n```typescript\n// Basic default parameters\nfunction greet(name: string, greeting: string = 'Hello'): string {\n  return `${greeting}, ${name}!`;\n}\n\ngreet('John'); // 'Hello, John!'\ngreet('Jane', 'Hi'); // 'Hi, Jane!'\n\n// Default parameters can reference previous parameters\nfunction createUser(name: string, email: string = `${name.toLowerCase()}@example.com`) {\n  return { name, email };\n}\n\ncreateUser('John'); // { name: 'John', email: 'john@example.com' }\n```\n\n**Default Parameters with Complex Types:**\n```typescript\ninterface Options {\n  timeout: number;\n  retries: number;\n  verbose: boolean;\n}\n\nconst defaultOptions: Options = {\n  timeout: 5000,\n  retries: 3,\n  verbose: false\n};\n\nfunction fetchData(url: string, options: Options = defaultOptions): Promise<any> {\n  // Implementation\n  return Promise.resolve();\n}\n\n// Partial defaults with object merging\nfunction apiCall(endpoint: string, config: Partial<Options> = {}): Promise<any> {\n  const finalConfig = { ...defaultOptions, ...config };\n  return fetchData(endpoint, finalConfig);\n}\n```\n\n**Function Overloads:**\n```typescript\n// Multiple function signatures\nfunction combine(a: string, b: string): string;\nfunction combine(a: number, b: number): number;\nfunction combine(a: string[], b: string[]): string[];\n\n// Implementation signature (not part of public API)\nfunction combine(a: any, b: any): any {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a + b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a + b;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  throw new Error('Invalid arguments');\n}\n\nconst str = combine('Hello', ' World'); // string\nconst num = combine(5, 10); // number\nconst arr = combine(['a'], ['b']); // string[]\n```\n\n**Method Overloads in Classes:**\n```typescript\nclass Calculator {\n  // Overload signatures\n  multiply(a: number, b: number): number;\n  multiply(a: string, times: number): string;\n  \n  // Implementation\n  multiply(a: number | string, b: number): number | string {\n    if (typeof a === 'number') {\n      return a * b;\n    }\n    return a.repeat(b);\n  }\n}\n\nconst calc = new Calculator();\nconst result1 = calc.multiply(5, 3); // 15\nconst result2 = calc.multiply('Hello', 3); // 'HelloHelloHello'\n```\n\n**Optional Parameters vs Overloads:**\n```typescript\n// Using optional parameters\nfunction format1(value: number, decimals?: number): string {\n  return decimals ? value.toFixed(decimals) : value.toString();\n}\n\n// Using overloads for different behavior\nfunction format2(value: number): string;\nfunction format2(value: number, decimals: number): string;\nfunction format2(value: number, decimals?: number): string {\n  if (decimals === undefined) {\n    return value.toString();\n  }\n  return value.toFixed(decimals);\n}\n```\n\n**Complex Overload Patterns:**\n```typescript\n// Event listener overloads\ninterface EventMap {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  load: Event;\n}\n\nfunction addEventListener<K extends keyof EventMap>(\n  type: K,\n  listener: (event: EventMap[K]) => void\n): void;\nfunction addEventListener(\n  type: string,\n  listener: (event: Event) => void\n): void;\nfunction addEventListener(\n  type: string,\n  listener: (event: any) => void\n): void {\n  // Implementation\n}\n\n// Type-safe event handling\naddEventListener('click', (e) => {\n  console.log(e.clientX); // MouseEvent properties available\n});\n\naddEventListener('keydown', (e) => {\n  console.log(e.key); // KeyboardEvent properties available\n});\n```\n\n**Constructor Overloads:**\n```typescript\nclass Point {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(coordinates: { x: number; y: number });\n  constructor(xOrCoords: number | { x: number; y: number }, y?: number) {\n    if (typeof xOrCoords === 'number') {\n      this.x = xOrCoords;\n      this.y = y!;\n    } else {\n      this.x = xOrCoords.x;\n      this.y = xOrCoords.y;\n    }\n  }\n}\n\nconst point1 = new Point(10, 20);\nconst point2 = new Point({ x: 10, y: 20 });\n```\n\n**Best Practices:**\n- Use default parameters when the default value is simple and commonly used\n- Use overloads when different parameter types require different logic\n- Keep overloads simple and well-documented\n- Consider union types instead of overloads when possible\n- Place most specific overloads first",
      "keywords": ["default parameters", "function overloads", "optional parameters", "method overloads", "constructor overloads", "parameter types", "function signatures", "type safety", "API design"],
      "difficulty": "easy"
    },
    {
      "id": 1022,
      "tag": "typescript",
      "question": "What are abstract classes and abstract methods in TypeScript? Provide examples.",
      "answer": "Abstract classes are base classes that cannot be instantiated directly and may contain abstract methods that must be implemented by subclasses.\n\n**Basic Abstract Class:**\n```typescript\nabstract class Animal {\n  name: string;\n  \n  constructor(name: string) {\n    this.name = name;\n  }\n  \n  // Concrete method\n  move(): void {\n    console.log(`${this.name} is moving`);\n  }\n  \n  // Abstract method - must be implemented by subclasses\n  abstract makeSound(): void;\n  abstract getSpecies(): string;\n}\n\n// Cannot instantiate abstract class\n// const animal = new Animal('Generic'); // ✗ Error\n```\n\n**Implementing Abstract Classes:**\n```typescript\nclass Dog extends Animal {\n  breed: string;\n  \n  constructor(name: string, breed: string) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  // Must implement abstract methods\n  makeSound(): void {\n    console.log(`${this.name} barks: Woof!`);\n  }\n  \n  getSpecies(): string {\n    return 'Canis familiaris';\n  }\n  \n  // Additional method specific to Dog\n  fetch(): void {\n    console.log(`${this.name} fetches the ball`);\n  }\n}\n\nclass Cat extends Animal {\n  indoor: boolean;\n  \n  constructor(name: string, indoor: boolean = true) {\n    super(name);\n    this.indoor = indoor;\n  }\n  \n  makeSound(): void {\n    console.log(`${this.name} meows: Meow!`);\n  }\n  \n  getSpecies(): string {\n    return 'Felis catus';\n  }\n}\n\nconst dog = new Dog('Buddy', 'Golden Retriever');\nconst cat = new Cat('Whiskers');\n\ndog.makeSound(); // 'Buddy barks: Woof!'\ncat.makeSound(); // 'Whiskers meows: Meow!'\n```\n\n**Abstract Properties:**\n```typescript\nabstract class Shape {\n  abstract readonly name: string;\n  abstract area: number;\n  \n  // Abstract getter/setter\n  abstract get perimeter(): number;\n  abstract set color(value: string);\n  \n  // Concrete method using abstract properties\n  describe(): string {\n    return `This ${this.name} has an area of ${this.area}`;\n  }\n}\n\nclass Rectangle extends Shape {\n  readonly name = 'Rectangle';\n  private _color: string = 'black';\n  \n  constructor(public width: number, public height: number) {\n    super();\n  }\n  \n  get area(): number {\n    return this.width * this.height;\n  }\n  \n  get perimeter(): number {\n    return 2 * (this.width + this.height);\n  }\n  \n  set color(value: string) {\n    this._color = value;\n  }\n  \n  get color(): string {\n    return this._color;\n  }\n}\n```\n\n**Abstract Classes with Generics:**\n```typescript\nabstract class Repository<T> {\n  protected items: T[] = [];\n  \n  // Concrete methods\n  findAll(): T[] {\n    return this.items;\n  }\n  \n  findById(id: string): T | undefined {\n    return this.items.find(item => this.getId(item) === id);\n  }\n  \n  // Abstract methods\n  abstract getId(item: T): string;\n  abstract validate(item: T): boolean;\n  abstract save(item: T): Promise<T>;\n}\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nclass UserRepository extends Repository<User> {\n  getId(user: User): string {\n    return user.id;\n  }\n  \n  validate(user: User): boolean {\n    return user.name.length > 0 && user.email.includes('@');\n  }\n  \n  async save(user: User): Promise<User> {\n    if (!this.validate(user)) {\n      throw new Error('Invalid user data');\n    }\n    this.items.push(user);\n    return user;\n  }\n}\n```\n\n**Factory Pattern with Abstract Classes:**\n```typescript\nabstract class DatabaseConnection {\n  abstract connect(): Promise<void>;\n  abstract disconnect(): Promise<void>;\n  abstract query(sql: string): Promise<any[]>;\n  \n  // Template method pattern\n  async executeTransaction<T>(operation: () => Promise<T>): Promise<T> {\n    await this.connect();\n    try {\n      const result = await operation();\n      return result;\n    } finally {\n      await this.disconnect();\n    }\n  }\n}\n\nclass PostgreSQLConnection extends DatabaseConnection {\n  async connect(): Promise<void> {\n    console.log('Connecting to PostgreSQL...');\n  }\n  \n  async disconnect(): Promise<void> {\n    console.log('Disconnecting from PostgreSQL...');\n  }\n  \n  async query(sql: string): Promise<any[]> {\n    console.log(`Executing PostgreSQL query: ${sql}`);\n    return [];\n  }\n}\n\nclass MySQLConnection extends DatabaseConnection {\n  async connect(): Promise<void> {\n    console.log('Connecting to MySQL...');\n  }\n  \n  async disconnect(): Promise<void> {\n    console.log('Disconnecting from MySQL...');\n  }\n  \n  async query(sql: string): Promise<any[]> {\n    console.log(`Executing MySQL query: ${sql}`);\n    return [];\n  }\n}\n```\n\n**Use Cases:**\n- Template Method pattern implementation\n- Enforcing consistent APIs across subclasses\n- Sharing common functionality while requiring specific implementations\n- Plugin architectures\n- Framework base classes\n\n**Benefits:**\n- Code reuse through inheritance\n- Enforced implementation contracts\n- Type safety with polymorphism\n- Clear separation of common and specific behavior\n- Better API design for extensible systems",
      "keywords": ["abstract classes", "abstract methods", "inheritance", "polymorphism", "template method", "base classes", "subclasses", "cannot instantiate", "must implement", "design patterns"],
      "difficulty": "easy"
    },
    {
      "id": 1023,
      "tag": "typescript",
      "question": "Explain conditional types (T extends U ? X : Y) in TypeScript with practical examples.",
      "answer": "Conditional types enable type-level logic, allowing types to be chosen based on whether one type extends another.\n\n**Basic Conditional Types:**\n```typescript\n// Basic syntax: T extends U ? X : Y\ntype IsString<T> = T extends string ? true : false;\n\ntype Test1 = IsString<string>; // true\ntype Test2 = IsString<number>; // false\ntype Test3 = IsString<'hello'>; // true (string literal extends string)\n\n// Conditional return types\ntype ApiResponse<T> = T extends string \n  ? { message: T; status: 'success' }\n  : { error: T; status: 'error' };\n\ntype SuccessResponse = ApiResponse<string>; // { message: string; status: 'success' }\ntype ErrorResponse = ApiResponse<Error>; // { error: Error; status: 'error' }\n```\n\n**Infer Keyword:**\n```typescript\n// Extract return type from function\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype FuncReturn = ReturnType<() => string>; // string\ntype ComplexReturn = ReturnType<(x: number) => Promise<User>>; // Promise<User>\n\n// Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringArrayElement = ArrayElement<string[]>; // string\ntype NumberArrayElement = ArrayElement<number[]>; // number\n\n// Extract promise value type\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\ntype PromiseValue = Awaited<Promise<string>>; // string\ntype NonPromiseValue = Awaited<number>; // number\n```\n\n**Nested Conditional Types:**\n```typescript\n// Deep readonly implementation\ntype DeepReadonly<T> = T extends (infer U)[]\n  ? ReadonlyArray<DeepReadonly<U>>\n  : T extends object\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : T;\n\ninterface User {\n  name: string;\n  hobbies: string[];\n  profile: {\n    age: number;\n    settings: { theme: string };\n  };\n}\n\ntype ReadonlyUser = DeepReadonly<User>;\n// {\n//   readonly name: string;\n//   readonly hobbies: readonly string[];\n//   readonly profile: {\n//     readonly age: number;\n//     readonly settings: { readonly theme: string };\n//   };\n// }\n```\n\n**Distributive Conditional Types:**\n```typescript\n// Conditional types distribute over union types\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype CleanUnion = NonNullable<string | number | null | undefined>; // string | number\n\n// Extract function types from union\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\n\ninterface Example {\n  name: string;\n  age: number;\n  getName(): string;\n  setAge(age: number): void;\n}\n\ntype FuncNames = FunctionPropertyNames<Example>; // 'getName' | 'setAge'\n```\n\n**Conditional Type Chains:**\n```typescript\n// Chain multiple conditions\ntype TypeName<T> = T extends string\n  ? 'string'\n  : T extends number\n  ? 'number'\n  : T extends boolean\n  ? 'boolean'\n  : T extends undefined\n  ? 'undefined'\n  : T extends Function\n  ? 'function'\n  : 'object';\n\ntype StringType = TypeName<string>; // 'string'\ntype NumberType = TypeName<42>; // 'number'\ntype FunctionType = TypeName<() => void>; // 'function'\ntype ObjectType = TypeName<{ x: number }>; // 'object'\n```\n\n**Practical Examples:**\n```typescript\n// Smart flatten type\ntype Flatten<T> = T extends any[] ? T[number] : T;\n\ntype FlatString = Flatten<string>; // string\ntype FlatArray = Flatten<string[]>; // string\ntype FlatNested = Flatten<string[][]>; // string[]\n\n// Conditional props based on discriminated unions\ntype ButtonProps<T extends 'button' | 'link'> = {\n  children: React.ReactNode;\n} & (T extends 'button'\n  ? { onClick: () => void; type?: 'button' | 'submit' }\n  : { href: string; target?: '_blank' });\n\n// Usage:\nconst button: ButtonProps<'button'> = {\n  children: 'Click me',\n  onClick: () => {}\n};\n\nconst link: ButtonProps<'link'> = {\n  children: 'Visit',\n  href: 'https://example.com'\n};\n\n// API response type based on method\ntype ApiCall<Method extends 'GET' | 'POST'> = Method extends 'GET'\n  ? { method: 'GET'; params?: Record<string, string> }\n  : { method: 'POST'; body: any; headers?: Record<string, string> };\n\nfunction makeRequest<M extends 'GET' | 'POST'>(config: ApiCall<M>) {\n  // Implementation based on method type\n}\n\nmakeRequest({ method: 'GET', params: { id: '1' } });\nmakeRequest({ method: 'POST', body: { name: 'John' } });\n```\n\n**Advanced Pattern Matching:**\n```typescript\n// Pattern matching for complex types\ntype PathValue<T, P> = P extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? PathValue<T[Key], Rest>\n    : never\n  : P extends keyof T\n  ? T[P]\n  : never;\n\ninterface NestedData {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n  };\n}\n\ntype UserName = PathValue<NestedData, 'user.profile.name'>; // string\ntype UserAge = PathValue<NestedData, 'user.profile.age'>; // number\n```\n\n**Benefits:**\n- Type-level programming and logic\n- Dynamic type generation\n- Better API design\n- Compile-time optimizations\n- Advanced type transformations",
      "keywords": ["conditional types", "extends keyword", "infer keyword", "type-level logic", "distributive types", "pattern matching", "type transformation", "generic constraints", "compile-time logic"],
      "difficulty": "medium"
    },
    {
      "id": 1024,
      "tag": "typescript",
      "question": "What are template literal types in TypeScript? Provide examples of their usage.",
      "answer": "Template literal types use template literal syntax to create types based on string manipulation and pattern matching.\n\n**Basic Template Literal Types:**\n```typescript\n// Basic template literal type\ntype World = 'world';\ntype Greeting = `hello ${World}`; // 'hello world'\n\n// With union types\ntype Color = 'red' | 'green' | 'blue';\ntype HexColor = `#${string}`;\ntype CSSColor = Color | HexColor;\n\n// Generate multiple combinations\ntype Size = 'small' | 'medium' | 'large';\ntype ButtonClass = `btn-${Size}`; // 'btn-small' | 'btn-medium' | 'btn-large'\n```\n\n**CSS-in-JS Patterns:**\n```typescript\n// CSS property patterns\ntype CSSProperty = \n  | `margin-${string}`\n  | `padding-${string}`\n  | `border-${string}`\n  | `background-${string}`;\n\ntype MarginProperty = `margin-${'top' | 'right' | 'bottom' | 'left'}`;\n// 'margin-top' | 'margin-right' | 'margin-bottom' | 'margin-left'\n\n// CSS units\ntype CSSUnit = 'px' | 'em' | 'rem' | '%' | 'vh' | 'vw';\ntype CSSValue<T extends number> = `${T}${CSSUnit}`;\n\ntype Width = CSSValue<100>; // '100px' | '100em' | '100rem' | '100%' | '100vh' | '100vw'\n\n// Styled components pattern\ntype StyledProps = {\n  [K in MarginProperty]?: string;\n};\n\nconst styles: StyledProps = {\n  'margin-top': '10px',\n  'margin-left': '20px'\n};\n```\n\n**Event Handling Patterns:**\n```typescript\n// Event handler naming convention\ntype EventType = 'click' | 'hover' | 'focus' | 'blur';\ntype EventHandler = `on${Capitalize<EventType>}`;\n// 'onClick' | 'onHover' | 'onFocus' | 'onBlur'\n\n// Component props with event handlers\ntype ButtonProps = {\n  [K in EventHandler]?: () => void;\n} & {\n  children: React.ReactNode;\n};\n\nconst button: ButtonProps = {\n  onClick: () => console.log('clicked'),\n  onHover: () => console.log('hovered'),\n  children: 'Click me'\n};\n```\n\n**API Endpoint Generation:**\n```typescript\n// REST API patterns\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\ntype APIVersion = 'v1' | 'v2';\ntype Resource = 'users' | 'posts' | 'comments';\n\ntype APIEndpoint = `/api/${APIVersion}/${Resource}`;\n// '/api/v1/users' | '/api/v1/posts' | '/api/v1/comments' | '/api/v2/users' | ...\n\n// With ID patterns\ntype ResourceWithId = `${APIEndpoint}/${string}`;\ntype SpecificEndpoint = '/api/v1/users/123' | '/api/v2/posts/abc';\n\n// Query parameters\ntype QueryParam = `?${string}=${string}`;\ntype EndpointWithQuery = `${APIEndpoint}${QueryParam}`;\n```\n\n**String Manipulation Utilities:**\n```typescript\n// Built-in string manipulation types\ntype UppercaseExample = Uppercase<'hello'>; // 'HELLO'\ntype LowercaseExample = Lowercase<'WORLD'>; // 'world'\ntype CapitalizeExample = Capitalize<'typescript'>; // 'Typescript'\ntype UncapitalizeExample = Uncapitalize<'TypeScript'>; // 'typeScript'\n\n// Custom string transformations\ntype KebabCase<S extends string> = S extends `${infer T}${infer U}`\n  ? `${T extends Capitalize<T> ? '-' : ''}${Lowercase<T>}${KebabCase<U>}`\n  : S;\n\ntype CamelToKebab = KebabCase<'userName'>; // 'user-name'\ntype PascalToKebab = KebabCase<'UserProfile'>; // 'user-profile'\n```\n\n**Path and Route Patterns:**\n```typescript\n// URL path patterns\ntype Route = '/home' | '/about' | '/contact';\ntype DynamicRoute = `/user/${string}` | `/post/${string}`;\ntype AllRoutes = Route | DynamicRoute;\n\n// Nested route patterns\ntype AdminRoute = `/admin/${string}`;\ntype APIRoute = `/api/${string}`;\ntype AppRoute = Route | AdminRoute | APIRoute;\n\n// Path parameter extraction\ntype ExtractPathParams<T extends string> = \n  T extends `${string}:${infer Param}/${infer Rest}`\n    ? { [K in Param]: string } & ExtractPathParams<Rest>\n    : T extends `${string}:${infer Param}`\n    ? { [K in Param]: string }\n    : {};\n\ntype UserRouteParams = ExtractPathParams<'/user/:id/post/:postId'>;\n// { id: string; postId: string }\n```\n\n**Database and SQL Patterns:**\n```typescript\n// SQL query patterns\ntype SQLCommand = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE';\ntype TableName = 'users' | 'posts' | 'comments';\ntype SQLQuery = `${SQLCommand} * FROM ${TableName}`;\n\n// Column patterns\ntype UserColumn = 'id' | 'name' | 'email' | 'created_at';\ntype SelectQuery = `SELECT ${UserColumn} FROM users`;\n// 'SELECT id FROM users' | 'SELECT name FROM users' | ...\n\n// Join patterns\ntype JoinType = 'INNER' | 'LEFT' | 'RIGHT';\ntype JoinQuery = `${SelectQuery} ${JoinType} JOIN ${TableName} ON ${string}`;\n```\n\n**Validation and Parsing:**\n```typescript\n// Email validation pattern\ntype Email = `${string}@${string}.${string}`;\n\n// URL validation pattern\ntype Protocol = 'http' | 'https';\ntype URL = `${Protocol}://${string}`;\n\n// Version pattern\ntype Version = `${number}.${number}.${number}`;\ntype SemVer = `${Version}${'alpha' | 'beta' | 'rc' | ''}`;\n\n// File extension patterns\ntype ImageExt = 'jpg' | 'png' | 'gif' | 'webp';\ntype ImageFile = `${string}.${ImageExt}`;\n\n// Environment variable patterns\ntype EnvPrefix = 'REACT_APP' | 'NEXT_PUBLIC';\ntype EnvVar = `${EnvPrefix}_${Uppercase<string>}`;\n```\n\n**Advanced Pattern Matching:**\n```typescript\n// Complex pattern extraction\ntype ParseJSON<T extends string> = T extends `{${infer Content}}`\n  ? ParseObject<Content>\n  : T extends `[${infer Content}]`\n  ? ParseArray<Content>\n  : T extends `\"${infer Content}\"`\n  ? Content\n  : T extends 'true' | 'false'\n  ? boolean\n  : T extends `${number}`\n  ? number\n  : never;\n\ntype ParseObject<T extends string> = {\n  // Complex object parsing logic\n};\n\ntype ParseArray<T extends string> = {\n  // Complex array parsing logic\n};\n```\n\n**Benefits:**\n- Type-safe string manipulation\n- API contract enforcement\n- CSS-in-JS type safety\n- Route and path validation\n- Template and pattern generation\n- Compile-time string validation",
      "keywords": ["template literal types", "string manipulation", "template literals", "string patterns", "CSS-in-JS", "API endpoints", "route patterns", "string validation", "pattern matching", "type generation"],
      "difficulty": "medium"
    },
    {
      "id": 1025,
      "tag": "typescript",
      "question": "What are branded types and nominal typing in TypeScript? How do you implement them?",
      "answer": "Branded types (nominal typing) create distinct types that are structurally identical but semantically different, preventing accidental mixing of similar types.\n\n**Basic Branded Types:**\n```typescript\n// Create a brand using intersection with unique symbol\ntype Brand<T, U> = T & { readonly __brand: unique symbol };\n\n// Define branded types\ntype UserId = Brand<string, 'UserId'>;\ntype Email = Brand<string, 'Email'>;\ntype ProductId = Brand<string, 'ProductId'>;\n\n// Constructor functions\nfunction createUserId(id: string): UserId {\n  // Validation logic here\n  if (!id || id.length < 3) {\n    throw new Error('Invalid user ID');\n  }\n  return id as UserId;\n}\n\nfunction createEmail(email: string): Email {\n  if (!email.includes('@')) {\n    throw new Error('Invalid email format');\n  }\n  return email as Email;\n}\n\n// Usage\nconst userId = createUserId('user123');\nconst email = createEmail('user@example.com');\nconst productId = createProductId('prod456');\n\n// Type safety - prevents mixing\nfunction getUserProfile(id: UserId): UserProfile {\n  // Implementation\n}\n\ngetUserProfile(userId); // ✓ Valid\ngetUserProfile(email); // ✗ Error: Email not assignable to UserId\ngetUserProfile('user123'); // ✗ Error: string not assignable to UserId\n```\n\n**Numeric Branded Types:**\n```typescript\n// Numeric brands with units\ntype Meters = Brand<number, 'Meters'>;\ntype Feet = Brand<number, 'Feet'>;\ntype Seconds = Brand<number, 'Seconds'>;\ntype Milliseconds = Brand<number, 'Milliseconds'>;\n\n// Constructor functions with validation\nfunction meters(value: number): Meters {\n  if (value < 0) throw new Error('Meters cannot be negative');\n  return value as Meters;\n}\n\nfunction feet(value: number): Feet {\n  if (value < 0) throw new Error('Feet cannot be negative');\n  return value as Feet;\n}\n\nfunction seconds(value: number): Seconds {\n  if (value < 0) throw new Error('Seconds cannot be negative');\n  return value as Seconds;\n}\n\n// Conversion functions\nfunction metersToFeet(m: Meters): Feet {\n  return feet((m as number) * 3.28084);\n}\n\nfunction secondsToMilliseconds(s: Seconds): Milliseconds {\n  return (s as number * 1000) as Milliseconds;\n}\n\n// Usage\nconst distance = meters(100);\nconst height = feet(6);\nconst duration = seconds(30);\n\n// Type-safe operations\nfunction calculateSpeed(distance: Meters, time: Seconds): number {\n  return (distance as number) / (time as number);\n}\n\ncalculateSpeed(distance, duration); // ✓ Valid\ncalculateSpeed(height, duration); // ✗ Error: Feet not assignable to Meters\n```\n\n**Advanced Branded Types with Validation:**\n```typescript\n// More sophisticated branding with runtime validation\ntype PositiveInteger = Brand<number, 'PositiveInteger'>;\ntype NonEmptyString = Brand<string, 'NonEmptyString'>;\ntype ValidatedEmail = Brand<string, 'ValidatedEmail'>;\n\n// Validation predicates\nfunction isPositiveInteger(value: number): value is PositiveInteger {\n  return Number.isInteger(value) && value > 0;\n}\n\nfunction isNonEmptyString(value: string): value is NonEmptyString {\n  return value.length > 0;\n}\n\nfunction isValidEmail(value: string): value is ValidatedEmail {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(value);\n}\n\n// Safe constructors\nfunction positiveInteger(value: number): PositiveInteger {\n  if (!isPositiveInteger(value)) {\n    throw new Error(`${value} is not a positive integer`);\n  }\n  return value;\n}\n\nfunction nonEmptyString(value: string): NonEmptyString {\n  if (!isNonEmptyString(value)) {\n    throw new Error('String cannot be empty');\n  }\n  return value;\n}\n\nfunction validatedEmail(value: string): ValidatedEmail {\n  if (!isValidEmail(value)) {\n    throw new Error(`${value} is not a valid email`);\n  }\n  return value;\n}\n```\n\n**Branded Types for Database IDs:**\n```typescript\n// Database entity IDs\ntype UserID = Brand<number, 'UserID'>;\ntype PostID = Brand<number, 'PostID'>;\ntype CommentID = Brand<number, 'CommentID'>;\n\n// Repository pattern with branded types\ninterface UserRepository {\n  findById(id: UserID): Promise<User | null>;\n  create(userData: CreateUserData): Promise<UserID>;\n  update(id: UserID, data: UpdateUserData): Promise<void>;\n  delete(id: UserID): Promise<void>;\n}\n\ninterface PostRepository {\n  findById(id: PostID): Promise<Post | null>;\n  findByAuthor(authorId: UserID): Promise<Post[]>;\n  create(postData: CreatePostData): Promise<PostID>;\n}\n\n// Usage prevents ID mixing\nclass BlogService {\n  constructor(\n    private userRepo: UserRepository,\n    private postRepo: PostRepository\n  ) {}\n  \n  async getAuthorPosts(userId: UserID): Promise<Post[]> {\n    return this.postRepo.findByAuthor(userId);\n  }\n  \n  async getPostAuthor(postId: PostID): Promise<User | null> {\n    const post = await this.postRepo.findById(postId);\n    if (!post) return null;\n    \n    return this.userRepo.findById(post.authorId);\n    // return this.userRepo.findById(postId); // ✗ Error: PostID not assignable to UserID\n  }\n}\n```\n\n**Branded Types for API Contracts:**\n```typescript\n// API versioning with branded types\ntype APIv1Response<T> = Brand<T, 'APIv1'>;\ntype APIv2Response<T> = Brand<T, 'APIv2'>;\n\ninterface UserV1 {\n  id: number;\n  name: string;\n}\n\ninterface UserV2 {\n  id: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n}\n\n// Version-specific handlers\nfunction handleV1Response(response: APIv1Response<UserV1[]>) {\n  // Handle v1 format\n}\n\nfunction handleV2Response(response: APIv2Response<UserV2[]>) {\n  // Handle v2 format\n}\n\n// Prevents version mixing\nconst v1Data = fetchV1Users(); // Returns APIv1Response<UserV1[]>\nconst v2Data = fetchV2Users(); // Returns APIv2Response<UserV2[]>\n\nhandleV1Response(v1Data); // ✓ Valid\nhandleV2Response(v2Data); // ✓ Valid\nhandleV1Response(v2Data); // ✗ Error: Version mismatch\n```\n\n**Money and Currency Brands:**\n```typescript\n// Currency-specific money types\ntype USD = Brand<number, 'USD'>;\ntype EUR = Brand<number, 'EUR'>;\ntype GBP = Brand<number, 'GBP'>;\n\nfunction usd(amount: number): USD {\n  return Math.round(amount * 100) / 100 as USD; // Round to 2 decimal places\n}\n\nfunction eur(amount: number): EUR {\n  return Math.round(amount * 100) / 100 as EUR;\n}\n\n// Currency conversion with exchange rates\nfunction usdToEur(amount: USD, rate: number): EUR {\n  return eur((amount as number) * rate);\n}\n\n// Type-safe calculations\nfunction calculateTotal(prices: USD[]): USD {\n  const total = prices.reduce((sum, price) => sum + (price as number), 0);\n  return usd(total);\n}\n\nconst price1 = usd(19.99);\nconst price2 = usd(29.50);\nconst euroPrice = eur(25.00);\n\nconst total = calculateTotal([price1, price2]); // ✓ Valid\nconst invalid = calculateTotal([price1, euroPrice]); // ✗ Error: EUR not assignable to USD\n```\n\n**Benefits:**\n- Prevents accidental type mixing\n- Adds semantic meaning to primitive types\n- Enforces domain-specific validation\n- Better API design and documentation\n- Compile-time safety for business logic\n- Clear intent and reduced bugs\n\n**When to Use:**\n- IDs that shouldn't be mixed (UserID vs ProductID)\n- Units of measurement (meters vs feet)\n- Currency types\n- Validated input types (Email, Phone)\n- API versioning\n- Security tokens and credentials",
      "keywords": ["branded types", "nominal typing", "type safety", "unique symbol", "type branding", "validation", "semantic types", "domain modeling", "type distinction", "runtime validation"],
      "difficulty": "medium"
    },
    {
      "id": 1026,
      "tag": "typescript",
      "question": "How do recursive types and the 'infer' keyword work in TypeScript? Provide examples.",
      "answer": "Recursive types reference themselves in their definition, while `infer` allows extracting and capturing types within conditional type expressions.\n\n**Basic Recursive Types:**\n```typescript\n// Recursive data structures\ntype LinkedList<T> = {\n  value: T;\n  next: LinkedList<T> | null;\n};\n\n// Tree structure\ntype BinaryTree<T> = {\n  value: T;\n  left: BinaryTree<T> | null;\n  right: BinaryTree<T> | null;\n};\n\n// JSON-like recursive type\ntype JSONValue = \n  | string\n  | number\n  | boolean\n  | null\n  | JSONValue[]\n  | { [key: string]: JSONValue };\n\nconst data: JSONValue = {\n  name: 'John',\n  age: 30,\n  hobbies: ['reading', 'coding'],\n  address: {\n    street: '123 Main St',\n    coordinates: [40.7128, -74.0060]\n  }\n};\n```\n\n**The 'infer' Keyword:**\n```typescript\n// Extract return type from function\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;\n\ntype FuncReturn = ReturnType<() => string>; // string\ntype AsyncReturn = ReturnType<() => Promise<number>>; // Promise<number>\n\n// Extract parameters from function\ntype Parameters<T> = T extends (...args: infer P) => any ? P : never;\n\ntype FuncParams = Parameters<(a: string, b: number) => void>; // [string, number]\n\n// Extract array element type\ntype ArrayElement<T> = T extends (infer U)[] ? U : never;\n\ntype StringElement = ArrayElement<string[]>; // string\ntype NumberElement = ArrayElement<number[]>; // number\n\n// Extract Promise value type\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\ntype PromiseString = Awaited<Promise<string>>; // string\ntype NonPromise = Awaited<number>; // number\n```\n\n**Recursive Type with 'infer':**\n```typescript\n// Deep flatten array type\ntype DeepFlatten<T> = T extends (infer U)[]\n  ? U extends any[]\n    ? DeepFlatten<U>\n    : U\n  : T;\n\ntype NestedArray = string[][][];\ntype Flattened = DeepFlatten<NestedArray>; // string\n\ntype MixedNested = (string | number[])[];\ntype MixedFlattened = DeepFlatten<MixedNested>; // string | number\n```\n\n**Complex Recursive Operations:**\n```typescript\n// Deep readonly implementation\ntype DeepReadonly<T> = {\n  readonly [P in keyof T]: T[P] extends object\n    ? T[P] extends Function\n      ? T[P]\n      : DeepReadonly<T[P]>\n    : T[P];\n};\n\ninterface NestedObject {\n  user: {\n    profile: {\n      name: string;\n      settings: {\n        theme: string;\n        notifications: boolean;\n      };\n    };\n    posts: Array<{\n      title: string;\n      content: string;\n    }>;\n  };\n}\n\ntype ReadonlyNested = DeepReadonly<NestedObject>;\n// All properties become readonly recursively\n```\n\n**Path Navigation Types:**\n```typescript\n// Extract value type at nested path\ntype PathValue<T, Path> = Path extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? PathValue<T[Key], Rest>\n    : never\n  : Path extends keyof T\n  ? T[Path]\n  : never;\n\n// Set value type at nested path\ntype SetPath<T, Path, Value> = Path extends `${infer Key}.${infer Rest}`\n  ? Key extends keyof T\n    ? {\n        [K in keyof T]: K extends Key\n          ? SetPath<T[K], Rest, Value>\n          : T[K]\n      }\n    : never\n  : Path extends keyof T\n  ? {\n      [K in keyof T]: K extends Path ? Value : T[K]\n    }\n  : never;\n\ninterface AppState {\n  user: {\n    profile: {\n      name: string;\n      age: number;\n    };\n  };\n  settings: {\n    theme: string;\n  };\n}\n\ntype UserName = PathValue<AppState, 'user.profile.name'>; // string\ntype UserAge = PathValue<AppState, 'user.profile.age'>; // number\n\ntype UpdatedState = SetPath<AppState, 'user.profile.name', 'John'>;\n// Updates the name field type while preserving structure\n```\n\n**Recursive String Operations:**\n```typescript\n// String length calculation (compile-time)\ntype StringLength<S extends string, Acc extends any[] = []> = \n  S extends `${string}${infer Rest}`\n    ? StringLength<Rest, [...Acc, any]>\n    : Acc['length'];\n\ntype Length = StringLength<'hello'>; // 5\n\n// String reversal\ntype Reverse<S extends string, Result extends string = ''> = \n  S extends `${infer First}${infer Rest}`\n    ? Reverse<Rest, `${First}${Result}`>\n    : Result;\n\ntype Reversed = Reverse<'hello'>; // 'olleh'\n\n// Join array of strings\ntype Join<T extends string[], Delimiter extends string = ''> = \n  T extends [infer First, ...infer Rest]\n    ? First extends string\n      ? Rest extends string[]\n        ? Rest['length'] extends 0\n          ? First\n          : `${First}${Delimiter}${Join<Rest, Delimiter>}`\n        : never\n      : never\n    : '';\n\ntype Joined = Join<['hello', 'world', 'typescript'], ' '>; // 'hello world typescript'\n```\n\n**Tree Traversal Types:**\n```typescript\n// Extract all leaf values from nested object\ntype LeafPaths<T, K extends keyof T = keyof T> = K extends string\n  ? T[K] extends object\n    ? T[K] extends any[]\n      ? K\n      : `${K}.${LeafPaths<T[K]>}`\n    : K\n  : never;\n\ntype AllPaths = LeafPaths<{\n  a: string;\n  b: {\n    c: number;\n    d: {\n      e: boolean;\n    };\n  };\n}>; // 'a' | 'b.c' | 'b.d.e'\n```\n\n**Function Composition Types:**\n```typescript\n// Compose function types\ntype Compose<F, G> = F extends (arg: infer A) => infer B\n  ? G extends (arg: B) => infer C\n    ? (arg: A) => C\n    : never\n  : never;\n\ntype Pipe<T extends any[], R = {}> = T extends [\n  (...args: any[]) => infer A,\n  ...infer Rest\n]\n  ? Rest extends []\n    ? (...args: any[]) => A\n    : Rest extends [any, ...any[]]\n    ? Pipe<Rest> extends (arg: A) => infer B\n      ? (...args: any[]) => B\n      : never\n    : never\n  : never;\n\n// Usage\nconst f1 = (x: number) => x.toString();\nconst f2 = (x: string) => x.length;\nconst f3 = (x: number) => x > 5;\n\ntype ComposedType = Pipe<[typeof f1, typeof f2, typeof f3]>;\n// (x: number) => boolean\n```\n\n**Practical Applications:**\n```typescript\n// Form validation with recursive error types\ntype ValidationErrors<T> = {\n  [K in keyof T]?: T[K] extends object\n    ? T[K] extends any[]\n      ? string\n      : ValidationErrors<T[K]>\n    : string;\n};\n\ninterface UserForm {\n  personal: {\n    firstName: string;\n    lastName: string;\n  };\n  contact: {\n    email: string;\n    phone: string;\n  };\n}\n\ntype FormErrors = ValidationErrors<UserForm>;\n// {\n//   personal?: {\n//     firstName?: string;\n//     lastName?: string;\n//   };\n//   contact?: {\n//     email?: string;\n//     phone?: string;\n//   };\n// }\n```\n\n**Benefits:**\n- Handle complex nested data structures\n- Type-safe operations on recursive data\n- Advanced type transformations\n- Compile-time computations\n- Better API design for nested objects\n- Type extraction and manipulation",
      "keywords": ["recursive types", "infer keyword", "type extraction", "nested types", "conditional types", "type manipulation", "tree structures", "path types", "type composition", "compile-time computation"],
      "difficulty": "medium"
    },
    {
      "id": 1027,
      "tag": "typescript",
      "question": "What is module augmentation and declaration merging in TypeScript? Provide practical examples.",
      "answer": "Module augmentation allows extending existing modules by adding new declarations, while declaration merging combines multiple declarations of the same name into a single definition.\n\n**Global Augmentation:**\n```typescript\n// Extending global interfaces\ndeclare global {\n  interface Window {\n    customAnalytics: {\n      track(event: string, data?: any): void;\n      identify(userId: string): void;\n    };\n    myAppConfig: {\n      apiUrl: string;\n      version: string;\n    };\n  }\n  \n  interface Array<T> {\n    last(): T | undefined;\n    first(): T | undefined;\n  }\n}\n\n// Implementation (in a separate file or module)\nWindow.prototype.customAnalytics = {\n  track(event: string, data?: any) {\n    console.log('Tracking:', event, data);\n  },\n  identify(userId: string) {\n    console.log('Identifying user:', userId);\n  }\n};\n\nArray.prototype.last = function<T>(this: T[]): T | undefined {\n  return this[this.length - 1];\n};\n\nArray.prototype.first = function<T>(this: T[]): T | undefined {\n  return this[0];\n};\n\n// Now available globally\nwindow.customAnalytics.track('page_view');\nconst numbers = [1, 2, 3];\nconst lastNumber = numbers.last(); // 3\n```\n\n**Third-Party Library Augmentation:**\n```typescript\n// Extending Express Request interface\nimport express from 'express';\n\ndeclare module 'express-serve-static-core' {\n  interface Request {\n    user?: {\n      id: string;\n      email: string;\n      role: 'admin' | 'user';\n    };\n    requestId: string;\n    startTime: number;\n  }\n  \n  interface Response {\n    sendSuccess<T>(data: T, message?: string): Response;\n    sendError(error: string, code?: number): Response;\n  }\n}\n\n// Middleware that uses the augmented types\nfunction authMiddleware(req: express.Request, res: express.Response, next: express.NextFunction) {\n  // Authenticate user and set req.user\n  req.user = {\n    id: '123',\n    email: 'user@example.com',\n    role: 'user'\n  };\n  req.requestId = Math.random().toString(36);\n  req.startTime = Date.now();\n  next();\n}\n\n// Route handlers can now use the extended interface\napp.get('/profile', (req, res) => {\n  if (!req.user) {\n    return res.sendError('Unauthorized', 401);\n  }\n  \n  res.sendSuccess({\n    user: req.user,\n    requestId: req.requestId\n  });\n});\n```\n\n**Module Augmentation for Libraries:**\n```typescript\n// Extending lodash with custom utilities\nimport _ from 'lodash';\n\ndeclare module 'lodash' {\n  interface LoDashStatic {\n    randomString(length?: number): string;\n    deepFreeze<T>(obj: T): T;\n    isValidEmail(email: string): boolean;\n  }\n}\n\n// Add custom methods to lodash\n_.mixin({\n  randomString(length: number = 10): string {\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    return _.times(length, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');\n  },\n  \n  deepFreeze<T>(obj: T): T {\n    Object.getOwnPropertyNames(obj).forEach(prop => {\n      const value = (obj as any)[prop];\n      if (value && typeof value === 'object') {\n        _.deepFreeze(value);\n      }\n    });\n    return Object.freeze(obj);\n  },\n  \n  isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n});\n\n// Now available with type safety\nconst randomId = _.randomString(8);\nconst isValid = _.isValidEmail('test@example.com');\nconst frozenObj = _.deepFreeze({ name: 'John', age: 30 });\n```\n\n**Declaration Merging - Interface Merging:**\n```typescript\n// Multiple interface declarations are automatically merged\ninterface User {\n  id: number;\n  name: string;\n}\n\ninterface User {\n  email: string;\n  createdAt: Date;\n}\n\ninterface User {\n  lastLoginAt?: Date;\n  isActive: boolean;\n}\n\n// Merged interface:\n// {\n//   id: number;\n//   name: string;\n//   email: string;\n//   createdAt: Date;\n//   lastLoginAt?: Date;\n//   isActive: boolean;\n// }\n\nconst user: User = {\n  id: 1,\n  name: 'John',\n  email: 'john@example.com',\n  createdAt: new Date(),\n  isActive: true\n};\n```\n\n**Namespace Merging:**\n```typescript\n// Namespace declarations can be merged\nnamespace Utilities {\n  export function formatDate(date: Date): string {\n    return date.toISOString().split('T')[0];\n  }\n}\n\nnamespace Utilities {\n  export function formatCurrency(amount: number, currency = 'USD'): string {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency\n    }).format(amount);\n  }\n}\n\nnamespace Utilities {\n  export interface FormatOptions {\n    locale?: string;\n    timezone?: string;\n  }\n  \n  export function formatDateTime(date: Date, options?: FormatOptions): string {\n    return new Intl.DateTimeFormat(options?.locale || 'en-US', {\n      timeZone: options?.timezone\n    }).format(date);\n  }\n}\n\n// All declarations are merged\nconst formattedDate = Utilities.formatDate(new Date());\nconst formattedPrice = Utilities.formatCurrency(99.99);\nconst formattedDateTime = Utilities.formatDateTime(new Date(), { locale: 'fr-FR' });\n```\n\n**Function Overload Merging:**\n```typescript\n// Function overloads can be merged across declarations\nfunction parseValue(value: string): string;\nfunction parseValue(value: number): number;\nfunction parseValue(value: string | number): string | number {\n  return typeof value === 'string' ? value.trim() : Math.round(value);\n}\n\n// Additional overloads in another declaration\nfunction parseValue(value: boolean): boolean;\nfunction parseValue(value: Date): string;\nfunction parseValue(value: any): any {\n  if (typeof value === 'boolean') return value;\n  if (value instanceof Date) return value.toISOString();\n  return typeof value === 'string' ? value.trim() : Math.round(value);\n}\n\n// All overloads are now available\nconst str = parseValue('  hello  '); // string\nconst num = parseValue(3.14); // number\nconst bool = parseValue(true); // boolean\nconst date = parseValue(new Date()); // string\n```\n\n**Practical Plugin System:**\n```typescript\n// Base plugin interface\ninterface PluginRegistry {\n  // Initially empty\n}\n\n// Core plugin system\nclass PluginManager {\n  private plugins: PluginRegistry = {} as PluginRegistry;\n  \n  register<K extends keyof PluginRegistry>(name: K, plugin: PluginRegistry[K]) {\n    this.plugins[name] = plugin;\n  }\n  \n  get<K extends keyof PluginRegistry>(name: K): PluginRegistry[K] {\n    return this.plugins[name];\n  }\n}\n\n// Plugins extend the registry through module augmentation\ndeclare global {\n  interface PluginRegistry {\n    logger: {\n      log(message: string): void;\n      error(message: string): void;\n    };\n  }\n}\n\ndeclare global {\n  interface PluginRegistry {\n    cache: {\n      get(key: string): any;\n      set(key: string, value: any): void;\n      clear(): void;\n    };\n  }\n}\n\ndeclare global {\n  interface PluginRegistry {\n    validator: {\n      isEmail(value: string): boolean;\n      isUrl(value: string): boolean;\n    };\n  }\n}\n\n// Type-safe plugin usage\nconst pluginManager = new PluginManager();\n\npluginManager.register('logger', {\n  log: (msg) => console.log(msg),\n  error: (msg) => console.error(msg)\n});\n\nconst logger = pluginManager.get('logger'); // Fully typed\nlogger.log('Hello, world!'); // Type-safe method call\n```\n\n**Benefits:**\n- Extend existing libraries safely\n- Add custom functionality to global objects\n- Create type-safe plugin systems\n- Gradual API enhancement\n- Better integration with third-party code\n- Maintain type safety while extending functionality",
      "keywords": ["module augmentation", "declaration merging", "interface merging", "namespace merging", "global augmentation", "third-party libraries", "plugin systems", "type extension", "library augmentation", "API enhancement"],
      "difficulty": "medium"
    },
    {
      "id": 1028,
      "tag": "typescript",
      "question": "Explain advanced mapped types with template literals and provide complex transformation examples.",
      "answer": "Advanced mapped types combine template literal types with mapping operations to create sophisticated type transformations and manipulations.\n\n**Template Literal Key Mapping:**\n```typescript\n// Transform keys with prefixes/suffixes\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype Setters<T> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;\n};\n\ninterface User {\n  name: string;\n  age: number;\n  email: string;\n}\n\ntype UserGetters = Getters<User>;\n// {\n//   getName: () => string;\n//   getAge: () => number;\n//   getEmail: () => string;\n// }\n\ntype UserSetters = Setters<User>;\n// {\n//   setName: (value: string) => void;\n//   setAge: (value: number) => void;\n//   setEmail: (value: string) => void;\n// }\n\n// Combine getters and setters\ntype AccessorPattern<T> = Getters<T> & Setters<T>;\ntype UserAccessors = AccessorPattern<User>;\n```\n\n**Event Handler Pattern Generation:**\n```typescript\n// Generate event handler types from event names\ntype EventHandlers<T extends Record<string, any>> = {\n  [K in keyof T as `on${Capitalize<string & K>}`]: (event: T[K]) => void;\n} & {\n  [K in keyof T as `${string & K}Listener`]: (event: T[K]) => void;\n};\n\ninterface DOMEvents {\n  click: MouseEvent;\n  keydown: KeyboardEvent;\n  load: Event;\n  error: ErrorEvent;\n}\n\ntype DOMEventHandlers = EventHandlers<DOMEvents>;\n// {\n//   onClick: (event: MouseEvent) => void;\n//   onKeydown: (event: KeyboardEvent) => void;\n//   onLoad: (event: Event) => void;\n//   onError: (event: ErrorEvent) => void;\n//   clickListener: (event: MouseEvent) => void;\n//   keydownListener: (event: KeyboardEvent) => void;\n//   loadListener: (event: Event) => void;\n//   errorListener: (event: ErrorEvent) => void;\n// }\n```\n\n**API Endpoint Type Generation:**\n```typescript\n// Generate API client methods from endpoint definitions\ntype HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\ntype EndpointConfig = {\n  [endpoint: string]: {\n    method: HTTPMethod;\n    request?: any;\n    response: any;\n  };\n};\n\ntype APIClient<T extends EndpointConfig> = {\n  [K in keyof T as T[K]['method'] extends 'GET'\n    ? `get${Capitalize<string & K>}`\n    : T[K]['method'] extends 'POST'\n    ? `create${Capitalize<string & K>}`\n    : T[K]['method'] extends 'PUT'\n    ? `update${Capitalize<string & K>}`\n    : T[K]['method'] extends 'DELETE'\n    ? `delete${Capitalize<string & K>}`\n    : `${Lowercase<T[K]['method']>}${Capitalize<string & K>}`\n  ]: T[K]['request'] extends undefined\n    ? () => Promise<T[K]['response']>\n    : (data: T[K]['request']) => Promise<T[K]['response']>;\n};\n\ninterface APIEndpoints extends EndpointConfig {\n  users: {\n    method: 'GET';\n    response: User[];\n  };\n  user: {\n    method: 'POST';\n    request: CreateUserRequest;\n    response: User;\n  };\n  profile: {\n    method: 'PUT';\n    request: UpdateProfileRequest;\n    response: Profile;\n  };\n}\n\ntype GeneratedAPIClient = APIClient<APIEndpoints>;\n// {\n//   getUsers: () => Promise<User[]>;\n//   createUser: (data: CreateUserRequest) => Promise<User>;\n//   updateProfile: (data: UpdateProfileRequest) => Promise<Profile>;\n// }\n```\n\n**Database Query Builder Types:**\n```typescript\n// Generate query builder methods from schema\ntype QueryMethods<T> = {\n  [K in keyof T as `findBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<T | null>;\n} & {\n  [K in keyof T as `findAllBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<T[]>;\n} & {\n  [K in keyof T as `deleteBy${Capitalize<string & K>}`]: (\n    value: T[K]\n  ) => Promise<boolean>;\n};\n\ninterface UserSchema {\n  id: number;\n  email: string;\n  username: string;\n  status: 'active' | 'inactive';\n}\n\ntype UserQueryMethods = QueryMethods<UserSchema>;\n// {\n//   findById: (value: number) => Promise<UserSchema | null>;\n//   findAllById: (value: number) => Promise<UserSchema[]>;\n//   deleteById: (value: number) => Promise<boolean>;\n//   findByEmail: (value: string) => Promise<UserSchema | null>;\n//   findAllByEmail: (value: string) => Promise<UserSchema[]>;\n//   deleteByEmail: (value: string) => Promise<boolean>;\n//   // ... and so on\n// }\n```\n\n**Form Validation Type Generation:**\n```typescript\n// Generate validation rules and error types\ntype ValidationRules<T> = {\n  [K in keyof T]?: {\n    required?: boolean;\n    minLength?: number;\n    maxLength?: number;\n    pattern?: RegExp;\n    custom?: (value: T[K]) => boolean;\n  };\n};\n\ntype ValidationErrors<T> = {\n  [K in keyof T as `${string & K}Error`]?: string;\n} & {\n  [K in keyof T as `is${Capitalize<string & K>}Valid`]: boolean;\n};\n\ntype FormState<T> = T & ValidationErrors<T> & {\n  isValid: boolean;\n  isDirty: boolean;\n  errors: Partial<Record<keyof T, string>>;\n};\n\ninterface RegisterForm {\n  username: string;\n  email: string;\n  password: string;\n  confirmPassword: string;\n}\n\ntype RegisterFormState = FormState<RegisterForm>;\n// {\n//   username: string;\n//   email: string;\n//   password: string;\n//   confirmPassword: string;\n//   usernameError?: string;\n//   emailError?: string;\n//   passwordError?: string;\n//   confirmPasswordError?: string;\n//   isUsernameValid: boolean;\n//   isEmailValid: boolean;\n//   isPasswordValid: boolean;\n//   isConfirmPasswordValid: boolean;\n//   isValid: boolean;\n//   isDirty: boolean;\n//   errors: Partial<Record<keyof RegisterForm, string>>;\n// }\n```\n\n**CSS-in-JS Type Generation:**\n```typescript\n// Generate CSS property types with vendor prefixes\ntype CSSProperties = {\n  color?: string;\n  backgroundColor?: string;\n  fontSize?: string;\n  margin?: string;\n  padding?: string;\n};\n\ntype VendorPrefixes = 'webkit' | 'moz' | 'ms' | 'o';\n\ntype VendorPrefixedCSS<T> = T & {\n  [K in keyof T as `-${VendorPrefixes}-${string & K}`]?: T[K];\n};\n\ntype PrefixedCSS = VendorPrefixedCSS<CSSProperties>;\n// Includes properties like:\n// -webkit-color, -moz-color, -ms-color, -o-color, etc.\n\n// Responsive design type generation\ntype Breakpoints = 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n\ntype ResponsiveCSS<T> = T & {\n  [K in keyof T as `${string & K}@${Breakpoints}`]?: T[K];\n};\n\ntype ResponsiveProperties = ResponsiveCSS<{\n  fontSize: string;\n  margin: string;\n  display: string;\n}>;\n// {\n//   fontSize?: string;\n//   margin?: string;\n//   display?: string;\n//   'fontSize@xs'?: string;\n//   'fontSize@sm'?: string;\n//   // ... and so on\n// }\n```\n\n**State Management Pattern:**\n```typescript\n// Generate Redux-style action creators and reducers\ntype ActionCreators<T extends Record<string, any>> = {\n  [K in keyof T as `set${Capitalize<string & K>}`]: (\n    payload: T[K]\n  ) => { type: `SET_${Uppercase<string & K>}`; payload: T[K] };\n} & {\n  [K in keyof T as `reset${Capitalize<string & K>}`]: () => {\n    type: `RESET_${Uppercase<string & K>}`;\n  };\n};\n\ntype ActionTypes<T> = {\n  [K in keyof T as `SET_${Uppercase<string & K>}`]: T[K];\n} & {\n  [K in keyof T as `RESET_${Uppercase<string & K>}`]: undefined;\n};\n\ninterface AppState {\n  user: User | null;\n  theme: 'light' | 'dark';\n  loading: boolean;\n}\n\ntype AppActionCreators = ActionCreators<AppState>;\n// {\n//   setUser: (payload: User | null) => { type: 'SET_USER'; payload: User | null };\n//   resetUser: () => { type: 'RESET_USER' };\n//   setTheme: (payload: 'light' | 'dark') => { type: 'SET_THEME'; payload: 'light' | 'dark' };\n//   resetTheme: () => { type: 'RESET_THEME' };\n//   setLoading: (payload: boolean) => { type: 'SET_LOADING'; payload: boolean };\n//   resetLoading: () => { type: 'RESET_LOADING' };\n// }\n\ntype AppActionTypes = ActionTypes<AppState>;\n// Union of all possible action types with their payloads\n```\n\n**Advanced Path Navigation:**\n```typescript\n// Deep path manipulation with template literals\ntype PathsToStringProps<T> = T extends string\n  ? []\n  : {\n      [K in Extract<keyof T, string>]: [K, ...PathsToStringProps<T[K]>];\n    }[Extract<keyof T, string>];\n\ntype Join<T extends string[], D extends string> = T extends []\n  ? never\n  : T extends [infer F]\n  ? F\n  : T extends [infer F, ...infer R]\n  ? F extends string\n    ? `${F}${D}${Join<Extract<R, string[]>, D>}`\n    : never\n  : string;\n\ntype PathsToString<T> = Join<PathsToStringProps<T>, '.'>;\n\ninterface NestedConfig {\n  database: {\n    host: string;\n    port: number;\n    credentials: {\n      username: string;\n      password: string;\n    };\n  };\n  api: {\n    baseUrl: string;\n    timeout: number;\n  };\n}\n\ntype ConfigPaths = PathsToString<NestedConfig>;\n// 'database.host' | 'database.credentials.username' | 'database.credentials.password' | 'api.baseUrl'\n```\n\n**Benefits:**\n- Automatic API generation from schemas\n- Type-safe code generation\n- Reduced boilerplate code\n- Consistent naming conventions\n- Compile-time validation\n- Enhanced developer experience\n- Better refactoring support",
      "keywords": ["advanced mapped types", "template literals", "key mapping", "type transformation", "code generation", "API generation", "pattern generation", "type manipulation", "compile-time generation", "developer experience"],
      "difficulty": "hard"
    },
    {
      "id": 1029,
      "tag": "typescript",
      "question": "How do you work with the TypeScript Compiler API and AST manipulation? Provide examples.",
      "answer": "The TypeScript Compiler API provides programmatic access to the TypeScript compiler, enabling AST (Abstract Syntax Tree) analysis, transformation, and code generation.\n\n**Setting Up the Compiler API:**\n```typescript\nimport * as ts from 'typescript';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\n// Create a program from source files\nfunction createProgram(filePaths: string[]): ts.Program {\n  const compilerOptions: ts.CompilerOptions = {\n    target: ts.ScriptTarget.ES2020,\n    module: ts.ModuleKind.CommonJS,\n    strict: true,\n    esModuleInterop: true\n  };\n  \n  return ts.createProgram(filePaths, compilerOptions);\n}\n\n// Parse a single source file\nfunction parseSourceFile(filePath: string): ts.SourceFile {\n  const sourceText = fs.readFileSync(filePath, 'utf8');\n  return ts.createSourceFile(\n    filePath,\n    sourceText,\n    ts.ScriptTarget.ES2020,\n    true\n  );\n}\n```\n\n**AST Traversal and Analysis:**\n```typescript\n// Visitor pattern for AST traversal\nfunction visitNode(node: ts.Node, sourceFile: ts.SourceFile): void {\n  switch (node.kind) {\n    case ts.SyntaxKind.FunctionDeclaration:\n      analyzeFunctionDeclaration(node as ts.FunctionDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.ClassDeclaration:\n      analyzeClassDeclaration(node as ts.ClassDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.InterfaceDeclaration:\n      analyzeInterfaceDeclaration(node as ts.InterfaceDeclaration, sourceFile);\n      break;\n    case ts.SyntaxKind.VariableStatement:\n      analyzeVariableStatement(node as ts.VariableStatement, sourceFile);\n      break;\n  }\n  \n  // Recursively visit child nodes\n  ts.forEachChild(node, (child) => visitNode(child, sourceFile));\n}\n\n// Function analysis\nfunction analyzeFunctionDeclaration(\n  node: ts.FunctionDeclaration,\n  sourceFile: ts.SourceFile\n): void {\n  const name = node.name?.text || 'anonymous';\n  const parameters = node.parameters.map(param => ({\n    name: param.name.getText(sourceFile),\n    type: param.type?.getText(sourceFile) || 'any',\n    optional: !!param.questionToken\n  }));\n  \n  const returnType = node.type?.getText(sourceFile) || 'void';\n  const isAsync = !!(node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.AsyncKeyword));\n  const isExported = !!(node.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword));\n  \n  console.log({\n    type: 'function',\n    name,\n    parameters,\n    returnType,\n    isAsync,\n    isExported,\n    lineNumber: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1\n  });\n}\n\n// Class analysis\nfunction analyzeClassDeclaration(\n  node: ts.ClassDeclaration,\n  sourceFile: ts.SourceFile\n): void {\n  const name = node.name?.text || 'anonymous';\n  const members = node.members.map(member => {\n    if (ts.isMethodDeclaration(member)) {\n      return {\n        type: 'method',\n        name: member.name?.getText(sourceFile),\n        isStatic: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword)),\n        isPrivate: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.PrivateKeyword))\n      };\n    } else if (ts.isPropertyDeclaration(member)) {\n      return {\n        type: 'property',\n        name: member.name?.getText(sourceFile),\n        propertyType: member.type?.getText(sourceFile) || 'any',\n        isReadonly: !!(member.modifiers?.some(mod => mod.kind === ts.SyntaxKind.ReadonlyKeyword))\n      };\n    }\n    return { type: 'unknown' };\n  });\n  \n  console.log({\n    type: 'class',\n    name,\n    members,\n    lineNumber: sourceFile.getLineAndCharacterOfPosition(node.getStart()).line + 1\n  });\n}\n```\n\n**Code Generation and Transformation:**\n```typescript\n// Create TypeScript AST nodes programmatically\nfunction createInterface(\n  name: string,\n  properties: Array<{ name: string; type: string; optional?: boolean }>\n): ts.InterfaceDeclaration {\n  const propertySignatures = properties.map(prop => \n    ts.factory.createPropertySignature(\n      undefined, // modifiers\n      prop.name,\n      prop.optional ? ts.factory.createToken(ts.SyntaxKind.QuestionToken) : undefined,\n      ts.factory.createTypeReferenceNode(prop.type)\n    )\n  );\n  \n  return ts.factory.createInterfaceDeclaration(\n    [ts.factory.createToken(ts.SyntaxKind.ExportKeyword)], // modifiers\n    name,\n    undefined, // type parameters\n    undefined, // heritage clauses\n    propertySignatures\n  );\n}\n\n// Generate a complete source file\nfunction generateApiTypes(endpoints: ApiEndpoint[]): string {\n  const statements: ts.Statement[] = [];\n  \n  // Generate request/response interfaces for each endpoint\n  endpoints.forEach(endpoint => {\n    if (endpoint.requestBody) {\n      const requestInterface = createInterface(\n        `${endpoint.name}Request`,\n        endpoint.requestBody.properties\n      );\n      statements.push(requestInterface);\n    }\n    \n    const responseInterface = createInterface(\n      `${endpoint.name}Response`,\n      endpoint.response.properties\n    );\n    statements.push(responseInterface);\n  });\n  \n  // Create source file\n  const sourceFile = ts.factory.createSourceFile(\n    statements,\n    ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),\n    ts.NodeFlags.None\n  );\n  \n  // Print to string\n  const printer = ts.createPrinter({\n    newLine: ts.NewLineKind.LineFeed\n  });\n  \n  return printer.printFile(sourceFile);\n}\n```\n\n**Custom Transformer:**\n```typescript\n// Transform TypeScript AST\nfunction createLoggerTransformer(): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile) => {\n      function visit(node: ts.Node): ts.Node {\n        // Add console.log to function entries\n        if (ts.isFunctionDeclaration(node) && node.name) {\n          const functionName = node.name.text;\n          const logStatement = ts.factory.createExpressionStatement(\n            ts.factory.createCallExpression(\n              ts.factory.createPropertyAccessExpression(\n                ts.factory.createIdentifier('console'),\n                'log'\n              ),\n              undefined,\n              [ts.factory.createStringLiteral(`Entering function: ${functionName}`)]\n            )\n          );\n          \n          const newBody = ts.factory.createBlock([\n            logStatement,\n            ...(node.body?.statements || [])\n          ]);\n          \n          return ts.factory.updateFunctionDeclaration(\n            node,\n            node.modifiers,\n            node.asteriskToken,\n            node.name,\n            node.typeParameters,\n            node.parameters,\n            node.type,\n            newBody\n          );\n        }\n        \n        return ts.visitEachChild(node, visit, context);\n      }\n      \n      return ts.visitNode(sourceFile, visit) as ts.SourceFile;\n    };\n  };\n}\n\n// Apply transformation\nfunction transformCode(sourceCode: string): string {\n  const sourceFile = ts.createSourceFile(\n    'temp.ts',\n    sourceCode,\n    ts.ScriptTarget.ES2020,\n    true\n  );\n  \n  const transformationResult = ts.transform(\n    sourceFile,\n    [createLoggerTransformer()]\n  );\n  \n  const printer = ts.createPrinter();\n  return printer.printFile(transformationResult.transformed[0]);\n}\n```\n\n**Type Checker Integration:**\n```typescript\n// Use the type checker for advanced analysis\nfunction analyzeWithTypeChecker(\n  program: ts.Program,\n  sourceFile: ts.SourceFile\n): void {\n  const typeChecker = program.getTypeChecker();\n  \n  function visitWithTypeInfo(node: ts.Node): void {\n    if (ts.isVariableDeclaration(node)) {\n      const symbol = typeChecker.getSymbolAtLocation(node.name);\n      const type = typeChecker.getTypeOfSymbolAtLocation(symbol!, node);\n      const typeString = typeChecker.typeToString(type);\n      \n      console.log({\n        variableName: node.name.getText(),\n        inferredType: typeString,\n        hasInitializer: !!node.initializer\n      });\n    }\n    \n    if (ts.isCallExpression(node)) {\n      const signature = typeChecker.getResolvedSignature(node);\n      if (signature) {\n        const returnType = typeChecker.getReturnTypeOfSignature(signature);\n        console.log({\n          callExpression: node.expression.getText(),\n          returnType: typeChecker.typeToString(returnType)\n        });\n      }\n    }\n    \n    ts.forEachChild(node, visitWithTypeInfo);\n  }\n  \n  visitWithTypeInfo(sourceFile);\n}\n```\n\n**Practical Applications:**\n```typescript\n// Code metrics analyzer\nfunction analyzeCodeMetrics(sourceFile: ts.SourceFile): CodeMetrics {\n  let functionCount = 0;\n  let classCount = 0;\n  let interfaceCount = 0;\n  let totalLines = 0;\n  let complexityScore = 0;\n  \n  function calculateComplexity(node: ts.Node): number {\n    let complexity = 1; // Base complexity\n    \n    ts.forEachChild(node, (child) => {\n      if (ts.isIfStatement(child) || \n          ts.isForStatement(child) || \n          ts.isWhileStatement(child) ||\n          ts.isSwitchStatement(child) ||\n          ts.isConditionalExpression(child)) {\n        complexity += 1;\n      }\n      complexity += calculateComplexity(child);\n    });\n    \n    return complexity;\n  }\n  \n  function visit(node: ts.Node): void {\n    switch (node.kind) {\n      case ts.SyntaxKind.FunctionDeclaration:\n        functionCount++;\n        complexityScore += calculateComplexity(node);\n        break;\n      case ts.SyntaxKind.ClassDeclaration:\n        classCount++;\n        break;\n      case ts.SyntaxKind.InterfaceDeclaration:\n        interfaceCount++;\n        break;\n    }\n    \n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n  totalLines = sourceFile.getLineAndCharacterOfPosition(sourceFile.end).line + 1;\n  \n  return {\n    functionCount,\n    classCount,\n    interfaceCount,\n    totalLines,\n    complexityScore,\n    averageComplexity: complexityScore / Math.max(functionCount, 1)\n  };\n}\n\n// Documentation generator\nfunction generateDocumentation(sourceFile: ts.SourceFile): Documentation {\n  const docs: Documentation = {\n    fileName: sourceFile.fileName,\n    functions: [],\n    classes: [],\n    interfaces: []\n  };\n  \n  function extractJSDocComment(node: ts.Node): string | undefined {\n    const jsDoc = (node as any).jsDoc;\n    if (jsDoc && jsDoc.length > 0) {\n      return jsDoc[0].comment;\n    }\n    return undefined;\n  }\n  \n  function visit(node: ts.Node): void {\n    if (ts.isFunctionDeclaration(node) && node.name) {\n      docs.functions.push({\n        name: node.name.text,\n        parameters: node.parameters.map(p => p.name.getText()),\n        returnType: node.type?.getText() || 'void',\n        documentation: extractJSDocComment(node)\n      });\n    }\n    \n    // Similar processing for classes and interfaces...\n    \n    ts.forEachChild(node, visit);\n  }\n  \n  visit(sourceFile);\n  return docs;\n}\n```\n\n**Build Tool Integration:**\n```typescript\n// Custom TypeScript plugin\nfunction createCustomPlugin(program: ts.Program): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    return (sourceFile: ts.SourceFile): ts.SourceFile => {\n      // Custom transformations based on compiler options or external config\n      const customConfig = getCustomConfig();\n      \n      if (customConfig.addRuntimeChecks) {\n        return addRuntimeTypeChecks(sourceFile, context);\n      }\n      \n      if (customConfig.optimizeBundle) {\n        return optimizeForBundle(sourceFile, context);\n      }\n      \n      return sourceFile;\n    };\n  };\n}\n```\n\n**Benefits:**\n- Programmatic code analysis\n- Custom code transformations\n- Build-time optimizations\n- Code generation from schemas\n- Static analysis tools\n- Custom linting rules\n- Documentation generation\n- Advanced refactoring tools",
      "keywords": ["TypeScript Compiler API", "AST manipulation", "Abstract Syntax Tree", "code generation", "type checker", "transformers", "static analysis", "build tools", "code metrics", "documentation generation"],
      "difficulty": "hard"
    }
  ]
}