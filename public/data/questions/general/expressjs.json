{
  "technology": "expressjs",
  "questions": [
    {
      "id": 8000,
      "tag": "expressjs",
      "question": "What is Express.js and what are its main benefits over using raw Node.js for web development?",
      "answer": "Express.js is a minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications. It's built on top of Node.js and acts as a layer of abstraction that simplifies the process of building web servers and APIs.\n\nKey benefits of Express.js over raw Node.js include:\n\n**Simplified Routing**: Express provides an intuitive routing system that makes it easy to handle different HTTP methods and URL patterns:\n```javascript\napp.get('/users/:id', (req, res) => {\n  res.json({ userId: req.params.id });\n});\n```\n\n**Middleware Support**: Built-in middleware system for handling cross-cutting concerns like authentication, logging, and parsing:\n```javascript\napp.use(express.json());\napp.use(express.static('public'));\n```\n\n**Template Engine Integration**: Easy integration with template engines like EJS, Pug, and Handlebars for server-side rendering.\n\n**Request/Response Enhancements**: Extended request and response objects with helpful methods and properties that simplify common tasks like sending JSON responses or parsing request data.\n\n**Community and Ecosystem**: Large ecosystem of middleware and plugins, extensive documentation, and strong community support.\n\nWhile raw Node.js gives you complete control, Express.js significantly reduces boilerplate code and development time while maintaining flexibility.",
      "keywords": ["express.js", "node.js", "web framework", "middleware", "routing", "server"],
      "difficulty": "easy"
    },
    {
      "id": 8001,
      "tag": "expressjs",
      "question": "How do you create a basic Express.js server with routing? Provide a complete example.",
      "answer": "Creating a basic Express.js server involves installing Express, creating an application instance, defining routes, and starting the server. Here's a complete example:\n\n**Installation**:\n```bash\nnpm init -y\nnpm install express\n```\n\n**Basic Server Setup** (app.js):\n```javascript\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Basic routes\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\napp.get('/about', (req, res) => {\n  res.json({ message: 'About page', version: '1.0.0' });\n});\n\napp.post('/users', (req, res) => {\n  res.status(201).json({ message: 'User created' });\n});\n\n// Handle 404\napp.use('*', (req, res) => {\n  res.status(404).json({ error: 'Route not found' });\n});\n\n// Start server\napp.listen(PORT, () => {\n  console.log(`Server running on port ${PORT}`);\n});\n```\n\n**Key Components**:\n- `express()` creates an Express application\n- Route methods (`get`, `post`, `put`, `delete`) define endpoints\n- Route handlers are callback functions that receive `req` and `res` objects\n- `app.listen()` starts the server on the specified port\n- Middleware like `app.use()` handles requests that don't match specific routes\n\n**Running the Server**:\n```bash\nnode app.js\n```\n\nThis creates a functional web server that can handle HTTP requests and responses with clean, organized routing.",
      "keywords": ["express server", "routing", "HTTP methods", "app.listen", "basic setup"],
      "difficulty": "easy"
    },
    {
      "id": 8002,
      "tag": "expressjs",
      "question": "Explain the concept of middleware in Express.js and provide examples of built-in middleware.",
      "answer": "Middleware in Express.js are functions that execute during the request-response cycle. They have access to the request object (`req`), response object (`res`), and the next middleware function in the application's request-response cycle, commonly denoted by `next`.\n\n**Middleware Function Structure**:\n```javascript\nfunction middlewareFunction(req, res, next) {\n  // Perform some operation\n  console.log('Middleware executed');\n  next(); // Pass control to next middleware\n}\n```\n\n**Types of Middleware**:\n1. **Application-level**: `app.use()` or `app.METHOD()`\n2. **Router-level**: Similar to application-level but bound to express.Router()\n3. **Error-handling**: Functions with four parameters (err, req, res, next)\n4. **Built-in**: Provided by Express\n5. **Third-party**: Installed via npm\n\n**Common Built-in Middleware Examples**:\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Parse JSON bodies\napp.use(express.json());\n\n// Parse URL-encoded bodies\napp.use(express.urlencoded({ extended: true }));\n\n// Serve static files\napp.use(express.static('public'));\n\n// Custom middleware\napp.use((req, res, next) => {\n  console.log(`${req.method} ${req.url} - ${new Date().toISOString()}`);\n  next();\n});\n\napp.get('/api/data', (req, res) => {\n  res.json({ message: 'Data received' });\n});\n```\n\n**Middleware Execution Order**: Middleware functions execute sequentially in the order they're defined. Always call `next()` unless you're ending the request-response cycle.",
      "keywords": ["middleware", "express.json", "express.static", "express.urlencoded", "next function", "request-response cycle"],
      "difficulty": "easy"
    },
    {
      "id": 8003,
      "tag": "expressjs",
      "question": "How do you handle route parameters and query strings in Express.js? Provide examples.",
      "answer": "Express.js provides built-in support for handling route parameters and query strings through the request object. Here's how to work with both:\n\n**Route Parameters**:\nRoute parameters are named URL segments that capture values at their position in the URL.\n\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Single parameter\napp.get('/users/:id', (req, res) => {\n  const userId = req.params.id;\n  res.json({ userId, message: `User ${userId} requested` });\n});\n\n// Multiple parameters\napp.get('/users/:userId/posts/:postId', (req, res) => {\n  const { userId, postId } = req.params;\n  res.json({ userId, postId });\n});\n\n// Optional parameters with ?\napp.get('/products/:id?', (req, res) => {\n  const productId = req.params.id || 'all';\n  res.json({ productId });\n});\n```\n\n**Query Strings**:\nQuery strings are key-value pairs that appear after the `?` in a URL.\n\n```javascript\n// URL: /search?term=nodejs&category=tutorial&limit=10\napp.get('/search', (req, res) => {\n  const { term, category, limit = 5 } = req.query;\n  \n  res.json({\n    searchTerm: term,\n    category: category,\n    limit: parseInt(limit),\n    allQuery: req.query\n  });\n});\n\n// Handle arrays in query strings\n// URL: /filter?tags=nodejs&tags=express&tags=api\napp.get('/filter', (req, res) => {\n  const tags = Array.isArray(req.query.tags) \n    ? req.query.tags \n    : [req.query.tags];\n  \n  res.json({ tags });\n});\n```\n\n**Parameter Validation**:\n```javascript\napp.get('/users/:id', (req, res) => {\n  const id = parseInt(req.params.id);\n  \n  if (isNaN(id)) {\n    return res.status(400).json({ error: 'Invalid user ID' });\n  }\n  \n  res.json({ userId: id });\n});\n```",
      "keywords": ["route parameters", "query strings", "req.params", "req.query", "URL parsing", "parameter validation"],
      "difficulty": "easy"
    },
    {
      "id": 8004,
      "tag": "expressjs",
      "question": "How do you serve static files in Express.js using express.static middleware?",
      "answer": "Express.js provides the `express.static` built-in middleware function to serve static files such as images, CSS files, JavaScript files, and other assets. This middleware is essential for serving client-side resources in web applications.\n\n**Basic Static File Serving**:\n```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\n// Serve static files from 'public' directory\napp.use(express.static('public'));\n\n// Using absolute path (recommended)\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.listen(3000);\n```\n\nWith this setup, files in the `public` directory are accessible:\n- `public/style.css` → `http://localhost:3000/style.css`\n- `public/images/logo.png` → `http://localhost:3000/images/logo.png`\n- `public/js/app.js` → `http://localhost:3000/js/app.js`\n\n**Virtual Path Prefix**:\nYou can create a virtual path prefix for static files:\n\n```javascript\n// Mount static middleware at /static path\napp.use('/static', express.static('public'));\n\n// Now files are accessed with /static prefix:\n// public/style.css → http://localhost:3000/static/style.css\n```\n\n**Multiple Static Directories**:\n```javascript\n// Serve from multiple directories\napp.use(express.static('public'));\napp.use(express.static('uploads'));\napp.use('/vendor', express.static('node_modules'));\n```\n\n**Static Options**:\n```javascript\nconst options = {\n  dotfiles: 'ignore',\n  etag: false,\n  extensions: ['htm', 'html'],\n  index: 'index.html',\n  maxAge: '1d',\n  redirect: false,\n  setHeaders: function (res, path, stat) {\n    res.set('x-timestamp', Date.now());\n  }\n};\n\napp.use(express.static('public', options));\n```\n\nThis middleware automatically handles file serving, MIME types, caching headers, and error responses.",
      "keywords": ["static files", "express.static", "public directory", "middleware", "file serving", "virtual path"],
      "difficulty": "easy"
    },
    {
      "id": 8005,
      "tag": "expressjs",
      "question": "Explain the request and response objects in Express.js and their key properties and methods.",
      "answer": "Express.js extends Node.js's native request and response objects with additional properties and methods to make web development easier and more intuitive.\n\n**Request Object (req)**:\nThe request object represents the HTTP request and contains properties for the request query string, parameters, body, HTTP headers, and more.\n\n**Key Request Properties**:\n```javascript\napp.get('/example', (req, res) => {\n  console.log(req.method);      // HTTP method (GET, POST, etc.)\n  console.log(req.url);         // '/example?name=john'\n  console.log(req.path);        // '/example'\n  console.log(req.query);       // { name: 'john' }\n  console.log(req.params);      // Route parameters\n  console.log(req.headers);     // Request headers\n  console.log(req.body);        // Request body (requires middleware)\n  console.log(req.ip);          // Client IP address\n  console.log(req.hostname);    // Host name\n});\n```\n\n**Useful Request Methods**:\n```javascript\nreq.get('Content-Type');       // Get specific header\nreq.is('json');                // Check content type\nreq.accepts('html');           // Check accepted content types\n```\n\n**Response Object (res)**:\nThe response object represents the HTTP response that Express sends when it receives an HTTP request.\n\n**Key Response Methods**:\n```javascript\napp.get('/api/users', (req, res) => {\n  // Send JSON response\n  res.json({ users: [] });\n  \n  // Send plain text\n  res.send('Hello World');\n  \n  // Set status code\n  res.status(404).json({ error: 'Not found' });\n  \n  // Set headers\n  res.set('Content-Type', 'text/plain');\n  \n  // Redirect\n  res.redirect('/login');\n  \n  // Send file\n  res.sendFile(path.join(__dirname, 'index.html'));\n  \n  // Set cookie\n  res.cookie('session', '123456');\n});\n```\n\n**Response Chaining**:\n```javascript\nres.status(200)\n   .set('Content-Type', 'application/json')\n   .json({ message: 'Success' });\n```\n\nThese objects provide a clean, intuitive API for handling HTTP requests and responses in web applications.",
      "keywords": ["request object", "response object", "req.params", "req.query", "res.json", "res.status", "HTTP methods"],
      "difficulty": "easy"
    },
    {
      "id": 8006,
      "tag": "expressjs",
      "question": "How do you create custom middleware in Express.js and implement error handling middleware?",
      "answer": "Custom middleware in Express.js allows you to create reusable functions that execute during the request-response cycle. Error handling middleware provides a centralized way to handle errors across your application.\n\n**Creating Custom Middleware**:\n\n**1. Basic Custom Middleware**:\n```javascript\nconst express = require('express');\nconst app = express();\n\n// Custom logging middleware\nconst logger = (req, res, next) => {\n  const timestamp = new Date().toISOString();\n  console.log(`[${timestamp}] ${req.method} ${req.url}`);\n  next(); // Pass control to next middleware\n};\n\n// Custom authentication middleware\nconst authenticate = (req, res, next) => {\n  const token = req.headers.authorization;\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  // Validate token (simplified)\n  if (token !== 'Bearer valid-token') {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n  \n  req.user = { id: 1, name: 'John Doe' };\n  next();\n};\n\n// Apply middleware\napp.use(logger);\napp.use('/protected', authenticate);\n```\n\n**2. Parameterized Middleware**:\n```javascript\n// Middleware factory function\nconst rateLimiter = (maxRequests) => {\n  const requests = new Map();\n  \n  return (req, res, next) => {\n    const ip = req.ip;\n    const now = Date.now();\n    const windowMs = 60000; // 1 minute\n    \n    if (!requests.has(ip)) {\n      requests.set(ip, []);\n    }\n    \n    const userRequests = requests.get(ip)\n      .filter(time => now - time < windowMs);\n    \n    if (userRequests.length >= maxRequests) {\n      return res.status(429).json({ error: 'Too many requests' });\n    }\n    \n    userRequests.push(now);\n    requests.set(ip, userRequests);\n    next();\n  };\n};\n\napp.use(rateLimiter(100)); // 100 requests per minute\n```\n\n**Error Handling Middleware**:\nError handling middleware functions have four parameters: `(err, req, res, next)`\n\n```javascript\n// Global error handler (must be last middleware)\nconst errorHandler = (err, req, res, next) => {\n  console.error(err.stack);\n  \n  // Handle different error types\n  if (err.name === 'ValidationError') {\n    return res.status(400).json({\n      error: 'Validation Error',\n      details: err.message\n    });\n  }\n  \n  if (err.name === 'CastError') {\n    return res.status(400).json({\n      error: 'Invalid ID format'\n    });\n  }\n  \n  // Default error response\n  res.status(err.status || 500).json({\n    error: process.env.NODE_ENV === 'production' \n      ? 'Something went wrong' \n      : err.message\n  });\n};\n\n// Routes that might throw errors\napp.get('/users/:id', async (req, res, next) => {\n  try {\n    const user = await getUserById(req.params.id);\n    if (!user) {\n      const error = new Error('User not found');\n      error.status = 404;\n      throw error;\n    }\n    res.json(user);\n  } catch (error) {\n    next(error); // Pass error to error handler\n  }\n});\n\n// Apply error handler (must be last)\napp.use(errorHandler);\n```\n\n**Async Error Handling**:\n```javascript\n// Utility wrapper for async routes\nconst asyncHandler = (fn) => (req, res, next) => {\n  Promise.resolve(fn(req, res, next)).catch(next);\n};\n\napp.get('/async-route', asyncHandler(async (req, res) => {\n  const data = await someAsyncOperation();\n  res.json(data);\n}));\n```",
      "keywords": ["custom middleware", "error handling", "middleware factory", "async errors", "error middleware", "next function"],
      "difficulty": "medium"
    },
    {
      "id": 8007,
      "tag": "expressjs",
      "question": "How do you integrate template engines like EJS or Pug with Express.js for server-side rendering?",
      "answer": "Template engines in Express.js enable server-side rendering by allowing you to generate dynamic HTML pages with embedded data. Express.js supports multiple template engines including EJS, Pug, Handlebars, and others.\n\n**Setting Up EJS**:\n\n**Installation and Configuration**:\n```bash\nnpm install ejs\n```\n\n```javascript\nconst express = require('express');\nconst path = require('path');\nconst app = express();\n\n// Set EJS as template engine\napp.set('view engine', 'ejs');\napp.set('views', path.join(__dirname, 'views'));\n\n// Route with data\napp.get('/', (req, res) => {\n  const data = {\n    title: 'Home Page',\n    users: [\n      { name: 'John', age: 30 },\n      { name: 'Jane', age: 25 }\n    ],\n    isLoggedIn: true\n  };\n  \n  res.render('index', data);\n});\n```\n\n**EJS Template** (views/index.ejs):\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title><%= title %></title>\n</head>\n<body>\n    <h1>Welcome to <%= title %></h1>\n    \n    <% if (isLoggedIn) { %>\n        <h2>Users List:</h2>\n        <ul>\n        <% users.forEach(user => { %>\n            <li><%= user.name %> - Age: <%= user.age %></li>\n        <% }) %>\n        </ul>\n    <% } else { %>\n        <p>Please log in to view users.</p>\n    <% } %>\n</body>\n</html>\n```\n\n**Setting Up Pug**:\n\n**Installation and Configuration**:\n```bash\nnpm install pug\n```\n\n```javascript\n// Set Pug as template engine\napp.set('view engine', 'pug');\napp.set('views', path.join(__dirname, 'views'));\n\napp.get('/pug-example', (req, res) => {\n  res.render('pugTemplate', {\n    title: 'Pug Example',\n    message: 'Hello from Pug!',\n    items: ['Item 1', 'Item 2', 'Item 3']\n  });\n});\n```\n\n**Pug Template** (views/pugTemplate.pug):\n```pug\ndoctype html\nhtml\n  head\n    title= title\n  body\n    h1= message\n    \n    if items.length > 0\n      ul\n        each item in items\n          li= item\n    else\n      p No items found\n```\n\n**Advanced Template Features**:\n\n**1. Layouts and Partials (EJS)**:\n```javascript\n// Using partials\napp.get('/profile', (req, res) => {\n  res.render('profile', {\n    user: { name: 'John', email: 'john@example.com' },\n    layout: 'layout' // Specify layout\n  });\n});\n```\n\n**2. Template Helpers**:\n```javascript\n// Add helper functions\napp.locals.formatDate = (date) => {\n  return date.toLocaleDateString();\n};\n\napp.locals.capitalize = (str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n```\n\n**3. Conditional Rendering and Error Handling**:\n```javascript\napp.get('/user/:id', async (req, res) => {\n  try {\n    const user = await getUserById(req.params.id);\n    \n    if (!user) {\n      return res.status(404).render('error', {\n        title: 'User Not Found',\n        message: 'The requested user does not exist'\n      });\n    }\n    \n    res.render('user-profile', { user, title: `${user.name}'s Profile` });\n  } catch (error) {\n    res.status(500).render('error', {\n      title: 'Server Error',\n      message: 'Something went wrong'\n    });\n  }\n});\n```\n\nTemplate engines provide powerful server-side rendering capabilities, enabling dynamic content generation with clean separation between logic and presentation.",
      "keywords": ["template engines", "EJS", "Pug", "server-side rendering", "views", "res.render", "dynamic HTML"],
      "difficulty": "medium"
    },
    {
      "id": 8008,
      "tag": "expressjs",
      "question": "How do you implement authentication and session management in Express.js applications?",
      "answer": "Authentication and session management in Express.js can be implemented using various approaches including sessions, JWT tokens, and OAuth. Here are the most common patterns:\n\n**1. Session-Based Authentication**:\n\n**Setup with express-session**:\n```bash\nnpm install express-session connect-mongo bcryptjs\n```\n\n```javascript\nconst express = require('express');\nconst session = require('express-session');\nconst MongoStore = require('connect-mongo');\nconst bcrypt = require('bcryptjs');\nconst app = express();\n\n// Session configuration\napp.use(session({\n  secret: process.env.SESSION_SECRET || 'your-secret-key',\n  resave: false,\n  saveUninitialized: false,\n  store: MongoStore.create({\n    mongoUrl: 'mongodb://localhost/your-app'\n  }),\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',\n    httpOnly: true,\n    maxAge: 24 * 60 * 60 * 1000 // 24 hours\n  }\n}));\n\napp.use(express.json());\n\n// Authentication middleware\nconst requireAuth = (req, res, next) => {\n  if (req.session && req.session.userId) {\n    return next();\n  } else {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n};\n\n// Login route\napp.post('/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Find user (replace with actual database query)\n    const user = await User.findOne({ email });\n    \n    if (!user || !await bcrypt.compare(password, user.password)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    // Create session\n    req.session.userId = user._id;\n    req.session.user = {\n      id: user._id,\n      email: user.email,\n      name: user.name\n    };\n    \n    res.json({ message: 'Login successful', user: req.session.user });\n  } catch (error) {\n    res.status(500).json({ error: 'Login failed' });\n  }\n});\n\n// Logout route\napp.post('/logout', (req, res) => {\n  req.session.destroy((err) => {\n    if (err) {\n      return res.status(500).json({ error: 'Logout failed' });\n    }\n    res.clearCookie('connect.sid');\n    res.json({ message: 'Logout successful' });\n  });\n});\n\n// Protected route\napp.get('/profile', requireAuth, (req, res) => {\n  res.json({ user: req.session.user });\n});\n```\n\n**2. JWT-Based Authentication**:\n\n```bash\nnpm install jsonwebtoken bcryptjs\n```\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-jwt-secret';\n\n// JWT middleware\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n  \n  jwt.verify(token, JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid token' });\n    }\n    req.user = user;\n    next();\n  });\n};\n\n// JWT login\napp.post('/auth/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ email });\n    \n    if (!user || !await bcrypt.compare(password, user.password)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    const token = jwt.sign(\n      { userId: user._id, email: user.email },\n      JWT_SECRET,\n      { expiresIn: '24h' }\n    );\n    \n    res.json({\n      token,\n      user: { id: user._id, email: user.email, name: user.name }\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Authentication failed' });\n  }\n});\n\n// Protected JWT route\napp.get('/api/protected', authenticateToken, (req, res) => {\n  res.json({ message: 'Protected data', user: req.user });\n});\n```\n\n**3. Password Hashing and Registration**:\n\n```javascript\n// Registration route\napp.post('/register', async (req, res) => {\n  try {\n    const { email, password, name } = req.body;\n    \n    // Validate input\n    if (!email || !password || password.length < 6) {\n      return res.status(400).json({ error: 'Invalid input' });\n    }\n    \n    // Check if user exists\n    const existingUser = await User.findOne({ email });\n    if (existingUser) {\n      return res.status(400).json({ error: 'User already exists' });\n    }\n    \n    // Hash password\n    const saltRounds = 12;\n    const hashedPassword = await bcrypt.hash(password, saltRounds);\n    \n    // Create user\n    const user = new User({\n      email,\n      password: hashedPassword,\n      name\n    });\n    \n    await user.save();\n    \n    res.status(201).json({ message: 'User created successfully' });\n  } catch (error) {\n    res.status(500).json({ error: 'Registration failed' });\n  }\n});\n```\n\n**Key Security Considerations**:\n- Always hash passwords with bcrypt\n- Use HTTPS in production\n- Set secure cookie options\n- Implement rate limiting\n- Validate and sanitize input\n- Use environment variables for secrets\n- Implement proper logout functionality\n- Consider implementing refresh tokens for JWT",
      "keywords": ["authentication", "session management", "JWT", "bcrypt", "express-session", "login", "password hashing", "middleware"],
      "difficulty": "medium"
    },
    {
      "id": 8009,
      "tag": "expressjs",
      "question": "How do you handle CORS (Cross-Origin Resource Sharing) in Express.js and implement security middleware?",
      "answer": "CORS (Cross-Origin Resource Sharing) is essential for enabling secure cross-origin requests in Express.js applications. Combined with other security middleware, it helps protect your application from various security threats.\n\n**1. CORS Implementation**:\n\n**Basic CORS Setup**:\n```bash\nnpm install cors\n```\n\n```javascript\nconst express = require('express');\nconst cors = require('cors');\nconst app = express();\n\n// Enable CORS for all routes\napp.use(cors());\n\n// Or configure specific origins\nconst corsOptions = {\n  origin: ['http://localhost:3000', 'https://myapp.com'],\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true // Allow cookies\n};\n\napp.use(cors(corsOptions));\n```\n\n**Manual CORS Implementation**:\n```javascript\n// Custom CORS middleware\nconst customCors = (req, res, next) => {\n  const allowedOrigins = ['http://localhost:3000', 'https://myapp.com'];\n  const origin = req.headers.origin;\n  \n  if (allowedOrigins.includes(origin)) {\n    res.setHeader('Access-Control-Allow-Origin', origin);\n  }\n  \n  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  res.setHeader('Access-Control-Allow-Credentials', 'true');\n  res.setHeader('Access-Control-Max-Age', '86400'); // 24 hours\n  \n  // Handle preflight requests\n  if (req.method === 'OPTIONS') {\n    return res.status(200).end();\n  }\n  \n  next();\n};\n\napp.use(customCors);\n```\n\n**2. Security Middleware Stack**:\n\n```bash\nnpm install helmet express-rate-limit express-validator compression\n```\n\n```javascript\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst { body, validationResult } = require('express-validator');\nconst compression = require('compression');\n\n// Helmet for security headers\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\", 'fonts.googleapis.com'],\n      fontSrc: [\"'self'\", 'fonts.gstatic.com'],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:']\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: {\n    error: 'Too many requests, please try again later.',\n    retryAfter: 900 // seconds\n  },\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\napp.use('/api/', limiter);\n\n// Stricter rate limiting for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  message: { error: 'Too many login attempts, please try again later.' }\n});\n\napp.use('/auth/', authLimiter);\n\n// Compression\napp.use(compression());\n```\n\n**3. Input Validation and Sanitization**:\n\n```javascript\n// Validation middleware\nconst validateUser = [\n  body('email')\n    .isEmail()\n    .normalizeEmail()\n    .withMessage('Valid email required'),\n  body('password')\n    .isLength({ min: 8 })\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n    .withMessage('Password must contain uppercase, lowercase, number, and special character'),\n  body('name')\n    .trim()\n    .isLength({ min: 2, max: 50 })\n    .matches(/^[a-zA-Z\\s]+$/)\n    .withMessage('Name must be 2-50 characters, letters only')\n];\n\n// Handle validation errors\nconst handleValidationErrors = (req, res, next) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: errors.array()\n    });\n  }\n  next();\n};\n\napp.post('/register', validateUser, handleValidationErrors, async (req, res) => {\n  // Registration logic here\n});\n```\n\n**4. Environment-Based Configuration**:\n\n```javascript\n// Environment-based CORS and security settings\nconst isDevelopment = process.env.NODE_ENV === 'development';\nconst isProduction = process.env.NODE_ENV === 'production';\n\nconst corsOptions = {\n  origin: isDevelopment \n    ? ['http://localhost:3000', 'http://localhost:3001']\n    : process.env.ALLOWED_ORIGINS?.split(',') || ['https://myapp.com'],\n  credentials: true,\n  optionsSuccessStatus: 200\n};\n\napp.use(cors(corsOptions));\n\n// Security headers based on environment\nif (isProduction) {\n  app.use(helmet({\n    hsts: {\n      maxAge: 31536000,\n      includeSubDomains: true,\n      preload: true\n    }\n  }));\n} else {\n  app.use(helmet({ hsts: false }));\n}\n```\n\n**5. API Key and Authentication Security**:\n\n```javascript\n// API key middleware for certain endpoints\nconst requireApiKey = (req, res, next) => {\n  const apiKey = req.headers['x-api-key'];\n  \n  if (!apiKey || apiKey !== process.env.API_KEY) {\n    return res.status(401).json({ error: 'Valid API key required' });\n  }\n  \n  next();\n};\n\napp.use('/api/admin/', requireApiKey);\n```\n\nThis comprehensive security setup protects against common vulnerabilities including XSS, CSRF, clickjacking, and various injection attacks while properly handling cross-origin requests.",
      "keywords": ["CORS", "security middleware", "helmet", "rate limiting", "input validation", "cross-origin", "security headers"],
      "difficulty": "medium"
    },
    {
      "id": 8010,
      "tag": "expressjs",
      "question": "How do you implement modular routing using Express Router and organize routes in separate files?",
      "answer": "Express Router provides a way to create modular, mountable route handlers. It allows you to organize routes into separate files and modules, making large applications more maintainable and structured.\n\n**Basic Router Setup**:\n\n**Creating Route Modules** (routes/users.js):\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Middleware specific to this router\nrouter.use((req, res, next) => {\n  console.log('Users route accessed at:', Date.now());\n  next();\n});\n\n// Define routes\nrouter.get('/', (req, res) => {\n  res.json({ message: 'Get all users' });\n});\n\nrouter.get('/:id', (req, res) => {\n  res.json({ message: `Get user ${req.params.id}` });\n});\n\nrouter.post('/', (req, res) => {\n  res.json({ message: 'Create new user', data: req.body });\n});\n\nrouter.put('/:id', (req, res) => {\n  res.json({ message: `Update user ${req.params.id}`, data: req.body });\n});\n\nrouter.delete('/:id', (req, res) => {\n  res.json({ message: `Delete user ${req.params.id}` });\n});\n\nmodule.exports = router;\n```\n\n**Products Routes** (routes/products.js):\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\nrouter.get('/', (req, res) => {\n  const { category, limit = 10 } = req.query;\n  res.json({ \n    message: 'Get products', \n    category, \n    limit: parseInt(limit) \n  });\n});\n\nrouter.get('/:id/reviews', (req, res) => {\n  res.json({ \n    productId: req.params.id, \n    reviews: [] \n  });\n});\n\nmodule.exports = router;\n```\n\n**Main Application** (app.js):\n```javascript\nconst express = require('express');\nconst usersRouter = require('./routes/users');\nconst productsRouter = require('./routes/products');\nconst app = express();\n\n// Global middleware\napp.use(express.json());\n\n// Mount routers\napp.use('/api/users', usersRouter);\napp.use('/api/products', productsRouter);\n\n// Routes are now available at:\n// GET /api/users/\n// GET /api/users/:id\n// GET /api/products/\n// GET /api/products/:id/reviews\n\napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n```\n\n**Advanced Router Organization**:\n\n**Nested Routers** (routes/api/index.js):\n```javascript\nconst express = require('express');\nconst usersRouter = require('./users');\nconst productsRouter = require('./products');\nconst authRouter = require('./auth');\nconst router = express.Router();\n\n// API-level middleware\nrouter.use((req, res, next) => {\n  res.set('X-API-Version', '1.0');\n  next();\n});\n\n// Mount sub-routers\nrouter.use('/users', usersRouter);\nrouter.use('/products', productsRouter);\nrouter.use('/auth', authRouter);\n\nmodule.exports = router;\n```\n\n**Route Parameters and Middleware**:\n```javascript\n// routes/users.js\nconst router = express.Router();\n\n// Parameter middleware\nrouter.param('id', (req, res, next, id) => {\n  // Validate ID format\n  if (!/^\\d+$/.test(id)) {\n    return res.status(400).json({ error: 'Invalid user ID' });\n  }\n  req.userId = parseInt(id);\n  next();\n});\n\nrouter.get('/:id', (req, res) => {\n  // req.userId is now available and validated\n  res.json({ userId: req.userId });\n});\n```\n\nThis modular approach keeps code organized, enables better testing, and makes applications easier to maintain as they grow.",
      "keywords": ["Express Router", "modular routing", "route organization", "router.param", "nested routers", "route modules"],
      "difficulty": "easy"
    },
    {
      "id": 8011,
      "tag": "expressjs",
      "question": "How do you handle form data validation and processing in Express.js applications?",
      "answer": "Form data handling in Express.js involves parsing different types of form data, validating input, and providing meaningful error responses. This is crucial for data integrity and security.\n\n**Basic Form Data Parsing**:\n\n```javascript\nconst express = require('express');\nconst { body, validationResult, query } = require('express-validator');\nconst app = express();\n\n// Parse URL-encoded form data\napp.use(express.urlencoded({ extended: true }));\napp.use(express.json());\n\n// Basic form handling\napp.post('/contact', (req, res) => {\n  const { name, email, message } = req.body;\n  \n  // Basic validation\n  if (!name || !email || !message) {\n    return res.status(400).json({\n      error: 'All fields are required'\n    });\n  }\n  \n  res.json({ message: 'Form submitted successfully' });\n});\n```\n\n**Advanced Validation with express-validator**:\n\n```bash\nnpm install express-validator\n```\n\n```javascript\n// User registration form validation\nconst validateRegistration = [\n  body('username')\n    .isLength({ min: 3, max: 20 })\n    .matches(/^[a-zA-Z0-9_]+$/)\n    .withMessage('Username must be 3-20 characters, alphanumeric and underscore only'),\n    \n  body('email')\n    .isEmail()\n    .normalizeEmail()\n    .withMessage('Valid email required'),\n    \n  body('password')\n    .isLength({ min: 8 })\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n    .withMessage('Password must contain uppercase, lowercase, number, and special character'),\n    \n  body('confirmPassword')\n    .custom((value, { req }) => {\n      if (value !== req.body.password) {\n        throw new Error('Passwords do not match');\n      }\n      return true;\n    }),\n    \n  body('age')\n    .isInt({ min: 13, max: 120 })\n    .withMessage('Age must be between 13 and 120'),\n    \n  body('website')\n    .optional({ nullable: true, checkFalsy: true })\n    .isURL()\n    .withMessage('Must be a valid URL')\n];\n\n// Handle validation results\nconst handleValidation = (req, res, next) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: errors.array().map(err => ({\n        field: err.path,\n        message: err.msg,\n        value: err.value\n      }))\n    });\n  }\n  next();\n};\n\napp.post('/register', validateRegistration, handleValidation, (req, res) => {\n  const { username, email, password, age, website } = req.body;\n  \n  // Process validated data\n  res.json({ \n    message: 'Registration successful',\n    user: { username, email, age, website }\n  });\n});\n```\n\n**Complex Form Validation**:\n\n```javascript\n// Multi-step form validation\nconst validateContactForm = [\n  body('personalInfo.firstName')\n    .trim()\n    .isLength({ min: 2 })\n    .withMessage('First name required'),\n    \n  body('personalInfo.lastName')\n    .trim()\n    .isLength({ min: 2 })\n    .withMessage('Last name required'),\n    \n  body('contact.phone')\n    .optional()\n    .isMobilePhone('any')\n    .withMessage('Valid phone number required'),\n    \n  body('preferences.newsletter')\n    .isBoolean()\n    .withMessage('Newsletter preference must be boolean'),\n    \n  body('preferences.categories')\n    .isArray({ min: 1 })\n    .withMessage('At least one category must be selected'),\n    \n  body('preferences.categories.*')\n    .isIn(['tech', 'business', 'lifestyle', 'education'])\n    .withMessage('Invalid category selection')\n];\n\napp.post('/contact-advanced', validateContactForm, handleValidation, (req, res) => {\n  const formData = req.body;\n  \n  // Process nested form data\n  res.json({\n    message: 'Advanced form processed',\n    data: formData\n  });\n});\n```\n\n**Query Parameter Validation**:\n\n```javascript\n// Search form with query parameters\nconst validateSearch = [\n  query('q')\n    .trim()\n    .isLength({ min: 1 })\n    .withMessage('Search query required'),\n    \n  query('category')\n    .optional()\n    .isIn(['all', 'products', 'articles', 'users'])\n    .withMessage('Invalid category'),\n    \n  query('page')\n    .optional()\n    .isInt({ min: 1 })\n    .toInt()\n    .withMessage('Page must be a positive integer'),\n    \n  query('limit')\n    .optional()\n    .isInt({ min: 1, max: 100 })\n    .toInt()\n    .withMessage('Limit must be between 1 and 100')\n];\n\napp.get('/search', validateSearch, handleValidation, (req, res) => {\n  const { q, category = 'all', page = 1, limit = 10 } = req.query;\n  \n  res.json({\n    query: q,\n    category,\n    page,\n    limit,\n    results: []\n  });\n});\n```\n\n**Custom Validation Functions**:\n\n```javascript\n// Custom async validator\nconst isEmailUnique = async (email) => {\n  const existingUser = await User.findOne({ email });\n  if (existingUser) {\n    throw new Error('Email already registered');\n  }\n  return true;\n};\n\nconst validateUniqueEmail = [\n  body('email')\n    .isEmail()\n    .normalizeEmail()\n    .custom(isEmailUnique)\n];\n```\n\nThis comprehensive validation approach ensures data integrity, provides clear error messages, and enhances security by preventing malicious input.",
      "keywords": ["form validation", "express-validator", "input validation", "form processing", "data validation", "validation middleware"],
      "difficulty": "easy"
    },
    {
      "id": 8012,
      "tag": "expressjs",
      "question": "How do you implement cookie parsing and management in Express.js applications?",
      "answer": "Cookie management in Express.js involves parsing incoming cookies, setting new cookies, and handling cookie security. Cookies are essential for session management, user preferences, and tracking.\n\n**Basic Cookie Parsing**:\n\n```bash\nnpm install cookie-parser\n```\n\n```javascript\nconst express = require('express');\nconst cookieParser = require('cookie-parser');\nconst app = express();\n\n// Parse cookies\napp.use(cookieParser('your-secret-key')); // Secret for signed cookies\n\n// Reading cookies\napp.get('/cookies', (req, res) => {\n  console.log('Regular cookies:', req.cookies);\n  console.log('Signed cookies:', req.signedCookies);\n  \n  res.json({\n    cookies: req.cookies,\n    signedCookies: req.signedCookies\n  });\n});\n\n// Setting basic cookies\napp.get('/set-cookie', (req, res) => {\n  // Set simple cookie\n  res.cookie('username', 'john_doe');\n  \n  // Set cookie with options\n  res.cookie('preferences', 'dark-theme', {\n    maxAge: 24 * 60 * 60 * 1000, // 24 hours\n    httpOnly: true,\n    secure: false, // Set to true in production with HTTPS\n    sameSite: 'strict'\n  });\n  \n  res.send('Cookies set successfully');\n});\n```\n\n**Advanced Cookie Management**:\n\n```javascript\n// Cookie utility functions\nconst cookieUtils = {\n  // Set secure cookie\n  setSecureCookie: (res, name, value, options = {}) => {\n    const defaultOptions = {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      maxAge: 24 * 60 * 60 * 1000 // 24 hours\n    };\n    \n    res.cookie(name, value, { ...defaultOptions, ...options });\n  },\n  \n  // Set signed cookie\n  setSignedCookie: (res, name, value, options = {}) => {\n    res.cookie(name, value, { ...options, signed: true });\n  },\n  \n  // Clear cookie\n  clearCookie: (res, name, options = {}) => {\n    res.clearCookie(name, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'strict',\n      ...options\n    });\n  }\n};\n\n// User session with cookies\napp.post('/login', (req, res) => {\n  const { username, password } = req.body;\n  \n  // Authenticate user (simplified)\n  if (username === 'admin' && password === 'password') {\n    // Set authentication cookie\n    cookieUtils.setSecureCookie(res, 'auth', 'authenticated', {\n      maxAge: 30 * 60 * 1000 // 30 minutes\n    });\n    \n    // Set user preferences\n    cookieUtils.setSignedCookie(res, 'user_id', '12345');\n    \n    // Set remember me cookie\n    if (req.body.remember) {\n      cookieUtils.setSecureCookie(res, 'remember_token', 'abc123', {\n        maxAge: 30 * 24 * 60 * 60 * 1000 // 30 days\n      });\n    }\n    \n    res.json({ message: 'Login successful' });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n\napp.post('/logout', (req, res) => {\n  // Clear all authentication cookies\n  cookieUtils.clearCookie(res, 'auth');\n  cookieUtils.clearCookie(res, 'user_id');\n  cookieUtils.clearCookie(res, 'remember_token');\n  \n  res.json({ message: 'Logout successful' });\n});\n```\n\n**Cookie-based Authentication Middleware**:\n\n```javascript\n// Authentication middleware using cookies\nconst authenticateWithCookie = (req, res, next) => {\n  const authCookie = req.cookies.auth;\n  const userIdCookie = req.signedCookies.user_id;\n  \n  if (!authCookie || authCookie !== 'authenticated') {\n    return res.status(401).json({ error: 'Authentication required' });\n  }\n  \n  if (!userIdCookie) {\n    return res.status(401).json({ error: 'Invalid session' });\n  }\n  \n  // Add user info to request\n  req.user = { id: userIdCookie };\n  next();\n};\n\n// Protected route\napp.get('/profile', authenticateWithCookie, (req, res) => {\n  res.json({ \n    message: 'Profile data', \n    userId: req.user.id \n  });\n});\n```\n\n**Cookie Consent and Management**:\n\n```javascript\n// Cookie consent handling\napp.get('/set-consent', (req, res) => {\n  const { essential, analytics, marketing } = req.query;\n  \n  // Always set essential cookies\n  res.cookie('consent_essential', 'true', {\n    maxAge: 365 * 24 * 60 * 60 * 1000, // 1 year\n    httpOnly: false // Accessible to frontend\n  });\n  \n  // Conditional cookies based on consent\n  if (analytics === 'true') {\n    res.cookie('consent_analytics', 'true', {\n      maxAge: 365 * 24 * 60 * 60 * 1000\n    });\n    \n    // Set analytics tracking cookie\n    res.cookie('analytics_id', `analytics_${Date.now()}`, {\n      maxAge: 365 * 24 * 60 * 60 * 1000\n    });\n  }\n  \n  if (marketing === 'true') {\n    res.cookie('consent_marketing', 'true', {\n      maxAge: 365 * 24 * 60 * 60 * 1000\n    });\n  }\n  \n  res.json({ message: 'Cookie preferences saved' });\n});\n\n// Middleware to check cookie consent\nconst checkCookieConsent = (requiredType) => {\n  return (req, res, next) => {\n    const consent = req.cookies[`consent_${requiredType}`];\n    \n    if (consent !== 'true') {\n      return res.status(403).json({ \n        error: `${requiredType} cookies not consented` \n      });\n    }\n    \n    next();\n  };\n};\n\n// Route that requires analytics consent\napp.get('/analytics', checkCookieConsent('analytics'), (req, res) => {\n  res.json({ message: 'Analytics data' });\n});\n```\n\n**Security Best Practices**:\n\n```javascript\n// Secure cookie configuration\nconst secureCookieOptions = {\n  httpOnly: true,                    // Prevent XSS attacks\n  secure: process.env.NODE_ENV === 'production', // HTTPS only in production\n  sameSite: 'strict',                // CSRF protection\n  maxAge: 60 * 60 * 1000,           // 1 hour expiry\n  domain: process.env.COOKIE_DOMAIN  // Restrict to specific domain\n};\n\n// Cookie rotation for enhanced security\nconst rotateCookie = (req, res, next) => {\n  const sessionId = req.cookies.session_id;\n  \n  if (sessionId) {\n    // Generate new session ID\n    const newSessionId = `session_${Date.now()}_${Math.random()}`;\n    \n    // Set new cookie\n    res.cookie('session_id', newSessionId, secureCookieOptions);\n    \n    // Clear old cookie\n    res.clearCookie('session_id');\n  }\n  \n  next();\n};\n```\n\nProper cookie management is crucial for security, user experience, and compliance with privacy regulations like GDPR.",
      "keywords": ["cookie parsing", "cookie-parser", "cookie security", "session cookies", "cookie consent", "signed cookies"],
      "difficulty": "easy"
    },
    {
      "id": 8013,
      "tag": "expressjs",
      "question": "How do you handle environment configuration and use dotenv in Express.js applications?",
      "answer": "Environment configuration is crucial for managing different deployment environments (development, staging, production) and keeping sensitive data secure. The dotenv package is the standard solution for loading environment variables from .env files.\n\n**Basic dotenv Setup**:\n\n```bash\nnpm install dotenv\n```\n\n**Environment Files Structure**:\n\n**.env** (local development):\n```bash\n# Server Configuration\nNODE_ENV=development\nPORT=3000\nHOST=localhost\n\n# Database\nDB_HOST=localhost\nDB_PORT=5432\nDB_NAME=myapp_dev\nDB_USER=dev_user\nDB_PASSWORD=dev_password\nDATABASE_URL=postgresql://dev_user:dev_password@localhost:5432/myapp_dev\n\n# Authentication\nJWT_SECRET=your-development-jwt-secret\nJWT_EXPIRES_IN=24h\nSESSION_SECRET=your-session-secret\n\n# External APIs\nAWS_ACCESS_KEY_ID=your-aws-key\nAWS_SECRET_ACCESS_KEY=your-aws-secret\nAWS_REGION=us-east-1\nS3_BUCKET=myapp-dev-uploads\n\n# Email\nSMTP_HOST=smtp.mailtrap.io\nSMTP_PORT=587\nSMTP_USER=your-mailtrap-user\nSMTP_PASS=your-mailtrap-pass\nFROM_EMAIL=noreply@myapp.com\n\n# Redis\nREDIS_URL=redis://localhost:6379\n\n# Application Settings\nCLIENT_URL=http://localhost:3000\nAPI_BASE_URL=http://localhost:3001\nLOG_LEVEL=debug\nENABLE_CORS=true\n```\n\n**Configuration Module** (config/index.js):\n\n```javascript\nrequire('dotenv').config();\n\n// Validate required environment variables\nconst requiredEnvVars = [\n  'NODE_ENV',\n  'PORT',\n  'DATABASE_URL',\n  'JWT_SECRET'\n];\n\nrequiredEnvVars.forEach(envVar => {\n  if (!process.env[envVar]) {\n    console.error(`Missing required environment variable: ${envVar}`);\n    process.exit(1);\n  }\n});\n\nconst config = {\n  // Environment\n  env: process.env.NODE_ENV || 'development',\n  isDevelopment: process.env.NODE_ENV === 'development',\n  isProduction: process.env.NODE_ENV === 'production',\n  isTest: process.env.NODE_ENV === 'test',\n  \n  // Server\n  port: parseInt(process.env.PORT) || 3000,\n  host: process.env.HOST || 'localhost',\n  \n  // Database\n  database: {\n    url: process.env.DATABASE_URL,\n    host: process.env.DB_HOST,\n    port: parseInt(process.env.DB_PORT) || 5432,\n    name: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    ssl: process.env.DB_SSL === 'true'\n  },\n  \n  // Authentication\n  auth: {\n    jwtSecret: process.env.JWT_SECRET,\n    jwtExpiresIn: process.env.JWT_EXPIRES_IN || '24h',\n    sessionSecret: process.env.SESSION_SECRET,\n    bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS) || 12\n  },\n  \n  // AWS\n  aws: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n    region: process.env.AWS_REGION || 'us-east-1',\n    s3Bucket: process.env.S3_BUCKET\n  },\n  \n  // Email\n  email: {\n    host: process.env.SMTP_HOST,\n    port: parseInt(process.env.SMTP_PORT) || 587,\n    user: process.env.SMTP_USER,\n    pass: process.env.SMTP_PASS,\n    from: process.env.FROM_EMAIL\n  },\n  \n  // Redis\n  redis: {\n    url: process.env.REDIS_URL || 'redis://localhost:6379'\n  },\n  \n  // Application\n  app: {\n    clientUrl: process.env.CLIENT_URL,\n    apiBaseUrl: process.env.API_BASE_URL,\n    logLevel: process.env.LOG_LEVEL || 'info',\n    enableCors: process.env.ENABLE_CORS === 'true'\n  }\n};\n\nmodule.exports = config;\n```\n\n**Application Setup** (app.js):\n\n```javascript\n// Load environment variables first\nrequire('dotenv').config();\n\nconst express = require('express');\nconst config = require('./config');\nconst app = express();\n\n// Environment-based middleware\nif (config.isDevelopment) {\n  const morgan = require('morgan');\n  app.use(morgan('dev'));\n}\n\n// CORS based on environment\nif (config.app.enableCors) {\n  const cors = require('cors');\n  app.use(cors({\n    origin: config.app.clientUrl,\n    credentials: true\n  }));\n}\n\n// Database connection using environment config\nconst connectDB = async () => {\n  try {\n    if (config.isDevelopment) {\n      console.log('Connecting to development database...');\n    }\n    \n    // Use config.database for connection\n    // await mongoose.connect(config.database.url);\n    console.log('Database connected successfully');\n  } catch (error) {\n    console.error('Database connection failed:', error);\n    process.exit(1);\n  }\n};\n\nconnectDB();\n\n// Routes using environment config\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'ok',\n    environment: config.env,\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime()\n  });\n});\n\napp.listen(config.port, config.host, () => {\n  console.log(`Server running in ${config.env} mode on ${config.host}:${config.port}`);\n});\n```\n\n**Environment-Specific Files**:\n\n**.env.production**:\n```bash\nNODE_ENV=production\nPORT=80\nDATABASE_URL=postgresql://user:pass@prod-db:5432/myapp\nJWT_SECRET=super-secure-production-secret\nLOG_LEVEL=error\nENABLE_CORS=false\n```\n\n**.env.test**:\n```bash\nNODE_ENV=test\nPORT=3001\nDATABASE_URL=postgresql://test:test@localhost:5432/myapp_test\nJWT_SECRET=test-secret\nLOG_LEVEL=silent\n```\n\n**Advanced Configuration with Validation**:\n\n```javascript\n// config/validator.js\nconst Joi = require('joi');\n\nconst envSchema = Joi.object({\n  NODE_ENV: Joi.string()\n    .valid('development', 'production', 'test')\n    .default('development'),\n    \n  PORT: Joi.number()\n    .positive()\n    .default(3000),\n    \n  DATABASE_URL: Joi.string()\n    .uri()\n    .required(),\n    \n  JWT_SECRET: Joi.string()\n    .min(32)\n    .required(),\n    \n  AWS_ACCESS_KEY_ID: Joi.string()\n    .when('NODE_ENV', {\n      is: 'production',\n      then: Joi.required(),\n      otherwise: Joi.optional()\n    })\n}).unknown();\n\nconst { error, value } = envSchema.validate(process.env);\n\nif (error) {\n  throw new Error(`Config validation error: ${error.message}`);\n}\n\nmodule.exports = value;\n```\n\n**Loading Environment-Specific Files**:\n\n```javascript\n// Load environment-specific .env file\nconst dotenv = require('dotenv');\nconst path = require('path');\n\nconst env = process.env.NODE_ENV || 'development';\nconst envFile = `.env.${env}`;\n\n// Load base .env file\ndotenv.config();\n\n// Load environment-specific file (overrides base)\ndotenv.config({ path: path.resolve(process.cwd(), envFile) });\n```\n\nThis approach provides flexible, secure, and maintainable environment configuration for Express.js applications across different deployment environments.",
      "keywords": ["environment configuration", "dotenv", "environment variables", "config management", "deployment environments", "security"],
      "difficulty": "easy"
    },
    {
      "id": 8014,
      "tag": "expressjs",
      "question": "How do you implement logging with Morgan middleware and create custom loggers in Express.js?",
      "answer": "Logging is essential for monitoring, debugging, and maintaining Express.js applications. Morgan is the most popular logging middleware, while Winston provides advanced logging capabilities.\n\n**Basic Morgan Setup**:\n\n```bash\nnpm install morgan\n```\n\n```javascript\nconst express = require('express');\nconst morgan = require('morgan');\nconst app = express();\n\n// Pre-defined formats\napp.use(morgan('combined'));    // Apache combined log format\napp.use(morgan('common'));      // Apache common log format\napp.use(morgan('dev'));         // Concise colored output for development\napp.use(morgan('short'));       // Shorter than default\napp.use(morgan('tiny'));        // Minimal output\n\n// Environment-based logging\nif (process.env.NODE_ENV === 'development') {\n  app.use(morgan('dev'));\n} else {\n  app.use(morgan('combined'));\n}\n```\n\n**Custom Morgan Formats**:\n\n```javascript\n// Custom format string\nmorgan.format('myformat', ':method :url :status :res[content-length] - :response-time ms');\n\n// Custom format function\nmorgan.format('custom', (tokens, req, res) => {\n  return [\n    tokens.method(req, res),\n    tokens.url(req, res),\n    tokens.status(req, res),\n    tokens.res(req, res, 'content-length'), '-',\n    tokens['response-time'](req, res), 'ms',\n    '- User:', req.user ? req.user.id : 'anonymous'\n  ].join(' ');\n});\n\napp.use(morgan('custom'));\n\n// JSON format for structured logging\nmorgan.format('json', (tokens, req, res) => {\n  return JSON.stringify({\n    method: tokens.method(req, res),\n    url: tokens.url(req, res),\n    status: Number(tokens.status(req, res)),\n    contentLength: tokens.res(req, res, 'content-length'),\n    responseTime: Number(tokens['response-time'](req, res)),\n    timestamp: new Date().toISOString(),\n    userAgent: tokens['user-agent'](req, res),\n    remoteAddr: tokens['remote-addr'](req, res)\n  });\n});\n```\n\n**Advanced Morgan Configuration**:\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\n// Create logs directory\nconst logsDir = path.join(__dirname, 'logs');\nif (!fs.existsSync(logsDir)) {\n  fs.mkdirSync(logsDir);\n}\n\n// Create write stream for access logs\nconst accessLogStream = fs.createWriteStream(\n  path.join(logsDir, 'access.log'),\n  { flags: 'a' }\n);\n\n// Log to file in production\nif (process.env.NODE_ENV === 'production') {\n  app.use(morgan('combined', { stream: accessLogStream }));\n} else {\n  app.use(morgan('dev'));\n}\n\n// Skip certain requests\napp.use(morgan('combined', {\n  skip: (req, res) => {\n    // Skip logging for health checks and static assets\n    return req.url === '/health' || \n           req.url.startsWith('/static/') || \n           res.statusCode < 400;\n  }\n}));\n\n// Custom tokens\nmorgan.token('id', (req) => req.id);\nmorgan.token('user-id', (req) => req.user ? req.user.id : 'anonymous');\nmorgan.token('body', (req) => JSON.stringify(req.body));\n\n// Use custom tokens\napp.use(morgan(':method :url :status :response-time ms - :user-id'));\n```\n\n**Winston for Advanced Logging**:\n\n```bash\nnpm install winston winston-daily-rotate-file\n```\n\n```javascript\nconst winston = require('winston');\nconst DailyRotateFile = require('winston-daily-rotate-file');\n\n// Create logger\nconst logger = winston.createLogger({\n  level: process.env.LOG_LEVEL || 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'express-app' },\n  transports: [\n    // Error logs\n    new DailyRotateFile({\n      filename: 'logs/error-%DATE%.log',\n      datePattern: 'YYYY-MM-DD',\n      level: 'error',\n      maxSize: '20m',\n      maxFiles: '14d'\n    }),\n    \n    // Combined logs\n    new DailyRotateFile({\n      filename: 'logs/combined-%DATE%.log',\n      datePattern: 'YYYY-MM-DD',\n      maxSize: '20m',\n      maxFiles: '14d'\n    })\n  ]\n});\n\n// Add console transport for development\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.combine(\n      winston.format.colorize(),\n      winston.format.simple()\n    )\n  }));\n}\n\n// Custom logging middleware\nconst requestLogger = (req, res, next) => {\n  // Add request ID\n  req.id = Math.random().toString(36).substr(2, 9);\n  \n  logger.info('Request started', {\n    id: req.id,\n    method: req.method,\n    url: req.url,\n    userAgent: req.get('User-Agent'),\n    ip: req.ip\n  });\n  \n  // Log response\n  const originalSend = res.send;\n  res.send = function(body) {\n    logger.info('Request completed', {\n      id: req.id,\n      method: req.method,\n      url: req.url,\n      statusCode: res.statusCode,\n      contentLength: body ? body.length : 0\n    });\n    \n    originalSend.call(this, body);\n  };\n  \n  next();\n};\n\napp.use(requestLogger);\n```\n\n**Error Logging**:\n\n```javascript\n// Error logging middleware\nconst errorLogger = (err, req, res, next) => {\n  logger.error('Unhandled error', {\n    error: {\n      message: err.message,\n      stack: err.stack,\n      name: err.name\n    },\n    request: {\n      id: req.id,\n      method: req.method,\n      url: req.url,\n      body: req.body,\n      headers: req.headers\n    }\n  });\n  \n  next(err);\n};\n\n// Application logging\napp.get('/api/users', async (req, res, next) => {\n  try {\n    logger.info('Fetching users', { userId: req.user?.id });\n    \n    const users = await User.find();\n    \n    logger.info('Users fetched successfully', { \n      count: users.length,\n      userId: req.user?.id \n    });\n    \n    res.json(users);\n  } catch (error) {\n    logger.error('Failed to fetch users', { \n      error: error.message,\n      userId: req.user?.id \n    });\n    next(error);\n  }\n});\n\n// Apply error logger before error handler\napp.use(errorLogger);\n```\n\n**Structured Logging with Context**:\n\n```javascript\n// Context logging utility\nclass RequestLogger {\n  constructor(req) {\n    this.requestId = req.id;\n    this.userId = req.user?.id;\n    this.context = {\n      requestId: this.requestId,\n      userId: this.userId\n    };\n  }\n  \n  info(message, meta = {}) {\n    logger.info(message, { ...this.context, ...meta });\n  }\n  \n  error(message, error, meta = {}) {\n    logger.error(message, {\n      ...this.context,\n      error: {\n        message: error.message,\n        stack: error.stack\n      },\n      ...meta\n    });\n  }\n  \n  warn(message, meta = {}) {\n    logger.warn(message, { ...this.context, ...meta });\n  }\n}\n\n// Middleware to add logger to request\napp.use((req, res, next) => {\n  req.logger = new RequestLogger(req);\n  next();\n});\n\n// Usage in routes\napp.post('/api/orders', async (req, res) => {\n  req.logger.info('Creating new order', { orderData: req.body });\n  \n  try {\n    const order = await Order.create(req.body);\n    req.logger.info('Order created successfully', { orderId: order.id });\n    res.status(201).json(order);\n  } catch (error) {\n    req.logger.error('Order creation failed', error, { orderData: req.body });\n    res.status(500).json({ error: 'Order creation failed' });\n  }\n});\n```\n\nThis logging setup provides comprehensive request tracking, error monitoring, and structured logging for production applications.",
      "keywords": ["logging", "Morgan", "Winston", "request logging", "error logging", "structured logging", "log rotation"],
      "difficulty": "easy"
    },
    {
      "id": 8015,
      "tag": "expressjs",
      "question": "How do you design and implement RESTful APIs in Express.js following best practices?",
      "answer": "RESTful API design in Express.js involves following HTTP conventions, proper resource modeling, consistent response formats, and implementing CRUD operations with appropriate status codes and error handling.\n\n**Basic REST API Structure**:\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\n\n// Resource: Users\n// GET /api/users - Get all users\nrouter.get('/', async (req, res) => {\n  try {\n    const { page = 1, limit = 10, search, sort = 'createdAt' } = req.query;\n    \n    const query = search ? { name: { $regex: search, $options: 'i' } } : {};\n    const options = {\n      page: parseInt(page),\n      limit: parseInt(limit),\n      sort: { [sort]: -1 }\n    };\n    \n    const users = await User.paginate(query, options);\n    \n    res.json({\n      status: 'success',\n      data: users.docs,\n      pagination: {\n        currentPage: users.page,\n        totalPages: users.totalPages,\n        totalItems: users.totalDocs,\n        hasNext: users.hasNextPage,\n        hasPrev: users.hasPrevPage\n      }\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to fetch users'\n    });\n  }\n});\n\n// GET /api/users/:id - Get specific user\nrouter.get('/:id', async (req, res) => {\n  try {\n    const user = await User.findById(req.params.id);\n    \n    if (!user) {\n      return res.status(404).json({\n        status: 'error',\n        message: 'User not found'\n      });\n    }\n    \n    res.json({\n      status: 'success',\n      data: user\n    });\n  } catch (error) {\n    if (error.name === 'CastError') {\n      return res.status(400).json({\n        status: 'error',\n        message: 'Invalid user ID'\n      });\n    }\n    \n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to fetch user'\n    });\n  }\n});\n\n// POST /api/users - Create new user\nrouter.post('/', async (req, res) => {\n  try {\n    const user = new User(req.body);\n    await user.save();\n    \n    res.status(201).json({\n      status: 'success',\n      message: 'User created successfully',\n      data: user\n    });\n  } catch (error) {\n    if (error.name === 'ValidationError') {\n      return res.status(400).json({\n        status: 'error',\n        message: 'Validation failed',\n        errors: Object.values(error.errors).map(e => e.message)\n      });\n    }\n    \n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to create user'\n    });\n  }\n});\n\n// PUT /api/users/:id - Update user\nrouter.put('/:id', async (req, res) => {\n  try {\n    const user = await User.findByIdAndUpdate(\n      req.params.id,\n      req.body,\n      { new: true, runValidators: true }\n    );\n    \n    if (!user) {\n      return res.status(404).json({\n        status: 'error',\n        message: 'User not found'\n      });\n    }\n    \n    res.json({\n      status: 'success',\n      message: 'User updated successfully',\n      data: user\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to update user'\n    });\n  }\n});\n\n// DELETE /api/users/:id - Delete user\nrouter.delete('/:id', async (req, res) => {\n  try {\n    const user = await User.findByIdAndDelete(req.params.id);\n    \n    if (!user) {\n      return res.status(404).json({\n        status: 'error',\n        message: 'User not found'\n      });\n    }\n    \n    res.status(204).end(); // No content for successful deletion\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to delete user'\n    });\n  }\n});\n\nmodule.exports = router;\n```\n\n**Advanced REST API Features**:\n\n```javascript\n// Nested resources: /api/users/:userId/posts\nconst userPostsRouter = express.Router({ mergeParams: true });\n\n// GET /api/users/:userId/posts\nuserPostsRouter.get('/', async (req, res) => {\n  try {\n    const { userId } = req.params;\n    const posts = await Post.find({ author: userId })\n                          .populate('author', 'name email')\n                          .sort({ createdAt: -1 });\n    \n    res.json({\n      status: 'success',\n      data: posts,\n      count: posts.length\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to fetch user posts'\n    });\n  }\n});\n\n// POST /api/users/:userId/posts\nuserPostsRouter.post('/', async (req, res) => {\n  try {\n    const post = new Post({\n      ...req.body,\n      author: req.params.userId\n    });\n    \n    await post.save();\n    await post.populate('author', 'name email');\n    \n    res.status(201).json({\n      status: 'success',\n      message: 'Post created successfully',\n      data: post\n    });\n  } catch (error) {\n    res.status(500).json({\n      status: 'error',\n      message: 'Failed to create post'\n    });\n  }\n});\n\n// Mount nested router\nrouter.use('/:userId/posts', userPostsRouter);\n```\n\n**API Response Standardization**:\n\n```javascript\n// Response helper utility\nclass APIResponse {\n  static success(res, data, message = null, statusCode = 200) {\n    const response = {\n      status: 'success',\n      data\n    };\n    \n    if (message) response.message = message;\n    \n    return res.status(statusCode).json(response);\n  }\n  \n  static error(res, message, statusCode = 500, errors = null) {\n    const response = {\n      status: 'error',\n      message\n    };\n    \n    if (errors) response.errors = errors;\n    \n    return res.status(statusCode).json(response);\n  }\n  \n  static paginated(res, data, pagination, message = null) {\n    return res.json({\n      status: 'success',\n      data,\n      pagination,\n      message\n    });\n  }\n}\n\n// Usage in routes\nrouter.get('/', async (req, res) => {\n  try {\n    const users = await User.find();\n    return APIResponse.success(res, users);\n  } catch (error) {\n    return APIResponse.error(res, 'Failed to fetch users');\n  }\n});\n```\n\n**API Versioning**:\n\n```javascript\n// Version 1 API\nconst v1Router = express.Router();\nv1Router.use('/users', require('./v1/users'));\nv1Router.use('/posts', require('./v1/posts'));\n\n// Version 2 API\nconst v2Router = express.Router();\nv2Router.use('/users', require('./v2/users'));\nv2Router.use('/posts', require('./v2/posts'));\n\n// Mount versions\napp.use('/api/v1', v1Router);\napp.use('/api/v2', v2Router);\n\n// Default to latest version\napp.use('/api', v2Router);\n```\n\n**Content Negotiation and HATEOAS**:\n\n```javascript\n// Content negotiation middleware\nconst contentNegotiation = (req, res, next) => {\n  const acceptHeader = req.get('Accept');\n  \n  if (acceptHeader && !acceptHeader.includes('application/json')) {\n    return res.status(406).json({\n      status: 'error',\n      message: 'Only application/json content type supported'\n    });\n  }\n  \n  next();\n};\n\n// HATEOAS links\nconst addHATEOASLinks = (resource, type) => {\n  const links = {\n    self: `/api/${type}/${resource._id}`,\n    edit: `/api/${type}/${resource._id}`,\n    delete: `/api/${type}/${resource._id}`\n  };\n  \n  if (type === 'users') {\n    links.posts = `/api/users/${resource._id}/posts`;\n  }\n  \n  return {\n    ...resource.toJSON(),\n    _links: links\n  };\n};\n\nrouter.get('/:id', async (req, res) => {\n  try {\n    const user = await User.findById(req.params.id);\n    \n    if (!user) {\n      return APIResponse.error(res, 'User not found', 404);\n    }\n    \n    const userWithLinks = addHATEOASLinks(user, 'users');\n    return APIResponse.success(res, userWithLinks);\n  } catch (error) {\n    return APIResponse.error(res, 'Failed to fetch user');\n  }\n});\n```\n\n**API Documentation with OpenAPI/Swagger**:\n\n```javascript\n/**\n * @swagger\n * /api/users:\n *   get:\n *     summary: Get all users\n *     tags: [Users]\n *     parameters:\n *       - in: query\n *         name: page\n *         schema:\n *           type: integer\n *         description: Page number\n *       - in: query\n *         name: limit\n *         schema:\n *           type: integer\n *         description: Number of users per page\n *     responses:\n *       200:\n *         description: List of users\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 status:\n *                   type: string\n *                   example: success\n *                 data:\n *                   type: array\n *                   items:\n *                     $ref: '#/components/schemas/User'\n */\nrouter.get('/', getUsersHandler);\n```\n\nThis RESTful API design follows industry standards with proper HTTP status codes, consistent response formats, error handling, and scalable architecture patterns.",
      "keywords": ["RESTful API", "HTTP methods", "status codes", "API design", "CRUD operations", "resource modeling", "HATEOAS"],
      "difficulty": "easy"
    },
    {
      "id": 8016,
      "tag": "expressjs",
      "question": "How do you integrate databases (MongoDB/PostgreSQL) with Express.js and implement data persistence patterns?",
      "answer": "Database integration in Express.js involves choosing appropriate ORMs/ODMs, implementing connection management, creating data models, and following best practices for data persistence and transactions.\n\n**MongoDB Integration with Mongoose**:\n\n```bash\nnpm install mongoose\n```\n\n**MongoDB Setup and Configuration**:\n\n```javascript\n// config/database.js\nconst mongoose = require('mongoose');\n\nconst connectDB = async () => {\n  try {\n    const conn = await mongoose.connect(process.env.MONGODB_URI, {\n      useNewUrlParser: true,\n      useUnifiedTopology: true\n    });\n    \n    console.log(`MongoDB Connected: ${conn.connection.host}`);\n    \n    // Handle connection events\n    mongoose.connection.on('error', (err) => {\n      console.error('MongoDB connection error:', err);\n    });\n    \n    mongoose.connection.on('disconnected', () => {\n      console.log('MongoDB disconnected');\n    });\n    \n    // Graceful shutdown\n    process.on('SIGINT', async () => {\n      await mongoose.connection.close();\n      console.log('MongoDB connection closed.');\n      process.exit(0);\n    });\n    \n  } catch (error) {\n    console.error('Database connection failed:', error);\n    process.exit(1);\n  }\n};\n\nmodule.exports = connectDB;\n```\n\n**Mongoose Models and Schemas**:\n\n```javascript\n// models/User.js\nconst mongoose = require('mongoose');\nconst bcrypt = require('bcryptjs');\n\nconst userSchema = new mongoose.Schema({\n  username: {\n    type: String,\n    required: [true, 'Username is required'],\n    unique: true,\n    trim: true,\n    minlength: 3,\n    maxlength: 20\n  },\n  email: {\n    type: String,\n    required: [true, 'Email is required'],\n    unique: true,\n    lowercase: true,\n    validate: {\n      validator: function(email) {\n        return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n      },\n      message: 'Invalid email format'\n    }\n  },\n  password: {\n    type: String,\n    required: [true, 'Password is required'],\n    minlength: 6,\n    select: false // Don't return password by default\n  },\n  profile: {\n    firstName: String,\n    lastName: String,\n    avatar: String,\n    bio: { type: String, maxlength: 500 }\n  },\n  role: {\n    type: String,\n    enum: ['user', 'admin', 'moderator'],\n    default: 'user'\n  },\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLogin: Date\n}, {\n  timestamps: true,\n  toJSON: { virtuals: true },\n  toObject: { virtuals: true }\n});\n\n// Virtual fields\nuserSchema.virtual('fullName').get(function() {\n  return `${this.profile.firstName} ${this.profile.lastName}`.trim();\n});\n\n// Indexes\nuserSchema.index({ email: 1 });\nuserSchema.index({ username: 1 });\nuserSchema.index({ 'profile.firstName': 1, 'profile.lastName': 1 });\n\n// Pre-save middleware\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  \n  this.password = await bcrypt.hash(this.password, 12);\n  next();\n});\n\n// Instance methods\nuserSchema.methods.comparePassword = async function(candidatePassword) {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\nuserSchema.methods.updateLastLogin = function() {\n  this.lastLogin = new Date();\n  return this.save();\n};\n\n// Static methods\nuserSchema.statics.findByEmail = function(email) {\n  return this.findOne({ email }).select('+password');\n};\n\nmodule.exports = mongoose.model('User', userSchema);\n```\n\n**PostgreSQL Integration with Sequelize**:\n\n```bash\nnpm install sequelize pg pg-hstore\n```\n\n**PostgreSQL Setup**:\n\n```javascript\n// config/database.js\nconst { Sequelize } = require('sequelize');\n\nconst sequelize = new Sequelize(process.env.DATABASE_URL, {\n  dialect: 'postgres',\n  logging: process.env.NODE_ENV === 'development' ? console.log : false,\n  pool: {\n    max: 10,\n    min: 0,\n    acquire: 30000,\n    idle: 10000\n  }\n});\n\nconst connectDB = async () => {\n  try {\n    await sequelize.authenticate();\n    console.log('PostgreSQL connected successfully');\n    \n    // Sync models in development\n    if (process.env.NODE_ENV === 'development') {\n      await sequelize.sync({ alter: true });\n    }\n  } catch (error) {\n    console.error('PostgreSQL connection failed:', error);\n    process.exit(1);\n  }\n};\n\nmodule.exports = { sequelize, connectDB };\n```\n\n**Sequelize Models**:\n\n```javascript\n// models/User.js\nconst { DataTypes } = require('sequelize');\nconst { sequelize } = require('../config/database');\nconst bcrypt = require('bcryptjs');\n\nconst User = sequelize.define('User', {\n  id: {\n    type: DataTypes.UUID,\n    defaultValue: DataTypes.UUIDV4,\n    primaryKey: true\n  },\n  username: {\n    type: DataTypes.STRING(20),\n    allowNull: false,\n    unique: true,\n    validate: {\n      len: [3, 20],\n      isAlphanumeric: true\n    }\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true,\n    validate: {\n      isEmail: true\n    }\n  },\n  password: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    validate: {\n      len: [6, 255]\n    }\n  },\n  firstName: DataTypes.STRING,\n  lastName: DataTypes.STRING,\n  role: {\n    type: DataTypes.ENUM('user', 'admin', 'moderator'),\n    defaultValue: 'user'\n  },\n  isActive: {\n    type: DataTypes.BOOLEAN,\n    defaultValue: true\n  },\n  lastLogin: DataTypes.DATE\n}, {\n  timestamps: true,\n  hooks: {\n    beforeSave: async (user) => {\n      if (user.changed('password')) {\n        user.password = await bcrypt.hash(user.password, 12);\n      }\n    }\n  }\n});\n\n// Instance methods\nUser.prototype.comparePassword = async function(candidatePassword) {\n  return bcrypt.compare(candidatePassword, this.password);\n};\n\n// Class methods\nUser.findByEmail = function(email) {\n  return this.findOne({ where: { email } });\n};\n\nmodule.exports = User;\n```\n\n**Repository Pattern Implementation**:\n\n```javascript\n// repositories/UserRepository.js\nclass UserRepository {\n  constructor(model) {\n    this.model = model;\n  }\n  \n  async create(userData) {\n    return await this.model.create(userData);\n  }\n  \n  async findById(id) {\n    return await this.model.findById(id);\n  }\n  \n  async findByEmail(email) {\n    return await this.model.findOne({ email });\n  }\n  \n  async findAll(options = {}) {\n    const { page = 1, limit = 10, sort = { createdAt: -1 } } = options;\n    \n    return await this.model\n      .find()\n      .sort(sort)\n      .skip((page - 1) * limit)\n      .limit(limit)\n      .exec();\n  }\n  \n  async update(id, updateData) {\n    return await this.model.findByIdAndUpdate(\n      id,\n      updateData,\n      { new: true, runValidators: true }\n    );\n  }\n  \n  async delete(id) {\n    return await this.model.findByIdAndDelete(id);\n  }\n  \n  async count(filter = {}) {\n    return await this.model.countDocuments(filter);\n  }\n  \n  async exists(filter) {\n    const doc = await this.model.findOne(filter).select('_id');\n    return !!doc;\n  }\n}\n\nmodule.exports = UserRepository;\n```\n\n**Service Layer with Business Logic**:\n\n```javascript\n// services/UserService.js\nconst UserRepository = require('../repositories/UserRepository');\nconst User = require('../models/User');\n\nclass UserService {\n  constructor() {\n    this.userRepository = new UserRepository(User);\n  }\n  \n  async createUser(userData) {\n    // Business logic validation\n    const emailExists = await this.userRepository.exists({ email: userData.email });\n    if (emailExists) {\n      throw new Error('Email already registered');\n    }\n    \n    const usernameExists = await this.userRepository.exists({ username: userData.username });\n    if (usernameExists) {\n      throw new Error('Username already taken');\n    }\n    \n    return await this.userRepository.create(userData);\n  }\n  \n  async getUserProfile(userId) {\n    const user = await this.userRepository.findById(userId);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    // Remove sensitive data\n    const { password, ...profile } = user.toObject();\n    return profile;\n  }\n  \n  async updateUserProfile(userId, updateData) {\n    // Prevent updating sensitive fields\n    const { password, role, ...allowedUpdates } = updateData;\n    \n    return await this.userRepository.update(userId, allowedUpdates);\n  }\n  \n  async authenticateUser(email, password) {\n    const user = await this.userRepository.findByEmail(email);\n    if (!user || !await user.comparePassword(password)) {\n      throw new Error('Invalid credentials');\n    }\n    \n    await user.updateLastLogin();\n    return user;\n  }\n}\n\nmodule.exports = UserService;\n```\n\n**Transaction Management**:\n\n```javascript\n// MongoDB Transactions\nconst createUserWithProfile = async (userData, profileData) => {\n  const session = await mongoose.startSession();\n  \n  try {\n    await session.withTransaction(async () => {\n      const user = new User(userData);\n      await user.save({ session });\n      \n      const profile = new Profile({\n        ...profileData,\n        userId: user._id\n      });\n      await profile.save({ session });\n      \n      return user;\n    });\n  } finally {\n    await session.endSession();\n  }\n};\n\n// PostgreSQL Transactions\nconst createUserWithProfile = async (userData, profileData) => {\n  const transaction = await sequelize.transaction();\n  \n  try {\n    const user = await User.create(userData, { transaction });\n    \n    const profile = await Profile.create({\n      ...profileData,\n      userId: user.id\n    }, { transaction });\n    \n    await transaction.commit();\n    return user;\n  } catch (error) {\n    await transaction.rollback();\n    throw error;\n  }\n};\n```\n\n**Connection Pooling and Performance**:\n\n```javascript\n// MongoDB connection optimization\nconst mongooseOptions = {\n  maxPoolSize: 10,\n  serverSelectionTimeoutMS: 5000,\n  socketTimeoutMS: 45000,\n  family: 4,\n  bufferCommands: false,\n  bufferMaxEntries: 0\n};\n\n// PostgreSQL connection optimization\nconst sequelizeOptions = {\n  pool: {\n    max: 20,\n    min: 5,\n    acquire: 60000,\n    idle: 10000\n  },\n  dialectOptions: {\n    ssl: process.env.NODE_ENV === 'production'\n  }\n};\n```\n\nThis database integration approach provides robust data persistence, proper error handling, transaction support, and scalable architecture patterns for Express.js applications.",
      "keywords": ["database integration", "MongoDB", "PostgreSQL", "Mongoose", "Sequelize", "data persistence", "transactions", "repository pattern"],
      "difficulty": "medium"
    },
    {
      "id": 8017,
      "tag": "expressjs",
      "question": "How do you handle file uploads in Express.js using Multer middleware and implement file processing?",
      "answer": "File upload handling in Express.js requires proper middleware configuration, storage management, validation, and security measures. Multer is the standard middleware for handling multipart/form-data and file uploads.\n\n**Basic Multer Setup**:\n\n```bash\nnpm install multer\n```\n\n**Simple File Upload Configuration**:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst app = express();\n\n// Ensure upload directory exists\nconst uploadDir = path.join(__dirname, 'uploads');\nif (!fs.existsSync(uploadDir)) {\n  fs.mkdirSync(uploadDir, { recursive: true });\n}\n\n// Basic memory storage (for small files)\nconst memoryStorage = multer.memoryStorage();\nconst uploadMemory = multer({ storage: memoryStorage });\n\n// Disk storage configuration\nconst diskStorage = multer.diskStorage({\n  destination: (req, file, cb) => {\n    cb(null, 'uploads/');\n  },\n  filename: (req, file, cb) => {\n    // Generate unique filename\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n  }\n});\n\nconst uploadDisk = multer({ storage: diskStorage });\n\n// Single file upload\napp.post('/upload/single', uploadDisk.single('file'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file uploaded' });\n  }\n  \n  res.json({\n    message: 'File uploaded successfully',\n    file: {\n      filename: req.file.filename,\n      originalname: req.file.originalname,\n      mimetype: req.file.mimetype,\n      size: req.file.size,\n      path: req.file.path\n    }\n  });\n});\n\n// Multiple files upload\napp.post('/upload/multiple', uploadDisk.array('files', 5), (req, res) => {\n  if (!req.files || req.files.length === 0) {\n    return res.status(400).json({ error: 'No files uploaded' });\n  }\n  \n  const fileInfo = req.files.map(file => ({\n    filename: file.filename,\n    originalname: file.originalname,\n    size: file.size,\n    path: file.path\n  }));\n  \n  res.json({\n    message: `${req.files.length} files uploaded successfully`,\n    files: fileInfo\n  });\n});\n```\n\n**Advanced File Upload with Validation**:\n\n```javascript\n// File filter function\nconst fileFilter = (req, file, cb) => {\n  // Allowed file types\n  const allowedTypes = {\n    'image/jpeg': '.jpg',\n    'image/jpg': '.jpg',\n    'image/png': '.png',\n    'image/gif': '.gif',\n    'application/pdf': '.pdf',\n    'text/plain': '.txt'\n  };\n  \n  if (allowedTypes[file.mimetype]) {\n    cb(null, true);\n  } else {\n    cb(new Error(`File type ${file.mimetype} not allowed`), false);\n  }\n};\n\n// Advanced multer configuration\nconst upload = multer({\n  storage: diskStorage,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n    files: 10 // Maximum 10 files\n  }\n});\n\n// Image upload with validation\napp.post('/upload/image', upload.single('image'), (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'Image file required' });\n    }\n    \n    // Additional validation\n    const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif'];\n    if (!allowedImageTypes.includes(req.file.mimetype)) {\n      // Clean up uploaded file\n      fs.unlinkSync(req.file.path);\n      return res.status(400).json({ error: 'Only JPEG, PNG, and GIF images allowed' });\n    }\n    \n    res.json({\n      message: 'Image uploaded successfully',\n      image: {\n        filename: req.file.filename,\n        originalname: req.file.originalname,\n        size: req.file.size,\n        url: `/uploads/${req.file.filename}`\n      }\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'File upload failed' });\n  }\n});\n```\n\n**Cloud Storage Integration (AWS S3)**:\n\n```bash\nnpm install aws-sdk multer-s3\n```\n\n```javascript\nconst AWS = require('aws-sdk');\nconst multerS3 = require('multer-s3');\n\n// Configure AWS\nAWS.config.update({\n  accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  region: process.env.AWS_REGION\n});\n\nconst s3 = new AWS.S3();\n\n// S3 storage configuration\nconst s3Storage = multerS3({\n  s3: s3,\n  bucket: process.env.S3_BUCKET,\n  key: (req, file, cb) => {\n    const folder = file.mimetype.startsWith('image/') ? 'images' : 'documents';\n    const filename = `${folder}/${Date.now()}-${file.originalname}`;\n    cb(null, filename);\n  },\n  contentType: multerS3.AUTO_CONTENT_TYPE,\n  metadata: (req, file, cb) => {\n    cb(null, {\n      fieldName: file.fieldname,\n      uploadedBy: req.user?.id || 'anonymous'\n    });\n  }\n});\n\nconst uploadS3 = multer({\n  storage: s3Storage,\n  fileFilter: fileFilter,\n  limits: {\n    fileSize: 10 * 1024 * 1024 // 10MB\n  }\n});\n\napp.post('/upload/s3', uploadS3.single('file'), (req, res) => {\n  res.json({\n    message: 'File uploaded to S3 successfully',\n    file: {\n      filename: req.file.key,\n      location: req.file.location,\n      bucket: req.file.bucket,\n      size: req.file.size\n    }\n  });\n});\n```\n\n**File Processing and Image Manipulation**:\n\n```bash\nnpm install sharp\n```\n\n```javascript\nconst sharp = require('sharp');\nconst path = require('path');\n\n// Image processing middleware\nconst processImage = async (req, res, next) => {\n  if (!req.file || !req.file.mimetype.startsWith('image/')) {\n    return next();\n  }\n  \n  try {\n    const filename = `processed-${Date.now()}.webp`;\n    const outputPath = path.join('uploads/processed', filename);\n    \n    // Ensure processed directory exists\n    const processedDir = path.dirname(outputPath);\n    if (!fs.existsSync(processedDir)) {\n      fs.mkdirSync(processedDir, { recursive: true });\n    }\n    \n    // Process image with Sharp\n    await sharp(req.file.buffer || req.file.path)\n      .resize(800, 600, {\n        fit: 'inside',\n        withoutEnlargement: true\n      })\n      .webp({ quality: 80 })\n      .toFile(outputPath);\n    \n    // Create thumbnail\n    const thumbnailPath = path.join('uploads/thumbnails', `thumb-${filename}`);\n    const thumbnailDir = path.dirname(thumbnailPath);\n    if (!fs.existsSync(thumbnailDir)) {\n      fs.mkdirSync(thumbnailDir, { recursive: true });\n    }\n    \n    await sharp(req.file.buffer || req.file.path)\n      .resize(150, 150, {\n        fit: 'cover'\n      })\n      .webp({ quality: 60 })\n      .toFile(thumbnailPath);\n    \n    // Clean up original file if using disk storage\n    if (req.file.path && req.file.path !== outputPath) {\n      fs.unlinkSync(req.file.path);\n    }\n    \n    // Add processed file info to request\n    req.processedFile = {\n      filename: filename,\n      path: outputPath,\n      thumbnail: thumbnailPath,\n      url: `/uploads/processed/${filename}`,\n      thumbnailUrl: `/uploads/thumbnails/thumb-${filename}`\n    };\n    \n    next();\n  } catch (error) {\n    console.error('Image processing error:', error);\n    next(error);\n  }\n};\n\n// Upload with processing\napp.post('/upload/processed', \n  uploadMemory.single('image'),\n  processImage,\n  (req, res) => {\n    if (!req.file) {\n      return res.status(400).json({ error: 'Image file required' });\n    }\n    \n    res.json({\n      message: 'Image processed and uploaded successfully',\n      original: {\n        originalname: req.file.originalname,\n        size: req.file.size\n      },\n      processed: req.processedFile\n    });\n  }\n);\n```\n\n**File Download and Streaming**:\n\n```javascript\n// Secure file download\napp.get('/download/:filename', (req, res) => {\n  const filename = req.params.filename;\n  const filePath = path.join(__dirname, 'uploads', filename);\n  \n  // Check if file exists\n  if (!fs.existsSync(filePath)) {\n    return res.status(404).json({ error: 'File not found' });\n  }\n  \n  // Security check - prevent directory traversal\n  const resolvedPath = path.resolve(filePath);\n  const uploadsPath = path.resolve(__dirname, 'uploads');\n  \n  if (!resolvedPath.startsWith(uploadsPath)) {\n    return res.status(403).json({ error: 'Access denied' });\n  }\n  \n  // Set appropriate headers\n  const stat = fs.statSync(filePath);\n  res.setHeader('Content-Length', stat.size);\n  res.setHeader('Content-Type', 'application/octet-stream');\n  res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n  \n  // Stream file\n  const fileStream = fs.createReadStream(filePath);\n  fileStream.pipe(res);\n});\n\n// File streaming with range support\napp.get('/stream/:filename', (req, res) => {\n  const filename = req.params.filename;\n  const filePath = path.join(__dirname, 'uploads', filename);\n  \n  if (!fs.existsSync(filePath)) {\n    return res.status(404).json({ error: 'File not found' });\n  }\n  \n  const stat = fs.statSync(filePath);\n  const fileSize = stat.size;\n  const range = req.headers.range;\n  \n  if (range) {\n    const parts = range.replace(/bytes=/, \"\").split(\"-\");\n    const start = parseInt(parts[0], 10);\n    const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;\n    const chunksize = (end - start) + 1;\n    \n    const fileStream = fs.createReadStream(filePath, { start, end });\n    \n    res.status(206);\n    res.setHeader('Content-Range', `bytes ${start}-${end}/${fileSize}`);\n    res.setHeader('Accept-Ranges', 'bytes');\n    res.setHeader('Content-Length', chunksize);\n    \n    fileStream.pipe(res);\n  } else {\n    res.setHeader('Content-Length', fileSize);\n    fs.createReadStream(filePath).pipe(res);\n  }\n});\n```\n\n**Error Handling for File Uploads**:\n\n```javascript\n// Global multer error handler\napp.use((error, req, res, next) => {\n  if (error instanceof multer.MulterError) {\n    switch (error.code) {\n      case 'LIMIT_FILE_SIZE':\n        return res.status(400).json({ error: 'File too large' });\n      case 'LIMIT_FILE_COUNT':\n        return res.status(400).json({ error: 'Too many files' });\n      case 'LIMIT_UNEXPECTED_FILE':\n        return res.status(400).json({ error: 'Unexpected field' });\n      default:\n        return res.status(400).json({ error: 'File upload error' });\n    }\n  }\n  \n  if (error.message.includes('File type')) {\n    return res.status(400).json({ error: error.message });\n  }\n  \n  next(error);\n});\n```\n\nThis comprehensive file upload implementation provides secure, scalable, and feature-rich file handling capabilities for Express.js applications.",
      "keywords": ["file uploads", "Multer", "file processing", "image manipulation", "cloud storage", "file validation", "streaming"],
      "difficulty": "medium"
    },
    {
      "id": 8018,
      "tag": "expressjs",
      "question": "How do you implement performance optimization and scaling strategies for Express.js applications in production?",
      "answer": "Performance optimization and scaling for Express.js applications involves multiple strategies including caching, clustering, load balancing, database optimization, and monitoring. Proper implementation ensures applications can handle high traffic and maintain responsiveness.\n\n**Application-Level Optimizations**:\n\n```javascript\nconst express = require('express');\nconst compression = require('compression');\nconst helmet = require('helmet');\nconst cors = require('cors');\nconst app = express();\n\n// Enable gzip compression\napp.use(compression({\n  filter: (req, res) => {\n    if (req.headers['x-no-compression']) {\n      return false;\n    }\n    return compression.filter(req, res);\n  },\n  level: 6,\n  threshold: 1024\n}));\n\n// Security headers with minimal overhead\napp.use(helmet({\n  contentSecurityPolicy: false, // Disable if not needed\n  crossOriginEmbedderPolicy: false\n}));\n\n// Optimized CORS for production\nconst corsOptions = {\n  origin: process.env.ALLOWED_ORIGINS?.split(',') || false,\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true,\n  maxAge: 86400 // Cache preflight for 24 hours\n};\napp.use(cors(corsOptions));\n\n// Efficient JSON parsing with limits\napp.use(express.json({ \n  limit: '10mb',\n  type: 'application/json'\n}));\napp.use(express.urlencoded({ \n  extended: true, \n  limit: '10mb'\n}));\n```\n\n**Caching Strategies**:\n\n```bash\nnpm install redis ioredis node-cache\n```\n\n```javascript\nconst Redis = require('ioredis');\nconst NodeCache = require('node-cache');\n\n// Redis for distributed caching\nconst redis = new Redis({\n  host: process.env.REDIS_HOST || 'localhost',\n  port: process.env.REDIS_PORT || 6379,\n  retryDelayOnFailover: 100,\n  maxRetriesPerRequest: 3,\n  lazyConnect: true\n});\n\n// In-memory cache for frequently accessed data\nconst memoryCache = new NodeCache({ \n  stdTTL: 300, // 5 minutes default TTL\n  checkperiod: 60 // Check for expired keys every minute\n});\n\n// Cache middleware factory\nconst cacheMiddleware = (ttl = 300, useRedis = false) => {\n  return async (req, res, next) => {\n    const key = `cache:${req.method}:${req.originalUrl}`;\n    \n    try {\n      let cachedData;\n      \n      if (useRedis) {\n        cachedData = await redis.get(key);\n        if (cachedData) {\n          return res.json(JSON.parse(cachedData));\n        }\n      } else {\n        cachedData = memoryCache.get(key);\n        if (cachedData) {\n          return res.json(cachedData);\n        }\n      }\n      \n      // Store original send method\n      const originalSend = res.send;\n      \n      res.send = function(data) {\n        // Cache successful responses\n        if (res.statusCode === 200) {\n          if (useRedis) {\n            redis.setex(key, ttl, data);\n          } else {\n            memoryCache.set(key, JSON.parse(data), ttl);\n          }\n        }\n        \n        originalSend.call(this, data);\n      };\n      \n      next();\n    } catch (error) {\n      console.error('Cache middleware error:', error);\n      next();\n    }\n  };\n};\n\n// Usage examples\napp.get('/api/users', cacheMiddleware(600, true), getUsersHandler);\napp.get('/api/posts', cacheMiddleware(300, false), getPostsHandler);\n```\n\n**Database Connection Optimization**:\n\n```javascript\n// MongoDB connection pooling\nconst mongoose = require('mongoose');\n\nconst mongooseOptions = {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  maxPoolSize: 10, // Maximum connections\n  minPoolSize: 5,  // Minimum connections\n  maxIdleTimeMS: 30000, // Close connections after 30s of inactivity\n  serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5s\n  socketTimeoutMS: 45000, // Close sockets after 45s of inactivity\n  bufferCommands: false, // Disable mongoose buffering\n  bufferMaxEntries: 0 // Disable mongoose buffering\n};\n\n// PostgreSQL connection pooling with Sequelize\nconst { Sequelize } = require('sequelize');\n\nconst sequelizeOptions = {\n  pool: {\n    max: 20,\n    min: 5,\n    acquire: 60000,\n    idle: 10000\n  },\n  logging: false, // Disable SQL logging in production\n  dialectOptions: {\n    ssl: process.env.NODE_ENV === 'production'\n  }\n};\n\n// Database query optimization\nconst optimizedUserQuery = async (req, res) => {\n  try {\n    const { page = 1, limit = 10 } = req.query;\n    \n    // Use lean() for read-only data (MongoDB)\n    const users = await User\n      .find({}, 'name email createdAt') // Select only needed fields\n      .lean() // Return plain JavaScript objects\n      .limit(limit * 1)\n      .skip((page - 1) * limit)\n      .sort({ createdAt: -1 })\n      .exec();\n    \n    res.json(users);\n  } catch (error) {\n    res.status(500).json({ error: 'Query failed' });\n  }\n};\n```\n\n**Clustering and Process Management**:\n\n```javascript\n// cluster.js\nconst cluster = require('cluster');\nconst numCPUs = require('os').cpus().length;\n\nif (cluster.isMaster) {\n  console.log(`Master ${process.pid} is running`);\n  \n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  // Restart workers that die\n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork();\n  });\n  \n  // Graceful shutdown\n  process.on('SIGTERM', () => {\n    console.log('SIGTERM received. Shutting down gracefully.');\n    \n    for (const id in cluster.workers) {\n      cluster.workers[id].kill();\n    }\n  });\n} else {\n  require('./app.js');\n  console.log(`Worker ${process.pid} started`);\n}\n```\n\n**HTTP/2 and Advanced Features**:\n\n```javascript\n// http2.js\nconst http2 = require('http2');\nconst fs = require('fs');\n\n// HTTP/2 server with Express\nconst options = {\n  key: fs.readFileSync('path/to/private-key.pem'),\n  cert: fs.readFileSync('path/to/certificate.pem')\n};\n\nconst server = http2.createSecureServer(options, app);\n\n// Server push for critical resources\napp.get('/', (req, res) => {\n  // Push critical CSS and JS files\n  if (req.httpVersion === '2.0') {\n    res.push('/css/critical.css');\n    res.push('/js/critical.js');\n  }\n  \n  res.render('index');\n});\n\nserver.listen(443, () => {\n  console.log('HTTP/2 server running on port 443');\n});\n```\n\n**Load Balancing with Nginx**:\n\n```nginx\n# nginx.conf\nupstream nodejs_backend {\n    least_conn;\n    server localhost:3000 weight=3;\n    server localhost:3001 weight=3;\n    server localhost:3002 weight=3;\n    server localhost:3003 weight=1; # Backup server\n    keepalive 32;\n}\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n    \n    # Gzip compression\n    gzip on;\n    gzip_comp_level 6;\n    gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;\n    \n    # Static file serving\n    location /static/ {\n        alias /var/www/static/;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n    \n    # API routes\n    location /api/ {\n        proxy_pass http://nodejs_backend;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_cache_bypass $http_upgrade;\n        \n        # Timeouts\n        proxy_connect_timeout 5s;\n        proxy_send_timeout 60s;\n        proxy_read_timeout 60s;\n    }\n    \n    # Rate limiting\n    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n    \n    location /api/auth/ {\n        limit_req zone=api burst=5 nodelay;\n        proxy_pass http://nodejs_backend;\n    }\n}\n```\n\n**Monitoring and Profiling**:\n\n```bash\nnpm install clinic autocannon prom-client\n```\n\n```javascript\n// monitoring.js\nconst promClient = require('prom-client');\n\n// Create metrics registry\nconst register = new promClient.Registry();\n\n// Default metrics\npromClient.collectDefaultMetrics({ register });\n\n// Custom metrics\nconst httpRequestDuration = new promClient.Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'HTTP request duration in seconds',\n  labelNames: ['method', 'route', 'status'],\n  buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10]\n});\n\nconst httpRequestCount = new promClient.Counter({\n  name: 'http_requests_total',\n  help: 'Total number of HTTP requests',\n  labelNames: ['method', 'route', 'status']\n});\n\nregister.registerMetric(httpRequestDuration);\nregister.registerMetric(httpRequestCount);\n\n// Monitoring middleware\nconst monitoringMiddleware = (req, res, next) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = (Date.now() - start) / 1000;\n    const route = req.route ? req.route.path : req.path;\n    \n    httpRequestDuration\n      .labels(req.method, route, res.statusCode)\n      .observe(duration);\n      \n    httpRequestCount\n      .labels(req.method, route, res.statusCode)\n      .inc();\n  });\n  \n  next();\n};\n\napp.use(monitoringMiddleware);\n\n// Metrics endpoint\napp.get('/metrics', async (req, res) => {\n  res.set('Content-Type', register.contentType);\n  const metrics = await register.metrics();\n  res.send(metrics);\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'ok',\n    timestamp: new Date().toISOString(),\n    uptime: process.uptime(),\n    memory: process.memoryUsage(),\n    cpu: process.cpuUsage()\n  });\n});\n```\n\n**Performance Testing Script**:\n\n```javascript\n// performance-test.js\nconst autocannon = require('autocannon');\n\nconst runLoadTest = async () => {\n  const result = await autocannon({\n    url: 'http://localhost:3000',\n    connections: 100,\n    duration: 30,\n    requests: [\n      {\n        method: 'GET',\n        path: '/api/users'\n      },\n      {\n        method: 'POST',\n        path: '/api/users',\n        headers: {\n          'content-type': 'application/json'\n        },\n        body: JSON.stringify({ name: 'Test User', email: 'test@example.com' })\n      }\n    ]\n  });\n  \n  console.log(result);\n};\n\nrunLoadTest();\n```\n\nThese optimization strategies ensure Express.js applications can handle production-level traffic with optimal performance, reliability, and scalability.",
      "keywords": ["performance optimization", "clustering", "caching", "load balancing", "monitoring", "scaling", "production deployment"],
      "difficulty": "hard"
    },
    {
      "id": 8019,
      "tag": "expressjs",
      "question": "How do you implement advanced security patterns, rate limiting, and protection against common vulnerabilities in Express.js applications?",
      "answer": "Advanced security in Express.js requires implementing multiple layers of protection including authentication, authorization, input validation, rate limiting, and protection against common attacks like XSS, CSRF, SQL injection, and DDoS attacks.\n\n**Comprehensive Security Middleware Stack**:\n\n```bash\nnpm install helmet express-rate-limit express-validator cors express-brute express-slow-down csurf express-session connect-redis bcryptjs jsonwebtoken\n```\n\n**Advanced Helmet Configuration**:\n\n```javascript\nconst helmet = require('helmet');\nconst express = require('express');\nconst app = express();\n\n// Comprehensive helmet configuration\napp.use(helmet({\n  // Content Security Policy\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\", 'fonts.googleapis.com', 'cdnjs.cloudflare.com'],\n      fontSrc: [\"'self'\", 'fonts.gstatic.com', 'cdnjs.cloudflare.com'],\n      scriptSrc: [\"'self'\", 'cdnjs.cloudflare.com'],\n      imgSrc: [\"'self'\", 'data:', 'https:', '*.amazonaws.com'],\n      connectSrc: [\"'self'\", 'api.example.com'],\n      frameSrc: [\"'none'\"],\n      objectSrc: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n    reportOnly: false\n  },\n  \n  // HTTP Strict Transport Security\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true\n  },\n  \n  // X-Frame-Options\n  frameguard: {\n    action: 'deny'\n  },\n  \n  // X-Content-Type-Options\n  noSniff: true,\n  \n  // Referrer Policy\n  referrerPolicy: {\n    policy: 'strict-origin-when-cross-origin'\n  },\n  \n  // Permissions Policy\n  permissionsPolicy: {\n    features: {\n      geolocation: ['self'],\n      microphone: ['none'],\n      camera: ['none'],\n      payment: ['self'],\n      usb: ['none']\n    }\n  }\n}));\n```\n\n**Advanced Rate Limiting and DDoS Protection**:\n\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst slowDown = require('express-slow-down');\nconst ExpressBrute = require('express-brute');\nconst RedisStore = require('express-brute-redis');\nconst redis = require('redis');\n\n// Redis setup for distributed rate limiting\nconst redisClient = redis.createClient({\n  host: process.env.REDIS_HOST,\n  port: process.env.REDIS_PORT\n});\n\nconst bruteStore = new RedisStore({\n  client: redisClient,\n  prefix: 'brute:'\n});\n\n// Global rate limiting\nconst globalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 1000, // Limit each IP to 1000 requests per windowMs\n  message: {\n    error: 'Too many requests from this IP, please try again later.',\n    retryAfter: 900\n  },\n  standardHeaders: true,\n  legacyHeaders: false,\n  skip: (req) => {\n    // Skip rate limiting for health checks\n    return req.path === '/health' || req.path === '/metrics';\n  },\n  onLimitReached: (req, res, options) => {\n    console.log(`Rate limit exceeded for IP: ${req.ip}`);\n    // Additional logging or alerting logic here\n  }\n});\n\n// API-specific rate limiting\nconst apiLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 500,\n  message: { error: 'API rate limit exceeded' }\n});\n\n// Authentication endpoint rate limiting\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 10,\n  skipSuccessfulRequests: true,\n  message: { error: 'Too many authentication attempts' }\n});\n\n// Progressive slowdown for repeated requests\nconst speedLimiter = slowDown({\n  windowMs: 15 * 60 * 1000,\n  delayAfter: 100, // Allow 100 requests per windowMs at full speed\n  delayMs: 500, // Add 500ms delay after delayAfter is reached\n  maxDelayMs: 20000 // Maximum delay of 20 seconds\n});\n\n// Brute force protection for login attempts\nconst bruteForceProtection = new ExpressBrute(bruteStore, {\n  freeRetries: 5,\n  minWait: 5 * 60 * 1000, // 5 minutes\n  maxWait: 60 * 60 * 1000, // 1 hour\n  failCallback: (req, res, next, nextValidRequestDate) => {\n    res.status(429).json({\n      error: 'Too many failed attempts',\n      nextValidRequestDate: nextValidRequestDate\n    });\n  }\n});\n\n// Apply rate limiting\napp.use(globalLimiter);\napp.use('/api', speedLimiter, apiLimiter);\napp.use('/auth', authLimiter);\n```\n\n**Advanced Input Validation and Sanitization**:\n\n```javascript\nconst { body, query, param, validationResult, matchedData } = require('express-validator');\nconst DOMPurify = require('isomorphic-dompurify');\nconst xss = require('xss');\n\n// XSS Protection utility\nconst sanitizeHtml = (html) => {\n  return xss(html, {\n    whiteList: {\n      p: [],\n      br: [],\n      strong: [],\n      em: [],\n      ul: [],\n      ol: [],\n      li: []\n    },\n    stripIgnoreTag: true,\n    stripIgnoreTagBody: ['script']\n  });\n};\n\n// Advanced validation schemas\nconst userValidation = {\n  register: [\n    body('email')\n      .isEmail()\n      .normalizeEmail()\n      .isLength({ max: 100 })\n      .custom(async (email) => {\n        const existingUser = await User.findOne({ email });\n        if (existingUser) {\n          throw new Error('Email already registered');\n        }\n        return true;\n      }),\n      \n    body('password')\n      .isLength({ min: 8, max: 128 })\n      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n      .withMessage('Password must contain uppercase, lowercase, number, and special character'),\n      \n    body('firstName')\n      .trim()\n      .isLength({ min: 2, max: 50 })\n      .matches(/^[a-zA-Z\\s'-]+$/)\n      .customSanitizer((value) => sanitizeHtml(value)),\n      \n    body('lastName')\n      .trim()\n      .isLength({ min: 2, max: 50 })\n      .matches(/^[a-zA-Z\\s'-]+$/)\n      .customSanitizer((value) => sanitizeHtml(value)),\n      \n    body('dateOfBirth')\n      .optional()\n      .isDate()\n      .custom((date) => {\n        const age = new Date().getFullYear() - new Date(date).getFullYear();\n        if (age < 13 || age > 120) {\n          throw new Error('Invalid age');\n        }\n        return true;\n      }),\n      \n    body('phone')\n      .optional()\n      .isMobilePhone('any')\n      .customSanitizer((value) => value.replace(/[^\\d+]/g, ''))\n  ],\n  \n  updateProfile: [\n    body('bio')\n      .optional()\n      .isLength({ max: 500 })\n      .customSanitizer((value) => sanitizeHtml(value)),\n      \n    body('website')\n      .optional()\n      .isURL({\n        protocols: ['http', 'https'],\n        require_protocol: true\n      })\n  ]\n};\n\n// Validation error handler\nconst handleValidationErrors = (req, res, next) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({\n      error: 'Validation failed',\n      details: errors.array().map(err => ({\n        field: err.path,\n        message: err.msg,\n        value: err.value\n      }))\n    });\n  }\n  \n  // Only pass validated data to next middleware\n  req.validatedData = matchedData(req);\n  next();\n};\n```\n\n**CSRF Protection Implementation**:\n\n```javascript\nconst csrf = require('csurf');\nconst session = require('express-session');\nconst RedisStore = require('connect-redis')(session);\n\n// Session configuration with security settings\nconst sessionConfig = {\n  store: new RedisStore({ client: redisClient }),\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  name: 'sessionId', // Don't use default name\n  cookie: {\n    secure: process.env.NODE_ENV === 'production',\n    httpOnly: true,\n    maxAge: 30 * 60 * 1000, // 30 minutes\n    sameSite: 'strict'\n  },\n  rolling: true // Reset expiration on activity\n};\n\napp.use(session(sessionConfig));\n\n// CSRF protection\nconst csrfProtection = csrf({\n  cookie: {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'strict'\n  },\n  ignoreMethods: ['GET', 'HEAD', 'OPTIONS'],\n  value: (req) => {\n    return req.body._csrf || req.query._csrf || req.headers['x-csrf-token'];\n  }\n});\n\n// Apply CSRF protection to state-changing operations\napp.use(['/api/users', '/api/posts', '/auth'], csrfProtection);\n\n// Provide CSRF token to client\napp.get('/csrf-token', csrfProtection, (req, res) => {\n  res.json({ csrfToken: req.csrfToken() });\n});\n```\n\n**Advanced Authentication and Authorization**:\n\n```javascript\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\nconst crypto = require('crypto');\n\n// JWT Configuration\nconst jwtConfig = {\n  accessToken: {\n    secret: process.env.JWT_ACCESS_SECRET,\n    expiresIn: '15m'\n  },\n  refreshToken: {\n    secret: process.env.JWT_REFRESH_SECRET,\n    expiresIn: '7d'\n  }\n};\n\n// Advanced authentication middleware\nconst authenticateToken = async (req, res, next) => {\n  try {\n    const authHeader = req.headers.authorization;\n    const token = authHeader && authHeader.split(' ')[1];\n    \n    if (!token) {\n      return res.status(401).json({ error: 'Access token required' });\n    }\n    \n    // Verify token\n    const decoded = jwt.verify(token, jwtConfig.accessToken.secret);\n    \n    // Check if user still exists and is active\n    const user = await User.findById(decoded.userId);\n    if (!user || !user.isActive) {\n      return res.status(401).json({ error: 'User not found or inactive' });\n    }\n    \n    // Check if password changed after token was issued\n    if (user.passwordChangedAt > decoded.iat) {\n      return res.status(401).json({ error: 'Token invalid due to password change' });\n    }\n    \n    req.user = user;\n    next();\n  } catch (error) {\n    if (error.name === 'TokenExpiredError') {\n      return res.status(401).json({ error: 'Token expired' });\n    }\n    return res.status(403).json({ error: 'Invalid token' });\n  }\n};\n\n// Role-based authorization\nconst authorize = (...roles) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Authentication required' });\n    }\n    \n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Insufficient permissions' });\n    }\n    \n    next();\n  };\n};\n\n// Resource-based authorization\nconst authorizeResource = (resourceModel) => {\n  return async (req, res, next) => {\n    try {\n      const resourceId = req.params.id;\n      const resource = await resourceModel.findById(resourceId);\n      \n      if (!resource) {\n        return res.status(404).json({ error: 'Resource not found' });\n      }\n      \n      // Check if user owns the resource or is admin\n      if (resource.userId.toString() !== req.user.id && req.user.role !== 'admin') {\n        return res.status(403).json({ error: 'Access denied' });\n      }\n      \n      req.resource = resource;\n      next();\n    } catch (error) {\n      res.status(500).json({ error: 'Authorization check failed' });\n    }\n  };\n};\n```\n\n**Security Monitoring and Logging**:\n\n```javascript\nconst winston = require('winston');\n\n// Security-focused logger\nconst securityLogger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.File({ \n      filename: 'logs/security.log',\n      level: 'warn'\n    }),\n    new winston.transports.File({ \n      filename: 'logs/security-error.log',\n      level: 'error'\n    })\n  ]\n});\n\n// Security monitoring middleware\nconst securityMonitoring = (req, res, next) => {\n  // Log suspicious activities\n  const suspiciousPatterns = [\n    /\\.\\.\\//g, // Directory traversal\n    /<script/gi, // XSS attempts\n    /union.*select/gi, // SQL injection\n    /javascript:/gi, // JavaScript protocol\n    /eval\\(/gi // Code injection\n  ];\n  \n  const requestData = JSON.stringify({\n    url: req.url,\n    body: req.body,\n    query: req.query,\n    headers: req.headers\n  });\n  \n  suspiciousPatterns.forEach(pattern => {\n    if (pattern.test(requestData)) {\n      securityLogger.warn('Suspicious request detected', {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        url: req.url,\n        method: req.method,\n        pattern: pattern.toString(),\n        data: requestData\n      });\n    }\n  });\n  \n  next();\n};\n\n// Failed authentication monitoring\nconst monitorFailedAuth = (req, res, next) => {\n  const originalSend = res.send;\n  \n  res.send = function(data) {\n    if (res.statusCode === 401 || res.statusCode === 403) {\n      securityLogger.warn('Authentication/Authorization failure', {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        url: req.url,\n        method: req.method,\n        statusCode: res.statusCode,\n        timestamp: new Date().toISOString()\n      });\n    }\n    \n    originalSend.call(this, data);\n  };\n  \n  next();\n};\n\napp.use(securityMonitoring);\napp.use(monitorFailedAuth);\n```\n\n**Complete Security Implementation**:\n\n```javascript\n// Apply all security middleware\napp.use('/api/admin', \n  bruteForceProtection.prevent,\n  authenticateToken,\n  authorize('admin')\n);\n\napp.use('/api/users/:id',\n  authenticateToken,\n  authorizeResource(User)\n);\n\napp.post('/auth/login',\n  bruteForceProtection.prevent,\n  userValidation.login,\n  handleValidationErrors,\n  loginHandler\n);\n\napp.post('/api/users',\n  csrfProtection,\n  userValidation.register,\n  handleValidationErrors,\n  createUserHandler\n);\n```\n\nThis comprehensive security implementation protects Express.js applications against modern threats while maintaining usability and performance.",
      "keywords": ["security patterns", "rate limiting", "CSRF protection", "XSS prevention", "authentication", "authorization", "input validation", "security monitoring"],
      "difficulty": "hard"
    }
  ]
}