{
  "technology": "flask",
  "questions": [
    {
      "id": 11000,
      "tag": "flask",
      "question": "What is Flask and what is its philosophy as a micro-framework?",
      "answer": "Flask is a lightweight web application framework written in Python. It's classified as a 'micro-framework' because it provides only the core components needed to build web applications, without making assumptions about how you want to implement other functionality.\n\n**Core Philosophy:**\n- **Minimalist Core**: Flask provides only essential components (routing, request handling, templating) out of the box\n- **Flexibility**: Developers choose their own tools for databases, authentication, form validation, etc.\n- **Extensibility**: Rich ecosystem of extensions for additional functionality\n- **Explicit over Implicit**: Clear, readable code with explicit configurations\n\n**Basic Flask Application:**\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello_world():\n    return 'Hello, World!'\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n**Key Characteristics:**\n- **WSGI Compliant**: Works with any WSGI server\n- **Jinja2 Templating**: Built-in template engine\n- **Werkzeug Integration**: Comprehensive WSGI utility library\n- **Blueprint Support**: Modular application structure\n- **Development Server**: Built-in server for testing\n\nFlask follows the principle of being 'batteries not included' - it gives you the foundation and lets you choose the best tools for your specific needs, making it ideal for both simple applications and complex, customized solutions.",
      "keywords": ["flask", "micro-framework", "python", "web framework", "minimalist", "WSGI", "werkzeug", "jinja2"],
      "difficulty": "easy"
    },
    {
      "id": 11001,
      "tag": "flask",
      "question": "How does routing work in Flask and what are the different ways to define routes?",
      "answer": "Flask routing maps URLs to Python functions using decorators or the `add_url_rule()` method. Routes define which function handles specific URL patterns.\n\n**Basic Routing with Decorators:**\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Home Page'\n\n@app.route('/about')\ndef about():\n    return 'About Page'\n```\n\n**Dynamic Routes with Variables:**\n```python\n@app.route('/user/<username>')\ndef user_profile(username):\n    return f'User: {username}'\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    return f'Post ID: {post_id}'\n\n# Variable types: string (default), int, float, path, uuid\n```\n\n**HTTP Methods:**\n```python\n@app.route('/submit', methods=['GET', 'POST'])\ndef submit():\n    if request.method == 'POST':\n        return 'Form submitted'\n    return 'Show form'\n```\n\n**Alternative Route Registration:**\n```python\ndef contact():\n    return 'Contact Page'\n\napp.add_url_rule('/contact', 'contact', contact)\n```\n\n**Route Options:**\n- **defaults**: Default values for variables\n- **strict_slashes**: Control trailing slash behavior\n- **subdomain**: Match specific subdomains\n\nRouting is central to Flask applications, providing clean URL structures and RESTful API endpoints.",
      "keywords": ["flask", "routing", "decorators", "URL", "HTTP methods", "dynamic routes", "variables"],
      "difficulty": "easy"
    },
    {
      "id": 11002,
      "tag": "flask",
      "question": "How does Flask handle requests and responses? Explain the request and response objects.",
      "answer": "Flask provides global request and response objects that contain all HTTP request data and allow you to construct HTTP responses.\n\n**Request Object:**\nThe `request` object contains incoming HTTP request data:\n\n```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/demo', methods=['GET', 'POST'])\ndef demo():\n    # Request method\n    method = request.method\n    \n    # URL parameters\n    name = request.args.get('name', 'Guest')\n    \n    # Form data\n    if request.method == 'POST':\n        email = request.form['email']\n    \n    # JSON data\n    if request.is_json:\n        data = request.get_json()\n    \n    # Headers\n    user_agent = request.headers.get('User-Agent')\n    \n    # Files\n    if 'file' in request.files:\n        file = request.files['file']\n    \n    return f'Hello {name}'\n```\n\n**Response Creation:**\n```python\nfrom flask import make_response, jsonify\n\n@app.route('/api/data')\ndef api_data():\n    # Simple string response\n    return 'Hello World'  # Default 200 status\n    \n    # Tuple response (content, status, headers)\n    return 'Not Found', 404\n    \n    # JSON response\n    return jsonify({'status': 'success', 'data': []})\n    \n    # Custom response object\n    resp = make_response('Custom response')\n    resp.headers['X-Custom-Header'] = 'Value'\n    resp.set_cookie('session_id', '12345')\n    return resp\n```\n\n**Key Request Properties:**\n- `request.method`, `request.url`, `request.path`\n- `request.args` (URL parameters), `request.form` (form data)\n- `request.json`, `request.files`, `request.headers`\n- `request.cookies`, `request.remote_addr`\n\nFlask's request/response handling provides a clean, intuitive interface for web development.",
      "keywords": ["flask", "request", "response", "HTTP", "form data", "JSON", "headers", "cookies"],
      "difficulty": "easy"
    },
    {
      "id": 11003,
      "tag": "flask",
      "question": "How do templates work in Flask with Jinja2? Provide examples of template usage.",
      "answer": "Flask uses Jinja2 as its default templating engine, allowing you to separate HTML structure from Python logic and create dynamic web pages.\n\n**Basic Template Setup:**\n\n**Directory Structure:**\n```\napp/\n├── app.py\n└── templates/\n    ├── base.html\n    └── index.html\n```\n\n**Flask Application:**\n```python\nfrom flask import Flask, render_template\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    user = {'name': 'John', 'age': 30}\n    items = ['Apple', 'Banana', 'Orange']\n    return render_template('index.html', user=user, items=items)\n```\n\n**Base Template (base.html):**\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>{% block title %}My App{% endblock %}</title>\n</head>\n<body>\n    <nav>\n        <a href=\"{{ url_for('index') }}\">Home</a>\n    </nav>\n    <main>\n        {% block content %}{% endblock %}\n    </main>\n</body>\n</html>\n```\n\n**Child Template (index.html):**\n```html\n{% extends \"base.html\" %}\n\n{% block title %}Welcome{% endblock %}\n\n{% block content %}\n<h1>Hello {{ user.name }}!</h1>\n<p>Age: {{ user.age }}</p>\n\n<ul>\n{% for item in items %}\n    <li>{{ item }}</li>\n{% endfor %}\n</ul>\n\n{% if user.age >= 18 %}\n    <p>You are an adult</p>\n{% else %}\n    <p>You are a minor</p>\n{% endif %}\n{% endblock %}\n```\n\n**Template Features:**\n- **Variables**: `{{ variable }}`\n- **Control Structures**: `{% if %}`, `{% for %}`\n- **Template Inheritance**: `{% extends %}`, `{% block %}`\n- **Filters**: `{{ name|upper }}`, `{{ price|round(2) }}`\n- **Functions**: `{{ url_for('route_name') }}`\n\nJinja2 provides powerful template features while maintaining clean separation between presentation and logic.",
      "keywords": ["flask", "jinja2", "templates", "template inheritance", "filters", "url_for", "render_template"],
      "difficulty": "easy"
    },
    {
      "id": 11004,
      "tag": "flask",
      "question": "How does Flask serve static files? Explain static file handling and organization.",
      "answer": "Flask automatically serves static files (CSS, JavaScript, images) from a designated static folder and provides utilities for generating URLs to these files.\n\n**Default Static File Structure:**\n```\napp/\n├── app.py\n├── static/\n│   ├── css/\n│   │   └── style.css\n│   ├── js/\n│   │   └── app.js\n│   └── images/\n│       └── logo.png\n└── templates/\n    └── index.html\n```\n\n**Basic Flask Setup:**\n```python\nfrom flask import Flask\n\n# Flask automatically looks for 'static' folder\napp = Flask(__name__)\n\n# Custom static folder\n# app = Flask(__name__, static_folder='assets')\n\n# Custom static URL path\n# app = Flask(__name__, static_url_path='/files')\n```\n\n**Accessing Static Files in Templates:**\n```html\n<!-- Using url_for() - recommended -->\n<link rel=\"stylesheet\" href=\"{{ url_for('static', filename='css/style.css') }}\">\n<script src=\"{{ url_for('static', filename='js/app.js') }}\"></script>\n<img src=\"{{ url_for('static', filename='images/logo.png') }}\" alt=\"Logo\">\n\n<!-- Direct path - not recommended -->\n<link rel=\"stylesheet\" href=\"/static/css/style.css\">\n```\n\n**Generating Static URLs in Python:**\n```python\nfrom flask import url_for\n\n@app.route('/page')\ndef page():\n    css_url = url_for('static', filename='css/style.css')\n    return f'<link rel=\"stylesheet\" href=\"{css_url}\">\n```\n\n**Custom Static File Handling:**\n```python\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n```\n\n**Benefits of url_for():**\n- **URL Reversing**: Automatically generates correct URLs\n- **Cache Busting**: Can append version parameters\n- **Flexibility**: Works with custom static configurations\n\n**Production Considerations:**\n- Use web servers (Nginx, Apache) to serve static files in production\n- Enable caching headers for better performance\n- Consider CDN for large applications\n\nFlask's static file handling provides a simple yet flexible system for managing web assets.",
      "keywords": ["flask", "static files", "url_for", "CSS", "JavaScript", "images", "assets", "static folder"],
      "difficulty": "easy"
    },
    {
      "id": 11005,
      "tag": "flask",
      "question": "Explain URL building and redirects in Flask. How do you generate URLs and redirect users?",
      "answer": "Flask provides powerful URL building capabilities through `url_for()` and redirect functionality through `redirect()`, enabling dynamic URL generation and user navigation control.\n\n**URL Building with url_for():**\n```python\nfrom flask import Flask, url_for, redirect, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Home Page'\n\n@app.route('/user/<username>')\ndef user_profile(username):\n    return f'User: {username}'\n\n@app.route('/admin')\ndef admin():\n    return 'Admin Panel'\n\n@app.route('/demo')\ndef demo_urls():\n    # Generate URLs for routes\n    home_url = url_for('index')\n    user_url = url_for('user_profile', username='john')\n    admin_url = url_for('admin')\n    \n    # URLs with query parameters\n    search_url = url_for('index', q='python', page=2)\n    # Results in: /?q=python&page=2\n    \n    return f'''\n    <a href=\"{home_url}\">Home</a><br>\n    <a href=\"{user_url}\">User Profile</a><br>\n    <a href=\"{admin_url}\">Admin</a><br>\n    <a href=\"{search_url}\">Search</a>\n    '''\n```\n\n**Redirects:**\n```python\n@app.route('/old-page')\ndef old_page():\n    # Redirect to another route\n    return redirect(url_for('index'))\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        # Process login\n        if valid_login():\n            return redirect(url_for('admin'))\n        else:\n            return redirect(url_for('login', error='invalid'))\n    return 'Login Form'\n\n@app.route('/external')\ndef external_redirect():\n    # External redirect\n    return redirect('https://www.google.com')\n\n@app.route('/conditional')\ndef conditional_redirect():\n    # Conditional redirect with status code\n    return redirect(url_for('admin'), code=302)  # Temporary redirect\n```\n\n**Template Usage:**\n```html\n<!-- In templates -->\n<a href=\"{{ url_for('index') }}\">Home</a>\n<a href=\"{{ url_for('user_profile', username='alice') }}\">Alice's Profile</a>\n\n<form action=\"{{ url_for('login') }}\" method=\"post\">\n    <!-- form fields -->\n</form>\n```\n\n**Benefits:**\n- **Maintainability**: URLs update automatically when routes change\n- **Consistency**: Prevents broken links\n- **Flexibility**: Easy to modify URL structures\n- **Security**: Prevents hardcoded URLs in templates\n\nURL building and redirects are essential for creating maintainable Flask applications with proper navigation flow.",
      "keywords": ["flask", "url_for", "redirect", "URL building", "navigation", "routes", "query parameters"],
      "difficulty": "easy"
    },
    {
      "id": 11006,
      "tag": "flask",
      "question": "What are Flask Blueprints and how do they help in creating modular applications?",
      "answer": "Flask Blueprints are a way to organize Flask applications into modular components. They allow you to group related routes, templates, and static files, making large applications more maintainable and reusable.\n\n**Blueprint Structure:**\n```\napp/\n├── app.py\n├── auth/\n│   ├── __init__.py\n│   ├── routes.py\n│   └── templates/\n│       └── login.html\n├── blog/\n│   ├── __init__.py\n│   ├── routes.py\n│   └── templates/\n│       └── post.html\n└── main/\n    ├── __init__.py\n    └── routes.py\n```\n\n**Creating a Blueprint:**\n```python\n# auth/routes.py\nfrom flask import Blueprint, render_template, request, redirect, url_for\n\nauth_bp = Blueprint('auth', __name__, \n                   template_folder='templates',\n                   static_folder='static',\n                   url_prefix='/auth')\n\n@auth_bp.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        # Handle login logic\n        return redirect(url_for('main.index'))\n    return render_template('login.html')\n\n@auth_bp.route('/logout')\ndef logout():\n    # Handle logout logic\n    return redirect(url_for('auth.login'))\n\n@auth_bp.route('/register')\ndef register():\n    return render_template('register.html')\n```\n\n**Registering Blueprints:**\n```python\n# app.py\nfrom flask import Flask\nfrom auth.routes import auth_bp\nfrom blog.routes import blog_bp\nfrom main.routes import main_bp\n\napp = Flask(__name__)\n\n# Register blueprints\napp.register_blueprint(auth_bp)\napp.register_blueprint(blog_bp, url_prefix='/blog')\napp.register_blueprint(main_bp)\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n**Blueprint Features:**\n```python\n# blog/routes.py\nblog_bp = Blueprint('blog', __name__)\n\n@blog_bp.route('/posts')\ndef posts():\n    return 'All Posts'\n\n@blog_bp.route('/post/<int:id>')\ndef post(id):\n    return f'Post {id}'\n\n# Before request hook for blueprint\n@blog_bp.before_request\ndef before_blog_request():\n    # Runs before each request to blog routes\n    pass\n\n# Error handler for blueprint\n@blog_bp.errorhandler(404)\ndef page_not_found(error):\n    return 'Blog page not found', 404\n```\n\n**Benefits:**\n- **Organization**: Logical grouping of related functionality\n- **Reusability**: Blueprints can be shared across projects\n- **Team Development**: Different teams can work on separate blueprints\n- **Namespace Management**: Avoid route name conflicts\n- **Template Organization**: Blueprint-specific templates and static files\n\n**URL Generation with Blueprints:**\n```python\n# Cross-blueprint URL generation\nurl_for('auth.login')      # /auth/login\nurl_for('blog.posts')      # /blog/posts\nurl_for('main.index')      # /\n```\n\nBlueprints are essential for building scalable Flask applications, providing clean separation of concerns and enabling modular architecture patterns.",
      "keywords": ["flask", "blueprints", "modular", "organization", "scalability", "url_prefix", "routes", "templates"],
      "difficulty": "medium"
    },
    {
      "id": 11007,
      "tag": "flask",
      "question": "How does session management work in Flask? Explain sessions, cookies, and security considerations.",
      "answer": "Flask provides built-in session management using secure cookies to store user data across requests. Sessions allow you to maintain state between HTTP requests for individual users.\n\n**Basic Session Setup:**\n```python\nfrom flask import Flask, session, request, redirect, url_for\n\napp = Flask(__name__)\n\n# Secret key required for session encryption\napp.secret_key = 'your-secret-key-change-in-production'\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return f'Logged in as {session[\"username\"]}'\n    return 'You are not logged in'\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form['username']\n        # Validate credentials (simplified)\n        if valid_credentials(username):\n            session['username'] = username\n            session['user_id'] = get_user_id(username)\n            return redirect(url_for('index'))\n    return render_login_form()\n\n@app.route('/logout')\ndef logout():\n    session.pop('username', None)\n    session.pop('user_id', None)\n    # Or clear all session data\n    # session.clear()\n    return redirect(url_for('index'))\n```\n\n**Session Configuration:**\n```python\nfrom datetime import timedelta\n\n# Session configuration\napp.config.update(\n    SECRET_KEY='your-very-secret-key',\n    SESSION_COOKIE_SECURE=True,      # HTTPS only\n    SESSION_COOKIE_HTTPONLY=True,    # No JavaScript access\n    SESSION_COOKIE_SAMESITE='Lax',   # CSRF protection\n    PERMANENT_SESSION_LIFETIME=timedelta(hours=2)\n)\n\n@app.route('/set_permanent')\ndef set_permanent():\n    session.permanent = True  # Use PERMANENT_SESSION_LIFETIME\n    session['data'] = 'persistent_data'\n    return 'Session set as permanent'\n```\n\n**Working with Session Data:**\n```python\n@app.route('/profile')\ndef profile():\n    # Check if user is logged in\n    if 'user_id' not in session:\n        return redirect(url_for('login'))\n    \n    # Store complex data\n    session['preferences'] = {\n        'theme': 'dark',\n        'language': 'en',\n        'notifications': True\n    }\n    \n    # Get session data with defaults\n    theme = session.get('theme', 'light')\n    \n    return f'User ID: {session[\"user_id\"]}, Theme: {theme}'\n\n@app.route('/cart/add/<item>')\ndef add_to_cart(item):\n    if 'cart' not in session:\n        session['cart'] = []\n    \n    cart = session['cart']\n    cart.append(item)\n    session['cart'] = cart  # Must reassign for changes to persist\n    \n    return f'Added {item} to cart. Cart: {session[\"cart\"]}'\n```\n\n**Security Best Practices:**\n```python\n# Production configuration\napp.config.update(\n    SECRET_KEY=os.environ.get('SECRET_KEY', 'fallback-key'),\n    SESSION_COOKIE_SECURE=True,        # HTTPS only\n    SESSION_COOKIE_HTTPONLY=True,      # Prevent XSS\n    SESSION_COOKIE_SAMESITE='Strict',  # CSRF protection\n    SESSION_COOKIE_DOMAIN='.example.com',  # Domain restriction\n    PERMANENT_SESSION_LIFETIME=timedelta(minutes=30)\n)\n\n# Session validation\n@app.before_request\ndef validate_session():\n    # Add session timeout checks\n    # Validate session integrity\n    # Check for session hijacking\n    pass\n```\n\n**Key Points:**\n- **Server-side Storage**: Flask sessions are client-side but encrypted\n- **Secret Key**: Required for session security - keep it secret!\n- **Size Limits**: Cookie size limited to ~4KB\n- **Security**: Use HTTPS, HttpOnly, and SameSite flags\n- **Persistence**: Sessions persist across browser sessions if marked permanent\n\nFor larger applications, consider server-side session storage (Redis, database) using Flask-Session extension for better security and scalability.",
      "keywords": ["flask", "sessions", "cookies", "security", "authentication", "state management", "secret key", "HTTPS"],
      "difficulty": "medium"
    },
    {
      "id": 11008,
      "tag": "flask",
      "question": "How do you handle errors in Flask? Explain error handling, custom error pages, and logging.",
      "answer": "Flask provides comprehensive error handling through error handlers, custom error pages, and built-in logging capabilities to create robust applications.\n\n**Basic Error Handlers:**\n```python\nfrom flask import Flask, render_template, abort\n\napp = Flask(__name__)\n\n# Handle specific HTTP errors\n@app.errorhandler(404)\ndef not_found_error(error):\n    return render_template('errors/404.html'), 404\n\n@app.errorhandler(500)\ndef internal_error(error):\n    return render_template('errors/500.html'), 500\n\n@app.errorhandler(403)\ndef forbidden_error(error):\n    return render_template('errors/403.html'), 403\n\n# Handle specific exceptions\n@app.errorhandler(ValueError)\ndef handle_value_error(error):\n    return f'Invalid value: {error}', 400\n```\n\n**Custom Error Pages:**\n```html\n<!-- templates/errors/404.html -->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Page Not Found</title>\n</head>\n<body>\n    <h1>404 - Page Not Found</h1>\n    <p>The page you are looking for doesn't exist.</p>\n    <a href=\"{{ url_for('index') }}\">Go Home</a>\n</body>\n</html>\n\n<!-- templates/errors/500.html -->\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Server Error</title>\n</head>\n<body>\n    <h1>500 - Internal Server Error</h1>\n    <p>Something went wrong on our end.</p>\n    <a href=\"{{ url_for('index') }}\">Go Home</a>\n</body>\n</html>\n```\n\n**Advanced Error Handling:**\n```python\nfrom werkzeug.exceptions import HTTPException\nimport logging\n\n# Global error handler for all HTTP exceptions\n@app.errorhandler(HTTPException)\ndef handle_http_exception(error):\n    app.logger.error(f'HTTP Error {error.code}: {error.description}')\n    \n    # Return JSON for API endpoints\n    if request.path.startswith('/api/'):\n        return {\n            'error': error.name,\n            'message': error.description,\n            'status_code': error.code\n        }, error.code\n    \n    # Return HTML for web pages\n    return render_template('errors/generic.html', error=error), error.code\n\n# Custom exception handling\nclass ValidationError(Exception):\n    def __init__(self, message, status_code=400):\n        self.message = message\n        self.status_code = status_code\n\n@app.errorhandler(ValidationError)\ndef handle_validation_error(error):\n    return {'error': 'Validation failed', 'message': error.message}, error.status_code\n\n@app.route('/user/<int:user_id>')\ndef get_user(user_id):\n    user = get_user_from_db(user_id)\n    if not user:\n        abort(404)  # Triggers 404 error handler\n    \n    if not user.is_active:\n        raise ValidationError('User account is inactive')\n    \n    return render_template('user.html', user=user)\n```\n\n**Logging Configuration:**\n```python\nimport logging\nfrom logging.handlers import RotatingFileHandler\n\n# Configure logging for production\nif not app.debug:\n    # File handler\n    file_handler = RotatingFileHandler('logs/app.log', maxBytes=10240, backupCount=10)\n    file_handler.setFormatter(logging.Formatter(\n        '%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n    ))\n    file_handler.setLevel(logging.INFO)\n    app.logger.addHandler(file_handler)\n    \n    app.logger.setLevel(logging.INFO)\n    app.logger.info('Application startup')\n\n# Using logging in routes\n@app.route('/api/data')\ndef get_data():\n    try:\n        data = fetch_data_from_api()\n        app.logger.info('Data fetched successfully')\n        return jsonify(data)\n    except Exception as e:\n        app.logger.error(f'Failed to fetch data: {str(e)}')\n        return {'error': 'Data unavailable'}, 500\n```\n\n**Blueprint Error Handlers:**\n```python\n# Blueprint-specific error handling\nfrom flask import Blueprint\n\napi_bp = Blueprint('api', __name__)\n\n@api_bp.errorhandler(404)\ndef api_not_found(error):\n    return {'error': 'API endpoint not found'}, 404\n\n@api_bp.errorhandler(Exception)\ndef api_error(error):\n    return {'error': 'Internal server error'}, 500\n```\n\n**Benefits:**\n- **User Experience**: Custom error pages instead of default browser errors\n- **Debugging**: Detailed logging for troubleshooting\n- **Security**: Hide sensitive error information in production\n- **Monitoring**: Track application errors and performance\n- **Graceful Degradation**: Handle failures without crashing\n\nProper error handling is crucial for production Flask applications, ensuring users see helpful messages while developers get detailed debugging information.",
      "keywords": ["flask", "error handling", "custom errors", "logging", "exception handling", "404", "500", "debugging"],
      "difficulty": "medium"
    },
    {
      "id": 11009,
      "tag": "flask",
      "question": "What is the Flask extensions ecosystem? Explain popular extensions and how to integrate them.",
      "answer": "Flask's extensions ecosystem provides additional functionality through third-party packages that integrate seamlessly with Flask applications. Extensions follow naming conventions and provide consistent APIs.\n\n**Popular Flask Extensions:**\n\n**Database Extensions:**\n```python\n# Flask-SQLAlchemy - ORM integration\nfrom flask_sqlalchemy import SQLAlchemy\n\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\ndb = SQLAlchemy(app)\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n\n# Flask-Migrate - Database migrations\nfrom flask_migrate import Migrate\nmigrate = Migrate(app, db)\n```\n\n**Authentication Extensions:**\n```python\n# Flask-Login - User session management\nfrom flask_login import LoginManager, UserMixin, login_required, current_user\n\nlogin_manager = LoginManager()\nlogin_manager.init_app(app)\nlogin_manager.login_view = 'login'\n\nclass User(UserMixin, db.Model):\n    # User model with login capabilities\n    pass\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n\n@app.route('/protected')\n@login_required\ndef protected():\n    return f'Hello {current_user.username}'\n\n# Flask-JWT-Extended - JWT tokens\nfrom flask_jwt_extended import JWTManager, create_access_token, jwt_required\n\njwt = JWTManager(app)\napp.config['JWT_SECRET_KEY'] = 'super-secret'\n\n@app.route('/api/login', methods=['POST'])\ndef api_login():\n    # Validate credentials\n    access_token = create_access_token(identity=username)\n    return {'access_token': access_token}\n\n@app.route('/api/protected')\n@jwt_required()\ndef api_protected():\n    return {'message': 'Access granted'}\n```\n\n**Form Handling:**\n```python\n# Flask-WTF - Form handling and CSRF protection\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, PasswordField, SubmitField\nfrom wtforms.validators import DataRequired, Email\n\nclass LoginForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired()])\n    password = PasswordField('Password', validators=[DataRequired()])\n    submit = SubmitField('Login')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    form = LoginForm()\n    if form.validate_on_submit():\n        # Process form data\n        username = form.username.data\n        password = form.password.data\n        return redirect(url_for('index'))\n    return render_template('login.html', form=form)\n```\n\n**API and Serialization:**\n```python\n# Flask-RESTful - RESTful API development\nfrom flask_restful import Api, Resource\n\napi = Api(app)\n\nclass UserAPI(Resource):\n    def get(self, user_id):\n        user = User.query.get_or_404(user_id)\n        return {'id': user.id, 'username': user.username}\n    \n    def put(self, user_id):\n        # Update user\n        pass\n    \n    def delete(self, user_id):\n        # Delete user\n        pass\n\napi.add_resource(UserAPI, '/api/users/<int:user_id>')\n\n# Flask-Marshmallow - Object serialization\nfrom flask_marshmallow import Marshmallow\n\nma = Marshmallow(app)\n\nclass UserSchema(ma.SQLAlchemyAutoSchema):\n    class Meta:\n        model = User\n        load_instance = True\n\nuser_schema = UserSchema()\nusers_schema = UserSchema(many=True)\n```\n\n**Additional Useful Extensions:**\n```python\n# Flask-Mail - Email sending\nfrom flask_mail import Mail, Message\n\nmail = Mail(app)\napp.config['MAIL_SERVER'] = 'smtp.gmail.com'\napp.config['MAIL_USE_TLS'] = True\n\n@app.route('/send-email')\ndef send_email():\n    msg = Message('Subject', recipients=['user@example.com'])\n    msg.body = 'Email body'\n    mail.send(msg)\n    return 'Email sent'\n\n# Flask-Caching - Caching support\nfrom flask_caching import Cache\n\ncache = Cache(app)\napp.config['CACHE_TYPE'] = 'simple'\n\n@app.route('/expensive-operation')\n@cache.cached(timeout=300)\ndef expensive_operation():\n    # Cached for 5 minutes\n    return perform_complex_calculation()\n\n# Flask-CORS - Cross-Origin Resource Sharing\nfrom flask_cors import CORS\n\nCORS(app, origins=['http://localhost:3000'])\n```\n\n**Extension Integration Patterns:**\n```python\n# Application factory pattern with extensions\ndef create_app():\n    app = Flask(__name__)\n    \n    # Initialize extensions\n    db.init_app(app)\n    login_manager.init_app(app)\n    mail.init_app(app)\n    \n    return app\n\n# Extension configuration\nclass Config:\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL')\n    SECRET_KEY = os.environ.get('SECRET_KEY')\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n```\n\n**Popular Extensions:**\n- **Flask-SQLAlchemy**: Database ORM\n- **Flask-Login**: User authentication\n- **Flask-WTF**: Form handling and CSRF\n- **Flask-Migrate**: Database migrations\n- **Flask-Mail**: Email integration\n- **Flask-RESTful**: API development\n- **Flask-JWT-Extended**: JWT authentication\n- **Flask-CORS**: Cross-origin requests\n- **Flask-Caching**: Performance optimization\n\nFlask's extension ecosystem makes it easy to add sophisticated functionality while maintaining the framework's simplicity and flexibility.",
      "keywords": ["flask", "extensions", "Flask-SQLAlchemy", "Flask-Login", "Flask-WTF", "Flask-RESTful", "ecosystem", "integration"],
      "difficulty": "medium"
    },
    {
      "id": 11010,
      "tag": "flask",
      "question": "How does form handling and validation work in Flask with WTForms? Provide examples of custom validators.",
      "answer": "Flask integrates with WTForms through Flask-WTF to provide powerful form handling, validation, and CSRF protection. WTForms creates form classes with built-in validation and rendering capabilities.\n\n**Basic Form Setup:**\n```python\nfrom flask import Flask, render_template, request, flash, redirect, url_for\nfrom flask_wtf import FlaskForm\nfrom wtforms import StringField, TextAreaField, SelectField, BooleanField, SubmitField\nfrom wtforms.validators import DataRequired, Email, Length, ValidationError\n\napp = Flask(__name__)\napp.secret_key = 'your-secret-key'\n\nclass ContactForm(FlaskForm):\n    name = StringField('Name', validators=[DataRequired(), Length(min=2, max=50)])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    subject = SelectField('Subject', choices=[\n        ('general', 'General Inquiry'),\n        ('support', 'Support'),\n        ('sales', 'Sales')\n    ])\n    message = TextAreaField('Message', validators=[DataRequired(), Length(min=10)])\n    newsletter = BooleanField('Subscribe to newsletter')\n    submit = SubmitField('Send Message')\n```\n\n**Form Handling in Routes:**\n```python\n@app.route('/contact', methods=['GET', 'POST'])\ndef contact():\n    form = ContactForm()\n    \n    if form.validate_on_submit():\n        # Process form data\n        name = form.name.data\n        email = form.email.data\n        subject = form.subject.data\n        message = form.message.data\n        \n        # Save to database or send email\n        save_contact_message(name, email, subject, message)\n        \n        flash('Your message has been sent successfully!', 'success')\n        return redirect(url_for('contact'))\n    \n    return render_template('contact.html', form=form)\n```\n\n**Template Rendering:**\n```html\n<!-- contact.html -->\n<form method=\"POST\">\n    {{ form.hidden_tag() }} <!-- CSRF token -->\n    \n    <div class=\"form-group\">\n        {{ form.name.label(class=\"form-label\") }}\n        {{ form.name(class=\"form-control\") }}\n        {% if form.name.errors %}\n            <div class=\"alert alert-danger\">\n                {% for error in form.name.errors %}\n                    <p>{{ error }}</p>\n                {% endfor %}\n            </div>\n        {% endif %}\n    </div>\n    \n    <div class=\"form-group\">\n        {{ form.email.label(class=\"form-label\") }}\n        {{ form.email(class=\"form-control\") }}\n        {% for error in form.email.errors %}\n            <div class=\"alert alert-danger\">{{ error }}</div>\n        {% endfor %}\n    </div>\n    \n    <div class=\"form-group\">\n        {{ form.message.label(class=\"form-label\") }}\n        {{ form.message(class=\"form-control\", rows=\"5\") }}\n    </div>\n    \n    {{ form.submit(class=\"btn btn-primary\") }}\n</form>\n```\n\n**Custom Validators:**\n```python\nfrom wtforms.validators import ValidationError\nimport re\n\nclass RegistrationForm(FlaskForm):\n    username = StringField('Username', validators=[DataRequired(), Length(min=4, max=20)])\n    password = StringField('Password', validators=[DataRequired()])\n    email = StringField('Email', validators=[DataRequired(), Email()])\n    \n    # Custom validator methods\n    def validate_username(self, username):\n        # Check if username already exists\n        user = User.query.filter_by(username=username.data).first()\n        if user:\n            raise ValidationError('Username already taken. Choose a different one.')\n        \n        # Check username format\n        if not re.match(r'^[a-zA-Z0-9_]+$', username.data):\n            raise ValidationError('Username can only contain letters, numbers, and underscores.')\n    \n    def validate_password(self, password):\n        # Password strength validation\n        if len(password.data) < 8:\n            raise ValidationError('Password must be at least 8 characters long.')\n        \n        if not re.search(r'[A-Z]', password.data):\n            raise ValidationError('Password must contain at least one uppercase letter.')\n        \n        if not re.search(r'[0-9]', password.data):\n            raise ValidationError('Password must contain at least one number.')\n\n# Custom validator functions\ndef phone_number_validator(form, field):\n    phone_pattern = r'^\\+?1?\\d{9,15}$'\n    if not re.match(phone_pattern, field.data):\n        raise ValidationError('Invalid phone number format.')\n\nclass UserForm(FlaskForm):\n    phone = StringField('Phone', validators=[DataRequired(), phone_number_validator])\n```\n\nWTForms provides robust form handling with built-in CSRF protection, making Flask applications more secure and user-friendly with comprehensive validation capabilities.",
      "keywords": ["flask", "WTForms", "forms", "validation", "CSRF", "custom validators", "form handling", "Flask-WTF"],
      "difficulty": "easy"
    },
    {
      "id": 11011,
      "tag": "flask",
      "question": "How do you integrate Flask with SQLAlchemy for database operations? Show CRUD examples.",
      "answer": "Flask-SQLAlchemy provides seamless integration between Flask and SQLAlchemy, offering an ORM (Object-Relational Mapping) solution for database operations with models, relationships, and queries.\n\n**Database Setup:**\n```python\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///blog.db'\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\ndb = SQLAlchemy(app)\n\n# Models\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    posts = db.relationship('Post', backref='author', lazy=True)\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(100), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    \n    def __repr__(self):\n        return f'<Post {self.title}>'\n\n# Create tables\nwith app.app_context():\n    db.create_all()\n```\n\n**CRUD Operations:**\n```python\n# CREATE operations\n@app.route('/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    \n    # Create new user\n    user = User(\n        username=data['username'],\n        email=data['email']\n    )\n    \n    try:\n        db.session.add(user)\n        db.session.commit()\n        return {'message': 'User created successfully', 'id': user.id}, 201\n    except Exception as e:\n        db.session.rollback()\n        return {'error': 'Failed to create user'}, 400\n\n# READ operations\n@app.route('/users')\ndef get_users():\n    # Get all users\n    users = User.query.all()\n    return {\n        'users': [{\n            'id': user.id,\n            'username': user.username,\n            'email': user.email,\n            'created_at': user.created_at.isoformat()\n        } for user in users]\n    }\n\n@app.route('/users/<int:user_id>')\ndef get_user(user_id):\n    # Get single user\n    user = User.query.get_or_404(user_id)\n    return {\n        'id': user.id,\n        'username': user.username,\n        'email': user.email,\n        'posts_count': len(user.posts)\n    }\n\n# UPDATE operations\n@app.route('/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    user = User.query.get_or_404(user_id)\n    data = request.get_json()\n    \n    user.username = data.get('username', user.username)\n    user.email = data.get('email', user.email)\n    \n    try:\n        db.session.commit()\n        return {'message': 'User updated successfully'}\n    except Exception as e:\n        db.session.rollback()\n        return {'error': 'Failed to update user'}, 400\n\n# DELETE operations\n@app.route('/users/<int:user_id>', methods=['DELETE'])\ndef delete_user(user_id):\n    user = User.query.get_or_404(user_id)\n    \n    try:\n        db.session.delete(user)\n        db.session.commit()\n        return {'message': 'User deleted successfully'}\n    except Exception as e:\n        db.session.rollback()\n        return {'error': 'Failed to delete user'}, 400\n```\n\n**Advanced Queries:**\n```python\n@app.route('/posts')\ndef get_posts():\n    # Query with joins and filters\n    posts = db.session.query(Post, User).join(User).filter(\n        Post.created_at > datetime(2023, 1, 1)\n    ).order_by(Post.created_at.desc()).all()\n    \n    return {\n        'posts': [{\n            'id': post.id,\n            'title': post.title,\n            'author': user.username,\n            'created_at': post.created_at.isoformat()\n        } for post, user in posts]\n    }\n\n@app.route('/search')\ndef search_posts():\n    query = request.args.get('q', '')\n    \n    # Text search with pagination\n    page = request.args.get('page', 1, type=int)\n    posts = Post.query.filter(\n        Post.title.contains(query) | Post.content.contains(query)\n    ).paginate(page=page, per_page=10, error_out=False)\n    \n    return {\n        'posts': [{\n            'id': post.id,\n            'title': post.title,\n            'author': post.author.username\n        } for post in posts.items],\n        'total': posts.total,\n        'pages': posts.pages,\n        'current_page': page\n    }\n```\n\n**Database Migrations:**\n```python\n# Install: pip install Flask-Migrate\nfrom flask_migrate import Migrate\n\nmigrate = Migrate(app, db)\n\n# Terminal commands:\n# flask db init\n# flask db migrate -m \"Initial migration\"\n# flask db upgrade\n```\n\nFlask-SQLAlchemy provides a powerful, Pythonic way to interact with databases, offering model relationships, query capabilities, and database migrations for robust data management.",
      "keywords": ["flask", "SQLAlchemy", "database", "ORM", "CRUD", "models", "relationships", "migrations"],
      "difficulty": "easy"
    },
    {
      "id": 11012,
      "tag": "flask",
      "question": "How do you implement authentication and authorization in Flask? Show login, logout, and role-based access.",
      "answer": "Flask authentication and authorization can be implemented using Flask-Login for session management and custom decorators for role-based access control.\n\n**User Model and Authentication Setup:**\n```python\nfrom flask import Flask, render_template, request, redirect, url_for, flash\nfrom flask_login import LoginManager, UserMixin, login_user, logout_user, login_required, current_user\nfrom werkzeug.security import generate_password_hash, check_password_hash\nfrom flask_sqlalchemy import SQLAlchemy\nfrom functools import wraps\n\napp = Flask(__name__)\napp.secret_key = 'your-secret-key'\ndb = SQLAlchemy(app)\n\n# Initialize Flask-Login\nlogin_manager = LoginManager()\nlogin_manager.init_app(app)\nlogin_manager.login_view = 'login'\nlogin_manager.login_message = 'Please log in to access this page.'\n\nclass User(UserMixin, db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    password_hash = db.Column(db.String(255), nullable=False)\n    role = db.Column(db.String(20), default='user')  # user, admin, moderator\n    is_active = db.Column(db.Boolean, default=True)\n    \n    def set_password(self, password):\n        self.password_hash = generate_password_hash(password)\n    \n    def check_password(self, password):\n        return check_password_hash(self.password_hash, password)\n    \n    def has_role(self, role):\n        return self.role == role\n    \n    def __repr__(self):\n        return f'<User {self.username}>'\n\n@login_manager.user_loader\ndef load_user(user_id):\n    return User.query.get(int(user_id))\n```\n\n**Authentication Routes:**\n```python\n@app.route('/register', methods=['GET', 'POST'])\ndef register():\n    if request.method == 'POST':\n        username = request.form['username']\n        email = request.form['email']\n        password = request.form['password']\n        \n        # Validation\n        if User.query.filter_by(username=username).first():\n            flash('Username already exists', 'error')\n            return render_template('register.html')\n        \n        if User.query.filter_by(email=email).first():\n            flash('Email already registered', 'error')\n            return render_template('register.html')\n        \n        # Create new user\n        user = User(username=username, email=email)\n        user.set_password(password)\n        \n        db.session.add(user)\n        db.session.commit()\n        \n        flash('Registration successful! Please log in.', 'success')\n        return redirect(url_for('login'))\n    \n    return render_template('register.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        username = request.form['username']\n        password = request.form['password']\n        remember = request.form.get('remember', False)\n        \n        user = User.query.filter_by(username=username).first()\n        \n        if user and user.check_password(password) and user.is_active:\n            login_user(user, remember=remember)\n            \n            # Redirect to next page or dashboard\n            next_page = request.args.get('next')\n            return redirect(next_page) if next_page else redirect(url_for('dashboard'))\n        else:\n            flash('Invalid username/password or account disabled', 'error')\n    \n    return render_template('login.html')\n\n@app.route('/logout')\n@login_required\ndef logout():\n    logout_user()\n    flash('You have been logged out', 'info')\n    return redirect(url_for('index'))\n```\n\n**Role-Based Authorization:**\n```python\n# Custom decorators for role-based access\ndef role_required(role):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                return redirect(url_for('login'))\n            \n            if not current_user.has_role(role):\n                flash('Access denied. Insufficient privileges.', 'error')\n                return redirect(url_for('dashboard'))\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\ndef admin_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not current_user.is_authenticated or not current_user.has_role('admin'):\n            flash('Admin access required', 'error')\n            return redirect(url_for('login'))\n        return f(*args, **kwargs)\n    return decorated_function\n\n# Protected routes\n@app.route('/dashboard')\n@login_required\ndef dashboard():\n    return render_template('dashboard.html', user=current_user)\n\n@app.route('/admin')\n@admin_required\ndef admin_panel():\n    users = User.query.all()\n    return render_template('admin.html', users=users)\n\n@app.route('/moderator')\n@role_required('moderator')\ndef moderator_panel():\n    return render_template('moderator.html')\n\n@app.route('/profile')\n@login_required\ndef profile():\n    return render_template('profile.html', user=current_user)\n```\n\n**Template Integration:**\n```html\n<!-- base.html -->\n<nav>\n    {% if current_user.is_authenticated %}\n        <span>Welcome, {{ current_user.username }}!</span>\n        <a href=\"{{ url_for('dashboard') }}\">Dashboard</a>\n        <a href=\"{{ url_for('profile') }}\">Profile</a>\n        \n        {% if current_user.has_role('admin') %}\n            <a href=\"{{ url_for('admin_panel') }}\">Admin</a>\n        {% endif %}\n        \n        {% if current_user.has_role('moderator') %}\n            <a href=\"{{ url_for('moderator_panel') }}\">Moderate</a>\n        {% endif %}\n        \n        <a href=\"{{ url_for('logout') }}\">Logout</a>\n    {% else %}\n        <a href=\"{{ url_for('login') }}\">Login</a>\n        <a href=\"{{ url_for('register') }}\">Register</a>\n    {% endif %}\n</nav>\n```\n\n**Advanced Features:**\n```python\n# Password reset functionality\nfrom itsdangerous import URLSafeTimedSerializer\n\ndef generate_reset_token(user_id):\n    serializer = URLSafeTimedSerializer(app.secret_key)\n    return serializer.dumps(user_id, salt='password-reset')\n\ndef verify_reset_token(token, expiration=3600):\n    serializer = URLSafeTimedSerializer(app.secret_key)\n    try:\n        user_id = serializer.loads(token, salt='password-reset', max_age=expiration)\n        return User.query.get(user_id)\n    except:\n        return None\n\n# Session management\n@app.before_request\ndef before_request():\n    if current_user.is_authenticated:\n        # Update last seen timestamp\n        current_user.last_seen = datetime.utcnow()\n        db.session.commit()\n```\n\nThis authentication system provides secure user management with role-based access control, password hashing, and session management for Flask applications.",
      "keywords": ["flask", "authentication", "authorization", "Flask-Login", "roles", "permissions", "login", "logout", "security"],
      "difficulty": "easy"
    },
    {
      "id": 11013,
      "tag": "flask",
      "question": "How do you manage Flask application configuration? Show examples of different configuration strategies.",
      "answer": "Flask configuration management involves organizing settings for different environments (development, testing, production) using configuration objects, environment variables, and configuration files.\n\n**Basic Configuration Methods:**\n```python\nfrom flask import Flask\nimport os\n\napp = Flask(__name__)\n\n# Method 1: Direct configuration\napp.config['SECRET_KEY'] = 'dev-secret-key'\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'\napp.config['DEBUG'] = True\n\n# Method 2: From dictionary\napp.config.update(\n    SECRET_KEY='dev-secret-key',\n    SQLALCHEMY_DATABASE_URI='sqlite:///app.db',\n    DEBUG=True\n)\n\n# Method 3: From environment variables\napp.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'fallback-key')\napp.config['DATABASE_URL'] = os.environ.get('DATABASE_URL')\n```\n\n**Configuration Classes:**\n```python\n# config.py\nimport os\nfrom datetime import timedelta\n\nclass Config:\n    \"\"\"Base configuration class\"\"\"\n    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'\n    SQLALCHEMY_TRACK_MODIFICATIONS = False\n    MAIL_SERVER = os.environ.get('MAIL_SERVER')\n    MAIL_PORT = int(os.environ.get('MAIL_PORT') or 587)\n    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in ['true', 'on', '1']\n    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')\n    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')\n    ADMINS = ['admin@example.com']\n    \n    # Session configuration\n    PERMANENT_SESSION_LIFETIME = timedelta(hours=2)\n    SESSION_COOKIE_SECURE = True\n    SESSION_COOKIE_HTTPONLY = True\n    SESSION_COOKIE_SAMESITE = 'Lax'\n    \n    # File upload settings\n    UPLOAD_FOLDER = 'uploads'\n    MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size\n    ALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\nclass DevelopmentConfig(Config):\n    \"\"\"Development configuration\"\"\"\n    DEBUG = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DEV_DATABASE_URL') or 'sqlite:///dev.db'\n    SESSION_COOKIE_SECURE = False  # Allow HTTP in development\n    \nclass TestingConfig(Config):\n    \"\"\"Testing configuration\"\"\"\n    TESTING = True\n    SQLALCHEMY_DATABASE_URI = os.environ.get('TEST_DATABASE_URL') or 'sqlite:///:memory:'\n    WTF_CSRF_ENABLED = False  # Disable CSRF for testing\n    SESSION_COOKIE_SECURE = False\n    \nclass ProductionConfig(Config):\n    \"\"\"Production configuration\"\"\"\n    DEBUG = False\n    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///prod.db'\n    \n    # Enhanced security for production\n    SESSION_COOKIE_SECURE = True\n    SESSION_COOKIE_HTTPONLY = True\n    SESSION_COOKIE_SAMESITE = 'Strict'\n    \n    # Logging configuration\n    LOG_TO_STDOUT = os.environ.get('LOG_TO_STDOUT')\n\n# Configuration dictionary\nconfig = {\n    'development': DevelopmentConfig,\n    'testing': TestingConfig,\n    'production': ProductionConfig,\n    'default': DevelopmentConfig\n}\n```\n\n**Application Factory Pattern:**\n```python\n# app/__init__.py\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_mail import Mail\nfrom config import config\n\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\nmail = Mail()\n\ndef create_app(config_name=None):\n    app = Flask(__name__)\n    \n    # Load configuration\n    if config_name is None:\n        config_name = os.environ.get('FLASK_CONFIG', 'default')\n    \n    app.config.from_object(config[config_name])\n    \n    # Initialize extensions\n    db.init_app(app)\n    login_manager.init_app(app)\n    mail.init_app(app)\n    \n    # Register blueprints\n    from app.main import bp as main_bp\n    app.register_blueprint(main_bp)\n    \n    from app.auth import bp as auth_bp\n    app.register_blueprint(auth_bp, url_prefix='/auth')\n    \n    return app\n\n# run.py\nfrom app import create_app\nimport os\n\napp = create_app(os.environ.get('FLASK_CONFIG'))\n\nif __name__ == '__main__':\n    app.run()\n```\n\n**Environment-Specific Configuration:**\n```bash\n# .env file for development\nexport FLASK_CONFIG=development\nexport SECRET_KEY=dev-secret-key\nexport DATABASE_URL=postgresql://user:pass@localhost/myapp_dev\nexport MAIL_SERVER=localhost\nexport MAIL_PORT=8025\n\n# .env.production\nexport FLASK_CONFIG=production\nexport SECRET_KEY=super-secret-production-key\nexport DATABASE_URL=postgresql://user:pass@prod-server/myapp\nexport MAIL_SERVER=smtp.gmail.com\nexport MAIL_USERNAME=app@company.com\nexport MAIL_PASSWORD=app-password\n```\n\n**Configuration File Loading:**\n```python\n# Alternative: Load from files\nclass Config:\n    @staticmethod\n    def init_app(app):\n        pass\n\nclass DevelopmentConfig(Config):\n    @classmethod\n    def init_app(cls, app):\n        Config.init_app(app)\n        \n        # Load development-specific settings\n        if os.path.exists('.env'):\n            app.config.from_pyfile('.env')\n\n# Loading JSON config\nimport json\n\ndef load_config_from_json(app, filename):\n    with open(filename) as config_file:\n        config_data = json.load(config_file)\n        app.config.update(config_data)\n\n# app.json\n{\n    \"SECRET_KEY\": \"your-secret-key\",\n    \"SQLALCHEMY_DATABASE_URI\": \"sqlite:///app.db\",\n    \"DEBUG\": false\n}\n```\n\n**Configuration Validation:**\n```python\ndef validate_config(app):\n    \"\"\"Validate critical configuration settings\"\"\"\n    required_settings = ['SECRET_KEY', 'SQLALCHEMY_DATABASE_URI']\n    \n    for setting in required_settings:\n        if not app.config.get(setting):\n            raise ValueError(f'Configuration missing: {setting}')\n    \n    if app.config['DEBUG'] and app.config.get('SESSION_COOKIE_SECURE'):\n        app.logger.warning('SESSION_COOKIE_SECURE=True in DEBUG mode')\n\n# Usage in application factory\ndef create_app(config_name=None):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    \n    validate_config(app)\n    \n    return app\n```\n\nFlask configuration management provides flexible ways to handle different environments, ensuring applications can be deployed securely with appropriate settings for each stage of development.",
      "keywords": ["flask", "configuration", "environment variables", "config classes", "application factory", "settings", "deployment"],
      "difficulty": "easy"
    },
    {
      "id": 11014,
      "tag": "flask",
      "question": "How do you test Flask applications? Show examples of unit tests, integration tests, and test fixtures.",
      "answer": "Flask testing involves unit tests for individual functions, integration tests for complete workflows, and test fixtures for consistent test data setup using pytest or unittest.\n\n**Basic Test Setup:**\n```python\n# tests/conftest.py\nimport pytest\nimport tempfile\nimport os\nfrom app import create_app, db\nfrom app.models import User, Post\n\n@pytest.fixture\ndef app():\n    \"\"\"Create application for testing\"\"\"\n    db_fd, db_path = tempfile.mkstemp()\n    \n    app = create_app({\n        'TESTING': True,\n        'SQLALCHEMY_DATABASE_URI': f'sqlite:///{db_path}',\n        'WTF_CSRF_ENABLED': False,\n        'SECRET_KEY': 'test-secret'\n    })\n    \n    with app.app_context():\n        db.create_all()\n        yield app\n        db.drop_all()\n    \n    os.close(db_fd)\n    os.unlink(db_path)\n\n@pytest.fixture\ndef client(app):\n    \"\"\"Test client for making requests\"\"\"\n    return app.test_client()\n\n@pytest.fixture\ndef runner(app):\n    \"\"\"CLI runner for testing commands\"\"\"\n    return app.test_cli_runner()\n\n@pytest.fixture\ndef auth(client):\n    \"\"\"Authentication helper\"\"\"\n    class AuthActions:\n        def __init__(self, client):\n            self._client = client\n        \n        def login(self, username='test', password='test'):\n            return self._client.post('/auth/login', data={\n                'username': username,\n                'password': password\n            })\n        \n        def logout(self):\n            return self._client.get('/auth/logout')\n    \n    return AuthActions(client)\n```\n\n**Unit Tests:**\n```python\n# tests/test_models.py\nimport pytest\nfrom app.models import User, Post\nfrom app import db\n\nclass TestUser:\n    def test_password_hashing(self, app):\n        \"\"\"Test password hashing and verification\"\"\"\n        with app.app_context():\n            user = User(username='test', email='test@example.com')\n            user.set_password('secret')\n            \n            assert user.password_hash != 'secret'\n            assert user.check_password('secret')\n            assert not user.check_password('wrong')\n    \n    def test_user_creation(self, app):\n        \"\"\"Test user model creation\"\"\"\n        with app.app_context():\n            user = User(username='test', email='test@example.com')\n            user.set_password('password')\n            \n            db.session.add(user)\n            db.session.commit()\n            \n            saved_user = User.query.filter_by(username='test').first()\n            assert saved_user is not None\n            assert saved_user.username == 'test'\n            assert saved_user.email == 'test@example.com'\n    \n    def test_user_repr(self, app):\n        \"\"\"Test string representation\"\"\"\n        with app.app_context():\n            user = User(username='test', email='test@example.com')\n            assert repr(user) == '<User test>'\n\nclass TestPost:\n    def test_post_creation(self, app):\n        \"\"\"Test post model creation\"\"\"\n        with app.app_context():\n            user = User(username='author', email='author@example.com')\n            user.set_password('password')\n            db.session.add(user)\n            db.session.commit()\n            \n            post = Post(title='Test Post', content='Test content', author=user)\n            db.session.add(post)\n            db.session.commit()\n            \n            saved_post = Post.query.filter_by(title='Test Post').first()\n            assert saved_post is not None\n            assert saved_post.author.username == 'author'\n```\n\n**Integration Tests:**\n```python\n# tests/test_auth.py\nimport pytest\nfrom flask import session\nfrom app.models import User\nfrom app import db\n\nclass TestAuth:\n    def test_register(self, client, app):\n        \"\"\"Test user registration\"\"\"\n        # Test GET request\n        response = client.get('/auth/register')\n        assert response.status_code == 200\n        assert b'Register' in response.data\n        \n        # Test successful registration\n        response = client.post('/auth/register', data={\n            'username': 'newuser',\n            'email': 'new@example.com',\n            'password': 'password',\n            'password2': 'password'\n        })\n        assert response.status_code == 302  # Redirect after success\n        \n        # Verify user was created\n        with app.app_context():\n            user = User.query.filter_by(username='newuser').first()\n            assert user is not None\n    \n    def test_register_validation(self, client):\n        \"\"\"Test registration validation\"\"\"\n        # Test duplicate username\n        client.post('/auth/register', data={\n            'username': 'test',\n            'email': 'test1@example.com',\n            'password': 'password',\n            'password2': 'password'\n        })\n        \n        response = client.post('/auth/register', data={\n            'username': 'test',\n            'email': 'test2@example.com',\n            'password': 'password',\n            'password2': 'password'\n        })\n        assert b'Username already exists' in response.data\n    \n    def test_login_logout(self, auth, client):\n        \"\"\"Test login and logout functionality\"\"\"\n        # Test login\n        response = auth.login()\n        assert response.status_code == 302\n        \n        # Test accessing protected page\n        response = client.get('/dashboard')\n        assert response.status_code == 200\n        \n        # Test logout\n        response = auth.logout()\n        assert response.status_code == 302\n        \n        # Test accessing protected page after logout\n        response = client.get('/dashboard')\n        assert response.status_code == 302  # Redirect to login\n\n# tests/test_blog.py\nclass TestBlog:\n    def test_create_post(self, client, auth, app):\n        \"\"\"Test creating a blog post\"\"\"\n        auth.login()\n        \n        response = client.post('/create', data={\n            'title': 'Test Post',\n            'content': 'This is a test post content.'\n        })\n        assert response.status_code == 302\n        \n        # Verify post was created\n        with app.app_context():\n            post = Post.query.filter_by(title='Test Post').first()\n            assert post is not None\n            assert post.content == 'This is a test post content.'\n    \n    def test_update_post(self, client, auth, app):\n        \"\"\"Test updating a blog post\"\"\"\n        auth.login()\n        \n        # Create a post first\n        client.post('/create', data={\n            'title': 'Original Title',\n            'content': 'Original content'\n        })\n        \n        # Update the post\n        response = client.post('/1/update', data={\n            'title': 'Updated Title',\n            'content': 'Updated content'\n        })\n        assert response.status_code == 302\n        \n        # Verify update\n        with app.app_context():\n            post = Post.query.get(1)\n            assert post.title == 'Updated Title'\n```\n\n**API Testing:**\n```python\n# tests/test_api.py\nimport json\n\nclass TestAPI:\n    def test_api_get_users(self, client, auth):\n        \"\"\"Test API endpoint\"\"\"\n        auth.login()\n        \n        response = client.get('/api/users')\n        assert response.status_code == 200\n        \n        data = json.loads(response.data)\n        assert 'users' in data\n    \n    def test_api_create_user(self, client):\n        \"\"\"Test API user creation\"\"\"\n        response = client.post('/api/users', \n            json={\n                'username': 'apiuser',\n                'email': 'api@example.com'\n            },\n            headers={'Content-Type': 'application/json'}\n        )\n        \n        assert response.status_code == 201\n        data = json.loads(response.data)\n        assert data['message'] == 'User created successfully'\n```\n\n**Test Fixtures and Mock Data:**\n```python\n# tests/fixtures.py\n@pytest.fixture\ndef sample_users(app):\n    \"\"\"Create sample users for testing\"\"\"\n    with app.app_context():\n        users = [\n            User(username='user1', email='user1@example.com'),\n            User(username='user2', email='user2@example.com'),\n            User(username='admin', email='admin@example.com', role='admin')\n        ]\n        \n        for user in users:\n            user.set_password('password')\n            db.session.add(user)\n        \n        db.session.commit()\n        return users\n\n# Running tests\n# pytest tests/\n# pytest tests/test_auth.py -v\n# pytest --cov=app tests/\n```\n\nFlask testing provides comprehensive coverage through unit tests for models, integration tests for routes, and fixtures for consistent test data, ensuring application reliability and correctness.",
      "keywords": ["flask", "testing", "pytest", "unit tests", "integration tests", "fixtures", "test client", "mocking"],
      "difficulty": "easy"
    },
    {
      "id": 11015,
      "tag": "flask",
      "question": "How do you handle file uploads in Flask? Show examples of file validation, storage, and security considerations.",
      "answer": "Flask file upload handling involves processing multipart form data, validating file types and sizes, secure storage, and implementing proper security measures to prevent malicious uploads.\n\n**Basic File Upload Setup:**\n```python\nfrom flask import Flask, request, redirect, url_for, flash, render_template, send_from_directory\nfrom werkzeug.utils import secure_filename\nimport os\nfrom PIL import Image  # For image processing\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'your-secret-key'\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16MB max file size\n\n# Allowed file extensions\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif', 'doc', 'docx'}\nIMAGE_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\ndef allowed_file(filename, allowed_extensions=ALLOWED_EXTENSIONS):\n    \"\"\"Check if file extension is allowed\"\"\"\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in allowed_extensions\n\ndef get_file_size(file):\n    \"\"\"Get file size in bytes\"\"\"\n    file.seek(0, os.SEEK_END)\n    size = file.tell()\n    file.seek(0)  # Reset file pointer\n    return size\n\n# Ensure upload directory exists\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n```\n\n**Single File Upload:**\n```python\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # Check if file is present\n        if 'file' not in request.files:\n            flash('No file selected', 'error')\n            return redirect(request.url)\n        \n        file = request.files['file']\n        \n        # Check if file is selected\n        if file.filename == '':\n            flash('No file selected', 'error')\n            return redirect(request.url)\n        \n        if file and allowed_file(file.filename):\n            # Security: Use secure_filename to prevent directory traversal\n            filename = secure_filename(file.filename)\n            \n            # Add timestamp to prevent filename conflicts\n            name, ext = os.path.splitext(filename)\n            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n            filename = f\"{name}_{timestamp}{ext}\"\n            \n            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n            \n            try:\n                # Additional validation\n                file_size = get_file_size(file)\n                if file_size > app.config['MAX_CONTENT_LENGTH']:\n                    flash('File too large', 'error')\n                    return redirect(request.url)\n                \n                file.save(filepath)\n                \n                # Process the uploaded file\n                process_uploaded_file(filepath, file.filename)\n                \n                flash(f'File {filename} uploaded successfully!', 'success')\n                return redirect(url_for('uploaded_file', filename=filename))\n                \n            except Exception as e:\n                flash(f'Upload failed: {str(e)}', 'error')\n                return redirect(request.url)\n        else:\n            flash('Invalid file type', 'error')\n    \n    return render_template('upload.html')\n\n@app.route('/uploads/<filename>')\ndef uploaded_file(filename):\n    \"\"\"Serve uploaded files\"\"\"\n    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)\n```\n\n**Multiple File Upload:**\n```python\n@app.route('/upload-multiple', methods=['GET', 'POST'])\ndef upload_multiple_files():\n    if request.method == 'POST':\n        uploaded_files = request.files.getlist('files')\n        \n        if not uploaded_files or all(f.filename == '' for f in uploaded_files):\n            flash('No files selected', 'error')\n            return redirect(request.url)\n        \n        successful_uploads = []\n        failed_uploads = []\n        \n        for file in uploaded_files:\n            if file.filename == '':\n                continue\n                \n            if file and allowed_file(file.filename):\n                try:\n                    filename = secure_filename(file.filename)\n                    name, ext = os.path.splitext(filename)\n                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n                    unique_filename = f\"{name}_{timestamp}_{len(successful_uploads)}{ext}\"\n                    \n                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)\n                    file.save(filepath)\n                    \n                    successful_uploads.append(unique_filename)\n                    \n                except Exception as e:\n                    failed_uploads.append(f\"{file.filename}: {str(e)}\")\n            else:\n                failed_uploads.append(f\"{file.filename}: Invalid file type\")\n        \n        if successful_uploads:\n            flash(f'Successfully uploaded {len(successful_uploads)} files', 'success')\n        if failed_uploads:\n            flash(f'Failed uploads: {\", \".join(failed_uploads)}', 'error')\n        \n        return render_template('upload_results.html', \n                             successful=successful_uploads, \n                             failed=failed_uploads)\n    \n    return render_template('upload_multiple.html')\n```\n\n**Image Processing and Validation:**\n```python\nfrom PIL import Image, ImageExifTags\nimport magic  # python-magic library\n\ndef validate_image(filepath):\n    \"\"\"Validate image file and extract metadata\"\"\"\n    try:\n        # Verify it's actually an image\n        with Image.open(filepath) as img:\n            img.verify()  # Verify image integrity\n        \n        # Re-open for processing (verify() makes image unusable)\n        with Image.open(filepath) as img:\n            # Check image dimensions\n            width, height = img.size\n            if width > 4000 or height > 4000:\n                return False, \"Image dimensions too large\"\n            \n            # Remove EXIF data for privacy\n            clean_img = Image.new(img.mode, img.size)\n            clean_img.putdata(list(img.getdata()))\n            clean_img.save(filepath)\n            \n            return True, f\"Image: {width}x{height}, Format: {img.format}\"\n            \n    except Exception as e:\n        return False, f\"Invalid image: {str(e)}\"\n\ndef validate_file_content(filepath):\n    \"\"\"Validate file content using magic numbers\"\"\"\n    try:\n        mime_type = magic.from_file(filepath, mime=True)\n        \n        # Define allowed MIME types\n        allowed_mime_types = {\n            'image/jpeg', 'image/png', 'image/gif',\n            'application/pdf', 'text/plain',\n            'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n        }\n        \n        if mime_type not in allowed_mime_types:\n            return False, f\"Forbidden file type: {mime_type}\"\n        \n        return True, f\"Valid file type: {mime_type}\"\n        \n    except Exception as e:\n        return False, f\"File validation error: {str(e)}\"\n\ndef process_uploaded_file(filepath, original_filename):\n    \"\"\"Process uploaded file with validation\"\"\"\n    # Validate file content\n    is_valid, message = validate_file_content(filepath)\n    if not is_valid:\n        os.remove(filepath)  # Remove invalid file\n        raise ValueError(message)\n    \n    # Special processing for images\n    if allowed_file(original_filename, IMAGE_EXTENSIONS):\n        is_valid_img, img_message = validate_image(filepath)\n        if not is_valid_img:\n            os.remove(filepath)\n            raise ValueError(img_message)\n    \n    # Log successful upload\n    app.logger.info(f\"File uploaded: {original_filename} -> {filepath}\")\n```\n\n**Database Integration:**\n```python\nfrom flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\n\ndb = SQLAlchemy(app)\n\nclass FileUpload(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    original_filename = db.Column(db.String(255), nullable=False)\n    stored_filename = db.Column(db.String(255), nullable=False)\n    file_size = db.Column(db.Integer, nullable=False)\n    mime_type = db.Column(db.String(100), nullable=False)\n    upload_date = db.Column(db.DateTime, default=datetime.utcnow)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))\n    \n    def __repr__(self):\n        return f'<FileUpload {self.original_filename}>'\n\ndef save_file_record(original_filename, stored_filename, file_size, mime_type, user_id=None):\n    \"\"\"Save file upload record to database\"\"\"\n    file_record = FileUpload(\n        original_filename=original_filename,\n        stored_filename=stored_filename,\n        file_size=file_size,\n        mime_type=mime_type,\n        user_id=user_id\n    )\n    \n    db.session.add(file_record)\n    db.session.commit()\n    return file_record\n```\n\n**Security Considerations Template:**\n```html\n<!-- upload.html -->\n<form method=\"POST\" enctype=\"multipart/form-data\">\n    <div class=\"form-group\">\n        <label for=\"file\">Choose file:</label>\n        <input type=\"file\" name=\"file\" id=\"file\" \n               accept=\".txt,.pdf,.png,.jpg,.jpeg,.gif,.doc,.docx\"\n               required>\n        <small class=\"form-text text-muted\">\n            Allowed types: TXT, PDF, PNG, JPG, GIF, DOC, DOCX. Max size: 16MB\n        </small>\n    </div>\n    <button type=\"submit\" class=\"btn btn-primary\">Upload</button>\n</form>\n```\n\nFlask file upload handling requires careful validation, secure filename handling, content type verification, and proper storage management to prevent security vulnerabilities while providing a smooth user experience.",
      "keywords": ["flask", "file upload", "secure_filename", "file validation", "image processing", "security", "multipart", "storage"],
      "difficulty": "easy"
    },
    {
      "id": 11016,
      "tag": "flask",
      "question": "How do you develop RESTful APIs with Flask? Show examples of HTTP methods, status codes, and JSON responses.",
      "answer": "Flask RESTful API development involves creating endpoints that follow REST principles, handling HTTP methods appropriately, returning proper status codes, and structuring JSON responses consistently.\n\n**Basic RESTful API Structure:**\n```python\nfrom flask import Flask, request, jsonify, abort\nfrom flask_sqlalchemy import SQLAlchemy\nfrom datetime import datetime\nimport json\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///api.db'\ndb = SQLAlchemy(app)\n\n# Models\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    email = db.Column(db.String(120), unique=True, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    posts = db.relationship('Post', backref='author', lazy=True, cascade='all, delete-orphan')\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'username': self.username,\n            'email': self.email,\n            'created_at': self.created_at.isoformat(),\n            'posts_count': len(self.posts)\n        }\n\nclass Post(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(100), nullable=False)\n    content = db.Column(db.Text, nullable=False)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'title': self.title,\n            'content': self.content,\n            'created_at': self.created_at.isoformat(),\n            'updated_at': self.updated_at.isoformat(),\n            'author': {\n                'id': self.author.id,\n                'username': self.author.username\n            }\n        }\n```\n\n**User Resource Endpoints:**\n```python\n# GET /api/users - List all users\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    page = request.args.get('page', 1, type=int)\n    per_page = min(request.args.get('per_page', 10, type=int), 100)\n    \n    users = User.query.paginate(\n        page=page, per_page=per_page, error_out=False\n    )\n    \n    return jsonify({\n        'users': [user.to_dict() for user in users.items],\n        'pagination': {\n            'page': page,\n            'pages': users.pages,\n            'per_page': per_page,\n            'total': users.total,\n            'has_next': users.has_next,\n            'has_prev': users.has_prev\n        }\n    }), 200\n\n# GET /api/users/<id> - Get specific user\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    user = User.query.get_or_404(user_id)\n    return jsonify(user.to_dict()), 200\n\n# POST /api/users - Create new user\n@app.route('/api/users', methods=['POST'])\ndef create_user():\n    if not request.is_json:\n        return jsonify({'error': 'Request must be JSON'}), 400\n    \n    data = request.get_json()\n    \n    # Validation\n    required_fields = ['username', 'email']\n    for field in required_fields:\n        if field not in data or not data[field]:\n            return jsonify({'error': f'Missing required field: {field}'}), 400\n    \n    # Check for existing user\n    if User.query.filter_by(username=data['username']).first():\n        return jsonify({'error': 'Username already exists'}), 409\n    \n    if User.query.filter_by(email=data['email']).first():\n        return jsonify({'error': 'Email already exists'}), 409\n    \n    try:\n        user = User(\n            username=data['username'],\n            email=data['email']\n        )\n        \n        db.session.add(user)\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'User created successfully',\n            'user': user.to_dict()\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to create user'}), 500\n\n# PUT /api/users/<id> - Update user\n@app.route('/api/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    user = User.query.get_or_404(user_id)\n    \n    if not request.is_json:\n        return jsonify({'error': 'Request must be JSON'}), 400\n    \n    data = request.get_json()\n    \n    try:\n        # Update fields if provided\n        if 'username' in data:\n            if data['username'] != user.username:\n                if User.query.filter_by(username=data['username']).first():\n                    return jsonify({'error': 'Username already exists'}), 409\n                user.username = data['username']\n        \n        if 'email' in data:\n            if data['email'] != user.email:\n                if User.query.filter_by(email=data['email']).first():\n                    return jsonify({'error': 'Email already exists'}), 409\n                user.email = data['email']\n        \n        db.session.commit()\n        \n        return jsonify({\n            'message': 'User updated successfully',\n            'user': user.to_dict()\n        }), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to update user'}), 500\n\n# DELETE /api/users/<id> - Delete user\n@app.route('/api/users/<int:user_id>', methods=['DELETE'])\ndef delete_user(user_id):\n    user = User.query.get_or_404(user_id)\n    \n    try:\n        db.session.delete(user)\n        db.session.commit()\n        \n        return jsonify({'message': 'User deleted successfully'}), 200\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to delete user'}), 500\n```\n\n**Posts Resource with Nested Routing:**\n```python\n# GET /api/posts - List all posts\n@app.route('/api/posts', methods=['GET'])\ndef get_posts():\n    # Filtering and sorting\n    author_id = request.args.get('author_id', type=int)\n    sort_by = request.args.get('sort', 'created_at')\n    order = request.args.get('order', 'desc')\n    \n    query = Post.query\n    \n    if author_id:\n        query = query.filter_by(user_id=author_id)\n    \n    # Sorting\n    if hasattr(Post, sort_by):\n        order_by = getattr(Post, sort_by)\n        if order == 'desc':\n            order_by = order_by.desc()\n        query = query.order_by(order_by)\n    \n    page = request.args.get('page', 1, type=int)\n    posts = query.paginate(page=page, per_page=10, error_out=False)\n    \n    return jsonify({\n        'posts': [post.to_dict() for post in posts.items],\n        'pagination': {\n            'page': page,\n            'pages': posts.pages,\n            'total': posts.total\n        }\n    }), 200\n\n# POST /api/users/<user_id>/posts - Create post for user\n@app.route('/api/users/<int:user_id>/posts', methods=['POST'])\ndef create_user_post(user_id):\n    user = User.query.get_or_404(user_id)\n    \n    if not request.is_json:\n        return jsonify({'error': 'Request must be JSON'}), 400\n    \n    data = request.get_json()\n    \n    required_fields = ['title', 'content']\n    for field in required_fields:\n        if field not in data or not data[field]:\n            return jsonify({'error': f'Missing required field: {field}'}), 400\n    \n    try:\n        post = Post(\n            title=data['title'],\n            content=data['content'],\n            user_id=user_id\n        )\n        \n        db.session.add(post)\n        db.session.commit()\n        \n        return jsonify({\n            'message': 'Post created successfully',\n            'post': post.to_dict()\n        }), 201\n        \n    except Exception as e:\n        db.session.rollback()\n        return jsonify({'error': 'Failed to create post'}), 500\n```\n\n**Error Handling and Status Codes:**\n```python\n# Global error handlers\n@app.errorhandler(400)\ndef bad_request(error):\n    return jsonify({\n        'error': 'Bad Request',\n        'message': 'The request could not be understood or was missing required parameters'\n    }), 400\n\n@app.errorhandler(404)\ndef not_found(error):\n    return jsonify({\n        'error': 'Not Found',\n        'message': 'The requested resource could not be found'\n    }), 404\n\n@app.errorhandler(405)\ndef method_not_allowed(error):\n    return jsonify({\n        'error': 'Method Not Allowed',\n        'message': 'The method is not allowed for the requested URL'\n    }), 405\n\n@app.errorhandler(500)\ndef internal_server_error(error):\n    db.session.rollback()\n    return jsonify({\n        'error': 'Internal Server Error',\n        'message': 'An unexpected error occurred'\n    }), 500\n\n# API status endpoint\n@app.route('/api/status', methods=['GET'])\ndef api_status():\n    return jsonify({\n        'status': 'healthy',\n        'version': '1.0.0',\n        'timestamp': datetime.utcnow().isoformat()\n    }), 200\n```\n\n**Request Validation and Content Negotiation:**\n```python\nfrom functools import wraps\n\ndef validate_json(f):\n    \"\"\"Decorator to validate JSON requests\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if not request.is_json:\n            return jsonify({'error': 'Content-Type must be application/json'}), 400\n        return f(*args, **kwargs)\n    return decorated_function\n\ndef validate_fields(required_fields):\n    \"\"\"Decorator to validate required fields\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            data = request.get_json()\n            for field in required_fields:\n                if field not in data or not data[field]:\n                    return jsonify({'error': f'Missing required field: {field}'}), 400\n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n# Usage example\n@app.route('/api/users', methods=['POST'])\n@validate_json\n@validate_fields(['username', 'email'])\ndef create_user_with_validation():\n    data = request.get_json()\n    # Process validated data\n    pass\n```\n\nFlask RESTful APIs provide structured, HTTP-compliant interfaces with proper status codes, JSON responses, and consistent error handling, enabling clean client-server communication following REST architectural principles.",
      "keywords": ["flask", "REST API", "HTTP methods", "JSON", "status codes", "pagination", "validation", "error handling"],
      "difficulty": "medium"
    },
    {
      "id": 11017,
      "tag": "flask",
      "question": "What are Flask security best practices? Explain CSRF protection, XSS prevention, and secure headers.",
      "answer": "Flask security involves implementing multiple layers of protection including CSRF tokens, XSS prevention, secure headers, input validation, and proper authentication to protect against common web vulnerabilities.\n\n**CSRF Protection with Flask-WTF:**\n```python\nfrom flask import Flask, render_template, request, session\nfrom flask_wtf import FlaskForm, CSRFProtect\nfrom flask_wtf.csrf import validate_csrf, ValidationError\nfrom wtforms import StringField, SubmitField\nfrom wtforms.validators import DataRequired\n\napp = Flask(__name__)\napp.secret_key = 'your-very-secret-key-change-in-production'\n\n# Enable CSRF protection globally\ncsrf = CSRFProtect(app)\n\nclass ContactForm(FlaskForm):\n    name = StringField('Name', validators=[DataRequired()])\n    message = StringField('Message', validators=[DataRequired()])\n    submit = SubmitField('Submit')\n\n@app.route('/contact', methods=['GET', 'POST'])\ndef contact():\n    form = ContactForm()\n    \n    if form.validate_on_submit():\n        # CSRF token automatically validated\n        name = form.name.data\n        message = form.message.data\n        # Process form safely\n        return 'Form submitted successfully'\n    \n    return render_template('contact.html', form=form)\n\n# API endpoint with manual CSRF validation\n@app.route('/api/data', methods=['POST'])\ndef api_data():\n    try:\n        validate_csrf(request.headers.get('X-CSRFToken'))\n    except ValidationError:\n        return {'error': 'CSRF token missing or invalid'}, 400\n    \n    # Process API request\n    return {'status': 'success'}\n\n# CSRF exempt for specific endpoints (use carefully)\n@app.route('/webhook', methods=['POST'])\n@csrf.exempt\ndef webhook():\n    # External webhook endpoint\n    return 'OK'\n```\n\n**XSS Prevention and Output Escaping:**\n```python\nfrom flask import Markup, escape\nfrom markupsafe import Markup as SafeMarkup\nimport bleach\nimport html\n\n# Template auto-escaping (enabled by default in Jinja2)\n@app.route('/user/<username>')\ndef user_profile(username):\n    # Username is automatically escaped in template\n    return render_template('profile.html', username=username)\n\n# Manual escaping when needed\n@app.route('/comment')\ndef show_comment():\n    user_comment = request.args.get('comment', '')\n    \n    # Escape user input\n    safe_comment = escape(user_comment)\n    \n    # Or use html.escape for more control\n    safe_comment = html.escape(user_comment, quote=True)\n    \n    return f'<p>Comment: {safe_comment}</p>'\n\n# Safe HTML rendering with bleach\ndef clean_html(content):\n    \"\"\"Clean HTML content, allowing safe tags only\"\"\"\n    allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li', 'a']\n    allowed_attributes = {'a': ['href', 'title']}\n    \n    cleaned = bleach.clean(\n        content,\n        tags=allowed_tags,\n        attributes=allowed_attributes,\n        strip=True\n    )\n    \n    return SafeMarkup(cleaned)\n\n@app.route('/safe-content')\ndef safe_content():\n    user_html = request.form.get('content', '')\n    cleaned_html = clean_html(user_html)\n    \n    return render_template('content.html', content=cleaned_html)\n\n# Content Security Policy\n@app.after_request\ndef set_csp_header(response):\n    response.headers['Content-Security-Policy'] = (\n        \"default-src 'self'; \"\n        \"script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; \"\n        \"style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; \"\n        \"img-src 'self' data: https:; \"\n        \"font-src 'self' https://fonts.gstatic.com;\"\n    )\n    return response\n```\n\n**Secure Headers and HTTPS:**\n```python\nfrom flask_talisman import Talisman\n\n# Use Flask-Talisman for comprehensive security headers\nTalisman(app, \n    force_https=True,\n    strict_transport_security=True,\n    strict_transport_security_max_age=31536000,  # 1 year\n    content_security_policy={\n        'default-src': \"'self'\",\n        'script-src': \"'self' 'unsafe-inline'\",\n        'style-src': \"'self' 'unsafe-inline'\",\n    }\n)\n\n# Manual security headers\n@app.after_request\ndef security_headers(response):\n    # Prevent clickjacking\n    response.headers['X-Frame-Options'] = 'DENY'\n    \n    # Prevent MIME type sniffing\n    response.headers['X-Content-Type-Options'] = 'nosniff'\n    \n    # XSS Protection\n    response.headers['X-XSS-Protection'] = '1; mode=block'\n    \n    # Referrer Policy\n    response.headers['Referrer-Policy'] = 'strict-origin-when-cross-origin'\n    \n    # Permissions Policy\n    response.headers['Permissions-Policy'] = (\n        'geolocation=(), microphone=(), camera=()'\n    )\n    \n    return response\n\n# HTTPS redirect\n@app.before_request\ndef force_https():\n    if not request.is_secure and not app.debug:\n        return redirect(request.url.replace('http://', 'https://'))\n```\n\n**Input Validation and Sanitization:**\n```python\nfrom wtforms.validators import ValidationError\nimport re\n\ndef validate_username(form, field):\n    \"\"\"Custom validator for username\"\"\"\n    if not re.match(r'^[a-zA-Z0-9_]+$', field.data):\n        raise ValidationError('Username can only contain letters, numbers, and underscores')\n    \n    if len(field.data) < 3 or len(field.data) > 20:\n        raise ValidationError('Username must be between 3 and 20 characters')\n\ndef validate_email_domain(form, field):\n    \"\"\"Validate email domain\"\"\"\n    allowed_domains = ['company.com', 'gmail.com', 'outlook.com']\n    domain = field.data.split('@')[1].lower()\n    \n    if domain not in allowed_domains:\n        raise ValidationError('Email domain not allowed')\n\nclass SecureForm(FlaskForm):\n    username = StringField('Username', validators=[\n        DataRequired(),\n        validate_username\n    ])\n    email = StringField('Email', validators=[\n        DataRequired(),\n        Email(),\n        validate_email_domain\n    ])\n\n# SQL Injection prevention with parameterized queries\nfrom flask_sqlalchemy import SQLAlchemy\n\n@app.route('/search')\ndef search_users():\n    query = request.args.get('q', '')\n    \n    # Safe: Using SQLAlchemy ORM\n    users = User.query.filter(User.username.contains(query)).all()\n    \n    # Safe: Using parameterized query\n    users = db.session.execute(\n        'SELECT * FROM users WHERE username LIKE :query',\n        {'query': f'%{query}%'}\n    ).fetchall()\n    \n    return jsonify([user.to_dict() for user in users])\n```\n\n**Session Security:**\n```python\nfrom datetime import timedelta\nimport secrets\n\n# Secure session configuration\napp.config.update(\n    SECRET_KEY=secrets.token_urlsafe(32),  # Generate strong secret key\n    SESSION_COOKIE_SECURE=True,           # HTTPS only\n    SESSION_COOKIE_HTTPONLY=True,         # No JavaScript access\n    SESSION_COOKIE_SAMESITE='Strict',     # CSRF protection\n    PERMANENT_SESSION_LIFETIME=timedelta(hours=2),\n    SESSION_COOKIE_NAME='secure_session'   # Don't reveal framework\n)\n\n# Session validation\n@app.before_request\ndef validate_session():\n    if 'user_id' in session:\n        # Check session timeout\n        if 'last_activity' in session:\n            last_activity = datetime.fromisoformat(session['last_activity'])\n            if datetime.utcnow() - last_activity > timedelta(hours=2):\n                session.clear()\n                return redirect(url_for('login'))\n        \n        # Update last activity\n        session['last_activity'] = datetime.utcnow().isoformat()\n        \n        # Regenerate session ID periodically (every 30 minutes)\n        if 'session_created' in session:\n            created = datetime.fromisoformat(session['session_created'])\n            if datetime.utcnow() - created > timedelta(minutes=30):\n                session.permanent = True  # Regenerate session ID\n                session['session_created'] = datetime.utcnow().isoformat()\n```\n\n**Rate Limiting and Brute Force Protection:**\n```python\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\n# Initialize rate limiter\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"1000 per hour\"]\n)\n\n# Login rate limiting\n@app.route('/login', methods=['POST'])\n@limiter.limit(\"5 per minute\")  # Max 5 login attempts per minute\ndef login():\n    # Login logic\n    pass\n\n# API rate limiting\n@app.route('/api/data')\n@limiter.limit(\"100 per hour\")\ndef api_data():\n    # API logic\n    pass\n\n# Password validation\ndef validate_password_strength(password):\n    \"\"\"Validate password meets security requirements\"\"\"\n    if len(password) < 8:\n        return False, \"Password must be at least 8 characters\"\n    \n    if not re.search(r'[A-Z]', password):\n        return False, \"Password must contain uppercase letter\"\n    \n    if not re.search(r'[a-z]', password):\n        return False, \"Password must contain lowercase letter\"\n    \n    if not re.search(r'\\d', password):\n        return False, \"Password must contain a number\"\n    \n    if not re.search(r'[!@#$%^&*(),.?\":{}|<>]', password):\n        return False, \"Password must contain special character\"\n    \n    return True, \"Password is strong\"\n```\n\nFlask security requires implementing multiple protective measures including CSRF tokens, XSS prevention, secure headers, input validation, and proper session management to create robust, secure web applications that protect against common vulnerabilities.",
      "keywords": ["flask", "security", "CSRF", "XSS", "secure headers", "validation", "HTTPS", "session security", "rate limiting"],
      "difficulty": "medium"
    },
    {
      "id": 11018,
      "tag": "flask",
      "question": "How do you optimize Flask performance and scale applications? Explain caching, database optimization, and deployment strategies.",
      "answer": "Flask performance optimization involves implementing caching strategies, database query optimization, asynchronous processing, CDN usage, and scalable deployment architectures to handle high-traffic applications effectively.\n\n**Caching Implementation:**\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_caching import Cache\nfrom functools import wraps\nimport redis\nimport hashlib\n\napp = Flask(__name__)\n\n# Cache configuration\napp.config['CACHE_TYPE'] = 'redis'\napp.config['CACHE_REDIS_URL'] = 'redis://localhost:6379/0'\napp.config['CACHE_DEFAULT_TIMEOUT'] = 300  # 5 minutes\n\ncache = Cache(app)\nredis_client = redis.Redis(host='localhost', port=6379, db=1)\n\n# Simple caching\n@app.route('/expensive-data')\n@cache.cached(timeout=600)  # Cache for 10 minutes\ndef expensive_data():\n    # Simulate expensive operation\n    import time\n    time.sleep(2)\n    return jsonify({'data': 'expensive computation result'})\n\n# Parameterized caching\n@app.route('/user/<int:user_id>/profile')\n@cache.cached(timeout=300, key_prefix='user_profile')\ndef user_profile(user_id):\n    user = User.query.get_or_404(user_id)\n    return jsonify(user.to_dict())\n\n# Custom cache key generation\ndef make_cache_key(*args, **kwargs):\n    \"\"\"Generate cache key based on request parameters\"\"\"\n    key_parts = [request.path]\n    key_parts.extend(request.args.values())\n    key_string = '|'.join(key_parts)\n    return hashlib.md5(key_string.encode()).hexdigest()\n\n@app.route('/search')\n@cache.cached(timeout=600, key_prefix='search', make_cache_key=make_cache_key)\ndef search():\n    query = request.args.get('q', '')\n    results = perform_search(query)\n    return jsonify({'results': results})\n\n# Manual cache management\n@app.route('/posts')\ndef get_posts():\n    cache_key = f\"posts:{request.args.get('page', 1)}\"\n    cached_posts = cache.get(cache_key)\n    \n    if cached_posts is None:\n        posts = Post.query.paginate(page=int(request.args.get('page', 1)))\n        cached_posts = [post.to_dict() for post in posts.items]\n        cache.set(cache_key, cached_posts, timeout=300)\n    \n    return jsonify({'posts': cached_posts})\n\n# Cache invalidation\ndef invalidate_user_cache(user_id):\n    \"\"\"Invalidate all cached data for a user\"\"\"\n    cache.delete(f'user_profile_{user_id}')\n    cache.delete_memoized(user_profile, user_id)\n    \n    # Pattern-based cache deletion\n    keys = redis_client.keys(f'user_{user_id}_*')\n    if keys:\n        redis_client.delete(*keys)\n\n@app.route('/users/<int:user_id>', methods=['PUT'])\ndef update_user(user_id):\n    user = User.query.get_or_404(user_id)\n    # Update user logic\n    db.session.commit()\n    \n    # Invalidate related caches\n    invalidate_user_cache(user_id)\n    \n    return jsonify(user.to_dict())\n```\n\n**Database Optimization:**\n```python\nfrom flask_sqlalchemy import SQLAlchemy\nfrom sqlalchemy import text, func, and_, or_\nfrom sqlalchemy.orm import joinedload, selectinload\n\n# Optimized queries with eager loading\n@app.route('/users-with-posts')\ndef users_with_posts():\n    # Bad: N+1 query problem\n    # users = User.query.all()\n    # for user in users:\n    #     posts = user.posts  # Triggers separate query for each user\n    \n    # Good: Eager loading\n    users = User.query.options(selectinload(User.posts)).all()\n    \n    return jsonify([{\n        'user': user.to_dict(),\n        'posts': [post.to_dict() for post in user.posts]\n    } for user in users])\n\n# Efficient pagination with cursor-based pagination\n@app.route('/posts/cursor')\ndef cursor_paginated_posts():\n    cursor = request.args.get('cursor', type=int)\n    limit = min(request.args.get('limit', 20, type=int), 100)\n    \n    query = Post.query.order_by(Post.id.desc())\n    \n    if cursor:\n        query = query.filter(Post.id < cursor)\n    \n    posts = query.limit(limit + 1).all()\n    \n    has_next = len(posts) > limit\n    if has_next:\n        posts = posts[:-1]\n    \n    next_cursor = posts[-1].id if posts and has_next else None\n    \n    return jsonify({\n        'posts': [post.to_dict() for post in posts],\n        'next_cursor': next_cursor,\n        'has_next': has_next\n    })\n\n# Database connection pooling\napp.config['SQLALCHEMY_ENGINE_OPTIONS'] = {\n    'pool_size': 20,\n    'pool_recycle': 3600,\n    'pool_pre_ping': True,\n    'max_overflow': 30\n}\n\n# Query optimization with indexes\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False, index=True)\n    email = db.Column(db.String(120), unique=True, nullable=False, index=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow, index=True)\n    \n    # Composite index for common queries\n    __table_args__ = (\n        db.Index('idx_user_created_active', 'created_at', 'is_active'),\n    )\n\n# Raw SQL for complex queries\n@app.route('/analytics/user-stats')\ndef user_statistics():\n    result = db.session.execute(text(\"\"\"\n        SELECT \n            DATE(created_at) as date,\n            COUNT(*) as user_count,\n            COUNT(CASE WHEN is_active = 1 THEN 1 END) as active_count\n        FROM users \n        WHERE created_at >= :start_date\n        GROUP BY DATE(created_at)\n        ORDER BY date DESC\n    \"\"\"), {'start_date': '2023-01-01'})\n    \n    return jsonify([dict(row) for row in result])\n```\n\n**Asynchronous Processing:**\n```python\nfrom celery import Celery\nfrom flask_mail import Mail, Message\n\n# Celery configuration\ncelery = Celery(app.name, broker='redis://localhost:6379/0')\ncelery.conf.update(app.config)\nmail = Mail(app)\n\n# Background tasks\n@celery.task\ndef send_email_async(subject, recipients, body):\n    \"\"\"Send email asynchronously\"\"\"\n    msg = Message(subject=subject, recipients=recipients, body=body)\n    mail.send(msg)\n    return f\"Email sent to {recipients}\"\n\n@celery.task\ndef process_image_upload(image_path, user_id):\n    \"\"\"Process uploaded image in background\"\"\"\n    from PIL import Image\n    \n    # Generate thumbnails\n    img = Image.open(image_path)\n    \n    # Create different sizes\n    sizes = [(150, 150), (300, 300), (800, 600)]\n    for size in sizes:\n        thumbnail = img.copy()\n        thumbnail.thumbnail(size, Image.Resampling.LANCZOS)\n        \n        filename = f\"thumb_{size[0]}x{size[1]}_{os.path.basename(image_path)}\"\n        thumbnail_path = os.path.join('uploads/thumbnails', filename)\n        thumbnail.save(thumbnail_path)\n    \n    # Update database\n    user = User.query.get(user_id)\n    user.profile_image = image_path\n    db.session.commit()\n    \n    return \"Image processing completed\"\n\n# Non-blocking endpoints\n@app.route('/upload-image', methods=['POST'])\ndef upload_image():\n    file = request.files['image']\n    \n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(filepath)\n        \n        # Process asynchronously\n        task = process_image_upload.delay(filepath, current_user.id)\n        \n        return jsonify({\n            'message': 'Image uploaded successfully',\n            'task_id': task.id,\n            'status': 'processing'\n        }), 202\n\n@app.route('/task-status/<task_id>')\ndef task_status(task_id):\n    task = process_image_upload.AsyncResult(task_id)\n    \n    return jsonify({\n        'task_id': task_id,\n        'status': task.status,\n        'result': task.result if task.ready() else None\n    })\n```\n\n**Production Deployment and Scaling:**\n```python\n# Gunicorn configuration (gunicorn_config.py)\nbind = \"0.0.0.0:8000\"\nworkers = 4  # (CPU cores * 2) + 1\nworker_class = \"gevent\"\nworker_connections = 1000\nmax_requests = 1000\nmax_requests_jitter = 100\npreload_app = True\nkeepalive = 2\n\n# Application factory for production\ndef create_app(config_name='production'):\n    app = Flask(__name__)\n    app.config.from_object(config[config_name])\n    \n    # Initialize extensions\n    db.init_app(app)\n    cache.init_app(app)\n    \n    # Register blueprints\n    from app.api import bp as api_bp\n    app.register_blueprint(api_bp, url_prefix='/api')\n    \n    # Health check endpoint\n    @app.route('/health')\n    def health_check():\n        try:\n            # Check database\n            db.session.execute('SELECT 1')\n            \n            # Check cache\n            cache.set('health_check', 'ok', timeout=1)\n            cache.get('health_check')\n            \n            return jsonify({\n                'status': 'healthy',\n                'timestamp': datetime.utcnow().isoformat()\n            }), 200\n        except Exception as e:\n            return jsonify({\n                'status': 'unhealthy',\n                'error': str(e)\n            }), 503\n    \n    return app\n\n# Docker configuration\n# Dockerfile\n'''\nFROM python:3.9-slim\n\nWORKDIR /app\n\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\nCOPY . .\n\nEXPOSE 8000\n\nCMD [\"gunicorn\", \"--config\", \"gunicorn_config.py\", \"app:create_app()\"]\n'''\n\n# Nginx configuration for load balancing\n'''\nupstream flask_app {\n    server app1:8000;\n    server app2:8000;\n    server app3:8000;\n}\n\nserver {\n    listen 80;\n    server_name yourdomain.com;\n    \n    location /static/ {\n        alias /var/www/static/;\n        expires 1y;\n        add_header Cache-Control \"public, immutable\";\n    }\n    \n    location / {\n        proxy_pass http://flask_app;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n}\n'''\n```\n\n**Monitoring and Performance Tracking:**\n```python\nfrom flask import g\nimport time\n\n# Request timing middleware\n@app.before_request\ndef before_request():\n    g.start_time = time.time()\n\n@app.after_request\ndef after_request(response):\n    if hasattr(g, 'start_time'):\n        duration = time.time() - g.start_time\n        response.headers['X-Response-Time'] = f\"{duration:.3f}s\"\n        \n        # Log slow requests\n        if duration > 1.0:  # Log requests taking more than 1 second\n            app.logger.warning(f\"Slow request: {request.path} took {duration:.3f}s\")\n    \n    return response\n\n# Database query monitoring\nimport logging\nlogging.getLogger('sqlalchemy.engine').setLevel(logging.INFO)\n```\n\nFlask performance optimization requires a comprehensive approach including intelligent caching, database optimization, asynchronous processing, and scalable deployment strategies to handle production workloads efficiently.",
      "keywords": ["flask", "performance", "caching", "database optimization", "scaling", "deployment", "gunicorn", "celery", "redis"],
      "difficulty": "hard"
    },
    {
      "id": 11019,
      "tag": "flask",
      "question": "What are advanced Flask patterns? Explain custom decorators, middleware, application factories, and plugin architecture.",
      "answer": "Advanced Flask patterns include custom decorators for cross-cutting concerns, middleware for request/response processing, application factories for flexible configuration, and plugin architectures for extensible applications.\n\n**Custom Decorators for Common Functionality:**\n```python\nfrom functools import wraps\nfrom flask import request, jsonify, current_app, g\nfrom flask_login import current_user\nimport time\nimport json\n\n# Authentication and authorization decorator\ndef require_roles(*roles):\n    \"\"\"Decorator to require specific user roles\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not current_user.is_authenticated:\n                return jsonify({'error': 'Authentication required'}), 401\n            \n            if not any(current_user.has_role(role) for role in roles):\n                return jsonify({'error': 'Insufficient privileges'}), 403\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n# API key authentication decorator\ndef require_api_key(f):\n    \"\"\"Decorator to require valid API key\"\"\"\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        api_key = request.headers.get('X-API-Key')\n        \n        if not api_key:\n            return jsonify({'error': 'API key required'}), 401\n        \n        # Validate API key (implement your logic)\n        if not is_valid_api_key(api_key):\n            return jsonify({'error': 'Invalid API key'}), 401\n        \n        # Store API key info in g for use in view\n        g.api_key = api_key\n        g.api_user = get_api_user(api_key)\n        \n        return f(*args, **kwargs)\n    return decorated_function\n\n# Rate limiting decorator\ndef rate_limit(max_requests=100, window=3600, key_func=None):\n    \"\"\"Custom rate limiting decorator\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            # Generate rate limit key\n            if key_func:\n                key = key_func()\n            else:\n                key = f\"rate_limit:{request.remote_addr}:{request.endpoint}\"\n            \n            # Check current count\n            current_count = cache.get(key) or 0\n            \n            if current_count >= max_requests:\n                return jsonify({\n                    'error': 'Rate limit exceeded',\n                    'retry_after': window\n                }), 429\n            \n            # Increment counter\n            cache.set(key, current_count + 1, timeout=window)\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n# Validation decorator\ndef validate_json(*required_fields):\n    \"\"\"Decorator to validate JSON request data\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            if not request.is_json:\n                return jsonify({'error': 'Content-Type must be application/json'}), 400\n            \n            data = request.get_json()\n            \n            # Check required fields\n            missing_fields = [field for field in required_fields if field not in data]\n            if missing_fields:\n                return jsonify({\n                    'error': 'Missing required fields',\n                    'missing': missing_fields\n                }), 400\n            \n            # Store validated data in g\n            g.json_data = data\n            \n            return f(*args, **kwargs)\n        return decorated_function\n    return decorator\n\n# Performance monitoring decorator\ndef monitor_performance(threshold=1.0):\n    \"\"\"Decorator to monitor endpoint performance\"\"\"\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            start_time = time.time()\n            \n            try:\n                result = f(*args, **kwargs)\n                status = 'success'\n                return result\n            except Exception as e:\n                status = 'error'\n                raise\n            finally:\n                duration = time.time() - start_time\n                \n                # Log performance metrics\n                current_app.logger.info(f\"Performance: {request.endpoint} - {duration:.3f}s - {status}\")\n                \n                # Alert for slow requests\n                if duration > threshold:\n                    current_app.logger.warning(f\"Slow request: {request.endpoint} took {duration:.3f}s\")\n        \n        return decorated_function\n    return decorator\n\n# Usage examples\n@app.route('/admin/users')\n@require_roles('admin', 'moderator')\n@monitor_performance(threshold=0.5)\ndef admin_users():\n    users = User.query.all()\n    return jsonify([user.to_dict() for user in users])\n\n@app.route('/api/data', methods=['POST'])\n@require_api_key\n@rate_limit(max_requests=50, window=3600)\n@validate_json('name', 'email')\ndef create_data():\n    data = g.json_data\n    # Process data\n    return jsonify({'status': 'created'})\n```\n\n**Custom Middleware Implementation:**\n```python\nclass RequestLoggingMiddleware:\n    \"\"\"Middleware to log all requests with detailed information\"\"\"\n    \n    def __init__(self, app=None):\n        self.app = app\n        if app is not None:\n            self.init_app(app)\n    \n    def init_app(self, app):\n        app.before_request(self.before_request)\n        app.after_request(self.after_request)\n        app.teardown_appcontext(self.teardown)\n    \n    def before_request(self):\n        g.start_time = time.time()\n        g.request_id = str(uuid.uuid4())\n        \n        # Log request details\n        current_app.logger.info(f\"Request [{g.request_id}]: {request.method} {request.path}\")\n        \n        if request.is_json:\n            current_app.logger.debug(f\"Request [{g.request_id}] JSON: {request.get_json()}\")\n    \n    def after_request(self, response):\n        if hasattr(g, 'start_time'):\n            duration = time.time() - g.start_time\n            \n            current_app.logger.info(\n                f\"Response [{g.request_id}]: {response.status_code} - {duration:.3f}s\"\n            )\n        \n        return response\n    \n    def teardown(self, exception):\n        if exception:\n            current_app.logger.error(f\"Request [{g.request_id}] failed: {exception}\")\n\nclass SecurityMiddleware:\n    \"\"\"Security-focused middleware\"\"\"\n    \n    def __init__(self, app=None):\n        if app:\n            self.init_app(app)\n    \n    def init_app(self, app):\n        app.before_request(self.security_checks)\n        app.after_request(self.add_security_headers)\n    \n    def security_checks(self):\n        # Block requests from suspicious IPs\n        blocked_ips = current_app.config.get('BLOCKED_IPS', [])\n        if request.remote_addr in blocked_ips:\n            abort(403, 'Access denied')\n        \n        # Validate User-Agent\n        user_agent = request.headers.get('User-Agent', '')\n        if not user_agent or 'bot' in user_agent.lower():\n            if request.endpoint not in ['api.public_data']:\n                abort(403, 'Invalid User-Agent')\n    \n    def add_security_headers(self, response):\n        security_headers = {\n            'X-Content-Type-Options': 'nosniff',\n            'X-Frame-Options': 'DENY',\n            'X-XSS-Protection': '1; mode=block',\n            'Strict-Transport-Security': 'max-age=31536000; includeSubDomains'\n        }\n        \n        for header, value in security_headers.items():\n            response.headers[header] = value\n        \n        return response\n```\n\n**Application Factory Pattern:**\n```python\n# app/__init__.py\nfrom flask import Flask\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_login import LoginManager\nfrom flask_migrate import Migrate\nfrom flask_mail import Mail\nfrom config import config\n\n# Initialize extensions\ndb = SQLAlchemy()\nlogin_manager = LoginManager()\nmigrate = Migrate()\nmail = Mail()\n\ndef create_app(config_name=None):\n    \"\"\"Application factory function\"\"\"\n    app = Flask(__name__)\n    \n    # Load configuration\n    if config_name is None:\n        config_name = os.environ.get('FLASK_CONFIG', 'default')\n    \n    app.config.from_object(config[config_name])\n    config[config_name].init_app(app)\n    \n    # Initialize extensions with app\n    db.init_app(app)\n    login_manager.init_app(app)\n    migrate.init_app(app, db)\n    mail.init_app(app)\n    \n    # Initialize custom middleware\n    RequestLoggingMiddleware(app)\n    SecurityMiddleware(app)\n    \n    # Register blueprints\n    from app.main import bp as main_bp\n    app.register_blueprint(main_bp)\n    \n    from app.api import bp as api_bp\n    app.register_blueprint(api_bp, url_prefix='/api/v1')\n    \n    from app.auth import bp as auth_bp\n    app.register_blueprint(auth_bp, url_prefix='/auth')\n    \n    # Register CLI commands\n    register_cli_commands(app)\n    \n    # Register error handlers\n    register_error_handlers(app)\n    \n    return app\n\ndef register_cli_commands(app):\n    \"\"\"Register custom CLI commands\"\"\"\n    \n    @app.cli.command()\n    def init_db():\n        \"\"\"Initialize the database\"\"\"\n        db.create_all()\n        print('Database initialized')\n    \n    @app.cli.command()\n    @click.argument('username')\n    @click.argument('email')\n    def create_admin(username, email):\n        \"\"\"Create admin user\"\"\"\n        admin = User(username=username, email=email, role='admin')\n        admin.set_password('admin123')  # Temporary password\n        db.session.add(admin)\n        db.session.commit()\n        print(f'Admin user {username} created')\n\ndef register_error_handlers(app):\n    \"\"\"Register global error handlers\"\"\"\n    \n    @app.errorhandler(404)\n    def not_found_error(error):\n        if request.path.startswith('/api/'):\n            return jsonify({'error': 'Not found'}), 404\n        return render_template('errors/404.html'), 404\n    \n    @app.errorhandler(500)\n    def internal_error(error):\n        db.session.rollback()\n        if request.path.startswith('/api/'):\n            return jsonify({'error': 'Internal server error'}), 500\n        return render_template('errors/500.html'), 500\n```\n\n**Plugin Architecture:**\n```python\n# Plugin base class\nclass FlaskPlugin:\n    \"\"\"Base class for Flask plugins\"\"\"\n    \n    def __init__(self, name):\n        self.name = name\n        self.app = None\n    \n    def init_app(self, app):\n        \"\"\"Initialize plugin with Flask app\"\"\"\n        self.app = app\n        self.register_hooks()\n        app.extensions[self.name] = self\n    \n    def register_hooks(self):\n        \"\"\"Register plugin hooks - override in subclasses\"\"\"\n        pass\n\n# Example plugin implementations\nclass AuditLogPlugin(FlaskPlugin):\n    \"\"\"Plugin to log all database changes\"\"\"\n    \n    def __init__(self):\n        super().__init__('audit_log')\n        self.audit_logs = []\n    \n    def register_hooks(self):\n        # Hook into SQLAlchemy events\n        from sqlalchemy import event\n        \n        @event.listens_for(db.session, 'before_commit')\n        def before_commit(session):\n            self.log_changes(session)\n        \n        # Add CLI command\n        @self.app.cli.command()\n        def show_audit_log():\n            for log in self.audit_logs[-10:]:  # Show last 10 entries\n                print(f\"{log['timestamp']}: {log['action']} on {log['table']}\")\n    \n    def log_changes(self, session):\n        for obj in session.new:\n            self.audit_logs.append({\n                'timestamp': datetime.utcnow(),\n                'action': 'INSERT',\n                'table': obj.__tablename__,\n                'id': getattr(obj, 'id', None)\n            })\n        \n        for obj in session.dirty:\n            self.audit_logs.append({\n                'timestamp': datetime.utcnow(),\n                'action': 'UPDATE',\n                'table': obj.__tablename__,\n                'id': getattr(obj, 'id', None)\n            })\n        \n        for obj in session.deleted:\n            self.audit_logs.append({\n                'timestamp': datetime.utcnow(),\n                'action': 'DELETE',\n                'table': obj.__tablename__,\n                'id': getattr(obj, 'id', None)\n            })\n\nclass MetricsPlugin(FlaskPlugin):\n    \"\"\"Plugin to collect application metrics\"\"\"\n    \n    def __init__(self):\n        super().__init__('metrics')\n        self.metrics = {\n            'request_count': 0,\n            'response_times': [],\n            'error_count': 0\n        }\n    \n    def register_hooks(self):\n        @self.app.before_request\n        def before_request():\n            g.start_time = time.time()\n            self.metrics['request_count'] += 1\n        \n        @self.app.after_request\n        def after_request(response):\n            if hasattr(g, 'start_time'):\n                duration = time.time() - g.start_time\n                self.metrics['response_times'].append(duration)\n                \n                # Keep only last 1000 response times\n                if len(self.metrics['response_times']) > 1000:\n                    self.metrics['response_times'] = self.metrics['response_times'][-1000:]\n                \n                if response.status_code >= 400:\n                    self.metrics['error_count'] += 1\n            \n            return response\n        \n        # Add metrics endpoint\n        @self.app.route('/metrics')\n        def metrics_endpoint():\n            avg_response_time = sum(self.metrics['response_times']) / len(self.metrics['response_times']) if self.metrics['response_times'] else 0\n            \n            return jsonify({\n                'request_count': self.metrics['request_count'],\n                'error_count': self.metrics['error_count'],\n                'avg_response_time': avg_response_time,\n                'uptime_seconds': time.time() - self.app.start_time\n            })\n\n# Plugin manager\nclass PluginManager:\n    \"\"\"Manage Flask plugins\"\"\"\n    \n    def __init__(self, app=None):\n        self.plugins = {}\n        if app:\n            self.init_app(app)\n    \n    def init_app(self, app):\n        app.plugin_manager = self\n        app.start_time = time.time()\n    \n    def register_plugin(self, plugin):\n        \"\"\"Register a plugin\"\"\"\n        self.plugins[plugin.name] = plugin\n        if hasattr(self, 'app'):\n            plugin.init_app(self.app)\n    \n    def get_plugin(self, name):\n        \"\"\"Get a plugin by name\"\"\"\n        return self.plugins.get(name)\n\n# Usage in application factory\ndef create_app(config_name=None):\n    app = Flask(__name__)\n    # ... other initialization ...\n    \n    # Initialize plugin manager\n    plugin_manager = PluginManager(app)\n    \n    # Register plugins\n    audit_plugin = AuditLogPlugin()\n    metrics_plugin = MetricsPlugin()\n    \n    plugin_manager.register_plugin(audit_plugin)\n    plugin_manager.register_plugin(metrics_plugin)\n    \n    return app\n```\n\nAdvanced Flask patterns enable building sophisticated, maintainable applications with reusable components, flexible architectures, and comprehensive cross-cutting concerns handled through decorators, middleware, and plugin systems.",
      "keywords": ["flask", "decorators", "middleware", "application factory", "plugins", "patterns", "architecture", "extensibility", "hooks"],
      "difficulty": "hard"
    }
  ]
}