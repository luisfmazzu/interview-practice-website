{
  "technology": "graphql",
  "questions": [
    {
      "id": 0,
      "tag": "graphql",
      "question": "What is GraphQL and how does it differ from REST APIs?",
      "answer": "**GraphQL** is a query language and runtime for APIs that allows clients to request exactly the data they need.\n\n**Key Differences from REST:**\n\n**GraphQL:**\n- **Single endpoint:** One URL for all operations\n- **Flexible queries:** Client specifies exact data needed\n- **Strong type system:** Schema-defined data structure\n- **Real-time subscriptions:** Built-in live data updates\n- **No over-fetching:** Get only requested fields\n- **Introspective:** Self-documenting API\n\n**REST:**\n- **Multiple endpoints:** Different URLs for different resources\n- **Fixed responses:** Server determines response structure\n- **Over/under-fetching:** Often get too much or too little data\n- **HTTP methods:** GET, POST, PUT, DELETE for operations\n- **Caching:** Simpler HTTP-based caching\n\n**GraphQL Benefits:**\n- **Efficient data loading:** Reduce network requests\n- **Strong typing:** Better developer experience\n- **Evolution without versioning:** Add fields without breaking changes\n- **Better mobile experience:** Reduced data transfer",
      "keywords": ["GraphQL", "REST API", "single endpoint", "flexible queries", "type system", "over-fetching", "subscriptions", "schema"],
      "difficulty": "easy"
    },
    {
      "id": 1,
      "tag": "graphql",
      "question": "Explain GraphQL schema, types, and resolvers.",
      "answer": "**GraphQL Schema** defines the API's type system and available operations.\n\n**Schema Example:**\n```graphql\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!\n}\n\ntype Query {\n  user(id: ID!): User\n  posts: [Post!]!\n}\n\ntype Mutation {\n  createPost(title: String!, content: String!): Post!\n}\n```\n\n**GraphQL Types:**\n- **Scalar types:** String, Int, Float, Boolean, ID\n- **Object types:** Custom types with fields\n- **List types:** Arrays of other types\n- **Non-null types:** Fields that cannot be null (!)\n- **Enums:** Fixed set of values\n- **Interfaces:** Abstract types\n- **Unions:** One of several types\n\n**Resolvers** are functions that fetch data for each field:\n```javascript\nconst resolvers = {\n  Query: {\n    user: (parent, args, context) => getUserById(args.id),\n    posts: () => getAllPosts()\n  },\n  User: {\n    posts: (user) => getPostsByUserId(user.id)\n  }\n};\n```\n\n**Resolver Function Signature:** `(parent, args, context, info) => data`",
      "keywords": ["GraphQL schema", "type system", "resolvers", "scalar types", "object types", "mutations", "query", "type definitions"],
      "difficulty": "medium"
    },
    {
      "id": 2,
      "tag": "graphql",
      "question": "What are GraphQL queries, mutations, and subscriptions?",
      "answer": "**GraphQL Operations:**\n\n**1. Queries (Read Operations):**\n```graphql\n# Simple query\nquery {\n  user(id: \"1\") {\n    name\n    email\n  }\n}\n\n# Query with variables\nquery GetUser($userId: ID!) {\n  user(id: $userId) {\n    name\n    posts {\n      title\n      createdAt\n    }\n  }\n}\n\n# Multiple fields in one request\nquery {\n  users {\n    name\n  }\n  posts {\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\n**2. Mutations (Write Operations):**\n```graphql\n# Create new data\nmutation {\n  createPost(title: \"Hello\", content: \"World\") {\n    id\n    title\n    author {\n      name\n    }\n  }\n}\n\n# Update existing data\nmutation UpdateUser($id: ID!, $name: String) {\n  updateUser(id: $id, name: $name) {\n    id\n    name\n    updatedAt\n  }\n}\n```\n\n**3. Subscriptions (Real-time Operations):**\n```graphql\n# Listen for new posts\nsubscription {\n  postAdded {\n    id\n    title\n    author {\n      name\n    }\n  }\n}\n```\n\n**Key Features:**\n- **Declarative:** Specify exactly what data you need\n- **Hierarchical:** Matches data structure\n- **Strongly typed:** Validated against schema",
      "keywords": ["GraphQL queries", "mutations", "subscriptions", "variables", "real-time", "declarative", "hierarchical", "strongly typed"],
      "difficulty": "easy"
    },
    {
      "id": 3,
      "tag": "graphql",
      "question": "How does GraphQL handle the N+1 query problem?",
      "answer": "**N+1 Query Problem** occurs when fetching a list of items triggers additional queries for each item's related data.\n\n**Example Problem:**\n```graphql\nquery {\n  posts {        # 1 query to get posts\n    title\n    author {     # N additional queries (one per post)\n      name\n    }\n  }\n}\n```\n\n**Solutions:**\n\n**1. DataLoader (Facebook's Solution):**\n```javascript\nconst DataLoader = require('dataloader');\n\n// Batch function\nconst batchUsers = async (userIds) => {\n  const users = await getUsersByIds(userIds);\n  return userIds.map(id => users.find(user => user.id === id));\n};\n\nconst userLoader = new DataLoader(batchUsers);\n\n// Resolver using DataLoader\nconst resolvers = {\n  Post: {\n    author: (post) => userLoader.load(post.authorId)\n  }\n};\n```\n\n**2. Query Complexity Analysis:**\n```javascript\nconst depthLimit = require('graphql-depth-limit');\nconst costAnalysis = require('graphql-cost-analysis');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  validationRules: [\n    depthLimit(10),\n    costAnalysis({ maximumCost: 1000 })\n  ]\n});\n```\n\n**3. Field-level Caching:**\n- Cache resolver results\n- Use Redis or in-memory cache\n- Implement cache invalidation strategies\n\n**4. Database-level Solutions:**\n- Use JOINs in SQL queries\n- Optimize database queries\n- Implement proper indexing",
      "keywords": ["N+1 problem", "DataLoader", "batching", "query complexity", "caching", "performance optimization", "database optimization"],
      "difficulty": "hard"
    },
    {
      "id": 4,
      "tag": "graphql",
      "question": "What are GraphQL fragments and how are they used?",
      "answer": "**GraphQL Fragments** are reusable units of query logic that can be shared across multiple queries.\n\n**Basic Fragment Example:**\n```graphql\n# Define fragment\nfragment UserInfo on User {\n  id\n  name\n  email\n  avatarUrl\n}\n\n# Use fragment in query\nquery {\n  user(id: \"1\") {\n    ...UserInfo\n  }\n  currentUser {\n    ...UserInfo\n  }\n}\n```\n\n**Nested Fragments:**\n```graphql\nfragment PostInfo on Post {\n  id\n  title\n  content\n  author {\n    ...UserInfo\n  }\n}\n\nfragment UserInfo on User {\n  id\n  name\n  email\n}\n\nquery {\n  posts {\n    ...PostInfo\n  }\n}\n```\n\n**Inline Fragments (Type Conditions):**\n```graphql\nquery {\n  search(query: \"javascript\") {\n    ... on User {\n      name\n      email\n    }\n    ... on Post {\n      title\n      content\n    }\n  }\n}\n```\n\n**Benefits:**\n- **DRY principle:** Avoid repeating field selections\n- **Maintainability:** Update fragment once, affects all uses\n- **Type safety:** Fragments are tied to specific types\n- **Conditional logic:** Handle union and interface types\n\n**Client-side Usage (Apollo Client):**\n```javascript\nconst USER_INFO = gql`\n  fragment UserInfo on User {\n    id\n    name\n    email\n  }\n`;\n```",
      "keywords": ["GraphQL fragments", "reusable queries", "inline fragments", "type conditions", "DRY principle", "union types", "interface types"],
      "difficulty": "medium"
    },
    {
      "id": 5,
      "tag": "graphql",
      "question": "How do you implement authentication and authorization in GraphQL?",
      "answer": "**GraphQL Authentication & Authorization:**\n\n**1. Authentication (Who are you?):**\n\n**Context-based Authentication:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => {\n    const token = req.headers.authorization?.replace('Bearer ', '');\n    const user = validateToken(token);\n    return { user };\n  }\n});\n\n// In resolvers\nconst resolvers = {\n  Query: {\n    me: (parent, args, context) => {\n      if (!context.user) {\n        throw new AuthenticationError('Not authenticated');\n      }\n      return context.user;\n    }\n  }\n};\n```\n\n**2. Authorization (What can you do?):**\n\n**Field-level Authorization:**\n```javascript\nconst resolvers = {\n  User: {\n    email: (user, args, context) => {\n      // Only return email for own profile or admin\n      if (context.user.id !== user.id && !context.user.isAdmin) {\n        throw new ForbiddenError('Access denied');\n      }\n      return user.email;\n    }\n  }\n};\n```\n\n**Schema Directives:**\n```graphql\ndirective @auth(requires: Role = USER) on FIELD_DEFINITION\n\nenum Role {\n  ADMIN\n  USER\n}\n\ntype Query {\n  users: [User!]! @auth(requires: ADMIN)\n  me: User @auth(requires: USER)\n}\n```\n\n**3. Best Practices:**\n- **Never trust client-side:** Always validate on server\n- **Principle of least privilege:** Deny by default\n- **Layer authorization:** Multiple levels of checks\n- **Rate limiting:** Prevent abuse\n- **Audit logging:** Track access patterns",
      "keywords": ["authentication", "authorization", "context", "JWT tokens", "field-level security", "schema directives", "rate limiting", "audit logging"],
      "difficulty": "medium"
    },
    {
      "id": 6,
      "tag": "graphql",
      "question": "What is Apollo Server and how do you set it up?",
      "answer": "**Apollo Server** is a popular GraphQL server implementation that works with any GraphQL schema.\n\n**Basic Setup:**\n```javascript\nconst { ApolloServer, gql } = require('apollo-server-express');\nconst express = require('express');\n\n// Type definitions\nconst typeDefs = gql`\n  type Book {\n    title: String\n    author: String\n  }\n\n  type Query {\n    books: [Book]\n  }\n`;\n\n// Resolvers\nconst resolvers = {\n  Query: {\n    books: () => [\n      { title: '1984', author: 'George Orwell' },\n      { title: 'Brave New World', author: 'Aldous Huxley' }\n    ]\n  }\n};\n\n// Server setup\nconst server = new ApolloServer({ \n  typeDefs, \n  resolvers,\n  context: ({ req }) => ({ user: req.user })\n});\n\nconst app = express();\nserver.applyMiddleware({ app });\n\napp.listen(4000, () => {\n  console.log(`Server ready at http://localhost:4000${server.graphqlPath}`);\n});\n```\n\n**Advanced Configuration:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => ({ user: req.user }),\n  formatError: (error) => {\n    console.error(error);\n    return new Error('Internal server error');\n  },\n  introspection: process.env.NODE_ENV !== 'production',\n  playground: process.env.NODE_ENV !== 'production',\n  plugins: [\n    require('apollo-server-plugin-response-cache')()\n  ]\n});\n```\n\n**Features:**\n- **GraphQL Playground:** Interactive query interface\n- **Introspection:** Self-documenting API\n- **Error handling:** Formatted error responses\n- **Caching:** Built-in response caching\n- **Metrics:** Performance monitoring",
      "keywords": ["Apollo Server", "GraphQL server", "type definitions", "resolvers", "context", "playground", "introspection", "error handling", "caching"],
      "difficulty": "medium"
    },
    {
      "id": 7,
      "tag": "graphql",
      "question": "How do you handle errors in GraphQL?",
      "answer": "**GraphQL Error Handling:**\n\n**1. GraphQL Error Response Format:**\n```json\n{\n  \"data\": {\n    \"user\": null\n  },\n  \"errors\": [\n    {\n      \"message\": \"User not found\",\n      \"locations\": [{ \"line\": 2, \"column\": 3 }],\n      \"path\": [\"user\"],\n      \"extensions\": {\n        \"code\": \"USER_NOT_FOUND\",\n        \"userId\": \"123\"\n      }\n    }\n  ]\n}\n```\n\n**2. Custom Error Classes:**\n```javascript\nconst { ApolloError } = require('apollo-server-express');\n\nclass UserNotFoundError extends ApolloError {\n  constructor(userId) {\n    super('User not found', 'USER_NOT_FOUND', { userId });\n  }\n}\n\nclass ValidationError extends ApolloError {\n  constructor(field, value) {\n    super(`Invalid ${field}: ${value}`, 'VALIDATION_ERROR', { field, value });\n  }\n}\n```\n\n**3. Error Handling in Resolvers:**\n```javascript\nconst resolvers = {\n  Query: {\n    user: async (parent, { id }) => {\n      try {\n        const user = await getUserById(id);\n        if (!user) {\n          throw new UserNotFoundError(id);\n        }\n        return user;\n      } catch (error) {\n        if (error instanceof DatabaseError) {\n          throw new ApolloError('Database connection failed', 'DATABASE_ERROR');\n        }\n        throw error;\n      }\n    }\n  }\n};\n```\n\n**4. Global Error Formatting:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  formatError: (error) => {\n    // Log error\n    console.error(error);\n    \n    // Hide internal errors in production\n    if (process.env.NODE_ENV === 'production' && !error.extensions?.code) {\n      return new Error('Internal server error');\n    }\n    \n    return error;\n  }\n});\n```\n\n**Best Practices:**\n- **Structured errors:** Use consistent error codes\n- **Partial data:** Return partial results when possible\n- **Security:** Don't expose sensitive information\n- **Logging:** Log errors for debugging",
      "keywords": ["GraphQL errors", "error handling", "custom errors", "error formatting", "partial data", "error codes", "security", "logging"],
      "difficulty": "medium"
    },
    {
      "id": 8,
      "tag": "graphql",
      "question": "What are GraphQL subscriptions and how do you implement them?",
      "answer": "**GraphQL Subscriptions** enable real-time data updates by maintaining persistent connections between client and server.\n\n**Schema Definition:**\n```graphql\ntype Subscription {\n  postAdded: Post!\n  commentAdded(postId: ID!): Comment!\n  userStatusChanged: User!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n}\n```\n\n**Server Implementation (Apollo Server):**\n```javascript\nconst { PubSub } = require('apollo-server-express');\nconst pubsub = new PubSub();\n\nconst resolvers = {\n  Mutation: {\n    createPost: async (parent, { title, content }) => {\n      const post = await createPost({ title, content });\n      \n      // Publish event\n      pubsub.publish('POST_ADDED', { postAdded: post });\n      \n      return post;\n    }\n  },\n  \n  Subscription: {\n    postAdded: {\n      subscribe: () => pubsub.asyncIterator('POST_ADDED')\n    },\n    \n    commentAdded: {\n      subscribe: (parent, { postId }) => \n        pubsub.asyncIterator(`COMMENT_ADDED_${postId}`)\n    }\n  }\n};\n\n// Server with subscription support\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers\n});\n\nconst httpServer = createServer(app);\nserver.installSubscriptionHandlers(httpServer);\n```\n\n**Client Implementation (Apollo Client):**\n```javascript\nimport { useSubscription } from '@apollo/client';\n\nconst POST_ADDED_SUBSCRIPTION = gql`\n  subscription {\n    postAdded {\n      id\n      title\n      content\n    }\n  }\n`;\n\nfunction PostList() {\n  const { data, loading } = useSubscription(POST_ADDED_SUBSCRIPTION);\n  \n  if (data) {\n    console.log('New post:', data.postAdded);\n  }\n  \n  return <div>...</div>;\n}\n```\n\n**Transport Protocols:**\n- **WebSockets:** Most common for subscriptions\n- **Server-Sent Events (SSE):** HTTP-based alternative\n- **WebRTC:** For peer-to-peer connections",
      "keywords": ["GraphQL subscriptions", "real-time", "PubSub", "WebSockets", "persistent connections", "Apollo Client", "event publishing", "live updates"],
      "difficulty": "hard"
    },
    {
      "id": 9,
      "tag": "graphql",
      "question": "How do you implement pagination in GraphQL?",
      "answer": "**GraphQL Pagination Strategies:**\n\n**1. Offset-based Pagination:**\n```graphql\ntype Query {\n  posts(offset: Int, limit: Int): PostConnection!\n}\n\ntype PostConnection {\n  posts: [Post!]!\n  totalCount: Int!\n  hasMore: Boolean!\n}\n```\n\n**2. Cursor-based Pagination (Relay Specification):**\n```graphql\ntype Query {\n  posts(\n    first: Int\n    after: String\n    last: Int\n    before: String\n  ): PostConnection!\n}\n\ntype PostConnection {\n  edges: [PostEdge!]!\n  pageInfo: PageInfo!\n  totalCount: Int\n}\n\ntype PostEdge {\n  node: Post!\n  cursor: String!\n}\n\ntype PageInfo {\n  hasNextPage: Boolean!\n  hasPreviousPage: Boolean!\n  startCursor: String\n  endCursor: String\n}\n```\n\n**Resolver Implementation:**\n```javascript\nconst resolvers = {\n  Query: {\n    posts: async (parent, { first, after, last, before }) => {\n      const limit = first || last || 10;\n      const offset = after ? decodeCursor(after) : 0;\n      \n      const posts = await getPostsPaginated(offset, limit + 1);\n      const hasNextPage = posts.length > limit;\n      \n      if (hasNextPage) posts.pop();\n      \n      return {\n        edges: posts.map((post, index) => ({\n          node: post,\n          cursor: encodeCursor(offset + index)\n        })),\n        pageInfo: {\n          hasNextPage,\n          hasPreviousPage: offset > 0,\n          startCursor: posts.length > 0 ? encodeCursor(offset) : null,\n          endCursor: posts.length > 0 ? encodeCursor(offset + posts.length - 1) : null\n        }\n      };\n    }\n  }\n};\n\n// Cursor encoding/decoding\nconst encodeCursor = (offset) => Buffer.from(offset.toString()).toString('base64');\nconst decodeCursor = (cursor) => parseInt(Buffer.from(cursor, 'base64').toString());\n```\n\n**Client Usage:**\n```javascript\nconst GET_POSTS = gql`\n  query GetPosts($first: Int, $after: String) {\n    posts(first: $first, after: $after) {\n      edges {\n        node {\n          id\n          title\n        }\n        cursor\n      }\n      pageInfo {\n        hasNextPage\n        endCursor\n      }\n    }\n  }\n`;\n```\n\n**Best Practices:**\n- **Use cursor-based:** Better for real-time data\n- **Limit page sizes:** Prevent performance issues\n- **Stable ordering:** Consistent sort order\n- **Connection pattern:** Follow Relay specifications",
      "keywords": ["pagination", "cursor-based", "offset-based", "Relay specification", "connections", "edges", "pageInfo", "stable ordering"],
      "difficulty": "hard"
    },
    {
      "id": 10,
      "tag": "graphql",
      "question": "What are GraphQL directives and how do you create custom ones?",
      "answer": "**GraphQL Directives** are annotations that modify the execution behavior of queries, fields, or schema elements.\n\n**Built-in Directives:**\n```graphql\nquery GetUser($includeEmail: Boolean!) {\n  user(id: \"1\") {\n    name\n    email @include(if: $includeEmail)\n    phone @skip(if: $includeEmail)\n  }\n}\n\n# Schema directives\ntype User {\n  id: ID!\n  name: String!\n  email: String! @deprecated(reason: \"Use contactEmail instead\")\n  contactEmail: String!\n}\n```\n\n**Custom Directive Definition:**\n```graphql\ndirective @auth(\n  requires: Role = USER\n) on FIELD_DEFINITION | OBJECT\n\ndirective @rateLimit(\n  max: Int!\n  window: String!\n) on FIELD_DEFINITION\n\ndirective @cacheControl(\n  maxAge: Int\n  scope: CacheControlScope\n) on FIELD_DEFINITION | OBJECT\n\nenum Role {\n  ADMIN\n  USER\n  GUEST\n}\n```\n\n**Custom Directive Implementation:**\n```javascript\nconst { SchemaDirectiveVisitor } = require('apollo-server-express');\n\nclass AuthDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { requires } = this.args;\n    const originalResolve = field.resolve || defaultFieldResolver;\n    \n    field.resolve = async function(parent, args, context, info) {\n      const user = context.user;\n      \n      if (!user) {\n        throw new AuthenticationError('Authentication required');\n      }\n      \n      if (requires === 'ADMIN' && !user.isAdmin) {\n        throw new ForbiddenError('Admin access required');\n      }\n      \n      return originalResolve.call(this, parent, args, context, info);\n    };\n  }\n}\n\nclass RateLimitDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    const { max, window } = this.args;\n    const originalResolve = field.resolve || defaultFieldResolver;\n    \n    field.resolve = async function(parent, args, context, info) {\n      const key = `${context.user?.id}:${info.fieldName}`;\n      const current = await redis.get(key) || 0;\n      \n      if (current >= max) {\n        throw new Error(`Rate limit exceeded: ${max} requests per ${window}`);\n      }\n      \n      await redis.incr(key);\n      await redis.expire(key, parseWindow(window));\n      \n      return originalResolve.call(this, parent, args, context, info);\n    };\n  }\n}\n\n// Server setup\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  schemaDirectives: {\n    auth: AuthDirective,\n    rateLimit: RateLimitDirective\n  }\n});\n```\n\n**Usage in Schema:**\n```graphql\ntype Query {\n  users: [User!]! @auth(requires: ADMIN)\n  me: User @auth(requires: USER) @rateLimit(max: 10, window: \"1m\")\n}\n```",
      "keywords": ["GraphQL directives", "custom directives", "schema directives", "authentication", "authorization", "rate limiting", "caching", "field modification"],
      "difficulty": "hard"
    },
    {
      "id": 11,
      "tag": "graphql",
      "question": "How do you test GraphQL APIs?",
      "answer": "**GraphQL API Testing Strategies:**\n\n**1. Unit Testing Resolvers:**\n```javascript\nconst { createTestClient } = require('apollo-server-testing');\n\ndescribe('User Resolvers', () => {\n  it('should return user by ID', async () => {\n    const mockUser = { id: '1', name: 'John Doe' };\n    const mockGetUser = jest.fn().mockResolvedValue(mockUser);\n    \n    const resolver = {\n      Query: {\n        user: (parent, { id }) => mockGetUser(id)\n      }\n    };\n    \n    const result = await resolver.Query.user(null, { id: '1' });\n    expect(result).toEqual(mockUser);\n    expect(mockGetUser).toHaveBeenCalledWith('1');\n  });\n});\n```\n\n**2. Integration Testing:**\n```javascript\nconst { createTestClient } = require('apollo-server-testing');\nconst { ApolloServer } = require('apollo-server-express');\n\nconst GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n    }\n  }\n`;\n\ndescribe('GraphQL API', () => {\n  let server, query, mutate;\n  \n  beforeAll(() => {\n    server = new ApolloServer({\n      typeDefs,\n      resolvers,\n      context: () => ({ user: mockUser })\n    });\n    \n    const testClient = createTestClient(server);\n    query = testClient.query;\n    mutate = testClient.mutate;\n  });\n  \n  it('should fetch user by ID', async () => {\n    const response = await query({\n      query: GET_USER,\n      variables: { id: '1' }\n    });\n    \n    expect(response.errors).toBeUndefined();\n    expect(response.data.user).toMatchObject({\n      id: '1',\n      name: 'John Doe'\n    });\n  });\n});\n```\n\n**3. Schema Testing:**\n```javascript\nconst { buildSchema } = require('graphql');\nconst { validateSchema } = require('graphql/validation');\n\ndescribe('GraphQL Schema', () => {\n  it('should be valid', () => {\n    const schema = buildSchema(typeDefs);\n    const errors = validateSchema(schema);\n    expect(errors).toHaveLength(0);\n  });\n  \n  it('should have required types', () => {\n    const schema = buildSchema(typeDefs);\n    expect(schema.getType('User')).toBeDefined();\n    expect(schema.getType('Query')).toBeDefined();\n  });\n});\n```\n\n**4. End-to-End Testing:**\n```javascript\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('GraphQL E2E', () => {\n  it('should handle complete user flow', async () => {\n    // Create user\n    const createResponse = await request(app)\n      .post('/graphql')\n      .send({\n        query: `mutation { createUser(name: \"Test\") { id name } }`\n      });\n    \n    const userId = createResponse.body.data.createUser.id;\n    \n    // Fetch user\n    const fetchResponse = await request(app)\n      .post('/graphql')\n      .send({\n        query: `query { user(id: \"${userId}\") { id name } }`\n      });\n    \n    expect(fetchResponse.body.data.user.name).toBe('Test');\n  });\n});\n```\n\n**Testing Tools:**\n- **Jest:** JavaScript testing framework\n- **Apollo Server Testing:** Testing utilities\n- **GraphQL Playground:** Interactive testing\n- **Insomnia/Postman:** API testing tools",
      "keywords": ["GraphQL testing", "unit testing", "integration testing", "schema validation", "end-to-end testing", "Jest", "Apollo Server Testing", "test client"],
      "difficulty": "medium"
    },
    {
      "id": 12,
      "tag": "graphql",
      "question": "What is schema stitching and federation in GraphQL?",
      "answer": "**Schema Stitching and Federation** are approaches for combining multiple GraphQL schemas into a unified API.\n\n**Schema Stitching (Legacy Approach):**\n```javascript\nconst { stitchSchemas } = require('@graphql-tools/stitch');\n\n// Individual schemas\nconst userSchema = makeExecutableSchema({\n  typeDefs: userTypeDefs,\n  resolvers: userResolvers\n});\n\nconst postSchema = makeExecutableSchema({\n  typeDefs: postTypeDefs,\n  resolvers: postResolvers\n});\n\n// Stitched schema\nconst stitchedSchema = stitchSchemas({\n  schemas: [userSchema, postSchema],\n  resolvers: {\n    User: {\n      posts: {\n        selectionSet: '{ id }',\n        resolve: (user, args, context, info) => {\n          return delegateToSchema({\n            schema: postSchema,\n            operation: 'query',\n            fieldName: 'postsByUserId',\n            args: { userId: user.id },\n            context,\n            info\n          });\n        }\n      }\n    }\n  }\n});\n```\n\n**Apollo Federation (Modern Approach):**\n\n**User Service:**\n```javascript\nconst { buildFederatedSchema } = require('@apollo/federation');\n\nconst typeDefs = gql`\n  type User @key(fields: \"id\") {\n    id: ID!\n    name: String!\n    email: String!\n  }\n  \n  extend type Query {\n    me: User\n  }\n`;\n\nconst resolvers = {\n  User: {\n    __resolveReference(user) {\n      return getUserById(user.id);\n    }\n  },\n  Query: {\n    me: () => getCurrentUser()\n  }\n};\n\nconst schema = buildFederatedSchema({ typeDefs, resolvers });\n```\n\n**Posts Service:**\n```javascript\nconst typeDefs = gql`\n  type Post @key(fields: \"id\") {\n    id: ID!\n    title: String!\n    content: String!\n    author: User!\n  }\n  \n  extend type User @key(fields: \"id\") {\n    id: ID! @external\n    posts: [Post!]!\n  }\n`;\n\nconst resolvers = {\n  Post: {\n    author: (post) => ({ __typename: 'User', id: post.authorId })\n  },\n  User: {\n    posts: (user) => getPostsByUserId(user.id)\n  }\n};\n```\n\n**Gateway Setup:**\n```javascript\nconst { ApolloGateway } = require('@apollo/gateway');\n\nconst gateway = new ApolloGateway({\n  serviceList: [\n    { name: 'users', url: 'http://localhost:4001/graphql' },\n    { name: 'posts', url: 'http://localhost:4002/graphql' }\n  ]\n});\n\nconst server = new ApolloServer({ gateway });\n```\n\n**Federation vs Stitching:**\n- **Federation:** Better type safety, automatic composition\n- **Stitching:** More flexible but complex\n- **Performance:** Federation optimizes query planning\n- **Development:** Federation has better tooling",
      "keywords": ["schema stitching", "Apollo Federation", "microservices", "schema composition", "federated gateway", "entity resolution", "distributed GraphQL"],
      "difficulty": "hard"
    },
    {
      "id": 13,
      "tag": "graphql",
      "question": "How do you implement caching in GraphQL?",
      "answer": "**GraphQL Caching Strategies:**\n\n**1. Query-level Caching:**\n```javascript\nconst { ApolloServer } = require('apollo-server-express');\nconst responseCachePlugin = require('apollo-server-plugin-response-cache');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    responseCachePlugin({\n      sessionId: (requestContext) => \n        requestContext.request.http.headers.get('session-id'),\n      shouldReadFromCache: (requestContext) => \n        requestContext.request.http.method === 'GET',\n      shouldWriteToCache: (requestContext) => \n        !requestContext.errors\n    })\n  ]\n});\n```\n\n**2. Field-level Caching with Directives:**\n```graphql\ntype Query {\n  user(id: ID!): User @cacheControl(maxAge: 300)\n  posts: [Post!]! @cacheControl(maxAge: 60)\n}\n\ntype User @cacheControl(maxAge: 300) {\n  id: ID!\n  name: String!\n  email: String! @cacheControl(maxAge: 30)\n}\n```\n\n**3. DataLoader for Batching and Caching:**\n```javascript\nconst DataLoader = require('dataloader');\n\n// Create DataLoader with caching\nconst userLoader = new DataLoader(\n  async (userIds) => {\n    const users = await getUsersByIds(userIds);\n    return userIds.map(id => users.find(user => user.id === id));\n  },\n  {\n    cache: true,\n    cacheKeyFn: (key) => key,\n    cacheMap: new Map() // Custom cache implementation\n  }\n);\n\n// Use in resolvers\nconst resolvers = {\n  Post: {\n    author: (post) => userLoader.load(post.authorId)\n  }\n};\n```\n\n**4. Redis Caching:**\n```javascript\nconst redis = require('redis');\nconst client = redis.createClient();\n\nconst resolvers = {\n  Query: {\n    user: async (parent, { id }) => {\n      // Check cache first\n      const cached = await client.get(`user:${id}`);\n      if (cached) {\n        return JSON.parse(cached);\n      }\n      \n      // Fetch from database\n      const user = await getUserById(id);\n      \n      // Cache result\n      await client.setex(`user:${id}`, 300, JSON.stringify(user));\n      \n      return user;\n    }\n  }\n};\n```\n\n**5. Persisted Queries:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    require('apollo-server-plugin-automatic-persisted-queries')({\n      cache: new Map(), // or Redis\n      ttl: 300\n    })\n  ]\n});\n```\n\n**6. HTTP Caching Headers:**\n```javascript\nconst resolvers = {\n  Query: {\n    posts: (parent, args, context) => {\n      context.setCacheHint({ maxAge: 60, scope: 'PUBLIC' });\n      return getAllPosts();\n    }\n  }\n};\n```\n\n**Best Practices:**\n- **Cache invalidation:** Clear cache when data changes\n- **Cache key strategy:** Include relevant parameters\n- **TTL management:** Set appropriate expiration times\n- **Cache warming:** Pre-populate frequently accessed data",
      "keywords": ["GraphQL caching", "query caching", "field-level caching", "DataLoader", "Redis", "persisted queries", "HTTP caching", "cache invalidation"],
      "difficulty": "hard"
    },
    {
      "id": 14,
      "tag": "graphql",
      "question": "What are GraphQL interfaces and unions, and when do you use them?",
      "answer": "**GraphQL Interfaces and Unions** provide ways to handle polymorphic types and shared field structures.\n\n**Interfaces (Shared Fields):**\n```graphql\n# Interface definition\ninterface Node {\n  id: ID!\n  createdAt: String!\n}\n\ninterface Content {\n  id: ID!\n  title: String!\n  author: User!\n  createdAt: String!\n}\n\n# Types implementing interfaces\ntype Post implements Node & Content {\n  id: ID!\n  createdAt: String!\n  title: String!\n  author: User!\n  content: String!\n  tags: [String!]!\n}\n\ntype Video implements Node & Content {\n  id: ID!\n  createdAt: String!\n  title: String!\n  author: User!\n  duration: Int!\n  url: String!\n}\n\ntype Query {\n  content: [Content!]!\n  nodes: [Node!]!\n}\n```\n\n**Interface Resolvers:**\n```javascript\nconst resolvers = {\n  // Interface type resolver\n  Content: {\n    __resolveType: (obj) => {\n      if (obj.content) return 'Post';\n      if (obj.duration) return 'Video';\n      return null;\n    }\n  },\n  \n  Query: {\n    content: () => [...posts, ...videos]\n  }\n};\n```\n\n**Unions (One of Many Types):**\n```graphql\n# Union definition\nunion SearchResult = User | Post | Video\n\ntype Query {\n  search(query: String!): [SearchResult!]!\n}\n```\n\n**Union Resolvers:**\n```javascript\nconst resolvers = {\n  SearchResult: {\n    __resolveType: (obj) => {\n      if (obj.email) return 'User';\n      if (obj.content) return 'Post';\n      if (obj.duration) return 'Video';\n      return null;\n    }\n  },\n  \n  Query: {\n    search: (parent, { query }) => {\n      return [\n        ...searchUsers(query),\n        ...searchPosts(query),\n        ...searchVideos(query)\n      ];\n    }\n  }\n};\n```\n\n**Querying with Fragments:**\n```graphql\n# Interface query\nquery {\n  content {\n    id\n    title\n    author {\n      name\n    }\n    ... on Post {\n      content\n      tags\n    }\n    ... on Video {\n      duration\n      url\n    }\n  }\n}\n\n# Union query\nquery {\n  search(query: \"javascript\") {\n    ... on User {\n      name\n      email\n    }\n    ... on Post {\n      title\n      content\n    }\n    ... on Video {\n      title\n      duration\n    }\n  }\n}\n```\n\n**When to Use:**\n- **Interfaces:** Shared behavior/fields (Content, Node)\n- **Unions:** Different types in same context (Search results)\n- **Abstract thinking:** Model real-world polymorphism",
      "keywords": ["GraphQL interfaces", "unions", "polymorphic types", "shared fields", "__resolveType", "inline fragments", "abstract types"],
      "difficulty": "medium"
    },
    {
      "id": 15,
      "tag": "graphql",
      "question": "How do you handle file uploads in GraphQL?",
      "answer": "**GraphQL File Upload Implementation:**\n\n**1. Multipart Upload Specification:**\n```graphql\n# Scalar type for file uploads\nscalar Upload\n\ntype Mutation {\n  uploadFile(file: Upload!): File!\n  uploadMultipleFiles(files: [Upload!]!): [File!]!\n  createPost(title: String!, content: String!, image: Upload): Post!\n}\n\ntype File {\n  id: ID!\n  filename: String!\n  mimetype: String!\n  encoding: String!\n  url: String!\n}\n```\n\n**2. Server Implementation (Apollo Server):**\n```javascript\nconst { GraphQLUpload } = require('graphql-upload');\nconst { createWriteStream } = require('fs');\nconst path = require('path');\n\nconst typeDefs = gql`\n  scalar Upload\n  \n  type Mutation {\n    uploadFile(file: Upload!): File!\n  }\n`;\n\nconst resolvers = {\n  Upload: GraphQLUpload,\n  \n  Mutation: {\n    uploadFile: async (parent, { file }) => {\n      const { createReadStream, filename, mimetype, encoding } = await file;\n      \n      // Generate unique filename\n      const uniqueFilename = `${Date.now()}-${filename}`;\n      const filepath = path.join(__dirname, 'uploads', uniqueFilename);\n      \n      // Save file to disk\n      const stream = createReadStream();\n      const writeStream = createWriteStream(filepath);\n      \n      await new Promise((resolve, reject) => {\n        stream\n          .pipe(writeStream)\n          .on('finish', resolve)\n          .on('error', reject);\n      });\n      \n      // Save file info to database\n      const fileRecord = await saveFileToDatabase({\n        filename: uniqueFilename,\n        originalName: filename,\n        mimetype,\n        encoding,\n        path: filepath\n      });\n      \n      return {\n        id: fileRecord.id,\n        filename,\n        mimetype,\n        encoding,\n        url: `/uploads/${uniqueFilename}`\n      };\n    }\n  }\n};\n\n// Server setup with upload support\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  uploads: {\n    maxFileSize: 10000000, // 10 MB\n    maxFiles: 5\n  }\n});\n```\n\n**3. Client Implementation:**\n```javascript\n// React with Apollo Client\nimport { useMutation } from '@apollo/client';\n\nconst UPLOAD_FILE = gql`\n  mutation UploadFile($file: Upload!) {\n    uploadFile(file: $file) {\n      id\n      filename\n      url\n    }\n  }\n`;\n\nfunction FileUpload() {\n  const [uploadFile] = useMutation(UPLOAD_FILE);\n  \n  const handleFileChange = (event) => {\n    const file = event.target.files[0];\n    if (file) {\n      uploadFile({\n        variables: { file },\n        onCompleted: (data) => {\n          console.log('File uploaded:', data.uploadFile);\n        }\n      });\n    }\n  };\n  \n  return (\n    <input\n      type=\"file\"\n      onChange={handleFileChange}\n      accept=\"image/*\"\n    />\n  );\n}\n```\n\n**4. Cloud Storage Integration:**\n```javascript\nconst AWS = require('aws-sdk');\nconst s3 = new AWS.S3();\n\nconst resolvers = {\n  Mutation: {\n    uploadFile: async (parent, { file }) => {\n      const { createReadStream, filename, mimetype } = await file;\n      \n      const key = `uploads/${Date.now()}-${filename}`;\n      \n      const uploadParams = {\n        Bucket: 'my-app-uploads',\n        Key: key,\n        Body: createReadStream(),\n        ContentType: mimetype,\n        ACL: 'public-read'\n      };\n      \n      const result = await s3.upload(uploadParams).promise();\n      \n      return {\n        id: key,\n        filename,\n        mimetype,\n        url: result.Location\n      };\n    }\n  }\n};\n```\n\n**Security Considerations:**\n- **File type validation:** Check MIME types\n- **Size limits:** Prevent large file uploads\n- **Virus scanning:** Scan uploaded files\n- **Access control:** Secure file access",
      "keywords": ["file uploads", "GraphQL Upload", "multipart", "Apollo Server", "file storage", "cloud storage", "security", "validation"],
      "difficulty": "hard"
    },
    {
      "id": 16,
      "tag": "graphql",
      "question": "What are the security considerations for GraphQL APIs?",
      "answer": "**GraphQL Security Considerations:**\n\n**1. Query Complexity Analysis:**\n```javascript\nconst depthLimit = require('graphql-depth-limit');\nconst costAnalysis = require('graphql-cost-analysis');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  validationRules: [\n    // Limit query depth\n    depthLimit(10),\n    \n    // Analyze query cost\n    costAnalysis({\n      maximumCost: 1000,\n      defaultCost: 1,\n      createError: (max, actual) => {\n        return new Error(`Query cost ${actual} exceeds maximum cost ${max}`);\n      }\n    })\n  ]\n});\n```\n\n**2. Query Timeout and Rate Limiting:**\n```javascript\nconst rateLimit = require('express-rate-limit');\n\n// Global rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 1000, // limit each IP to 1000 requests per windowMs\n  message: 'Too many requests from this IP'\n});\n\napp.use('/graphql', limiter);\n\n// Query timeout\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    {\n      requestDidStart() {\n        return {\n          willSendResponse(requestContext) {\n            // Timeout after 30 seconds\n            setTimeout(() => {\n              if (!requestContext.response.http.body) {\n                throw new Error('Query timeout');\n              }\n            }, 30000);\n          }\n        };\n      }\n    }\n  ]\n});\n```\n\n**3. Input Validation and Sanitization:**\n```javascript\nconst { GraphQLScalarType } = require('graphql');\nconst { GraphQLError } = require('graphql/error');\n\n// Custom scalar for email validation\nconst EmailType = new GraphQLScalarType({\n  name: 'Email',\n  serialize: (value) => value,\n  parseValue: (value) => {\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)) {\n      throw new GraphQLError('Invalid email format');\n    }\n    return value;\n  },\n  parseLiteral: (ast) => {\n    if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(ast.value)) {\n      throw new GraphQLError('Invalid email format');\n    }\n    return ast.value;\n  }\n});\n\n// Input validation in resolvers\nconst resolvers = {\n  Mutation: {\n    createUser: (parent, { input }) => {\n      // Validate input\n      if (!input.name || input.name.length < 2) {\n        throw new ValidationError('Name must be at least 2 characters');\n      }\n      \n      if (!input.email || !isValidEmail(input.email)) {\n        throw new ValidationError('Invalid email address');\n      }\n      \n      // Sanitize input\n      const sanitizedInput = {\n        name: input.name.trim(),\n        email: input.email.toLowerCase().trim()\n      };\n      \n      return createUser(sanitizedInput);\n    }\n  }\n};\n```\n\n**4. Authorization and Field-level Security:**\n```javascript\nconst resolvers = {\n  User: {\n    email: (user, args, context) => {\n      // Only return email to owner or admin\n      if (context.user.id !== user.id && !context.user.isAdmin) {\n        return null; // or throw error\n      }\n      return user.email;\n    },\n    \n    creditCard: (user, args, context) => {\n      // Sensitive data - admin only\n      if (!context.user.isAdmin) {\n        throw new ForbiddenError('Admin access required');\n      }\n      return user.creditCard;\n    }\n  }\n};\n```\n\n**5. Disable Introspection in Production:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  introspection: process.env.NODE_ENV !== 'production',\n  playground: process.env.NODE_ENV !== 'production'\n});\n```\n\n**6. SQL Injection Prevention:**\n```javascript\n// Use parameterized queries\nconst resolvers = {\n  Query: {\n    user: async (parent, { id }) => {\n      // ❌ Vulnerable to injection\n      // const query = `SELECT * FROM users WHERE id = '${id}'`;\n      \n      // ✅ Safe parameterized query\n      const query = 'SELECT * FROM users WHERE id = $1';\n      const result = await db.query(query, [id]);\n      return result.rows[0];\n    }\n  }\n};\n```\n\n**Security Checklist:**\n- ✅ Implement authentication and authorization\n- ✅ Validate and sanitize all inputs\n- ✅ Limit query complexity and depth\n- ✅ Implement rate limiting\n- ✅ Disable introspection in production\n- ✅ Use HTTPS for all communications\n- ✅ Implement proper error handling\n- ✅ Regular security audits and updates",
      "keywords": ["GraphQL security", "query complexity", "rate limiting", "input validation", "authorization", "introspection", "SQL injection", "authentication"],
      "difficulty": "hard"
    },
    {
      "id": 17,
      "tag": "graphql",
      "question": "How do you implement real-time features with GraphQL subscriptions?",
      "answer": "**Real-time GraphQL Subscriptions Implementation:**\n\n**1. Basic Subscription Setup:**\n```graphql\ntype Subscription {\n  messageAdded(roomId: ID!): Message!\n  userStatusChanged: UserStatus!\n  notificationReceived(userId: ID!): Notification!\n}\n\ntype Message {\n  id: ID!\n  content: String!\n  user: User!\n  room: Room!\n  createdAt: String!\n}\n\ntype UserStatus {\n  userId: ID!\n  status: Status!\n  lastSeen: String!\n}\n\nenum Status {\n  ONLINE\n  OFFLINE\n  AWAY\n}\n```\n\n**2. Server Implementation with PubSub:**\n```javascript\nconst { PubSub, withFilter } = require('apollo-server-express');\nconst pubsub = new PubSub();\n\n// Constants for subscription events\nconst MESSAGE_ADDED = 'MESSAGE_ADDED';\nconst USER_STATUS_CHANGED = 'USER_STATUS_CHANGED';\nconst NOTIFICATION_RECEIVED = 'NOTIFICATION_RECEIVED';\n\nconst resolvers = {\n  Mutation: {\n    sendMessage: async (parent, { roomId, content }, { user }) => {\n      const message = await createMessage({\n        content,\n        userId: user.id,\n        roomId\n      });\n      \n      // Publish to subscribers\n      pubsub.publish(MESSAGE_ADDED, {\n        messageAdded: message,\n        roomId\n      });\n      \n      return message;\n    },\n    \n    updateUserStatus: async (parent, { status }, { user }) => {\n      const userStatus = await updateStatus(user.id, status);\n      \n      pubsub.publish(USER_STATUS_CHANGED, {\n        userStatusChanged: userStatus\n      });\n      \n      return userStatus;\n    }\n  },\n  \n  Subscription: {\n    messageAdded: {\n      subscribe: withFilter(\n        () => pubsub.asyncIterator(MESSAGE_ADDED),\n        (payload, variables) => {\n          // Only send to subscribers of this room\n          return payload.roomId === variables.roomId;\n        }\n      )\n    },\n    \n    userStatusChanged: {\n      subscribe: () => pubsub.asyncIterator(USER_STATUS_CHANGED)\n    },\n    \n    notificationReceived: {\n      subscribe: withFilter(\n        () => pubsub.asyncIterator(NOTIFICATION_RECEIVED),\n        (payload, variables, context) => {\n          // Only send to the specific user\n          return payload.notificationReceived.userId === variables.userId &&\n                 context.user.id === variables.userId;\n        }\n      )\n    }\n  }\n};\n```\n\n**3. Redis PubSub for Scaling:**\n```javascript\nconst { RedisPubSub } = require('graphql-redis-subscriptions');\nconst Redis = require('ioredis');\n\nconst options = {\n  host: 'localhost',\n  port: 6379,\n  retryDelayOnFailover: 100,\n  enableOfflineQueue: false\n};\n\nconst pubsub = new RedisPubSub({\n  publisher: new Redis(options),\n  subscriber: new Redis(options)\n});\n```\n\n**4. WebSocket Server Setup:**\n```javascript\nconst { ApolloServer } = require('apollo-server-express');\nconst { createServer } = require('http');\nconst express = require('express');\n\nasync function startServer() {\n  const app = express();\n  \n  const server = new ApolloServer({\n    typeDefs,\n    resolvers,\n    context: ({ req, connection }) => {\n      // HTTP context\n      if (req) {\n        const user = getUser(req.headers.authorization);\n        return { user };\n      }\n      \n      // WebSocket context\n      if (connection) {\n        return connection.context;\n      }\n    },\n    subscriptions: {\n      onConnect: (connectionParams, webSocket) => {\n        const user = getUser(connectionParams.authorization);\n        if (!user) {\n          throw new Error('Authentication failed');\n        }\n        return { user };\n      },\n      onDisconnect: (webSocket, context) => {\n        console.log('Client disconnected');\n      }\n    }\n  });\n  \n  server.applyMiddleware({ app });\n  \n  const httpServer = createServer(app);\n  server.installSubscriptionHandlers(httpServer);\n  \n  httpServer.listen(4000, () => {\n    console.log(`Server ready at http://localhost:4000${server.graphqlPath}`);\n    console.log(`Subscriptions ready at ws://localhost:4000${server.subscriptionsPath}`);\n  });\n}\n```\n\n**5. Client Implementation:**\n```javascript\nimport { useSubscription } from '@apollo/client';\n\nconst MESSAGE_SUBSCRIPTION = gql`\n  subscription MessageAdded($roomId: ID!) {\n    messageAdded(roomId: $roomId) {\n      id\n      content\n      user {\n        id\n        name\n      }\n      createdAt\n    }\n  }\n`;\n\nfunction ChatRoom({ roomId }) {\n  const { data, loading } = useSubscription(MESSAGE_SUBSCRIPTION, {\n    variables: { roomId }\n  });\n  \n  useEffect(() => {\n    if (data) {\n      // Handle new message\n      console.log('New message:', data.messageAdded);\n    }\n  }, [data]);\n  \n  return <div>Chat Room</div>;\n}\n```\n\n**6. Advanced Features:**\n```javascript\n// Connection management\nconst connectionMap = new Map();\n\nconst resolvers = {\n  Subscription: {\n    typingIndicator: {\n      subscribe: withFilter(\n        () => pubsub.asyncIterator('TYPING'),\n        (payload, variables, context) => {\n          return payload.roomId === variables.roomId &&\n                 payload.userId !== context.user.id;\n        }\n      )\n    }\n  }\n};\n\n// Presence tracking\nconst trackUserPresence = (userId, status) => {\n  pubsub.publish('USER_PRESENCE', {\n    userPresence: { userId, status, timestamp: new Date() }\n  });\n};\n```",
      "keywords": ["real-time", "GraphQL subscriptions", "WebSocket", "PubSub", "Redis", "presence tracking", "live updates", "chat application"],
      "difficulty": "hard"
    },
    {
      "id": 18,
      "tag": "graphql",
      "question": "What are the performance optimization techniques for GraphQL?",
      "answer": "**GraphQL Performance Optimization Techniques:**\n\n**1. Query Complexity Analysis:**\n```javascript\nconst costAnalysis = require('graphql-cost-analysis');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  validationRules: [\n    costAnalysis({\n      maximumCost: 1000,\n      defaultCost: 1,\n      scalars: {\n        String: 1,\n        Int: 1,\n        ID: 1\n      },\n      objectCost: 2,\n      listFactor: 10,\n      introspectionCost: 1000\n    })\n  ]\n});\n```\n\n**2. DataLoader for N+1 Problem:**\n```javascript\nconst DataLoader = require('dataloader');\n\n// Batch loading function\nconst batchUsers = async (userIds) => {\n  const users = await User.findByIds(userIds);\n  return userIds.map(id => users.find(user => user.id === id));\n};\n\n// Create DataLoader with caching\nconst userLoader = new DataLoader(batchUsers, {\n  cache: true,\n  batchScheduleFn: callback => setTimeout(callback, 10) // Wait 10ms to batch\n});\n\nconst resolvers = {\n  Post: {\n    author: (post) => userLoader.load(post.authorId)\n  }\n};\n```\n\n**3. Query Optimization with Database:**\n```javascript\nconst resolvers = {\n  Query: {\n    posts: async (parent, args, context, info) => {\n      // Analyze query to determine required joins\n      const requestedFields = getFieldNames(info);\n      \n      let query = Post.query();\n      \n      if (requestedFields.includes('author')) {\n        query = query.withGraphJoined('author');\n      }\n      \n      if (requestedFields.includes('comments')) {\n        query = query.withGraphJoined('comments');\n      }\n      \n      return query;\n    }\n  }\n};\n\n// Helper function to extract field names\nfunction getFieldNames(info) {\n  return info.fieldNodes[0].selectionSet.selections\n    .map(selection => selection.name.value);\n}\n```\n\n**4. Response Caching:**\n```javascript\nconst responseCachePlugin = require('apollo-server-plugin-response-cache');\n\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    responseCachePlugin({\n      sessionId: (requestContext) => \n        requestContext.request.http.headers.get('user-id'),\n      shouldReadFromCache: (requestContext) => {\n        return requestContext.request.operationName !== 'GetCurrentUser';\n      },\n      shouldWriteToCache: (requestContext) => {\n        return !requestContext.errors && \n               requestContext.request.operationName !== 'GetSecretData';\n      }\n    })\n  ],\n  cacheControl: {\n    defaultMaxAge: 300 // 5 minutes\n  }\n});\n```\n\n**5. Field-level Caching:**\n```javascript\nconst resolvers = {\n  Query: {\n    expensiveData: async (parent, args, context) => {\n      const cacheKey = `expensive-data:${JSON.stringify(args)}`;\n      \n      // Check cache first\n      let data = await redis.get(cacheKey);\n      if (data) {\n        return JSON.parse(data);\n      }\n      \n      // Expensive computation\n      data = await performExpensiveCalculation(args);\n      \n      // Cache result\n      await redis.setex(cacheKey, 3600, JSON.stringify(data));\n      \n      return data;\n    }\n  }\n};\n```\n\n**6. Persisted Queries:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  plugins: [\n    require('apollo-server-plugin-automatic-persisted-queries')({\n      cache: new Map(), // or Redis\n      ttl: 300\n    })\n  ]\n});\n\n// Client usage\nconst client = new ApolloClient({\n  uri: '/graphql',\n  cache: new InMemoryCache(),\n  link: createPersistedQueryLink().concat(\n    createHttpLink({ uri: '/graphql' })\n  )\n});\n```\n\n**7. Query Batching:**\n```javascript\n// Client-side batching\nconst batchLink = new BatchHttpLink({\n  uri: '/graphql',\n  batchMax: 5,\n  batchInterval: 20\n});\n\nconst client = new ApolloClient({\n  link: batchLink,\n  cache: new InMemoryCache()\n});\n```\n\n**8. Database Connection Pooling:**\n```javascript\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n  host: 'localhost',\n  port: 5432,\n  database: 'myapp',\n  user: 'postgres',\n  password: 'password',\n  max: 20, // Maximum connections\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000\n});\n```\n\n**9. Lazy Loading and Pagination:**\n```javascript\nconst resolvers = {\n  User: {\n    posts: async (user, { first, after }) => {\n      return {\n        edges: await getPostsPaginated(user.id, first, after),\n        pageInfo: await getPostsPageInfo(user.id, first, after)\n      };\n    }\n  }\n};\n```\n\n**10. Monitoring and Profiling:**\n```javascript\nconst apolloServerPlugin = {\n  requestDidStart() {\n    return {\n      didResolveOperation(requestContext) {\n        console.log('Operation:', requestContext.request.operationName);\n      },\n      willSendResponse(requestContext) {\n        console.log('Response time:', Date.now() - requestContext.request.startTime);\n      }\n    };\n  }\n};\n```",
      "keywords": ["performance optimization", "query complexity", "DataLoader", "caching", "persisted queries", "database optimization", "connection pooling", "monitoring"],
      "difficulty": "hard"
    },
    {
      "id": 19,
      "tag": "graphql",
      "question": "How do you migrate from REST API to GraphQL?",
      "answer": "**REST to GraphQL Migration Strategy:**\n\n**1. Gradual Migration Approach:**\n```javascript\n// Hybrid approach - GraphQL alongside REST\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  dataSources: () => ({\n    restAPI: new RESTDataSource(),\n    userAPI: new UserRESTAPI()\n  })\n});\n\n// REST DataSource wrapper\nclass UserRESTAPI extends RESTDataSource {\n  constructor() {\n    super();\n    this.baseURL = 'https://api.example.com/';\n  }\n  \n  async getUser(id) {\n    return this.get(`users/${id}`);\n  }\n  \n  async getUserPosts(userId) {\n    return this.get(`users/${userId}/posts`);\n  }\n}\n```\n\n**2. Schema Design from REST Endpoints:**\n```graphql\n# Map REST endpoints to GraphQL types\n# GET /users/:id -> User type\ntype User {\n  id: ID!\n  name: String!\n  email: String!\n  posts: [Post!]!  # GET /users/:id/posts\n}\n\n# GET /posts -> Post type\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  author: User!     # GET /users/:id\n  comments: [Comment!]!  # GET /posts/:id/comments\n}\n\ntype Query {\n  # GET /users\n  users: [User!]!\n  # GET /users/:id\n  user(id: ID!): User\n  # GET /posts\n  posts: [Post!]!\n  # GET /posts/:id\n  post(id: ID!): Post\n}\n\ntype Mutation {\n  # POST /users\n  createUser(input: CreateUserInput!): User!\n  # PUT /users/:id\n  updateUser(id: ID!, input: UpdateUserInput!): User!\n  # DELETE /users/:id\n  deleteUser(id: ID!): Boolean\n}\n```\n\n**3. Resolver Implementation Using REST APIs:**\n```javascript\nconst resolvers = {\n  Query: {\n    users: (parent, args, { dataSources }) => {\n      return dataSources.userAPI.getUsers();\n    },\n    \n    user: (parent, { id }, { dataSources }) => {\n      return dataSources.userAPI.getUser(id);\n    }\n  },\n  \n  User: {\n    posts: (user, args, { dataSources }) => {\n      return dataSources.userAPI.getUserPosts(user.id);\n    }\n  },\n  \n  Post: {\n    author: (post, args, { dataSources }) => {\n      return dataSources.userAPI.getUser(post.authorId);\n    }\n  },\n  \n  Mutation: {\n    createUser: (parent, { input }, { dataSources }) => {\n      return dataSources.userAPI.createUser(input);\n    },\n    \n    updateUser: (parent, { id, input }, { dataSources }) => {\n      return dataSources.userAPI.updateUser(id, input);\n    }\n  }\n};\n```\n\n**4. Data Transformation Layer:**\n```javascript\n// Transform REST response to GraphQL schema\nclass UserRESTAPI extends RESTDataSource {\n  async getUser(id) {\n    const restUser = await this.get(`users/${id}`);\n    \n    // Transform REST response to match GraphQL schema\n    return {\n      id: restUser.user_id,\n      name: `${restUser.first_name} ${restUser.last_name}`,\n      email: restUser.email_address,\n      createdAt: new Date(restUser.created_timestamp).toISOString()\n    };\n  }\n}\n```\n\n**5. Authentication Migration:**\n```javascript\nconst server = new ApolloServer({\n  typeDefs,\n  resolvers,\n  context: ({ req }) => {\n    // Reuse existing REST authentication\n    const token = req.headers.authorization;\n    const user = validateJWTToken(token); // Existing REST auth logic\n    \n    return {\n      user,\n      dataSources: {\n        userAPI: new UserRESTAPI(token) // Pass token to REST calls\n      }\n    };\n  }\n});\n\n// Pass auth headers to REST calls\nclass UserRESTAPI extends RESTDataSource {\n  constructor(token) {\n    super();\n    this.token = token;\n  }\n  \n  willSendRequest(request) {\n    request.headers.set('Authorization', this.token);\n  }\n}\n```\n\n**6. Client Migration Strategy:**\n```javascript\n// Gradual client migration\nconst client = new ApolloClient({\n  uri: '/graphql',\n  cache: new InMemoryCache(),\n  link: from([\n    // Fallback to REST for unmigrated queries\n    new RestLink({\n      uri: '/api/v1/'\n    }),\n    new HttpLink({\n      uri: '/graphql'\n    })\n  ])\n});\n\n// Feature flags for migration\nfunction UserProfile({ userId }) {\n  const useGraphQL = featureFlags.graphql;\n  \n  if (useGraphQL) {\n    return <GraphQLUserProfile userId={userId} />;\n  } else {\n    return <RESTUserProfile userId={userId} />;\n  }\n}\n```\n\n**7. Performance Considerations:**\n```javascript\n// Optimize REST calls with DataLoader\nconst userLoader = new DataLoader(async (userIds) => {\n  // Batch REST calls when possible\n  const users = await fetch(`/api/users?ids=${userIds.join(',')}`);\n  return userIds.map(id => users.find(user => user.id === id));\n});\n\nconst resolvers = {\n  Post: {\n    author: (post) => userLoader.load(post.authorId)\n  }\n};\n```\n\n**8. Migration Phases:**\n\n**Phase 1:** GraphQL alongside REST\n- Set up GraphQL server\n- Create schema mapping REST endpoints\n- Implement basic queries\n\n**Phase 2:** Feature-by-feature migration\n- Migrate specific features to GraphQL\n- Use feature flags for rollout\n- Monitor performance and errors\n\n**Phase 3:** Optimize and consolidate\n- Remove duplicate REST endpoints\n- Optimize GraphQL resolvers\n- Direct database access where beneficial\n\n**Phase 4:** Complete migration\n- Deprecate REST endpoints\n- Full GraphQL adoption\n- Clean up legacy code\n\n**Migration Benefits:**\n- **Reduced over-fetching:** Get exactly needed data\n- **Single endpoint:** Simplified API management\n- **Better developer experience:** Strong typing, introspection\n- **Real-time capabilities:** Built-in subscriptions",
      "keywords": ["REST to GraphQL migration", "gradual migration", "REST DataSource", "data transformation", "authentication migration", "client migration", "performance optimization"],
      "difficulty": "hard"
    }
  ]
}