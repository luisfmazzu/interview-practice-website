{
  "technology": "fastapi",
  "questions": [
    {
      "id": 12000,
      "tag": "fastapi",
      "question": "What is FastAPI and what are its key features?",
      "answer": "FastAPI is a modern, fast web framework for building APIs with Python 3.7+ based on standard Python type hints. It was created by Sebastian Ramirez and has gained popularity for its performance and developer experience.\n\nKey features of FastAPI:\n\n**Performance**: One of the fastest Python frameworks available, comparable to NodeJS and Go, thanks to Starlette for web parts and Pydantic for data parts.\n\n**Fast to code**: Increases development speed by 200-300% with intuitive design and excellent editor support.\n\n**Automatic API documentation**: Generates interactive API documentation (Swagger UI and ReDoc) automatically from your code.\n\n**Type safety**: Built on Python type hints, providing excellent IDE support with autocompletion and type checking.\n\n**Data validation**: Automatic request and response data validation using Pydantic models.\n\n**Async support**: Native support for async/await, making it perfect for I/O-bound operations.\n\n**Standards-based**: Based on OpenAPI (formerly Swagger) and JSON Schema standards.\n\n**Easy to use**: Designed to be easy to use and learn, with minimal code duplication.\n\nExample of a simple FastAPI application:\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\nasync def read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n```",
      "keywords": ["fastapi", "python", "web framework", "api", "performance", "type hints", "async", "documentation"],
      "difficulty": "easy"
    },
    {
      "id": 12001,
      "tag": "fastapi",
      "question": "How do you work with path parameters and query parameters in FastAPI?",
      "answer": "FastAPI makes it easy to work with both path parameters and query parameters through function parameters and type hints.\n\n**Path Parameters**:\nPath parameters are part of the URL path and are declared in the path operation decorator:\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n\n@app.get(\"/users/{user_id}/items/{item_id}\")\nasync def read_user_item(user_id: int, item_id: str):\n    return {\"user_id\": user_id, \"item_id\": item_id}\n```\n\n**Query Parameters**:\nQuery parameters are function parameters that are not part of the path parameters:\n\n```python\n@app.get(\"/items/\")\nasync def read_items(skip: int = 0, limit: int = 10):\n    return {\"skip\": skip, \"limit\": limit}\n\n# URL: /items/?skip=20&limit=5\n```\n\n**Combining Both**:\n```python\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: str, q: str = None, short: bool = False):\n    item = {\"item_id\": item_id}\n    if q:\n        item.update({\"q\": q})\n    if not short:\n        item.update({\"description\": \"This is an amazing item\"})\n    return item\n```\n\n**Type Validation**:\nFastAPI automatically validates parameter types and returns 422 errors for invalid data. You can also use Enum for restricted values:\n\n```python\nfrom enum import Enum\n\nclass ModelName(str, Enum):\n    alexnet = \"alexnet\"\n    resnet = \"resnet\"\n\n@app.get(\"/models/{model_name}\")\nasync def get_model(model_name: ModelName):\n    return {\"model_name\": model_name}\n```",
      "keywords": ["path parameters", "query parameters", "url", "validation", "type hints", "enum"],
      "difficulty": "easy"
    },
    {
      "id": 12002,
      "tag": "fastapi",
      "question": "How do you handle request bodies and use Pydantic models in FastAPI?",
      "answer": "FastAPI uses Pydantic models to handle request bodies, providing automatic validation, serialization, and documentation generation.\n\n**Basic Pydantic Model**:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n\n@app.post(\"/items/\")\nasync def create_item(item: Item):\n    return item\n```\n\n**Advanced Validation**:\nPydantic provides powerful validation features:\n\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List\nfrom datetime import datetime\n\nclass User(BaseModel):\n    name: str = Field(..., min_length=1, max_length=50)\n    email: str = Field(..., regex=r'^\\S+@\\S+\\.\\S+$')\n    age: int = Field(..., gt=0, le=120)\n    tags: List[str] = []\n    created_at: datetime = Field(default_factory=datetime.now)\n    \n    @validator('name')\n    def name_must_be_alphanumeric(cls, v):\n        assert v.replace(' ', '').isalnum(), 'Name must be alphanumeric'\n        return v.title()\n\n@app.post(\"/users/\")\nasync def create_user(user: User):\n    return {\"message\": f\"User {user.name} created successfully\"}\n```\n\n**Combining with Path and Query Parameters**:\n```python\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item, q: Optional[str] = None):\n    result = {\"item_id\": item_id, **item.dict()}\n    if q:\n        result.update({\"q\": q})\n    return result\n```\n\n**Nested Models**:\n```python\nclass Image(BaseModel):\n    url: str\n    name: str\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    images: Optional[List[Image]] = None\n```\n\nPydantic automatically handles JSON parsing, validation, and provides clear error messages for invalid data.",
      "keywords": ["request body", "pydantic", "models", "validation", "json", "serialization", "basemodel"],
      "difficulty": "easy"
    },
    {
      "id": 12003,
      "tag": "fastapi",
      "question": "How do you define response models and implement data validation in FastAPI?",
      "answer": "FastAPI allows you to define response models using Pydantic, providing automatic serialization, validation, and API documentation for your responses.\n\n**Basic Response Model**:\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n\nclass ItemResponse(BaseModel):\n    id: int\n    name: str\n    price: float\n    total_price: float\n\n@app.post(\"/items/\", response_model=ItemResponse)\nasync def create_item(item: Item):\n    # Simulate database save\n    item_dict = item.dict()\n    item_dict[\"id\"] = 123\n    item_dict[\"total_price\"] = item.price + (item.tax or 0)\n    return item_dict\n```\n\n**Response Model Benefits**:\n- **Data filtering**: Only fields defined in response model are returned\n- **Automatic documentation**: OpenAPI schema generation\n- **Type safety**: IDE support and validation\n- **Serialization**: Automatic JSON conversion\n\n**Multiple Response Models**:\n```python\nclass UserBase(BaseModel):\n    username: str\n    email: str\n\nclass UserCreate(UserBase):\n    password: str\n\nclass UserResponse(UserBase):\n    id: int\n    is_active: bool\n    \n    class Config:\n        from_attributes = True  # For SQLAlchemy models\n\n@app.post(\"/users/\", response_model=UserResponse)\nasync def create_user(user: UserCreate):\n    # Password won't be included in response\n    return {\"id\": 1, \"username\": user.username, \n            \"email\": user.email, \"is_active\": True}\n```\n\n**Response Model Lists**:\n```python\n@app.get(\"/items/\", response_model=List[ItemResponse])\nasync def read_items():\n    return [\n        {\"id\": 1, \"name\": \"Item 1\", \"price\": 10.0, \"total_price\": 11.0},\n        {\"id\": 2, \"name\": \"Item 2\", \"price\": 20.0, \"total_price\": 22.0}\n    ]\n```\n\n**Status Codes and Validation**:\n```python\nfrom fastapi import status\n\n@app.post(\"/items/\", response_model=ItemResponse, status_code=status.HTTP_201_CREATED)\nasync def create_item(item: Item):\n    return item_dict\n```",
      "keywords": ["response model", "data validation", "serialization", "pydantic", "status codes", "documentation"],
      "difficulty": "easy"
    },
    {
      "id": 12004,
      "tag": "fastapi",
      "question": "What are path operations and HTTP methods in FastAPI? How do you implement them?",
      "answer": "Path operations in FastAPI are functions that handle HTTP requests to specific URL paths. FastAPI supports all standard HTTP methods through decorators.\n\n**Basic HTTP Methods**:\n```python\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id, \"method\": \"GET\"}\n\n@app.post(\"/items/\")\nasync def create_item(item: dict):\n    return {\"message\": \"Item created\", \"item\": item}\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: dict):\n    return {\"item_id\": item_id, \"item\": item, \"method\": \"PUT\"}\n\n@app.delete(\"/items/{item_id}\")\nasync def delete_item(item_id: int):\n    return {\"message\": f\"Item {item_id} deleted\"}\n\n@app.patch(\"/items/{item_id}\")\nasync def patch_item(item_id: int, item: dict):\n    return {\"item_id\": item_id, \"updated_fields\": item}\n```\n\n**Additional HTTP Methods**:\n```python\n@app.head(\"/items/{item_id}\")\nasync def head_item(item_id: int):\n    return {}  # Only headers, no body\n\n@app.options(\"/items/{item_id}\")\nasync def options_item(item_id: int):\n    return {\"allowed_methods\": [\"GET\", \"POST\", \"PUT\", \"DELETE\"]}\n```\n\n**Path Operation Configuration**:\n```python\n@app.post(\n    \"/items/\",\n    response_model=ItemResponse,\n    status_code=201,\n    tags=[\"items\"],\n    summary=\"Create an item\",\n    description=\"Create a new item with all the information\",\n    response_description=\"The created item\"\n)\nasync def create_item(item: ItemCreate):\n    return item\n```\n\n**Multiple Path Operations**:\nYou can have multiple operations for the same path with different methods:\n\n```python\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    return {\"item_id\": item_id}\n\n@app.put(\"/items/{item_id}\")\nasync def update_item(item_id: int, item: Item):\n    return {\"item_id\": item_id, \"item\": item}\n```\n\n**Error Handling**:\n```python\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id < 1:\n        raise HTTPException(status_code=400, detail=\"Item ID must be positive\")\n    if item_id > 1000:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return {\"item_id\": item_id}\n```",
      "keywords": ["path operations", "http methods", "get", "post", "put", "delete", "patch", "decorators", "rest api"],
      "difficulty": "easy"
    },
    {
      "id": 12005,
      "tag": "fastapi",
      "question": "How does FastAPI automatically generate API documentation with Swagger UI and ReDoc?",
      "answer": "FastAPI automatically generates interactive API documentation using OpenAPI (formerly Swagger) specification. It provides two built-in documentation interfaces: Swagger UI and ReDoc.\n\n**Automatic Generation**:\nFastAPI creates documentation from your code automatically:\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import Optional\n\napp = FastAPI(\n    title=\"My API\",\n    description=\"This is a very fancy project, with auto docs for the API\",\n    version=\"2.5.0\",\n)\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None\n    price: float\n    tax: Optional[float] = None\n\n@app.post(\"/items/\", tags=[\"items\"])\nasync def create_item(item: Item):\n    \"\"\"Create an item with all the information.\"\"\"\n    return item\n```\n\n**Accessing Documentation**:\n- **Swagger UI**: `http://localhost:8000/docs`\n- **ReDoc**: `http://localhost:8000/redoc`\n- **OpenAPI JSON**: `http://localhost:8000/openapi.json`\n\n**Enhanced Documentation**:\n```python\nfrom fastapi import FastAPI, Path, Query\n\n@app.get(\n    \"/items/{item_id}\",\n    tags=[\"items\"],\n    summary=\"Read an item\",\n    description=\"Get an item by its ID from the database\",\n    response_description=\"The item information\"\n)\nasync def read_item(\n    item_id: int = Path(..., title=\"Item ID\", description=\"The ID of the item to get\", ge=1),\n    q: Optional[str] = Query(None, title=\"Query string\", description=\"Query string for the items to search\", max_length=50)\n):\n    \"\"\"Get an item by ID with optional query parameter.\"\"\"\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n**Customizing Documentation**:\n```python\napp = FastAPI(\n    title=\"My Super Project\",\n    description=\"This is a very fancy project\",\n    version=\"2.5.0\",\n    terms_of_service=\"http://example.com/terms/\",\n    contact={\n        \"name\": \"Deadpoolio the Amazing\",\n        \"url\": \"http://x-force.example.com/contact/\",\n        \"email\": \"dp@x-force.example.com\",\n    },\n    license_info={\n        \"name\": \"Apache 2.0\",\n        \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\",\n    },\n)\n```\n\n**Documentation Features**:\n- **Interactive testing**: Try out endpoints directly from the docs\n- **Request/response examples**: Automatic generation from Pydantic models\n- **Authentication**: Shows required authentication methods\n- **Schema validation**: Live validation in the browser\n- **Code generation**: Client SDK generation in multiple languages\n\nThe documentation updates automatically as you modify your code, making it always in sync with your API implementation.",
      "keywords": ["swagger ui", "redoc", "openapi", "documentation", "automatic", "interactive", "api docs", "schema"],
      "difficulty": "easy"
    },
    {
      "id": 12006,
      "tag": "fastapi",
      "question": "How does FastAPI's dependency injection system work and what are its benefits?",
      "answer": "FastAPI's dependency injection system is a powerful feature that allows you to declare dependencies that can be shared across multiple path operations, providing reusable code, better testing, and cleaner architecture.\n\n**Basic Dependencies**:\n```python\nfrom fastapi import FastAPI, Depends\n\napp = FastAPI()\n\ndef common_parameters(q: str = None, skip: int = 0, limit: int = 100):\n    return {\"q\": q, \"skip\": skip, \"limit\": limit}\n\n@app.get(\"/items/\")\nasync def read_items(commons: dict = Depends(common_parameters)):\n    return commons\n\n@app.get(\"/users/\")\nasync def read_users(commons: dict = Depends(common_parameters)):\n    return commons\n```\n\n**Class-based Dependencies**:\n```python\nclass CommonQueryParams:\n    def __init__(self, q: str = None, skip: int = 0, limit: int = 100):\n        self.q = q\n        self.skip = skip\n        self.limit = limit\n\n@app.get(\"/items/\")\nasync def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):\n    response = {}\n    if commons.q:\n        response.update({\"q\": commons.q})\n    response.update({\"skip\": commons.skip, \"limit\": commons.limit})\n    return response\n\n# Shortcut syntax\n@app.get(\"/users/\")\nasync def read_users(commons: CommonQueryParams = Depends()):\n    return commons\n```\n\n**Database Dependencies**:\n```python\nfrom sqlalchemy.orm import Session\nfrom database import SessionLocal\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/{user_id}\")\nasync def read_user(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).filter(User.id == user_id).first()\n    return user\n```\n\n**Authentication Dependencies**:\n```python\nfrom fastapi import HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\n\nsecurity = HTTPBearer()\n\nasync def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    token = credentials.credentials\n    user = verify_token(token)  # Your token verification logic\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Invalid authentication credentials\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    return user\n\n@app.get(\"/protected/\")\nasync def protected_route(current_user: User = Depends(get_current_user)):\n    return {\"message\": f\"Hello {current_user.username}\"}\n```\n\n**Sub-dependencies**:\n```python\ndef verify_token(token: str = Depends(oauth2_scheme)):\n    # Token verification logic\n    return decode_token(token)\n\ndef get_current_user(token_data: dict = Depends(verify_token)):\n    user = get_user(token_data[\"sub\"])\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n\n@app.get(\"/me/\")\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    return current_user\n```\n\n**Global Dependencies**:\n```python\napp = FastAPI(dependencies=[Depends(verify_api_key)])\n\n# Or for specific routers\nrouter = APIRouter(dependencies=[Depends(get_current_user)])\n```\n\n**Benefits**:\n- **Code reusability**: Share common logic across endpoints\n- **Separation of concerns**: Keep business logic separate from HTTP handling\n- **Easy testing**: Mock dependencies for unit tests\n- **Type safety**: Full IDE support and type checking\n- **Automatic documentation**: Dependencies appear in OpenAPI docs\n- **Performance**: Dependencies are cached per request",
      "keywords": ["dependency injection", "depends", "reusable", "database", "authentication", "testing", "separation of concerns"],
      "difficulty": "medium"
    },
    {
      "id": 12007,
      "tag": "fastapi",
      "question": "How do you implement authentication and security in FastAPI using OAuth2 and JWT tokens?",
      "answer": "FastAPI provides comprehensive security features with built-in support for OAuth2, JWT tokens, and various authentication schemes.\n\n**Basic OAuth2 Setup**:\n```python\nfrom fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom datetime import datetime, timedelta\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\n# Configuration\nSECRET_KEY = \"your-secret-key\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str\n\nclass TokenData(BaseModel):\n    username: str = None\n\nclass User(BaseModel):\n    username: str\n    email: str = None\n    full_name: str = None\n    disabled: bool = None\n```\n\n**Password Hashing and Verification**:\n```python\ndef verify_password(plain_password, hashed_password):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password):\n    return pwd_context.hash(password)\n\ndef authenticate_user(username: str, password: str):\n    user = get_user(username)\n    if not user or not verify_password(password, user.hashed_password):\n        return False\n    return user\n```\n\n**JWT Token Creation and Validation**:\n```python\ndef create_access_token(data: dict, expires_delta: timedelta = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n    \n    user = get_user(username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    return user\n\nasync def get_current_active_user(current_user: User = Depends(get_current_user)):\n    if current_user.disabled:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return current_user\n```\n\n**Authentication Endpoints**:\n```python\n@app.post(\"/token\", response_model=Token)\nasync def login_for_access_token(form_data: OAuth2PasswordRequestForm = Depends()):\n    user = authenticate_user(form_data.username, form_data.password)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n@app.get(\"/users/me/\", response_model=User)\nasync def read_users_me(current_user: User = Depends(get_current_active_user)):\n    return current_user\n\n@app.get(\"/protected/\")\nasync def protected_route(current_user: User = Depends(get_current_active_user)):\n    return {\"message\": f\"Hello {current_user.username}, this is a protected route\"}\n```\n\n**Security Best Practices**:\n- Use strong secret keys and store them securely\n- Implement token refresh mechanisms\n- Add rate limiting for authentication endpoints\n- Use HTTPS in production\n- Implement proper logout functionality\n- Consider using refresh tokens for better security",
      "keywords": ["authentication", "oauth2", "jwt", "security", "tokens", "password hashing", "authorization", "bearer token"],
      "difficulty": "medium"
    },
    {
      "id": 12008,
      "tag": "fastapi",
      "question": "How do you implement background tasks and async processing in FastAPI?",
      "answer": "FastAPI provides excellent support for background tasks and asynchronous processing, allowing you to handle time-consuming operations without blocking the main request-response cycle.\n\n**Basic Background Tasks**:\n```python\nfrom fastapi import FastAPI, BackgroundTasks\nimport time\n\napp = FastAPI()\n\ndef write_notification(email: str, message: str = \"\"):\n    with open(\"log.txt\", mode=\"w\") as email_file:\n        content = f\"notification for {email}: {message}\\n\"\n        email_file.write(content)\n        time.sleep(5)  # Simulate slow I/O operation\n\n@app.post(\"/send-notification/{email}\")\nasync def send_notification(email: str, background_tasks: BackgroundTasks):\n    background_tasks.add_task(write_notification, email, message=\"some notification\")\n    return {\"message\": \"Notification sent in the background\"}\n```\n\n**Multiple Background Tasks**:\n```python\ndef send_email(email: str, subject: str, body: str):\n    # Email sending logic\n    print(f\"Sending email to {email}: {subject}\")\n    time.sleep(2)\n\ndef log_activity(user_id: int, action: str):\n    # Activity logging logic\n    print(f\"User {user_id} performed: {action}\")\n    time.sleep(1)\n\n@app.post(\"/register/\")\nasync def register_user(user: UserCreate, background_tasks: BackgroundTasks):\n    # Create user in database\n    new_user = create_user(user)\n    \n    # Add multiple background tasks\n    background_tasks.add_task(\n        send_email, \n        user.email, \n        \"Welcome!\", \n        \"Thanks for registering\"\n    )\n    background_tasks.add_task(log_activity, new_user.id, \"user_registered\")\n    \n    return {\"message\": \"User registered successfully\"}\n```\n\n**Async Background Processing with Celery**:\n```python\nfrom celery import Celery\nfrom fastapi import FastAPI\n\n# Celery configuration\ncelery_app = Celery(\n    \"tasks\",\n    broker=\"redis://localhost:6379/0\",\n    backend=\"redis://localhost:6379/0\"\n)\n\n@celery_app.task\ndef process_heavy_computation(data: dict):\n    # Heavy computation that might take minutes\n    result = perform_complex_analysis(data)\n    return result\n\n@celery_app.task\ndef send_bulk_emails(email_list: list, template: str):\n    for email in email_list:\n        send_email_template(email, template)\n    return f\"Sent {len(email_list)} emails\"\n\napp = FastAPI()\n\n@app.post(\"/process-data/\")\nasync def process_data(data: dict):\n    task = process_heavy_computation.delay(data)\n    return {\"task_id\": task.id, \"status\": \"processing\"}\n\n@app.get(\"/task-status/{task_id}\")\nasync def get_task_status(task_id: str):\n    task = celery_app.AsyncResult(task_id)\n    return {\n        \"task_id\": task_id,\n        \"status\": task.status,\n        \"result\": task.result if task.ready() else None\n    }\n```\n\n**WebSocket for Real-time Updates**:\n```python\nfrom fastapi import WebSocket, WebSocketDisconnect\nimport asyncio\nimport json\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            # Process data in background\n            asyncio.create_task(process_websocket_data(websocket, data))\n    except WebSocketDisconnect:\n        print(f\"Client {client_id} disconnected\")\n\nasync def process_websocket_data(websocket: WebSocket, data: str):\n    # Simulate processing\n    await asyncio.sleep(2)\n    processed_data = {\"processed\": data, \"timestamp\": time.time()}\n    await websocket.send_text(json.dumps(processed_data))\n```\n\n**Async Context Managers for Resources**:\n```python\nimport aiofiles\nimport asyncio\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    # Startup\n    print(\"Starting up background services\")\n    background_task = asyncio.create_task(periodic_cleanup())\n    yield\n    # Shutdown\n    print(\"Shutting down background services\")\n    background_task.cancel()\n\napp = FastAPI(lifespan=lifespan)\n\nasync def periodic_cleanup():\n    while True:\n        await asyncio.sleep(3600)  # Run every hour\n        print(\"Running periodic cleanup\")\n        # Cleanup logic here\n```\n\n**Best Practices**:\n- Use BackgroundTasks for quick operations (< 10 seconds)\n- Use Celery/RQ for heavy, long-running tasks\n- Monitor background task performance\n- Implement proper error handling and logging\n- Consider using task queues for scalability\n- Use WebSockets for real-time communication",
      "keywords": ["background tasks", "async", "celery", "websockets", "task queue", "asynchronous processing", "concurrent"],
      "difficulty": "medium"
    },
    {
      "id": 12009,
      "tag": "fastapi",
      "question": "How do you integrate FastAPI with databases using SQLAlchemy and implement proper database patterns?",
      "answer": "FastAPI integrates seamlessly with SQLAlchemy, providing a robust foundation for database operations with proper async support and dependency injection.\n\n**Database Setup**:\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom fastapi import FastAPI, Depends, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\n# Database configuration\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n# For PostgreSQL: \"postgresql://user:password@localhost/dbname\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, \n    connect_args={\"check_same_thread\": False}  # Only for SQLite\n)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# Database dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n```\n\n**SQLAlchemy Models**:\n```python\nfrom sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom datetime import datetime\n\nclass User(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    username = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    items = relationship(\"Item\", back_populates=\"owner\")\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    description = Column(String)\n    owner_id = Column(Integer, ForeignKey(\"users.id\"))\n    \n    owner = relationship(\"User\", back_populates=\"items\")\n\n# Create tables\nBase.metadata.create_all(bind=engine)\n```\n\n**Pydantic Schemas**:\n```python\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nfrom datetime import datetime\n\nclass ItemBase(BaseModel):\n    title: str\n    description: Optional[str] = None\n\nclass ItemCreate(ItemBase):\n    pass\n\nclass Item(ItemBase):\n    id: int\n    owner_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass UserBase(BaseModel):\n    email: str\n    username: str\n\nclass UserCreate(UserBase):\n    password: str\n\nclass User(UserBase):\n    id: int\n    is_active: bool\n    created_at: datetime\n    items: List[Item] = []\n    \n    class Config:\n        from_attributes = True\n```\n\n**CRUD Operations**:\n```python\nfrom sqlalchemy.orm import Session\nfrom passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef get_user(db: Session, user_id: int):\n    return db.query(User).filter(User.id == user_id).first()\n\ndef get_user_by_email(db: Session, email: str):\n    return db.query(User).filter(User.email == email).first()\n\ndef get_users(db: Session, skip: int = 0, limit: int = 100):\n    return db.query(User).offset(skip).limit(limit).all()\n\ndef create_user(db: Session, user: UserCreate):\n    hashed_password = pwd_context.hash(user.password)\n    db_user = User(\n        email=user.email,\n        username=user.username,\n        hashed_password=hashed_password\n    )\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n\ndef create_user_item(db: Session, item: ItemCreate, user_id: int):\n    db_item = Item(**item.dict(), owner_id=user_id)\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item\n```\n\n**API Endpoints**:\n```python\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=User)\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = get_user_by_email(db, email=user.email)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Email already registered\")\n    return create_user(db=db, user=user)\n\n@app.get(\"/users/\", response_model=List[User])\ndef read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    users = get_users(db, skip=skip, limit=limit)\n    return users\n\n@app.get(\"/users/{user_id}\", response_model=User)\ndef read_user(user_id: int, db: Session = Depends(get_db)):\n    db_user = get_user(db, user_id=user_id)\n    if db_user is None:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return db_user\n\n@app.post(\"/users/{user_id}/items/\", response_model=Item)\ndef create_item_for_user(\n    user_id: int, item: ItemCreate, db: Session = Depends(get_db)\n):\n    return create_user_item(db=db, item=item, user_id=user_id)\n```\n\n**Async Database Support**:\n```python\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\n\n# Async database setup\nDATABASE_URL = \"postgresql+asyncpg://user:password@localhost/dbname\"\nasync_engine = create_async_engine(DATABASE_URL)\nAsyncSessionLocal = async_sessionmaker(async_engine, expire_on_commit=False)\n\nasync def get_async_db():\n    async with AsyncSessionLocal() as session:\n        yield session\n\n@app.get(\"/async-users/{user_id}\")\nasync def read_user_async(user_id: int, db: AsyncSession = Depends(get_async_db)):\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user\n```\n\n**Best Practices**:\n- Use connection pooling for production\n- Implement database migrations with Alembic\n- Use async drivers for better performance\n- Implement proper error handling and transactions\n- Use database indexes for frequently queried fields\n- Consider using database connection health checks",
      "keywords": ["sqlalchemy", "database", "orm", "crud", "async", "postgresql", "migrations", "relationships", "sessions"],
      "difficulty": "medium"
    },
    {
      "id": 12010,
      "tag": "fastapi",
      "question": "How do you configure middleware and CORS in FastAPI applications?",
      "answer": "FastAPI provides powerful middleware capabilities for handling cross-cutting concerns like CORS, authentication, logging, and request processing. Middleware runs before and after each request.\n\n**CORS Configuration**:\n```python\nfrom fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\n\napp = FastAPI()\n\n# Configure CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:3000\", \"https://mydomain.com\"],\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"*\"],\n)\n\n# For development (allow all origins)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n```\n\n**Custom Middleware**:\n```python\nimport time\nfrom fastapi import Request\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.responses import Response\n\nclass TimingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.time()\n        response = await call_next(request)\n        process_time = time.time() - start_time\n        response.headers[\"X-Process-Time\"] = str(process_time)\n        return response\n\napp.add_middleware(TimingMiddleware)\n\n# Function-based middleware\n@app.middleware(\"http\")\nasync def add_security_headers(request: Request, call_next):\n    response = await call_next(request)\n    response.headers[\"X-Content-Type-Options\"] = \"nosniff\"\n    response.headers[\"X-Frame-Options\"] = \"DENY\"\n    response.headers[\"X-XSS-Protection\"] = \"1; mode=block\"\n    return response\n```\n\n**Built-in Middleware**:\n```python\nfrom fastapi.middleware.gzip import GZipMiddleware\nfrom fastapi.middleware.httpsredirect import HTTPSRedirectMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\n\n# Gzip compression\napp.add_middleware(GZipMiddleware, minimum_size=1000)\n\n# HTTPS redirect (for production)\napp.add_middleware(HTTPSRedirectMiddleware)\n\n# Trusted host protection\napp.add_middleware(\n    TrustedHostMiddleware, \n    allowed_hosts=[\"example.com\", \"*.example.com\"]\n)\n```\n\n**Logging Middleware**:\n```python\nimport logging\nfrom uuid import uuid4\n\nlogger = logging.getLogger(__name__)\n\n@app.middleware(\"http\")\nasync def log_requests(request: Request, call_next):\n    request_id = str(uuid4())\n    logger.info(f\"Request {request_id}: {request.method} {request.url}\")\n    \n    start_time = time.time()\n    response = await call_next(request)\n    process_time = time.time() - start_time\n    \n    logger.info(\n        f\"Request {request_id} completed: {response.status_code} \"\n        f\"in {process_time:.4f}s\"\n    )\n    return response\n```\n\nMiddleware executes in the order it's added and wraps around your path operations, making it perfect for authentication, logging, and request modification.",
      "keywords": ["middleware", "cors", "security headers", "logging", "gzip", "https redirect", "custom middleware"],
      "difficulty": "easy"
    },
    {
      "id": 12011,
      "tag": "fastapi",
      "question": "How do you handle file uploads and form data in FastAPI?",
      "answer": "FastAPI provides comprehensive support for handling file uploads and form data through built-in classes and proper validation.\n\n**Single File Upload**:\n```python\nfrom fastapi import FastAPI, File, UploadFile, HTTPException\nimport shutil\nfrom pathlib import Path\n\napp = FastAPI()\n\n@app.post(\"/upload-file/\")\nasync def upload_file(file: UploadFile = File(...)):\n    # Validate file type\n    if file.content_type not in [\"image/jpeg\", \"image/png\", \"image/gif\"]:\n        raise HTTPException(status_code=400, detail=\"Invalid file type\")\n    \n    # Validate file size (5MB limit)\n    if file.size > 5 * 1024 * 1024:\n        raise HTTPException(status_code=400, detail=\"File too large\")\n    \n    # Save file\n    upload_dir = Path(\"uploads\")\n    upload_dir.mkdir(exist_ok=True)\n    \n    file_path = upload_dir / file.filename\n    with open(file_path, \"wb\") as buffer:\n        shutil.copyfileobj(file.file, buffer)\n    \n    return {\n        \"filename\": file.filename,\n        \"content_type\": file.content_type,\n        \"size\": file.size,\n        \"message\": \"File uploaded successfully\"\n    }\n```\n\n**Multiple File Upload**:\n```python\nfrom typing import List\n\n@app.post(\"/upload-multiple/\")\nasync def upload_multiple_files(files: List[UploadFile] = File(...)):\n    uploaded_files = []\n    \n    for file in files:\n        # Process each file\n        content = await file.read()\n        uploaded_files.append({\n            \"filename\": file.filename,\n            \"size\": len(content),\n            \"content_type\": file.content_type\n        })\n        \n        # Reset file pointer if you need to read again\n        await file.seek(0)\n    \n    return {\"uploaded_files\": uploaded_files}\n```\n\n**Form Data with Files**:\n```python\nfrom fastapi import Form\nfrom pydantic import BaseModel\n\nclass ItemData(BaseModel):\n    name: str\n    description: str\n    price: float\n\n@app.post(\"/create-item/\")\nasync def create_item(\n    name: str = Form(...),\n    description: str = Form(...),\n    price: float = Form(...),\n    image: UploadFile = File(None)\n):\n    item_data = {\n        \"name\": name,\n        \"description\": description,\n        \"price\": price\n    }\n    \n    if image:\n        # Process image upload\n        image_path = f\"uploads/{image.filename}\"\n        with open(image_path, \"wb\") as buffer:\n            content = await image.read()\n            buffer.write(content)\n        item_data[\"image_path\"] = image_path\n    \n    return item_data\n```\n\n**Advanced File Processing**:\n```python\nimport aiofiles\nfrom PIL import Image\nimport io\n\n@app.post(\"/process-image/\")\nasync def process_image(file: UploadFile = File(...)):\n    # Read file content\n    content = await file.read()\n    \n    # Process with PIL\n    image = Image.open(io.BytesIO(content))\n    \n    # Resize image\n    resized_image = image.resize((800, 600))\n    \n    # Save processed image\n    output_buffer = io.BytesIO()\n    resized_image.save(output_buffer, format='JPEG')\n    \n    # Save to disk asynchronously\n    async with aiofiles.open(f\"processed/{file.filename}\", \"wb\") as f:\n        await f.write(output_buffer.getvalue())\n    \n    return {\n        \"original_size\": image.size,\n        \"new_size\": resized_image.size,\n        \"processed_file\": f\"processed/{file.filename}\"\n    }\n```\n\n**File Streaming**:\n```python\nfrom fastapi.responses import StreamingResponse\n\n@app.get(\"/download/{filename}\")\ndef download_file(filename: str):\n    file_path = Path(f\"uploads/{filename}\")\n    \n    if not file_path.exists():\n        raise HTTPException(status_code=404, detail=\"File not found\")\n    \n    def iter_file():\n        with open(file_path, \"rb\") as file_like:\n            yield from file_like\n    \n    return StreamingResponse(\n        iter_file(),\n        media_type=\"application/octet-stream\",\n        headers={\"Content-Disposition\": f\"attachment; filename={filename}\"}\n    )\n```\n\nKey considerations: validate file types and sizes, handle async file operations properly, implement proper error handling, and consider security implications of file uploads.",
      "keywords": ["file upload", "form data", "multipart", "file validation", "image processing", "streaming", "aiofiles"],
      "difficulty": "easy"
    },
    {
      "id": 12012,
      "tag": "fastapi",
      "question": "How do you implement comprehensive error handling and custom exceptions in FastAPI?",
      "answer": "FastAPI provides robust error handling mechanisms through HTTP exceptions, custom exception handlers, and validation error customization.\n\n**Basic HTTP Exceptions**:\n```python\nfrom fastapi import FastAPI, HTTPException, status\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id < 1:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Item ID must be positive\",\n            headers={\"X-Error\": \"Invalid ID\"}\n        )\n    \n    if item_id > 1000:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Item {item_id} not found\"\n        )\n    \n    return {\"item_id\": item_id}\n```\n\n**Custom Exception Classes**:\n```python\nclass ItemNotFoundError(Exception):\n    def __init__(self, item_id: int):\n        self.item_id = item_id\n        super().__init__(f\"Item {item_id} not found\")\n\nclass InsufficientPermissionsError(Exception):\n    def __init__(self, action: str):\n        self.action = action\n        super().__init__(f\"Insufficient permissions for {action}\")\n\nclass ValidationError(Exception):\n    def __init__(self, field: str, message: str):\n        self.field = field\n        self.message = message\n        super().__init__(f\"Validation error in {field}: {message}\")\n```\n\n**Custom Exception Handlers**:\n```python\nfrom fastapi import Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(ItemNotFoundError)\nasync def item_not_found_handler(request: Request, exc: ItemNotFoundError):\n    logger.warning(f\"Item not found: {exc.item_id}\")\n    return JSONResponse(\n        status_code=404,\n        content={\n            \"error\": \"Item not found\",\n            \"item_id\": exc.item_id,\n            \"message\": str(exc)\n        }\n    )\n\n@app.exception_handler(InsufficientPermissionsError)\nasync def permission_handler(request: Request, exc: InsufficientPermissionsError):\n    logger.error(f\"Permission denied: {exc.action}\")\n    return JSONResponse(\n        status_code=403,\n        content={\n            \"error\": \"Forbidden\",\n            \"action\": exc.action,\n            \"message\": \"You don't have permission to perform this action\"\n        }\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": \"Validation failed\",\n            \"field\": exc.field,\n            \"message\": exc.message\n        }\n    )\n```\n\n**Global Exception Handler**:\n```python\nfrom fastapi import HTTPException\nfrom starlette.exceptions import HTTPException as StarletteHTTPException\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {str(exc)}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": getattr(request.state, 'request_id', 'unknown')\n        }\n    )\n\n@app.exception_handler(StarletteHTTPException)\nasync def http_exception_handler(request: Request, exc: StarletteHTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\n            \"error\": \"HTTP Error\",\n            \"status_code\": exc.status_code,\n            \"message\": exc.detail\n        }\n    )\n```\n\n**Validation Error Customization**:\n```python\nfrom fastapi.exceptions import RequestValidationError\nfrom pydantic import ValidationError as PydanticValidationError\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    errors = []\n    for error in exc.errors():\n        errors.append({\n            \"field\": \" -> \".join(str(x) for x in error[\"loc\"]),\n            \"message\": error[\"msg\"],\n            \"type\": error[\"type\"]\n        })\n    \n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": \"Validation failed\",\n            \"details\": errors,\n            \"body\": exc.body\n        }\n    )\n```\n\n**Using Custom Exceptions in Endpoints**:\n```python\n@app.get(\"/users/{user_id}/items/{item_id}\")\nasync def get_user_item(user_id: int, item_id: int, current_user: User = Depends(get_current_user)):\n    # Check permissions\n    if current_user.id != user_id and not current_user.is_admin:\n        raise InsufficientPermissionsError(\"access user items\")\n    \n    # Get item\n    item = get_item_by_id(item_id)\n    if not item:\n        raise ItemNotFoundError(item_id)\n    \n    # Validate ownership\n    if item.owner_id != user_id:\n        raise ValidationError(\"item_id\", \"Item does not belong to this user\")\n    \n    return item\n```\n\nThis approach provides clear, consistent error responses with proper logging and makes debugging easier for both developers and API consumers.",
      "keywords": ["error handling", "custom exceptions", "http exceptions", "validation errors", "exception handlers", "logging"],
      "difficulty": "easy"
    },
    {
      "id": 12013,
      "tag": "fastapi",
      "question": "How do you test FastAPI applications using pytest and TestClient?",
      "answer": "FastAPI provides excellent testing capabilities through the TestClient, which is built on top of Starlette's testing utilities and works seamlessly with pytest.\n\n**Basic Test Setup**:\n```python\n# test_main.py\nfrom fastapi.testclient import TestClient\nfrom main import app\nimport pytest\n\nclient = TestClient(app)\n\ndef test_read_root():\n    response = client.get(\"/\")\n    assert response.status_code == 200\n    assert response.json() == {\"message\": \"Hello World\"}\n\ndef test_create_item():\n    response = client.post(\n        \"/items/\",\n        json={\"name\": \"Test Item\", \"price\": 10.5, \"description\": \"Test description\"}\n    )\n    assert response.status_code == 200\n    assert response.json()[\"name\"] == \"Test Item\"\n    assert response.json()[\"price\"] == 10.5\n```\n\n**Testing with Dependencies**:\n```python\nfrom fastapi import Depends\nfrom sqlalchemy.orm import Session\nfrom database import get_db\n\n# Override dependency for testing\ndef get_test_db():\n    # Return test database session\n    pass\n\n# Override dependency in tests\napp.dependency_overrides[get_db] = get_test_db\n\ndef test_create_user():\n    response = client.post(\n        \"/users/\",\n        json={\"email\": \"test@example.com\", \"username\": \"testuser\", \"password\": \"testpass\"}\n    )\n    assert response.status_code == 200\n    assert response.json()[\"email\"] == \"test@example.com\"\n```\n\n**Async Testing**:\n```python\nimport pytest\nimport asyncio\nfrom httpx import AsyncClient\nfrom main import app\n\n@pytest.mark.asyncio\nasync def test_async_endpoint():\n    async with AsyncClient(app=app, base_url=\"http://test\") as ac:\n        response = await ac.get(\"/async-endpoint\")\n    assert response.status_code == 200\n\n# Alternative using pytest-asyncio\n@pytest.fixture\ndef event_loop():\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n```\n\n**Database Testing with Fixtures**:\n```python\nimport pytest\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\nfrom database import Base, get_db\n\nSQLALCHEMY_DATABASE_URL = \"sqlite:///./test.db\"\n\nengine = create_engine(\n    SQLALCHEMY_DATABASE_URL, connect_args={\"check_same_thread\": False}\n)\nTestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n@pytest.fixture\ndef test_db():\n    Base.metadata.create_all(bind=engine)\n    db = TestingSessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n        Base.metadata.drop_all(bind=engine)\n\n@pytest.fixture\ndef client(test_db):\n    def get_test_db():\n        try:\n            yield test_db\n        finally:\n            test_db.close()\n    \n    app.dependency_overrides[get_db] = get_test_db\n    with TestClient(app) as test_client:\n        yield test_client\n    app.dependency_overrides.clear()\n\ndef test_create_user(client):\n    response = client.post(\n        \"/users/\",\n        json={\"email\": \"test@example.com\", \"username\": \"testuser\", \"password\": \"secret\"}\n    )\n    assert response.status_code == 200\n```\n\n**Authentication Testing**:\n```python\n@pytest.fixture\ndef authenticated_client(client, test_db):\n    # Create test user\n    user_data = {\"email\": \"test@example.com\", \"username\": \"testuser\", \"password\": \"secret\"}\n    client.post(\"/users/\", json=user_data)\n    \n    # Login to get token\n    login_response = client.post(\n        \"/token\",\n        data={\"username\": \"testuser\", \"password\": \"secret\"},\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    )\n    token = login_response.json()[\"access_token\"]\n    \n    # Add token to client headers\n    client.headers.update({\"Authorization\": f\"Bearer {token}\"})\n    return client\n\ndef test_protected_endpoint(authenticated_client):\n    response = authenticated_client.get(\"/protected\")\n    assert response.status_code == 200\n    assert \"message\" in response.json()\n```\n\n**Testing File Uploads**:\n```python\ndef test_file_upload():\n    with open(\"test_image.jpg\", \"rb\") as f:\n        response = client.post(\n            \"/upload/\",\n            files={\"file\": (\"test_image.jpg\", f, \"image/jpeg\")}\n        )\n    assert response.status_code == 200\n    assert response.json()[\"filename\"] == \"test_image.jpg\"\n\ndef test_form_data_with_file():\n    with open(\"test_image.jpg\", \"rb\") as f:\n        response = client.post(\n            \"/items/\",\n            data={\"name\": \"Test Item\", \"price\": \"10.5\"},\n            files={\"image\": (\"test_image.jpg\", f, \"image/jpeg\")}\n        )\n    assert response.status_code == 200\n```\n\n**Testing Error Cases**:\n```python\ndef test_item_not_found():\n    response = client.get(\"/items/999\")\n    assert response.status_code == 404\n    assert \"not found\" in response.json()[\"detail\"].lower()\n\ndef test_validation_error():\n    response = client.post(\n        \"/items/\",\n        json={\"name\": \"\", \"price\": -1}  # Invalid data\n    )\n    assert response.status_code == 422\n    assert \"validation\" in response.json()[\"detail\"][0][\"type\"]\n```\n\n**Parametrized Tests**:\n```python\n@pytest.mark.parametrize(\"item_id,expected_status\", [\n    (1, 200),\n    (999, 404),\n    (-1, 400)\n])\ndef test_get_item_various_ids(item_id, expected_status):\n    response = client.get(f\"/items/{item_id}\")\n    assert response.status_code == expected_status\n\n@pytest.mark.parametrize(\"user_data,expected_status\", [\n    ({\"email\": \"valid@example.com\", \"username\": \"valid\", \"password\": \"secret\"}, 200),\n    ({\"email\": \"invalid-email\", \"username\": \"valid\", \"password\": \"secret\"}, 422),\n    ({\"email\": \"valid@example.com\", \"username\": \"\", \"password\": \"secret\"}, 422),\n])\ndef test_create_user_validation(user_data, expected_status):\n    response = client.post(\"/users/\", json=user_data)\n    assert response.status_code == expected_status\n```\n\nThis testing approach ensures comprehensive coverage of your FastAPI application, including happy paths, error cases, authentication, and edge cases.",
      "keywords": ["testing", "pytest", "testclient", "fixtures", "async testing", "database testing", "authentication testing", "parametrized tests"],
      "difficulty": "easy"
    },
    {
      "id": 12014,
      "tag": "fastapi",
      "question": "How do you handle configuration and environment variables in FastAPI applications?",
      "answer": "FastAPI applications require proper configuration management for different environments. Pydantic provides excellent support for environment variable handling with validation.\n\n**Basic Configuration with Pydantic Settings**:\n```python\nfrom pydantic import BaseSettings, Field\nfrom typing import Optional, List\nfrom functools import lru_cache\n\nclass Settings(BaseSettings):\n    app_name: str = \"My FastAPI App\"\n    debug: bool = False\n    database_url: str = Field(..., env=\"DATABASE_URL\")\n    secret_key: str = Field(..., env=\"SECRET_KEY\")\n    algorithm: str = \"HS256\"\n    access_token_expire_minutes: int = 30\n    \n    # API Keys\n    redis_url: Optional[str] = None\n    email_api_key: Optional[str] = None\n    \n    # CORS settings\n    allowed_origins: List[str] = [\"http://localhost:3000\"]\n    \n    class Config:\n        env_file = \".env\"\n        env_file_encoding = \"utf-8\"\n        case_sensitive = False\n\n@lru_cache()\ndef get_settings():\n    return Settings()\n\nsettings = get_settings()\n```\n\n**Environment-Specific Configuration**:\n```python\nfrom enum import Enum\n\nclass Environment(str, Enum):\n    DEVELOPMENT = \"development\"\n    TESTING = \"testing\"\n    PRODUCTION = \"production\"\n\nclass Settings(BaseSettings):\n    environment: Environment = Environment.DEVELOPMENT\n    \n    # Database\n    database_url: str\n    database_pool_size: int = 5\n    database_max_overflow: int = 10\n    \n    # Security\n    secret_key: str\n    algorithm: str = \"HS256\"\n    access_token_expire_minutes: int = 30\n    \n    # External services\n    redis_url: Optional[str] = None\n    smtp_host: Optional[str] = None\n    smtp_port: int = 587\n    smtp_username: Optional[str] = None\n    smtp_password: Optional[str] = None\n    \n    # Logging\n    log_level: str = \"INFO\"\n    \n    @property\n    def is_development(self) -> bool:\n        return self.environment == Environment.DEVELOPMENT\n    \n    @property\n    def is_production(self) -> bool:\n        return self.environment == Environment.PRODUCTION\n    \n    class Config:\n        env_file = \".env\"\n        case_sensitive = False\n\n# Environment-specific settings\nclass DevelopmentSettings(Settings):\n    debug: bool = True\n    log_level: str = \"DEBUG\"\n    database_url: str = \"sqlite:///./dev.db\"\n\nclass ProductionSettings(Settings):\n    debug: bool = False\n    log_level: str = \"WARNING\"\n    database_pool_size: int = 20\n    database_max_overflow: int = 30\n\nclass TestingSettings(Settings):\n    debug: bool = True\n    database_url: str = \"sqlite:///./test.db\"\n    access_token_expire_minutes: int = 5\n\n@lru_cache()\ndef get_settings() -> Settings:\n    env = os.getenv(\"ENVIRONMENT\", \"development\")\n    if env == \"production\":\n        return ProductionSettings()\n    elif env == \"testing\":\n        return TestingSettings()\n    else:\n        return DevelopmentSettings()\n```\n\n**Using Configuration in FastAPI**:\n```python\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\ndef create_app() -> FastAPI:\n    settings = get_settings()\n    \n    app = FastAPI(\n        title=settings.app_name,\n        debug=settings.debug,\n        version=\"1.0.0\"\n    )\n    \n    # Database setup\n    engine = create_engine(\n        settings.database_url,\n        pool_size=settings.database_pool_size,\n        max_overflow=settings.database_max_overflow\n    )\n    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n    \n    # CORS configuration\n    if settings.allowed_origins:\n        from fastapi.middleware.cors import CORSMiddleware\n        app.add_middleware(\n            CORSMiddleware,\n            allow_origins=settings.allowed_origins,\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n    \n    return app\n\napp = create_app()\n\n@app.get(\"/info\")\nasync def get_app_info(settings: Settings = Depends(get_settings)):\n    return {\n        \"app_name\": settings.app_name,\n        \"environment\": settings.environment,\n        \"debug\": settings.debug,\n        \"version\": \"1.0.0\"\n    }\n```\n\n**Configuration with Validation**:\n```python\nfrom pydantic import validator, AnyHttpUrl\nfrom typing import Union\n\nclass Settings(BaseSettings):\n    database_url: str\n    secret_key: str = Field(..., min_length=32)\n    allowed_origins: List[Union[str, AnyHttpUrl]] = []\n    \n    @validator(\"database_url\")\n    def validate_database_url(cls, v):\n        if not v.startswith((\"postgresql://\", \"sqlite://\", \"mysql://\")):\n            raise ValueError(\"Invalid database URL scheme\")\n        return v\n    \n    @validator(\"secret_key\")\n    def validate_secret_key(cls, v):\n        if len(v) < 32:\n            raise ValueError(\"Secret key must be at least 32 characters\")\n        return v\n    \n    @validator(\"allowed_origins\", pre=True)\n    def parse_cors_origins(cls, v):\n        if isinstance(v, str):\n            return [origin.strip() for origin in v.split(\",\")]\n        return v\n```\n\n**Docker Environment Configuration**:\n```dockerfile\n# Dockerfile\nFROM python:3.11-slim\n\nWORKDIR /app\n\n# Environment variables with defaults\nENV ENVIRONMENT=production\nENV DEBUG=false\nENV LOG_LEVEL=INFO\n\nCOPY requirements.txt .\nRUN pip install -r requirements.txt\n\nCOPY . .\n\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n```\n\n**Docker Compose Configuration**:\n```yaml\n# docker-compose.yml\nversion: '3.8'\nservices:\n  api:\n    build: .\n    ports:\n      - \"8000:8000\"\n    environment:\n      - ENVIRONMENT=development\n      - DEBUG=true\n      - DATABASE_URL=postgresql://user:password@db:5432/myapp\n      - SECRET_KEY=your-super-secret-key-here\n      - REDIS_URL=redis://redis:6379\n    env_file:\n      - .env\n    depends_on:\n      - db\n      - redis\n  \n  db:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: myapp\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n  \n  redis:\n    image: redis:7-alpine\n\nvolumes:\n  postgres_data:\n```\n\nThis configuration approach provides type safety, validation, environment-specific settings, and easy testing while keeping sensitive data secure.",
      "keywords": ["configuration", "environment variables", "pydantic settings", "env file", "docker", "validation", "environment specific"],
      "difficulty": "easy"
    },
    {
      "id": 12015,
      "tag": "fastapi",
      "question": "How do you implement WebSocket support in FastAPI for real-time communication?",
      "answer": "FastAPI provides excellent WebSocket support for real-time communication, enabling bidirectional communication between clients and servers.\n\n**Basic WebSocket Implementation**:\n```python\nfrom fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\nimport json\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def send_personal_message(self, message: str, websocket: WebSocket):\n        await websocket.send_text(message)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.send_personal_message(f\"You wrote: {data}\", websocket)\n            await manager.broadcast(f\"Client #{client_id} says: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left the chat\")\n```\n\n**Chat Room Implementation**:\n```python\nfrom typing import Dict, Set\nimport uuid\n\nclass ChatRoom:\n    def __init__(self):\n        self.rooms: Dict[str, Set[WebSocket]] = {}\n        self.user_rooms: Dict[WebSocket, str] = {}\n    \n    async def join_room(self, websocket: WebSocket, room_id: str, username: str):\n        await websocket.accept()\n        \n        if room_id not in self.rooms:\n            self.rooms[room_id] = set()\n        \n        self.rooms[room_id].add(websocket)\n        self.user_rooms[websocket] = room_id\n        \n        # Notify room about new user\n        await self.broadcast_to_room(\n            room_id,\n            {\"type\": \"user_joined\", \"username\": username, \"message\": f\"{username} joined the room\"},\n            exclude=websocket\n        )\n        \n        # Send current room info to new user\n        await websocket.send_text(json.dumps({\n            \"type\": \"room_info\",\n            \"room_id\": room_id,\n            \"users_count\": len(self.rooms[room_id])\n        }))\n    \n    async def leave_room(self, websocket: WebSocket, username: str):\n        room_id = self.user_rooms.get(websocket)\n        if room_id and room_id in self.rooms:\n            self.rooms[room_id].discard(websocket)\n            if websocket in self.user_rooms:\n                del self.user_rooms[websocket]\n            \n            # Notify room about user leaving\n            await self.broadcast_to_room(\n                room_id,\n                {\"type\": \"user_left\", \"username\": username, \"message\": f\"{username} left the room\"}\n            )\n            \n            # Clean up empty rooms\n            if not self.rooms[room_id]:\n                del self.rooms[room_id]\n    \n    async def broadcast_to_room(self, room_id: str, message: dict, exclude: WebSocket = None):\n        if room_id not in self.rooms:\n            return\n        \n        message_text = json.dumps(message)\n        disconnected = set()\n        \n        for connection in self.rooms[room_id]:\n            if connection != exclude:\n                try:\n                    await connection.send_text(message_text)\n                except:\n                    disconnected.add(connection)\n        \n        # Clean up disconnected connections\n        for connection in disconnected:\n            self.rooms[room_id].discard(connection)\n            if connection in self.user_rooms:\n                del self.user_rooms[connection]\n\nchat_room = ChatRoom()\n\n@app.websocket(\"/chat/{room_id}\")\nasync def chat_websocket(websocket: WebSocket, room_id: str, username: str = \"Anonymous\"):\n    await chat_room.join_room(websocket, room_id, username)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            message_data = json.loads(data)\n            \n            # Broadcast message to room\n            await chat_room.broadcast_to_room(room_id, {\n                \"type\": \"message\",\n                \"username\": username,\n                \"message\": message_data.get(\"message\", \"\"),\n                \"timestamp\": int(time.time())\n            })\n    except WebSocketDisconnect:\n        await chat_room.leave_room(websocket, username)\n```\n\n**Real-time Notifications**:\n```python\nimport asyncio\nfrom datetime import datetime\n\nclass NotificationManager:\n    def __init__(self):\n        self.user_connections: Dict[int, WebSocket] = {}\n    \n    async def connect_user(self, user_id: int, websocket: WebSocket):\n        await websocket.accept()\n        self.user_connections[user_id] = websocket\n    \n    async def disconnect_user(self, user_id: int):\n        if user_id in self.user_connections:\n            del self.user_connections[user_id]\n    \n    async def send_notification(self, user_id: int, notification: dict):\n        if user_id in self.user_connections:\n            try:\n                await self.user_connections[user_id].send_text(json.dumps(notification))\n            except:\n                await self.disconnect_user(user_id)\n    \n    async def broadcast_system_message(self, message: str):\n        notification = {\n            \"type\": \"system\",\n            \"message\": message,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        disconnected_users = []\n        for user_id, connection in self.user_connections.items():\n            try:\n                await connection.send_text(json.dumps(notification))\n            except:\n                disconnected_users.append(user_id)\n        \n        # Clean up disconnected users\n        for user_id in disconnected_users:\n            await self.disconnect_user(user_id)\n\nnotification_manager = NotificationManager()\n\n@app.websocket(\"/notifications/{user_id}\")\nasync def notification_websocket(websocket: WebSocket, user_id: int):\n    await notification_manager.connect_user(user_id, websocket)\n    try:\n        # Send initial connection confirmation\n        await websocket.send_text(json.dumps({\n            \"type\": \"connected\",\n            \"message\": \"Connected to notifications\",\n            \"user_id\": user_id\n        }))\n        \n        # Keep connection alive and handle any incoming messages\n        while True:\n            await websocket.receive_text()\n    except WebSocketDisconnect:\n        await notification_manager.disconnect_user(user_id)\n```\n\n**WebSocket with Authentication**:\n```python\nfrom fastapi import Depends, HTTPException, status\nfrom jose import JWTError, jwt\n\nasync def get_current_user_websocket(websocket: WebSocket, token: str = None):\n    if not token:\n        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n        return None\n    \n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n            return None\n    except JWTError:\n        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n        return None\n    \n    user = get_user(username)\n    if user is None:\n        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n        return None\n    \n    return user\n\n@app.websocket(\"/secure-chat/{room_id}\")\nasync def secure_chat(websocket: WebSocket, room_id: str, token: str):\n    user = await get_current_user_websocket(websocket, token)\n    if not user:\n        return\n    \n    await chat_room.join_room(websocket, room_id, user.username)\n    # ... rest of chat logic\n```\n\n**Background Task Integration**:\n```python\nasync def send_scheduled_notifications():\n    while True:\n        await asyncio.sleep(60)  # Check every minute\n        \n        # Get pending notifications from database\n        notifications = get_pending_notifications()\n        \n        for notification in notifications:\n            await notification_manager.send_notification(\n                notification.user_id,\n                {\n                    \"type\": \"scheduled\",\n                    \"title\": notification.title,\n                    \"message\": notification.message,\n                    \"timestamp\": datetime.utcnow().isoformat()\n                }\n            )\n            mark_notification_sent(notification.id)\n\n# Start background task\n@app.on_event(\"startup\")\nasync def startup_event():\n    asyncio.create_task(send_scheduled_notifications())\n```\n\nWebSockets in FastAPI enable real-time features like chat applications, live updates, notifications, and collaborative tools with proper connection management and error handling.",
      "keywords": ["websockets", "real-time", "chat", "notifications", "bidirectional communication", "connection manager", "broadcasting"],
      "difficulty": "easy"
    },
    {
      "id": 12016,
      "tag": "fastapi",
      "question": "How do you implement advanced Pydantic features and custom validators in FastAPI?",
      "answer": "Pydantic provides powerful validation and serialization capabilities that can be extended with custom validators, complex field types, and advanced features for robust FastAPI applications.\n\n**Custom Validators**:\n```python\nfrom pydantic import BaseModel, validator, root_validator, Field\nfrom typing import Optional, List, Dict, Any\nimport re\nfrom datetime import datetime, date\nfrom decimal import Decimal\n\nclass UserModel(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n    email: str\n    age: int = Field(..., gt=0, le=120)\n    password: str\n    confirm_password: str\n    phone: Optional[str] = None\n    birth_date: Optional[date] = None\n    \n    @validator('username')\n    def username_alphanumeric(cls, v):\n        if not re.match(r'^[a-zA-Z0-9_]+$', v):\n            raise ValueError('Username must contain only letters, numbers, and underscores')\n        return v.lower()\n    \n    @validator('email')\n    def email_format(cls, v):\n        email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n        if not re.match(email_regex, v):\n            raise ValueError('Invalid email format')\n        return v.lower()\n    \n    @validator('phone')\n    def phone_format(cls, v):\n        if v is None:\n            return v\n        \n        # Remove all non-digits\n        digits = re.sub(r'\\D', '', v)\n        \n        if len(digits) not in [10, 11]:\n            raise ValueError('Phone number must be 10 or 11 digits')\n        \n        # Format as (XXX) XXX-XXXX\n        if len(digits) == 10:\n            return f'({digits[:3]}) {digits[3:6]}-{digits[6:]}'\n        else:\n            return f'+{digits[0]} ({digits[1:4]}) {digits[4:7]}-{digits[7:]}'\n    \n    @validator('birth_date')\n    def birth_date_not_future(cls, v):\n        if v and v > date.today():\n            raise ValueError('Birth date cannot be in the future')\n        return v\n    \n    @root_validator\n    def validate_passwords_match(cls, values):\n        password = values.get('password')\n        confirm_password = values.get('confirm_password')\n        \n        if password != confirm_password:\n            raise ValueError('Passwords do not match')\n        \n        # Password strength validation\n        if len(password) < 8:\n            raise ValueError('Password must be at least 8 characters')\n        \n        if not re.search(r'[A-Z]', password):\n            raise ValueError('Password must contain at least one uppercase letter')\n        \n        if not re.search(r'[a-z]', password):\n            raise ValueError('Password must contain at least one lowercase letter')\n        \n        if not re.search(r'\\d', password):\n            raise ValueError('Password must contain at least one digit')\n        \n        return values\n    \n    @root_validator\n    def validate_age_birth_date(cls, values):\n        age = values.get('age')\n        birth_date = values.get('birth_date')\n        \n        if age and birth_date:\n            calculated_age = (date.today() - birth_date).days // 365\n            if abs(calculated_age - age) > 1:\n                raise ValueError('Age and birth date do not match')\n        \n        return values\n```\n\n**Custom Field Types and Serializers**:\n```python\nfrom pydantic import BaseModel, Field, validator\nfrom typing import Union\nfrom decimal import Decimal, ROUND_HALF_UP\nfrom uuid import UUID, uuid4\n\nclass Money:\n    def __init__(self, amount: Union[str, int, float, Decimal], currency: str = \"USD\"):\n        self.amount = Decimal(str(amount)).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)\n        self.currency = currency.upper()\n    \n    def __str__(self):\n        return f\"{self.amount} {self.currency}\"\n    \n    def __repr__(self):\n        return f\"Money({self.amount}, '{self.currency}')\"\n    \n    @classmethod\n    def __get_validators__(cls):\n        yield cls.validate\n    \n    @classmethod\n    def validate(cls, v):\n        if isinstance(v, cls):\n            return v\n        \n        if isinstance(v, dict):\n            return cls(v.get('amount'), v.get('currency', 'USD'))\n        \n        if isinstance(v, str):\n            # Parse \"$10.50\" or \"10.50 USD\"\n            if v.startswith('$'):\n                return cls(v[1:], 'USD')\n            \n            parts = v.split()\n            if len(parts) == 2:\n                return cls(parts[0], parts[1])\n            else:\n                return cls(v, 'USD')\n        \n        return cls(v)\n    \n    @classmethod\n    def __modify_schema__(cls, field_schema):\n        field_schema.update(\n            examples=[\"10.50\", \"$25.99\", \"100.00 EUR\", {\"amount\": \"15.75\", \"currency\": \"USD\"}],\n            description=\"Monetary value with currency\"\n        )\n\nclass ProductModel(BaseModel):\n    id: UUID = Field(default_factory=uuid4)\n    name: str = Field(..., min_length=1, max_length=100)\n    price: Money\n    discount_price: Optional[Money] = None\n    category: str\n    tags: List[str] = []\n    metadata: Dict[str, Any] = {}\n    \n    @validator('discount_price')\n    def discount_less_than_price(cls, v, values):\n        if v and 'price' in values:\n            if v.amount >= values['price'].amount:\n                raise ValueError('Discount price must be less than regular price')\n        return v\n    \n    @validator('tags')\n    def tags_unique(cls, v):\n        if len(v) != len(set(v)):\n            raise ValueError('Tags must be unique')\n        return [tag.lower().strip() for tag in v]\n    \n    class Config:\n        json_encoders = {\n            Money: lambda v: {\"amount\": str(v.amount), \"currency\": v.currency},\n            UUID: str,\n        }\n        schema_extra = {\n            \"example\": {\n                \"name\": \"Premium Widget\",\n                \"price\": \"29.99\",\n                \"discount_price\": \"24.99\",\n                \"category\": \"electronics\",\n                \"tags\": [\"premium\", \"widget\", \"electronic\"]\n            }\n        }\n```\n\n**Advanced Validation with Dependencies**:\n```python\nfrom typing import ForwardRef\nfrom pydantic import BaseModel, validator\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    state: str = Field(..., min_length=2, max_length=2)\n    zip_code: str\n    country: str = \"US\"\n    \n    @validator('zip_code')\n    def validate_zip_code(cls, v, values):\n        country = values.get('country', 'US')\n        \n        if country == 'US':\n            if not re.match(r'^\\d{5}(-\\d{4})?$', v):\n                raise ValueError('Invalid US ZIP code format')\n        elif country == 'CA':\n            if not re.match(r'^[A-Z]\\d[A-Z] \\d[A-Z]\\d$', v.upper()):\n                raise ValueError('Invalid Canadian postal code format')\n        \n        return v.upper() if country == 'CA' else v\n\nclass Company(BaseModel):\n    name: str\n    address: Address\n    employees: List['Employee'] = []\n    \n    @validator('employees')\n    def validate_employees(cls, v):\n        if len(v) > 1000:\n            raise ValueError('Company cannot have more than 1000 employees in this model')\n        return v\n\nclass Employee(BaseModel):\n    name: str\n    position: str\n    salary: Money\n    company: Optional['Company'] = None\n    manager: Optional['Employee'] = None\n    \n    @validator('manager')\n    def manager_not_self(cls, v, values):\n        if v and 'name' in values and v.name == values['name']:\n            raise ValueError('Employee cannot be their own manager')\n        return v\n\n# Update forward references\nCompany.model_rebuild()\nEmployee.model_rebuild()\n```\n\n**Custom Validation with External Data**:\n```python\nimport httpx\nfrom pydantic import BaseModel, validator\nfrom functools import lru_cache\n\n@lru_cache(maxsize=100)\ndef validate_country_code(code: str) -> bool:\n    # Cache country code validation\n    valid_codes = ['US', 'CA', 'UK', 'DE', 'FR', 'JP', 'AU']  # Simplified\n    return code.upper() in valid_codes\n\nclass ShippingAddress(BaseModel):\n    recipient: str\n    street: str\n    city: str\n    country_code: str\n    postal_code: str\n    \n    @validator('country_code')\n    def validate_country(cls, v):\n        if not validate_country_code(v):\n            raise ValueError(f'Unsupported country code: {v}')\n        return v.upper()\n    \n    @validator('postal_code')\n    def validate_postal_code_format(cls, v, values):\n        country_code = values.get('country_code', '').upper()\n        \n        patterns = {\n            'US': r'^\\d{5}(-\\d{4})?$',\n            'CA': r'^[A-Z]\\d[A-Z] \\d[A-Z]\\d$',\n            'UK': r'^[A-Z]{1,2}\\d[A-Z\\d]? \\d[A-Z]{2}$',\n            'DE': r'^\\d{5}$',\n        }\n        \n        if country_code in patterns:\n            if not re.match(patterns[country_code], v.upper()):\n                raise ValueError(f'Invalid postal code format for {country_code}')\n        \n        return v.upper()\n```\n\n**Using Advanced Models in FastAPI**:\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import ValidationError\n\napp = FastAPI()\n\n@app.post(\"/users/\", response_model=UserModel)\nasync def create_user(user: UserModel):\n    # The validation happens automatically\n    # user.password and user.confirm_password are already validated\n    \n    # Hash password before saving (remove confirm_password)\n    user_dict = user.dict(exclude={'confirm_password'})\n    user_dict['password'] = hash_password(user.password)\n    \n    return user_dict\n\n@app.post(\"/products/\", response_model=ProductModel)\nasync def create_product(product: ProductModel):\n    # Custom Money type is automatically validated and serialized\n    return product\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request, exc):\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"detail\": [\n                {\n                    \"loc\": error[\"loc\"],\n                    \"msg\": error[\"msg\"],\n                    \"type\": error[\"type\"]\n                }\n                for error in exc.errors()\n            ]\n        }\n    )\n```\n\nThese advanced Pydantic features provide robust data validation, custom field types, and complex business logic validation while maintaining clean, readable code and excellent error messages.",
      "keywords": ["pydantic", "custom validators", "field types", "validation", "serialization", "root validator", "custom types", "complex validation"],
      "difficulty": "medium"
    },
    {
      "id": 12017,
      "tag": "fastapi",
      "question": "How do you deploy FastAPI applications using Docker and implement proper containerization strategies?",
      "answer": "Deploying FastAPI applications with Docker requires careful consideration of performance, security, and scalability. Here's a comprehensive approach to containerization and deployment.\n\n**Multi-stage Dockerfile**:\n```dockerfile\n# Build stage\nFROM python:3.11-slim as builder\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PIP_NO_CACHE_DIR=1 \\\n    PIP_DISABLE_PIP_VERSION_CHECK=1\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    build-essential \\\n    libpq-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Create and activate virtual environment\nRUN python -m venv /opt/venv\nENV PATH=\"/opt/venv/bin:$PATH\"\n\n# Copy requirements and install Python dependencies\nCOPY requirements.txt .\nRUN pip install --upgrade pip && \\\n    pip install -r requirements.txt\n\n# Production stage\nFROM python:3.11-slim as production\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    PATH=\"/opt/venv/bin:$PATH\"\n\n# Install runtime dependencies\nRUN apt-get update && apt-get install -y \\\n    libpq5 \\\n    && rm -rf /var/lib/apt/lists/* \\\n    && apt-get clean\n\n# Create non-root user\nRUN groupadd -r appuser && useradd -r -g appuser appuser\n\n# Copy virtual environment from builder stage\nCOPY --from=builder /opt/venv /opt/venv\n\n# Set working directory\nWORKDIR /app\n\n# Copy application code\nCOPY --chown=appuser:appuser . .\n\n# Switch to non-root user\nUSER appuser\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \\\n    CMD python -c \"import requests; requests.get('http://localhost:8000/health', timeout=10)\"\n\n# Expose port\nEXPOSE 8000\n\n# Run the application\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\", \"--workers\", \"4\"]\n```\n\n**Production-ready Dockerfile with Gunicorn**:\n```dockerfile\nFROM python:3.11-slim\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    curl \\\n    libpq-dev \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Create non-root user\nRUN groupadd -r fastapi && useradd -r -g fastapi fastapi\n\n# Set working directory\nWORKDIR /app\n\n# Copy requirements and install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY --chown=fastapi:fastapi . .\n\n# Create necessary directories\nRUN mkdir -p logs uploads && chown -R fastapi:fastapi logs uploads\n\nUSER fastapi\n\n# Gunicorn configuration\nEXPOSE 8000\n\n# Use gunicorn with uvicorn workers for production\nCMD [\"gunicorn\", \"main:app\", \\\n     \"--worker-class\", \"uvicorn.workers.UvicornWorker\", \\\n     \"--workers\", \"4\", \\\n     \"--bind\", \"0.0.0.0:8000\", \\\n     \"--access-logfile\", \"logs/access.log\", \\\n     \"--error-logfile\", \"logs/error.log\", \\\n     \"--log-level\", \"info\"]\n```\n\n**Docker Compose for Development**:\n```yaml\nversion: '3.8'\n\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile.dev\n    ports:\n      - \"8000:8000\"\n    environment:\n      - ENVIRONMENT=development\n      - DEBUG=true\n      - DATABASE_URL=postgresql://user:password@db:5432/fastapi_dev\n      - REDIS_URL=redis://redis:6379/0\n    volumes:\n      - .:/app\n      - ./logs:/app/logs\n    depends_on:\n      - db\n      - redis\n    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload\n  \n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: fastapi_dev\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: password\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init.sql:/docker-entrypoint-initdb.d/init.sql\n    ports:\n      - \"5432:5432\"\n  \n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n  \n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n    volumes:\n      - ./nginx.conf:/etc/nginx/nginx.conf\n    depends_on:\n      - api\n\nvolumes:\n  postgres_data:\n  redis_data:\n```\n\n**Production Docker Compose**:\n```yaml\nversion: '3.8'\n\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    environment:\n      - ENVIRONMENT=production\n      - DATABASE_URL=postgresql://user:${DB_PASSWORD}@db:5432/fastapi_prod\n      - SECRET_KEY=${SECRET_KEY}\n      - REDIS_URL=redis://redis:6379/0\n    volumes:\n      - ./logs:/app/logs\n      - ./uploads:/app/uploads\n    depends_on:\n      - db\n      - redis\n    restart: unless-stopped\n    deploy:\n      replicas: 3\n      resources:\n        limits:\n          memory: 512M\n          cpus: '0.5'\n        reservations:\n          memory: 256M\n          cpus: '0.25'\n  \n  db:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_DB: fastapi_prod\n      POSTGRES_USER: user\n      POSTGRES_PASSWORD: ${DB_PASSWORD}\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    restart: unless-stopped\n    deploy:\n      resources:\n        limits:\n          memory: 1G\n          cpus: '1'\n  \n  redis:\n    image: redis:7-alpine\n    volumes:\n      - redis_data:/data\n    restart: unless-stopped\n  \n  nginx:\n    image: nginx:alpine\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - ./nginx.prod.conf:/etc/nginx/nginx.conf\n      - ./ssl:/etc/nginx/ssl\n    depends_on:\n      - api\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  redis_data:\n\nnetworks:\n  default:\n    driver: bridge\n```\n\n**Nginx Configuration**:\n```nginx\nevents {\n    worker_connections 1024;\n}\n\nhttp {\n    upstream fastapi {\n        server api:8000;\n    }\n    \n    server {\n        listen 80;\n        server_name localhost;\n        \n        client_max_body_size 50M;\n        \n        # Security headers\n        add_header X-Frame-Options DENY;\n        add_header X-Content-Type-Options nosniff;\n        add_header X-XSS-Protection \"1; mode=block\";\n        add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\";\n        \n        # Gzip compression\n        gzip on;\n        gzip_vary on;\n        gzip_min_length 1024;\n        gzip_types text/plain text/css application/json application/javascript text/xml application/xml;\n        \n        # API routes\n        location /api/ {\n            proxy_pass http://fastapi;\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_set_header X-Forwarded-Proto $scheme;\n            \n            # Timeout settings\n            proxy_connect_timeout 60s;\n            proxy_send_timeout 60s;\n            proxy_read_timeout 60s;\n        }\n        \n        # WebSocket support\n        location /ws/ {\n            proxy_pass http://fastapi;\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n        }\n        \n        # Static files\n        location /static/ {\n            alias /app/static/;\n            expires 1y;\n            add_header Cache-Control \"public, immutable\";\n        }\n        \n        # Health check\n        location /health {\n            proxy_pass http://fastapi/health;\n            access_log off;\n        }\n    }\n}\n```\n\n**Kubernetes Deployment**:\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: fastapi-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: fastapi-app\n  template:\n    metadata:\n      labels:\n        app: fastapi-app\n    spec:\n      containers:\n      - name: fastapi\n        image: myregistry/fastapi-app:latest\n        ports:\n        - containerPort: 8000\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: database-url\n        - name: SECRET_KEY\n          valueFrom:\n            secretKeyRef:\n              name: app-secrets\n              key: secret-key\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"250m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 8000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: fastapi-service\nspec:\n  selector:\n    app: fastapi-app\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: LoadBalancer\n```\n\n**CI/CD Pipeline (GitHub Actions)**:\n```yaml\nname: Deploy FastAPI\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Python\n      uses: actions/setup-python@v4\n      with:\n        python-version: '3.11'\n    - name: Install dependencies\n      run: |\n        pip install -r requirements.txt\n        pip install pytest\n    - name: Run tests\n      run: pytest\n  \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build and push Docker image\n      uses: docker/build-push-action@v4\n      with:\n        push: true\n        tags: myregistry/fastapi-app:latest\n    - name: Deploy to production\n      run: |\n        docker-compose -f docker-compose.prod.yml up -d\n```\n\nThis containerization strategy provides scalability, security, and maintainability for production FastAPI deployments with proper monitoring, logging, and resource management.",
      "keywords": ["docker", "containerization", "deployment", "gunicorn", "nginx", "kubernetes", "docker compose", "production", "ci/cd"],
      "difficulty": "medium"
    },
    {
      "id": 12018,
      "tag": "fastapi",
      "question": "How do you optimize FastAPI performance and implement advanced async patterns for high-throughput applications?",
      "answer": "Optimizing FastAPI for high-throughput applications requires understanding async patterns, connection pooling, caching strategies, and performance monitoring techniques.\n\n**Async Database Operations with Connection Pooling**:\n```python\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker\nfrom sqlalchemy.pool import NullPool, QueuePool\nfrom contextlib import asynccontextmanager\nimport asyncio\nfrom typing import AsyncGenerator\n\nclass DatabaseManager:\n    def __init__(self, database_url: str):\n        # Optimized engine configuration\n        self.engine = create_async_engine(\n            database_url,\n            poolclass=QueuePool,\n            pool_size=20,  # Number of persistent connections\n            max_overflow=30,  # Additional connections when pool is full\n            pool_pre_ping=True,  # Validate connections before use\n            pool_recycle=3600,  # Recycle connections every hour\n            echo=False,  # Disable SQL echo in production\n        )\n        self.async_session = async_sessionmaker(\n            self.engine, \n            class_=AsyncSession, \n            expire_on_commit=False\n        )\n    \n    @asynccontextmanager\n    async def get_session(self) -> AsyncGenerator[AsyncSession, None]:\n        async with self.async_session() as session:\n            try:\n                yield session\n                await session.commit()\n            except Exception:\n                await session.rollback()\n                raise\n            finally:\n                await session.close()\n    \n    async def close(self):\n        await self.engine.dispose()\n\ndb_manager = DatabaseManager(DATABASE_URL)\n\n# Dependency for FastAPI\nasync def get_async_db():\n    async with db_manager.get_session() as session:\n        yield session\n\n# Optimized CRUD operations\nclass UserService:\n    @staticmethod\n    async def get_users_batch(db: AsyncSession, user_ids: List[int]) -> List[User]:\n        \"\"\"Fetch multiple users in a single query\"\"\"\n        result = await db.execute(\n            select(User).where(User.id.in_(user_ids))\n        )\n        return result.scalars().all()\n    \n    @staticmethod\n    async def create_users_bulk(db: AsyncSession, users_data: List[dict]) -> List[User]:\n        \"\"\"Bulk insert for better performance\"\"\"\n        users = [User(**user_data) for user_data in users_data]\n        db.add_all(users)\n        await db.flush()  # Get IDs without committing\n        return users\n```\n\n**Advanced Caching Strategies**:\n```python\nimport aioredis\nfrom functools import wraps\nimport json\nimport pickle\nfrom typing import Optional, Any, Callable\nfrom datetime import timedelta\n\nclass CacheManager:\n    def __init__(self, redis_url: str):\n        self.redis_pool = None\n    \n    async def init_redis(self):\n        self.redis_pool = aioredis.ConnectionPool.from_url(\n            redis_url,\n            max_connections=20,\n            retry_on_timeout=True,\n            health_check_interval=30\n        )\n        self.redis = aioredis.Redis(connection_pool=self.redis_pool)\n    \n    async def get(self, key: str, deserialize: bool = True) -> Optional[Any]:\n        try:\n            value = await self.redis.get(key)\n            if value is None:\n                return None\n            \n            if deserialize:\n                try:\n                    return json.loads(value)\n                except json.JSONDecodeError:\n                    return pickle.loads(value)\n            return value\n        except Exception as e:\n            logger.error(f\"Cache get error for key {key}: {e}\")\n            return None\n    \n    async def set(self, key: str, value: Any, expire: int = 3600, serialize: bool = True):\n        try:\n            if serialize:\n                try:\n                    serialized_value = json.dumps(value, default=str)\n                except (TypeError, ValueError):\n                    serialized_value = pickle.dumps(value)\n            else:\n                serialized_value = value\n            \n            await self.redis.set(key, serialized_value, ex=expire)\n        except Exception as e:\n            logger.error(f\"Cache set error for key {key}: {e}\")\n    \n    async def delete(self, key: str):\n        try:\n            await self.redis.delete(key)\n        except Exception as e:\n            logger.error(f\"Cache delete error for key {key}: {e}\")\n    \n    async def close(self):\n        await self.redis_pool.disconnect()\n\ncache_manager = CacheManager(REDIS_URL)\n\n# Caching decorator\ndef cache_result(expire: int = 3600, key_prefix: str = \"\"):\n    def decorator(func: Callable):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            # Generate cache key\n            cache_key = f\"{key_prefix}:{func.__name__}:\" + \":\".join(\n                str(arg) for arg in args\n            ) + \":\".join(f\"{k}={v}\" for k, v in sorted(kwargs.items()))\n            \n            # Try to get from cache\n            cached_result = await cache_manager.get(cache_key)\n            if cached_result is not None:\n                return cached_result\n            \n            # Execute function and cache result\n            result = await func(*args, **kwargs)\n            await cache_manager.set(cache_key, result, expire)\n            return result\n        return wrapper\n    return decorator\n\n# Usage in services\nclass UserService:\n    @cache_result(expire=1800, key_prefix=\"user\")\n    async def get_user_profile(self, user_id: int, db: AsyncSession) -> dict:\n        result = await db.execute(\n            select(User).options(\n                selectinload(User.posts),\n                selectinload(User.followers)\n            ).where(User.id == user_id)\n        )\n        user = result.scalar_one_or_none()\n        if not user:\n            return None\n        \n        return {\n            \"id\": user.id,\n            \"username\": user.username,\n            \"posts_count\": len(user.posts),\n            \"followers_count\": len(user.followers)\n        }\n```\n\n**Async Task Queue and Background Processing**:\n```python\nimport asyncio\nfrom asyncio import Queue\nfrom typing import Callable, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\nimport logging\n\nclass TaskPriority(Enum):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    CRITICAL = 4\n\n@dataclass\nclass Task:\n    id: str\n    func: Callable\n    args: tuple\n    kwargs: dict\n    priority: TaskPriority = TaskPriority.MEDIUM\n    retries: int = 3\n    \n    def __lt__(self, other):\n        return self.priority.value > other.priority.value\n\nclass AsyncTaskQueue:\n    def __init__(self, max_workers: int = 10):\n        self.queue = asyncio.PriorityQueue()\n        self.workers = []\n        self.max_workers = max_workers\n        self.running = False\n        self.stats = {\n            \"processed\": 0,\n            \"failed\": 0,\n            \"retries\": 0\n        }\n    \n    async def start(self):\n        self.running = True\n        self.workers = [\n            asyncio.create_task(self._worker(f\"worker-{i}\"))\n            for i in range(self.max_workers)\n        ]\n    \n    async def stop(self):\n        self.running = False\n        for worker in self.workers:\n            worker.cancel()\n        await asyncio.gather(*self.workers, return_exceptions=True)\n    \n    async def add_task(self, task: Task):\n        await self.queue.put(task)\n    \n    async def _worker(self, name: str):\n        while self.running:\n            try:\n                task = await asyncio.wait_for(self.queue.get(), timeout=1.0)\n                await self._execute_task(task)\n                self.queue.task_done()\n            except asyncio.TimeoutError:\n                continue\n            except Exception as e:\n                logger.error(f\"Worker {name} error: {e}\")\n    \n    async def _execute_task(self, task: Task):\n        for attempt in range(task.retries + 1):\n            try:\n                if asyncio.iscoroutinefunction(task.func):\n                    result = await task.func(*task.args, **task.kwargs)\n                else:\n                    result = task.func(*task.args, **task.kwargs)\n                \n                self.stats[\"processed\"] += 1\n                logger.info(f\"Task {task.id} completed successfully\")\n                return result\n            \n            except Exception as e:\n                if attempt < task.retries:\n                    self.stats[\"retries\"] += 1\n                    logger.warning(f\"Task {task.id} failed (attempt {attempt + 1}): {e}\")\n                    await asyncio.sleep(2 ** attempt)  # Exponential backoff\n                else:\n                    self.stats[\"failed\"] += 1\n                    logger.error(f\"Task {task.id} failed permanently: {e}\")\n                    break\n\n# Global task queue\ntask_queue = AsyncTaskQueue(max_workers=20)\n\n# Background task functions\nasync def send_email_async(to: str, subject: str, body: str):\n    # Simulate email sending\n    await asyncio.sleep(0.1)\n    logger.info(f\"Email sent to {to}: {subject}\")\n\nasync def process_image_async(image_path: str, user_id: int):\n    # Simulate image processing\n    await asyncio.sleep(0.5)\n    logger.info(f\"Image processed: {image_path} for user {user_id}\")\n\n# FastAPI integration\n@app.on_event(\"startup\")\nasync def startup_event():\n    await cache_manager.init_redis()\n    await task_queue.start()\n\n@app.on_event(\"shutdown\")\nasync def shutdown_event():\n    await task_queue.stop()\n    await cache_manager.close()\n    await db_manager.close()\n```\n\n**Performance Monitoring and Metrics**:\n```python\nimport time\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST\nfrom starlette.responses import Response\n\n# Prometheus metrics\nREQUEST_COUNT = Counter(\n    'fastapi_requests_total',\n    'Total number of requests',\n    ['method', 'endpoint', 'status']\n)\n\nREQUEST_DURATION = Histogram(\n    'fastapi_request_duration_seconds',\n    'Request duration in seconds',\n    ['method', 'endpoint']\n)\n\nACTIVE_REQUESTS = Counter(\n    'fastapi_active_requests',\n    'Number of active requests'\n)\n\nclass MetricsMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request, call_next):\n        start_time = time.time()\n        \n        # Get endpoint for metrics\n        endpoint = request.url.path\n        method = request.method\n        \n        # Increment active requests\n        ACTIVE_REQUESTS.inc()\n        \n        try:\n            response = await call_next(request)\n            \n            # Record metrics\n            duration = time.time() - start_time\n            REQUEST_DURATION.labels(method=method, endpoint=endpoint).observe(duration)\n            REQUEST_COUNT.labels(\n                method=method, \n                endpoint=endpoint, \n                status=response.status_code\n            ).inc()\n            \n            # Add performance headers\n            response.headers[\"X-Response-Time\"] = str(duration)\n            \n            return response\n        \n        finally:\n            ACTIVE_REQUESTS.dec()\n\napp.add_middleware(MetricsMiddleware)\n\n@app.get(\"/metrics\")\nasync def get_metrics():\n    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)\n```\n\n**Optimized FastAPI Configuration**:\n```python\nfrom fastapi import FastAPI\nfrom uvicorn.workers import UvicornWorker\n\n# Custom Uvicorn worker for better performance\nclass CustomUvicornWorker(UvicornWorker):\n    CONFIG_KWARGS = {\n        \"loop\": \"uvloop\",  # Use uvloop for better performance on Linux\n        \"http\": \"httptools\",  # Use httptools for better HTTP parsing\n        \"lifespan\": \"on\",\n        \"access_log\": False,  # Disable access logs for better performance\n    }\n\n# FastAPI app configuration\napp = FastAPI(\n    title=\"High Performance API\",\n    docs_url=None if os.getenv(\"ENVIRONMENT\") == \"production\" else \"/docs\",\n    redoc_url=None if os.getenv(\"ENVIRONMENT\") == \"production\" else \"/redoc\",\n)\n\n# Optimized endpoint\n@app.get(\"/users/{user_id}\", response_model=UserResponse)\nasync def get_user(\n    user_id: int,\n    db: AsyncSession = Depends(get_async_db),\n    background_tasks: BackgroundTasks = None\n):\n    # Use cached service method\n    user_data = await UserService().get_user_profile(user_id, db)\n    \n    if not user_data:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    # Add background task for analytics\n    if background_tasks:\n        background_tasks.add_task(\n            track_user_view, user_id=user_id, timestamp=time.time()\n        )\n    \n    return user_data\n\n# Batch endpoint for better throughput\n@app.post(\"/users/batch\", response_model=List[UserResponse])\nasync def get_users_batch(\n    user_ids: List[int] = Body(..., max_items=100),\n    db: AsyncSession = Depends(get_async_db)\n):\n    users = await UserService.get_users_batch(db, user_ids)\n    return users\n```\n\nThese optimizations provide significant performance improvements through async database operations, intelligent caching, background task processing, and comprehensive monitoring for high-throughput FastAPI applications.",
      "keywords": ["performance optimization", "async patterns", "connection pooling", "caching", "task queue", "monitoring", "metrics", "high throughput", "database optimization"],
      "difficulty": "hard"
    },
    {
      "id": 12019,
      "tag": "fastapi",
      "question": "How do you implement advanced FastAPI patterns including custom middleware, plugin architecture, and API versioning strategies?",
      "answer": "Advanced FastAPI applications require sophisticated architectural patterns for scalability, maintainability, and extensibility. Here's how to implement enterprise-level patterns.\n\n**Custom Middleware Architecture**:\n```python\nfrom starlette.middleware.base import BaseHTTPMiddleware\nfrom starlette.requests import Request\nfrom starlette.responses import Response, JSONResponse\nfrom typing import Callable, Dict, Any, Optional\nimport uuid\nimport time\nimport logging\nfrom contextvars import ContextVar\n\n# Context variables for request tracking\nrequest_id_var: ContextVar[str] = ContextVar('request_id')\nuser_id_var: ContextVar[Optional[int]] = ContextVar('user_id', default=None)\n\nclass RequestTrackingMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        # Generate unique request ID\n        request_id = str(uuid.uuid4())\n        request_id_var.set(request_id)\n        \n        # Add request ID to request state\n        request.state.request_id = request_id\n        \n        # Track request start time\n        start_time = time.time()\n        \n        # Add correlation ID header if present\n        correlation_id = request.headers.get('X-Correlation-ID', request_id)\n        \n        try:\n            response = await call_next(request)\n            \n            # Add tracking headers to response\n            response.headers['X-Request-ID'] = request_id\n            response.headers['X-Correlation-ID'] = correlation_id\n            response.headers['X-Response-Time'] = str(time.time() - start_time)\n            \n            return response\n        \n        except Exception as e:\n            # Log error with request context\n            logging.error(f\"Request {request_id} failed: {str(e)}\", \n                         extra={'request_id': request_id, 'correlation_id': correlation_id})\n            raise\n\nclass RateLimitingMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app, calls: int = 100, period: int = 60):\n        super().__init__(app)\n        self.calls = calls\n        self.period = period\n        self.clients: Dict[str, Dict[str, Any]] = {}\n    \n    def _get_client_key(self, request: Request) -> str:\n        # Use user ID if authenticated, otherwise IP\n        user_id = getattr(request.state, 'user_id', None)\n        if user_id:\n            return f\"user:{user_id}\"\n        return f\"ip:{request.client.host}\"\n    \n    def _is_rate_limited(self, client_key: str) -> tuple[bool, Dict[str, Any]]:\n        now = time.time()\n        \n        if client_key not in self.clients:\n            self.clients[client_key] = {\n                'calls': 1,\n                'reset_time': now + self.period,\n                'window_start': now\n            }\n            return False, self.clients[client_key]\n        \n        client_data = self.clients[client_key]\n        \n        # Reset window if period has passed\n        if now >= client_data['reset_time']:\n            client_data['calls'] = 1\n            client_data['reset_time'] = now + self.period\n            client_data['window_start'] = now\n            return False, client_data\n        \n        # Check if limit exceeded\n        if client_data['calls'] >= self.calls:\n            return True, client_data\n        \n        client_data['calls'] += 1\n        return False, client_data\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        client_key = self._get_client_key(request)\n        is_limited, client_data = self._is_rate_limited(client_key)\n        \n        if is_limited:\n            return JSONResponse(\n                status_code=429,\n                content={\n                    \"error\": \"Rate limit exceeded\",\n                    \"retry_after\": int(client_data['reset_time'] - time.time())\n                },\n                headers={\n                    \"Retry-After\": str(int(client_data['reset_time'] - time.time())),\n                    \"X-RateLimit-Limit\": str(self.calls),\n                    \"X-RateLimit-Remaining\": \"0\",\n                    \"X-RateLimit-Reset\": str(int(client_data['reset_time']))\n                }\n            )\n        \n        response = await call_next(request)\n        \n        # Add rate limit headers\n        response.headers[\"X-RateLimit-Limit\"] = str(self.calls)\n        response.headers[\"X-RateLimit-Remaining\"] = str(self.calls - client_data['calls'])\n        response.headers[\"X-RateLimit-Reset\"] = str(int(client_data['reset_time']))\n        \n        return response\n\nclass SecurityMiddleware(BaseHTTPMiddleware):\n    def __init__(self, app, allowed_hosts: Optional[list] = None):\n        super().__init__(app)\n        self.allowed_hosts = allowed_hosts or []\n    \n    async def dispatch(self, request: Request, call_next: Callable) -> Response:\n        # Host validation\n        if self.allowed_hosts and request.headers.get(\"host\") not in self.allowed_hosts:\n            return JSONResponse(\n                status_code=400,\n                content={\"error\": \"Invalid host header\"}\n            )\n        \n        # Security headers\n        response = await call_next(request)\n        \n        security_headers = {\n            \"X-Content-Type-Options\": \"nosniff\",\n            \"X-Frame-Options\": \"DENY\",\n            \"X-XSS-Protection\": \"1; mode=block\",\n            \"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains\",\n            \"Content-Security-Policy\": \"default-src 'self'\",\n            \"Referrer-Policy\": \"strict-origin-when-cross-origin\"\n        }\n        \n        for header, value in security_headers.items():\n            response.headers[header] = value\n        \n        return response\n```\n\n**Plugin Architecture System**:\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Any, Type\nfrom fastapi import FastAPI, APIRouter\nfrom pydantic import BaseModel\nimport importlib\nimport inspect\n\nclass PluginInterface(ABC):\n    \"\"\"Base interface for all plugins\"\"\"\n    \n    @property\n    @abstractmethod\n    def name(self) -> str:\n        pass\n    \n    @property\n    @abstractmethod\n    def version(self) -> str:\n        pass\n    \n    @abstractmethod\n    async def initialize(self, app: FastAPI) -> None:\n        \"\"\"Initialize the plugin\"\"\"\n        pass\n    \n    @abstractmethod\n    async def configure(self, config: Dict[str, Any]) -> None:\n        \"\"\"Configure the plugin with settings\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_routes(self) -> List[APIRouter]:\n        \"\"\"Return routes to be added to the app\"\"\"\n        return []\n    \n    async def cleanup(self) -> None:\n        \"\"\"Cleanup resources when shutting down\"\"\"\n        pass\n\nclass PluginConfig(BaseModel):\n    enabled: bool = True\n    config: Dict[str, Any] = {}\n    dependencies: List[str] = []\n    load_order: int = 100\n\nclass PluginManager:\n    def __init__(self):\n        self.plugins: Dict[str, PluginInterface] = {}\n        self.plugin_configs: Dict[str, PluginConfig] = {}\n        self.load_order: List[str] = []\n    \n    def register_plugin(self, plugin_class: Type[PluginInterface], config: PluginConfig):\n        \"\"\"Register a plugin class with configuration\"\"\"\n        plugin_instance = plugin_class()\n        plugin_name = plugin_instance.name\n        \n        self.plugins[plugin_name] = plugin_instance\n        self.plugin_configs[plugin_name] = config\n    \n    def discover_plugins(self, plugin_dir: str = \"plugins\"):\n        \"\"\"Auto-discover plugins in a directory\"\"\"\n        try:\n            plugin_module = importlib.import_module(plugin_dir)\n            \n            for name, obj in inspect.getmembers(plugin_module):\n                if (inspect.isclass(obj) and \n                    issubclass(obj, PluginInterface) and \n                    obj != PluginInterface):\n                    \n                    config = PluginConfig()  # Default config\n                    self.register_plugin(obj, config)\n        \n        except ImportError:\n            pass\n    \n    def _resolve_dependencies(self) -> List[str]:\n        \"\"\"Resolve plugin load order based on dependencies\"\"\"\n        resolved = []\n        remaining = list(self.plugins.keys())\n        \n        while remaining:\n            progress = False\n            \n            for plugin_name in remaining[:]:\n                config = self.plugin_configs[plugin_name]\n                \n                # Check if all dependencies are resolved\n                if all(dep in resolved for dep in config.dependencies):\n                    resolved.append(plugin_name)\n                    remaining.remove(plugin_name)\n                    progress = True\n            \n            if not progress:\n                raise ValueError(f\"Circular dependency detected in plugins: {remaining}\")\n        \n        # Sort by load order within dependency constraints\n        resolved.sort(key=lambda x: self.plugin_configs[x].load_order)\n        return resolved\n    \n    async def load_plugins(self, app: FastAPI):\n        \"\"\"Load all registered plugins in dependency order\"\"\"\n        self.load_order = self._resolve_dependencies()\n        \n        for plugin_name in self.load_order:\n            if not self.plugin_configs[plugin_name].enabled:\n                continue\n            \n            plugin = self.plugins[plugin_name]\n            config = self.plugin_configs[plugin_name].config\n            \n            # Initialize and configure plugin\n            await plugin.initialize(app)\n            await plugin.configure(config)\n            \n            # Add plugin routes\n            for router in plugin.get_routes():\n                app.include_router(router, prefix=f\"/plugins/{plugin_name}\")\n            \n            logging.info(f\"Loaded plugin: {plugin_name} v{plugin.version}\")\n    \n    async def unload_plugins(self):\n        \"\"\"Cleanup all plugins\"\"\"\n        for plugin_name in reversed(self.load_order):\n            plugin = self.plugins[plugin_name]\n            await plugin.cleanup()\n            logging.info(f\"Unloaded plugin: {plugin_name}\")\n\n# Example plugin implementation\nclass AuthenticationPlugin(PluginInterface):\n    @property\n    def name(self) -> str:\n        return \"authentication\"\n    \n    @property\n    def version(self) -> str:\n        return \"1.0.0\"\n    \n    async def initialize(self, app: FastAPI):\n        self.app = app\n        # Initialize authentication services\n    \n    async def configure(self, config: Dict[str, Any]):\n        self.jwt_secret = config.get(\"jwt_secret\", \"default-secret\")\n        self.token_expiry = config.get(\"token_expiry\", 3600)\n    \n    def get_routes(self) -> List[APIRouter]:\n        router = APIRouter()\n        \n        @router.post(\"/login\")\n        async def login(credentials: dict):\n            # Authentication logic\n            return {\"token\": \"jwt-token\", \"expires_in\": self.token_expiry}\n        \n        @router.post(\"/refresh\")\n        async def refresh_token(token: str):\n            # Token refresh logic\n            return {\"token\": \"new-jwt-token\"}\n        \n        return [router]\n```\n\n**API Versioning Strategy**:\n```python\nfrom fastapi import FastAPI, APIRouter, Header, Depends, HTTPException\nfrom typing import Optional, Dict, Any\nfrom enum import Enum\n\nclass APIVersion(str, Enum):\n    V1 = \"v1\"\n    V2 = \"v2\"\n    V3 = \"v3\"\n\nclass VersionedFastAPI:\n    def __init__(self, title: str = \"Versioned API\"):\n        self.apps: Dict[str, FastAPI] = {}\n        self.routers: Dict[str, Dict[str, APIRouter]] = {}\n        self.main_app = FastAPI(title=title)\n        \n        for version in APIVersion:\n            self.apps[version.value] = FastAPI(\n                title=f\"{title} {version.value.upper()}\",\n                version=version.value,\n                docs_url=f\"/{version.value}/docs\",\n                redoc_url=f\"/{version.value}/redoc\",\n                openapi_url=f\"/{version.value}/openapi.json\"\n            )\n            self.routers[version.value] = {}\n    \n    def add_router(self, router: APIRouter, version: APIVersion, prefix: str = \"\", tags: List[str] = None):\n        \"\"\"Add a router to a specific API version\"\"\"\n        self.apps[version.value].include_router(router, prefix=prefix, tags=tags)\n    \n    def create_versioned_app(self) -> FastAPI:\n        \"\"\"Create the main app with version routing\"\"\"\n        \n        # Mount versioned apps\n        for version, app in self.apps.items():\n            self.main_app.mount(f\"/{version}\", app)\n        \n        # Add version detection middleware\n        @self.main_app.middleware(\"http\")\n        async def version_middleware(request, call_next):\n            # Extract version from header or URL\n            api_version = request.headers.get(\"API-Version\")\n            \n            if not api_version:\n                # Try to extract from URL path\n                path_parts = request.url.path.strip(\"/\").split(\"/\")\n                if path_parts and path_parts[0] in [v.value for v in APIVersion]:\n                    api_version = path_parts[0]\n            \n            request.state.api_version = api_version\n            response = await call_next(request)\n            \n            if api_version:\n                response.headers[\"API-Version\"] = api_version\n            \n            return response\n        \n        # Add version info endpoint\n        @self.main_app.get(\"/versions\")\n        async def get_versions():\n            return {\n                \"supported_versions\": [v.value for v in APIVersion],\n                \"default_version\": APIVersion.V3.value,\n                \"deprecated_versions\": [APIVersion.V1.value]\n            }\n        \n        return self.main_app\n\n# Version-specific dependencies\ndef get_api_version(api_version: Optional[str] = Header(None, alias=\"API-Version\")) -> str:\n    if not api_version:\n        return APIVersion.V3.value  # Default to latest\n    \n    if api_version not in [v.value for v in APIVersion]:\n        raise HTTPException(status_code=400, detail=f\"Unsupported API version: {api_version}\")\n    \n    return api_version\n\n# Version-specific models\nclass UserV1(BaseModel):\n    id: int\n    name: str\n    email: str\n\nclass UserV2(BaseModel):\n    id: int\n    first_name: str\n    last_name: str\n    email: str\n    created_at: datetime\n\nclass UserV3(BaseModel):\n    id: UUID\n    first_name: str\n    last_name: str\n    email: str\n    profile: Optional[dict] = None\n    created_at: datetime\n    updated_at: datetime\n\n# Version-specific routers\nclass UserController:\n    @staticmethod\n    def create_v1_router() -> APIRouter:\n        router = APIRouter(prefix=\"/users\", tags=[\"Users V1\"])\n        \n        @router.get(\"/\", response_model=List[UserV1])\n        async def get_users_v1():\n            # V1 implementation\n            return []\n        \n        return router\n    \n    @staticmethod\n    def create_v2_router() -> APIRouter:\n        router = APIRouter(prefix=\"/users\", tags=[\"Users V2\"])\n        \n        @router.get(\"/\", response_model=List[UserV2])\n        async def get_users_v2():\n            # V2 implementation with separate first/last name\n            return []\n        \n        return router\n    \n    @staticmethod\n    def create_v3_router() -> APIRouter:\n        router = APIRouter(prefix=\"/users\", tags=[\"Users V3\"])\n        \n        @router.get(\"/\", response_model=List[UserV3])\n        async def get_users_v3():\n            # V3 implementation with UUID and profiles\n            return []\n        \n        return router\n\n# Application setup\ndef create_app() -> FastAPI:\n    versioned_api = VersionedFastAPI(\"Advanced API\")\n    \n    # Add version-specific routers\n    versioned_api.add_router(UserController.create_v1_router(), APIVersion.V1)\n    versioned_api.add_router(UserController.create_v2_router(), APIVersion.V2)\n    versioned_api.add_router(UserController.create_v3_router(), APIVersion.V3)\n    \n    app = versioned_api.create_versioned_app()\n    \n    # Add middleware\n    app.add_middleware(RequestTrackingMiddleware)\n    app.add_middleware(RateLimitingMiddleware, calls=1000, period=3600)\n    app.add_middleware(SecurityMiddleware, allowed_hosts=[\"api.example.com\"])\n    \n    # Initialize plugin manager\n    plugin_manager = PluginManager()\n    plugin_manager.discover_plugins()\n    \n    @app.on_event(\"startup\")\n    async def startup():\n        await plugin_manager.load_plugins(app)\n    \n    @app.on_event(\"shutdown\")\n    async def shutdown():\n        await plugin_manager.unload_plugins()\n    \n    return app\n\napp = create_app()\n```\n\nThese advanced patterns provide enterprise-level architecture with proper separation of concerns, extensibility through plugins, comprehensive middleware stack, and robust API versioning strategies for large-scale FastAPI applications.",
      "keywords": ["advanced patterns", "custom middleware", "plugin architecture", "api versioning", "enterprise architecture", "middleware stack", "extensibility", "scalability"],
      "difficulty": "hard"
    }
  ]
}