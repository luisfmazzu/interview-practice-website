{
  "technology": "apis",
  "questions": [
    {
      "id": 16000,
      "tag": "apis",
      "question": "What is REST and what are its key principles?",
      "answer": "REST (Representational State Transfer) is an architectural style for designing networked applications.\n\n**Key Principles:**\n1. **Stateless** - Each request contains all information needed\n2. **Client-Server** - Separation of concerns\n3. **Cacheable** - Responses should be cacheable when possible\n4. **Uniform Interface** - Consistent API design\n5. **Layered System** - Architecture can have multiple layers\n6. **Code on Demand** (optional) - Server can send executable code\n\n**Uniform Interface Constraints:**\n- Resource identification via URIs\n- Resource manipulation through representations\n- Self-descriptive messages\n- Hypermedia as the engine of application state (HATEOAS)\n\n**Benefits:**\n- Scalability\n- Simplicity\n- Platform independence\n- Stateless nature improves reliability",
      "keywords": ["REST", "stateless", "client-server", "cacheable", "uniform interface", "layered system", "HATEOAS", "scalability"],
      "difficulty": "medium"
    },
    {
      "id": 16001,
      "tag": "apis",
      "question": "Explain the difference between HTTP methods (GET, POST, PUT, DELETE, PATCH).",
      "answer": "HTTP methods define the type of operation to perform on a resource.\n\n**GET:**\n- Retrieve data from server\n- Safe and idempotent\n- Should not modify server state\n- Cacheable\n\n**POST:**\n- Create new resources\n- Not idempotent (multiple calls create multiple resources)\n- Request body contains data\n- Not cacheable\n\n**PUT:**\n- Create or completely replace a resource\n- Idempotent\n- Request body contains complete resource representation\n\n**DELETE:**\n- Remove a resource\n- Idempotent\n- May return 204 (No Content) or 200 (OK)\n\n**PATCH:**\n- Partial update of a resource\n- Not necessarily idempotent\n- Request body contains only changes\n\n**Example:**\n```\nGET /users/123      - Get user 123\nPOST /users         - Create new user\nPUT /users/123      - Replace user 123\nPATCH /users/123    - Update user 123 partially\nDELETE /users/123   - Delete user 123\n```",
      "keywords": ["HTTP methods", "GET", "POST", "PUT", "DELETE", "PATCH", "idempotent", "safe methods", "CRUD operations"],
      "difficulty": "easy"
    },
    {
      "id": 16002,
      "tag": "apis",
      "question": "What are HTTP status codes and explain the main categories?",
      "answer": "HTTP status codes indicate the result of an HTTP request.\n\n**1xx - Informational:**\n- 100 Continue\n- 101 Switching Protocols\n\n**2xx - Success:**\n- 200 OK - Request successful\n- 201 Created - Resource created\n- 204 No Content - Success but no content returned\n\n**3xx - Redirection:**\n- 301 Moved Permanently\n- 302 Found (temporary redirect)\n- 304 Not Modified (cached version is current)\n\n**4xx - Client Error:**\n- 400 Bad Request - Invalid request syntax\n- 401 Unauthorized - Authentication required\n- 403 Forbidden - Server understood but refuses\n- 404 Not Found - Resource doesn't exist\n- 409 Conflict - Request conflicts with current state\n- 422 Unprocessable Entity - Validation errors\n\n**5xx - Server Error:**\n- 500 Internal Server Error\n- 502 Bad Gateway\n- 503 Service Unavailable\n- 504 Gateway Timeout\n\n**Best Practices:**\n- Use appropriate status codes\n- Include meaningful error messages\n- Be consistent across your API",
      "keywords": ["HTTP status codes", "informational", "success", "redirection", "client error", "server error", "error handling"],
      "difficulty": "easy"
    },
    {
      "id": 16003,
      "tag": "apis",
      "question": "What is GraphQL and how does it differ from REST?",
      "answer": "GraphQL is a query language and runtime for APIs that allows clients to request exactly the data they need.\n\n**Key Features:**\n- Single endpoint\n- Client specifies exactly what data to fetch\n- Strong type system\n- Real-time subscriptions\n- Introspection capabilities\n\n**GraphQL vs REST:**\n\n**Data Fetching:**\n- GraphQL: Single request, specific fields\n- REST: Multiple endpoints, fixed data structure\n\n**Over/Under-fetching:**\n- GraphQL: Eliminates over/under-fetching\n- REST: Often fetches too much or too little data\n\n**Versioning:**\n- GraphQL: Schema evolution without versioning\n- REST: API versioning required\n\n**Caching:**\n- GraphQL: More complex caching\n- REST: HTTP caching works well\n\n**Example GraphQL Query:**\n```graphql\nquery {\n  user(id: \"123\") {\n    name\n    email\n    posts {\n      title\n      createdAt\n    }\n  }\n}\n```\n\n**When to use GraphQL:**\n- Complex data relationships\n- Mobile applications (bandwidth concerns)\n- Rapid frontend development\n- Multiple client types",
      "keywords": ["GraphQL", "query language", "single endpoint", "over-fetching", "under-fetching", "schema", "type system", "subscriptions"],
      "difficulty": "medium"
    },
    {
      "id": 16004,
      "tag": "apis",
      "question": "Explain API authentication methods (API Keys, OAuth, JWT).",
      "answer": "API authentication verifies the identity of clients making requests.\n\n**API Keys:**\n- Simple string identifier\n- Passed in header or query parameter\n- Easy to implement but less secure\n- Good for server-to-server communication\n\n```\nGET /api/users\nAuthorization: Bearer your-api-key\n```\n\n**JWT (JSON Web Tokens):**\n- Self-contained tokens with encoded information\n- Stateless authentication\n- Contains header, payload, and signature\n- Can include expiration and user claims\n\n```javascript\n// JWT structure: header.payload.signature\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n```\n\n**OAuth 2.0:**\n- Authorization framework, not authentication\n- Allows third-party access without sharing credentials\n- Multiple grant types (authorization code, client credentials, etc.)\n- Uses access tokens and refresh tokens\n\n**OAuth Flow:**\n1. Client requests authorization\n2. User grants permission\n3. Authorization server returns authorization code\n4. Client exchanges code for access token\n5. Client uses access token for API requests\n\n**Best Practices:**\n- Use HTTPS always\n- Implement token expiration\n- Store tokens securely\n- Use appropriate method for use case",
      "keywords": ["authentication", "API keys", "JWT", "OAuth", "access tokens", "authorization", "bearer tokens", "security"],
      "difficulty": "medium"
    },
    {
      "id": 16005,
      "tag": "apis",
      "question": "What is API rate limiting and why is it important?",
      "answer": "API rate limiting controls the number of requests a client can make within a specific time period.\n\n**Why Rate Limiting is Important:**\n1. **Prevent abuse** - Stop malicious attacks\n2. **Ensure fair usage** - Prevent one client from monopolizing resources\n3. **Maintain performance** - Protect server from overload\n4. **Cost control** - Manage infrastructure costs\n5. **SLA compliance** - Guarantee service levels\n\n**Common Rate Limiting Strategies:**\n\n**1. Fixed Window:**\n- Allow N requests per fixed time window\n- Simple but can cause traffic spikes\n\n**2. Sliding Window:**\n- More granular than fixed window\n- Smoother traffic distribution\n\n**3. Token Bucket:**\n- Tokens added at fixed rate\n- Requests consume tokens\n- Allows burst traffic\n\n**4. Leaky Bucket:**\n- Requests processed at fixed rate\n- Excess requests dropped\n- Smooths out traffic\n\n**Implementation:**\n```javascript\n// Express.js with express-rate-limit\nconst rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit to 100 requests per windowMs\n  message: 'Too many requests'\n});\n\napp.use('/api/', limiter);\n```\n\n**HTTP Headers:**\n- `X-RateLimit-Limit`: Request limit\n- `X-RateLimit-Remaining`: Remaining requests\n- `X-RateLimit-Reset`: Time when limit resets\n- `Retry-After`: When to retry after hitting limit",
      "keywords": ["rate limiting", "throttling", "abuse prevention", "fixed window", "sliding window", "token bucket", "leaky bucket", "HTTP headers"],
      "difficulty": "medium"
    },
    {
      "id": 16006,
      "tag": "apis",
      "question": "What is API versioning and what are the different strategies?",
      "answer": "API versioning allows you to make changes to your API while maintaining backward compatibility.\n\n**Why Version APIs:**\n- Backward compatibility\n- Gradual migration\n- Different client needs\n- Breaking changes management\n\n**Versioning Strategies:**\n\n**1. URL Path Versioning:**\n```\nGET /api/v1/users\nGET /api/v2/users\n```\n- Pros: Clear, easy to understand\n- Cons: URL pollution, caching issues\n\n**2. Query Parameter Versioning:**\n```\nGET /api/users?version=1\nGET /api/users?version=2\n```\n- Pros: Clean URLs\n- Cons: Easy to miss, default version handling\n\n**3. Header Versioning:**\n```\nGET /api/users\nX-API-Version: v1\n```\n- Pros: Clean URLs, flexible\n- Cons: Not visible in browser, harder to test\n\n**4. Accept Header Versioning:**\n```\nGET /api/users\nAccept: application/vnd.myapi.v1+json\n```\n- Pros: RESTful, content negotiation\n- Cons: Complex, harder to debug\n\n**5. Subdomain Versioning:**\n```\nv1.api.example.com/users\nv2.api.example.com/users\n```\n- Pros: Clear separation\n- Cons: DNS/SSL complexity\n\n**Best Practices:**\n- Start with versioning from day one\n- Use semantic versioning (major.minor.patch)\n- Provide migration guides\n- Deprecate old versions gradually\n- Support multiple versions simultaneously\n- Document version lifecycle",
      "keywords": ["API versioning", "backward compatibility", "URL versioning", "header versioning", "semantic versioning", "deprecation", "migration"],
      "difficulty": "medium"
    },
    {
      "id": 16007,
      "tag": "apis",
      "question": "What are webhooks and how do they differ from APIs?",
      "answer": "Webhooks are HTTP callbacks that send data to other applications when specific events occur.\n\n**Webhooks (Push Model):**\n- Server sends data to client automatically\n- Event-driven\n- Real-time notifications\n- Client provides endpoint to receive data\n\n**APIs (Pull Model):**\n- Client requests data from server\n- Request-response pattern\n- Client controls timing\n- Server provides endpoints for data access\n\n**How Webhooks Work:**\n1. Client registers webhook URL with service\n2. Event occurs on service\n3. Service sends HTTP POST to webhook URL\n4. Client processes the data\n\n**Example Webhook Registration:**\n```javascript\n// Register webhook\nPOST /api/webhooks\n{\n  \"url\": \"https://myapp.com/webhook\",\n  \"events\": [\"user.created\", \"payment.completed\"]\n}\n\n// Webhook payload received\nPOST https://myapp.com/webhook\n{\n  \"event\": \"user.created\",\n  \"data\": {\n    \"id\": \"123\",\n    \"email\": \"user@example.com\"\n  },\n  \"timestamp\": \"2023-10-01T12:00:00Z\"\n}\n```\n\n**Webhook Security:**\n- Signature verification\n- HTTPS required\n- IP whitelisting\n- Timestamp validation\n\n**Use Cases:**\n- Payment notifications\n- User registration events\n- Content updates\n- System monitoring alerts\n- Third-party integrations\n\n**Benefits:**\n- Real-time updates\n- Reduced polling\n- Lower server load\n- Better user experience\n\n**Challenges:**\n- Reliability (retries, failures)\n- Security considerations\n- Debugging complexity\n- Order of delivery",
      "keywords": ["webhooks", "HTTP callbacks", "push notifications", "event-driven", "real-time", "signature verification", "polling alternative"],
      "difficulty": "medium"
    },
    {
      "id": 16008,
      "tag": "apis",
      "question": "Explain CORS (Cross-Origin Resource Sharing) and why it's needed.",
      "answer": "CORS is a security feature that controls how web pages from one domain can access resources from another domain.\n\n**Same-Origin Policy:**\nBrowsers enforce same-origin policy by default, blocking requests between different:\n- Protocols (http vs https)\n- Domains (example.com vs api.com)\n- Ports (3000 vs 8080)\n\n**Why CORS is Needed:**\n- Enable legitimate cross-origin requests\n- Maintain security while allowing flexibility\n- Support modern web applications\n- Allow API consumption from web browsers\n\n**CORS Headers:**\n\n**Request Headers:**\n```\nOrigin: https://example.com\nAccess-Control-Request-Method: POST\nAccess-Control-Request-Headers: Content-Type\n```\n\n**Response Headers:**\n```\nAccess-Control-Allow-Origin: https://example.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: Content-Type, Authorization\nAccess-Control-Allow-Credentials: true\nAccess-Control-Max-Age: 86400\n```\n\n**Preflight Requests:**\nFor complex requests, browsers send OPTIONS request first:\n```javascript\n// This triggers preflight\nfetch('https://api.example.com/data', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token'\n  },\n  body: JSON.stringify({data: 'value'})\n});\n```\n\n**Server Implementation:**\n```javascript\n// Express.js\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', '*');\n  res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n  res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');\n  \n  if (req.method === 'OPTIONS') {\n    res.sendStatus(200);\n  } else {\n    next();\n  }\n});\n```\n\n**Security Considerations:**\n- Don't use wildcard (*) with credentials\n- Be specific with allowed origins\n- Validate and sanitize requests\n- Consider using CSRF tokens",
      "keywords": ["CORS", "same-origin policy", "cross-origin", "preflight", "security", "browser", "Access-Control headers", "OPTIONS request"],
      "difficulty": "medium"
    },
    {
      "id": 16009,
      "tag": "apis",
      "question": "What is API documentation and what should it include?",
      "answer": "API documentation is comprehensive information about how to use and integrate with an API.\n\n**Essential Components:**\n\n**1. Overview:**\n- API purpose and capabilities\n- Base URL and endpoints\n- Authentication requirements\n- Rate limits and quotas\n\n**2. Authentication:**\n- How to obtain credentials\n- Authentication methods\n- Token usage examples\n- Security best practices\n\n**3. Endpoints:**\n- HTTP methods and URLs\n- Request/response formats\n- Parameters (required/optional)\n- Example requests and responses\n\n**4. Error Handling:**\n- Error codes and meanings\n- Error response format\n- Troubleshooting guides\n\n**5. Code Examples:**\n- Multiple programming languages\n- Common use cases\n- SDK usage examples\n\n**Example Documentation Structure:**\n```markdown\n## GET /api/users/{id}\n\nRetrieve a specific user by ID.\n\n### Parameters\n- `id` (required): User ID\n\n### Headers\n- `Authorization`: Bearer token\n- `Content-Type`: application/json\n\n### Response\n```json\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n```\n\n### Error Responses\n- `404`: User not found\n- `401`: Unauthorized\n```\n\n**Documentation Tools:**\n- **Swagger/OpenAPI** - Interactive documentation\n- **Postman** - API testing and documentation\n- **GitBook** - Documentation platform\n- **Redoc** - OpenAPI documentation generator\n\n**Best Practices:**\n- Keep it up-to-date\n- Include interactive examples\n- Provide getting started guide\n- Use consistent formatting\n- Include changelog\n- Offer multiple formats (JSON, XML)\n- Provide SDKs and libraries\n- Include performance guidelines\n- Add troubleshooting section\n- Make it searchable",
      "keywords": ["API documentation", "OpenAPI", "Swagger", "endpoints", "examples", "authentication", "error handling", "SDK", "interactive docs"],
      "difficulty": "easy"
    },
    {
      "id": 16010,
      "tag": "apis",
      "question": "What are the differences between SOAP and REST?",
      "answer": "SOAP and REST are different approaches to web services, each with distinct characteristics.\n\n**SOAP (Simple Object Access Protocol):**\n- Protocol with strict standards\n- XML-based messaging\n- Built-in error handling\n- Supports transactions\n- WS-Security for security\n- WSDL for service description\n\n**REST (Representational State Transfer):**\n- Architectural style\n- Multiple formats (JSON, XML, HTML)\n- Uses HTTP methods\n- Stateless\n- Simpler and lightweight\n- No built-in standards\n\n**Comparison:**\n\n**Message Format:**\n```xml\n<!-- SOAP -->\n<soap:Envelope>\n  <soap:Header/>\n  <soap:Body>\n    <GetUser>\n      <UserId>123</UserId>\n    </GetUser>\n  </soap:Body>\n</soap:Envelope>\n```\n\n```json\n// REST\nGET /api/users/123\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\"\n}\n```\n\n**Key Differences:**\n\n| Aspect | SOAP | REST |\n|--------|------|------|\n| **Protocol** | Strict protocol | Architectural style |\n| **Format** | XML only | JSON, XML, HTML |\n| **Transport** | HTTP, SMTP, TCP | Primarily HTTP |\n| **Security** | WS-Security | HTTPS, OAuth |\n| **Caching** | Not cacheable | HTTP caching |\n| **Performance** | Slower (overhead) | Faster (lightweight) |\n| **Standards** | Extensive standards | No formal standards |\n| **Error Handling** | Built-in fault handling | HTTP status codes |\n\n**When to Use SOAP:**\n- Enterprise applications\n- Complex transactions\n- Strict security requirements\n- Need for ACID compliance\n- Legacy system integration\n\n**When to Use REST:**\n- Web applications\n- Mobile applications\n- Microservices\n- Public APIs\n- Simple CRUD operations\n- Need for scalability",
      "keywords": ["SOAP", "REST", "XML", "JSON", "protocol", "architectural style", "WS-Security", "HTTP methods", "enterprise", "web services"],
      "difficulty": "medium"
    },
    {
      "id": 16011,
      "tag": "apis",
      "question": "What is API caching and what strategies can be used?",
      "answer": "API caching stores frequently requested data to improve performance and reduce server load.\n\n**Types of API Caching:**\n\n**1. Browser Caching:**\n- Client-side caching\n- Controlled by HTTP headers\n- Reduces network requests\n\n**2. CDN Caching:**\n- Geographic distribution\n- Edge server caching\n- Faster content delivery\n\n**3. Reverse Proxy Caching:**\n- Server-side caching\n- Nginx, Varnish, Cloudflare\n- Reduces backend load\n\n**4. Application-Level Caching:**\n- In-memory caching (Redis, Memcached)\n- Database query caching\n- Computed result caching\n\n**HTTP Caching Headers:**\n\n**Cache-Control:**\n```http\nCache-Control: public, max-age=3600\nCache-Control: private, no-cache\nCache-Control: no-store\n```\n\n**ETag (Entity Tag):**\n```http\n// Response\nETag: \"123456789\"\n\n// Subsequent request\nIf-None-Match: \"123456789\"\n\n// Server response if unchanged\n304 Not Modified\n```\n\n**Last-Modified:**\n```http\n// Response\nLast-Modified: Wed, 21 Oct 2023 07:28:00 GMT\n\n// Subsequent request\nIf-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT\n```\n\n**Caching Strategies:**\n\n**1. Cache-Aside (Lazy Loading):**\n```javascript\nasync function getUser(id) {\n  let user = await cache.get(`user:${id}`);\n  if (!user) {\n    user = await database.getUser(id);\n    await cache.set(`user:${id}`, user, 3600);\n  }\n  return user;\n}\n```\n\n**2. Write-Through:**\n- Write to cache and database simultaneously\n- Ensures cache consistency\n- Higher write latency\n\n**3. Write-Behind (Write-Back):**\n- Write to cache immediately\n- Write to database asynchronously\n- Better write performance\n- Risk of data loss\n\n**4. Refresh-Ahead:**\n- Proactively refresh cache before expiration\n- Reduces cache misses\n- More complex implementation\n\n**Cache Invalidation:**\n- Time-based expiration (TTL)\n- Event-based invalidation\n- Manual cache clearing\n- Cache tagging and purging\n\n**Best Practices:**\n- Cache frequently accessed data\n- Use appropriate TTL values\n- Implement cache warming\n- Monitor cache hit rates\n- Handle cache failures gracefully\n- Consider cache size limits\n- Use compression for large objects",
      "keywords": ["caching", "HTTP headers", "Cache-Control", "ETag", "Last-Modified", "cache-aside", "write-through", "TTL", "invalidation", "performance"],
      "difficulty": "medium"
    },
    {
      "id": 16012,
      "tag": "apis",
      "question": "What is pagination in APIs and what are the different approaches?",
      "answer": "Pagination divides large datasets into smaller, manageable chunks to improve performance and user experience.\n\n**Why Pagination is Needed:**\n- Reduce response size and load time\n- Improve server performance\n- Better user experience\n- Reduce memory usage\n- Handle large datasets efficiently\n\n**Pagination Strategies:**\n\n**1. Offset-Based (Limit/Offset):**\n```http\nGET /api/users?limit=20&offset=40\n\n// Response\n{\n  \"data\": [...],\n  \"total\": 1000,\n  \"limit\": 20,\n  \"offset\": 40,\n  \"hasNext\": true,\n  \"hasPrev\": true\n}\n```\n- Pros: Simple, allows jumping to any page\n- Cons: Performance degrades with high offsets, inconsistent with concurrent modifications\n\n**2. Page-Based:**\n```http\nGET /api/users?page=3&size=20\n\n// Response\n{\n  \"data\": [...],\n  \"currentPage\": 3,\n  \"totalPages\": 50,\n  \"pageSize\": 20,\n  \"totalItems\": 1000\n}\n```\n- Pros: User-friendly, easy to understand\n- Cons: Same performance issues as offset-based\n\n**3. Cursor-Based (Keyset Pagination):**\n```http\nGET /api/users?cursor=eyJpZCI6MTIzfQ&limit=20\n\n// Response\n{\n  \"data\": [...],\n  \"nextCursor\": \"eyJpZCI6MTQzfQ\",\n  \"prevCursor\": \"eyJpZCI6MTAzfQ\",\n  \"hasNext\": true,\n  \"hasPrev\": true\n}\n```\n- Pros: Consistent performance, handles real-time data well\n- Cons: Can't jump to arbitrary pages, more complex\n\n**4. Time-Based:**\n```http\nGET /api/posts?since=2023-10-01T00:00:00Z&limit=20\n\n// For reverse chronological\nGET /api/posts?until=2023-10-01T00:00:00Z&limit=20\n```\n- Good for time-series data\n- Natural ordering by timestamp\n\n**Implementation Example:**\n```javascript\n// Cursor-based implementation\napp.get('/api/users', async (req, res) => {\n  const { cursor, limit = 20 } = req.query;\n  const decodedCursor = cursor ? JSON.parse(Buffer.from(cursor, 'base64').toString()) : null;\n  \n  const query = decodedCursor \n    ? { id: { $gt: decodedCursor.id } }\n    : {};\n  \n  const users = await User.find(query)\n    .sort({ id: 1 })\n    .limit(parseInt(limit) + 1);\n  \n  const hasNext = users.length > limit;\n  if (hasNext) users.pop();\n  \n  const nextCursor = hasNext \n    ? Buffer.from(JSON.stringify({ id: users[users.length - 1].id })).toString('base64')\n    : null;\n  \n  res.json({\n    data: users,\n    nextCursor,\n    hasNext\n  });\n});\n```\n\n**Best Practices:**\n- Provide consistent metadata\n- Set reasonable default and maximum limits\n- Include total count when needed\n- Use cursor-based for large datasets\n- Implement proper error handling\n- Consider caching for expensive queries\n- Document pagination clearly\n- Support both forward and backward navigation when possible",
      "keywords": ["pagination", "offset", "cursor", "limit", "page", "performance", "large datasets", "keyset pagination", "navigation"],
      "difficulty": "medium"
    },
    {
      "id": 16013,
      "tag": "apis",
      "question": "What is API throttling and how does it differ from rate limiting?",
      "answer": "API throttling and rate limiting are both traffic control mechanisms, but they work differently.\n\n**Rate Limiting:**\n- **Hard limit** on number of requests\n- **Binary decision**: allow or deny\n- **Blocks requests** when limit exceeded\n- Returns 429 Too Many Requests\n\n**Throttling:**\n- **Controls the rate** of request processing\n- **Delays requests** instead of blocking\n- **Queues excess requests**\n- Gradually processes requests\n\n**Key Differences:**\n\n| Aspect | Rate Limiting | Throttling |\n|--------|---------------|------------|\n| **Action** | Block requests | Delay requests |\n| **Response** | 429 error | Slower response |\n| **Behavior** | Hard cutoff | Gradual slowdown |\n| **Implementation** | Counter-based | Queue-based |\n| **User Impact** | Request failure | Slower response |\n\n**Throttling Strategies:**\n\n**1. Simple Delay:**\n```javascript\nfunction throttleRequest(req, res, next) {\n  const delay = calculateDelay(req.user.tier);\n  setTimeout(() => {\n    next();\n  }, delay);\n}\n```\n\n**2. Queue-Based:**\n```javascript\nclass RequestThrottler {\n  constructor(maxConcurrent = 10) {\n    this.queue = [];\n    this.processing = 0;\n    this.maxConcurrent = maxConcurrent;\n  }\n  \n  async throttle(request) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ request, resolve, reject });\n      this.processQueue();\n    });\n  }\n  \n  async processQueue() {\n    if (this.processing >= this.maxConcurrent || this.queue.length === 0) {\n      return;\n    }\n    \n    this.processing++;\n    const { request, resolve, reject } = this.queue.shift();\n    \n    try {\n      const result = await this.executeRequest(request);\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    } finally {\n      this.processing--;\n      this.processQueue();\n    }\n  }\n}\n```\n\n**3. Adaptive Throttling:**\n```javascript\nfunction adaptiveThrottle(req, res, next) {\n  const serverLoad = getServerLoad();\n  const delay = serverLoad > 0.8 ? 1000 : \n                serverLoad > 0.6 ? 500 : \n                serverLoad > 0.4 ? 200 : 0;\n  \n  setTimeout(() => next(), delay);\n}\n```\n\n**Combined Implementation:**\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst slowDown = require('express-slow-down');\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\n\n// Throttling\nconst speedLimiter = slowDown({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  delayAfter: 50, // allow 50 requests per windowMs without delay\n  delayMs: 500 // add 500ms delay per request after delayAfter\n});\n\napp.use('/api/', limiter, speedLimiter);\n```\n\n**When to Use Each:**\n\n**Rate Limiting:**\n- Prevent abuse and attacks\n- Enforce API quotas\n- Protect against DDoS\n- Clear usage boundaries\n\n**Throttling:**\n- Manage server load\n- Provide graceful degradation\n- Handle traffic spikes\n- Maintain service availability\n\n**Best Practices:**\n- Combine both techniques\n- Implement tiered throttling based on user plans\n- Provide clear documentation\n- Monitor and adjust limits based on usage patterns\n- Use appropriate HTTP headers to communicate delays\n- Implement circuit breakers for downstream services",
      "keywords": ["throttling", "rate limiting", "traffic control", "delay", "queue", "server load", "graceful degradation", "429 error", "adaptive throttling"],
      "difficulty": "medium"
    },
    {
      "id": 16014,
      "tag": "apis",
      "question": "What is content negotiation in APIs?",
      "answer": "Content negotiation is the process where client and server agree on the best representation of a resource based on client preferences.\n\n**Types of Content Negotiation:**\n\n**1. Media Type Negotiation:**\nClient specifies preferred response formats:\n```http\n// Client request\nGET /api/users/123\nAccept: application/json, application/xml;q=0.8, text/html;q=0.7\n\n// Server response\nContent-Type: application/json\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\"\n}\n```\n\n**2. Language Negotiation:**\n```http\n// Client request\nGET /api/content\nAccept-Language: en-US,en;q=0.9,es;q=0.8\n\n// Server response\nContent-Language: en-US\n```\n\n**3. Encoding Negotiation:**\n```http\n// Client request\nGET /api/data\nAccept-Encoding: gzip, deflate, br\n\n// Server response\nContent-Encoding: gzip\n```\n\n**4. Character Set Negotiation:**\n```http\n// Client request\nAccept-Charset: utf-8, iso-8859-1;q=0.8\n\n// Server response\nContent-Type: text/html; charset=utf-8\n```\n\n**Quality Values (q-values):**\n- Range from 0.0 to 1.0\n- Higher values indicate preference\n- Default is 1.0 if not specified\n\n```http\nAccept: application/json;q=1.0, application/xml;q=0.8, text/plain;q=0.5\n```\n\n**Server-Side Implementation:**\n```javascript\n// Express.js example\napp.get('/api/users/:id', (req, res) => {\n  const user = getUserById(req.params.id);\n  \n  res.format({\n    'application/json': () => {\n      res.json(user);\n    },\n    'application/xml': () => {\n      const xml = convertToXML(user);\n      res.type('application/xml').send(xml);\n    },\n    'text/html': () => {\n      res.render('user', { user });\n    },\n    'default': () => {\n      res.status(406).send('Not Acceptable');\n    }\n  });\n});\n```\n\n**API Versioning with Content Negotiation:**\n```http\n// Version in Accept header\nAccept: application/vnd.myapi.v2+json\n\n// Custom media types\nAccept: application/vnd.github.v3+json\n```\n\n**Implementation Example:**\n```javascript\nfunction handleContentNegotiation(req, res) {\n  const acceptHeader = req.headers.accept;\n  const supportedTypes = [\n    'application/json',\n    'application/xml',\n    'text/csv'\n  ];\n  \n  // Parse Accept header\n  const acceptedTypes = parseAcceptHeader(acceptHeader);\n  \n  // Find best match\n  const bestMatch = findBestMatch(acceptedTypes, supportedTypes);\n  \n  if (!bestMatch) {\n    return res.status(406).json({\n      error: 'Not Acceptable',\n      supported: supportedTypes\n    });\n  }\n  \n  // Set response content type\n  res.type(bestMatch);\n  \n  // Return data in requested format\n  switch (bestMatch) {\n    case 'application/json':\n      return res.json(data);\n    case 'application/xml':\n      return res.send(convertToXML(data));\n    case 'text/csv':\n      return res.send(convertToCSV(data));\n  }\n}\n```\n\n**Best Practices:**\n- Support common formats (JSON, XML)\n- Provide sensible defaults\n- Use standard MIME types\n- Handle unsupported types gracefully (406 Not Acceptable)\n- Document supported formats\n- Consider performance implications\n- Implement proper error handling\n- Use caching appropriately for different formats\n\n**Benefits:**\n- Client flexibility\n- Single endpoint, multiple formats\n- Future-proof API design\n- Better client integration\n- Reduced API surface area",
      "keywords": ["content negotiation", "Accept header", "media types", "MIME types", "q-values", "406 Not Acceptable", "format negotiation", "API versioning"],
      "difficulty": "medium"
    },
    {
      "id": 16015,
      "tag": "apis",
      "question": "What are API gateways and what problems do they solve?",
      "answer": "An API Gateway is a server that acts as an intermediary between clients and backend services, providing a single entry point for API requests.\n\n**Problems API Gateways Solve:**\n\n**1. Service Orchestration:**\n- Multiple backend services\n- Complex client-service interactions\n- Need for service composition\n\n**2. Cross-Cutting Concerns:**\n- Authentication and authorization\n- Rate limiting and throttling\n- Logging and monitoring\n- Request/response transformation\n\n**3. Protocol Translation:**\n- HTTP to gRPC conversion\n- REST to GraphQL translation\n- Legacy system integration\n\n**Core Functions:**\n\n**1. Request Routing:**\n```yaml\n# API Gateway configuration\nroutes:\n  - path: /users/*\n    service: user-service\n    url: http://user-service:8080\n  - path: /orders/*\n    service: order-service\n    url: http://order-service:8081\n```\n\n**2. Authentication & Authorization:**\n```javascript\n// Gateway middleware\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization;\n  if (!validateToken(token)) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n  req.user = decodeToken(token);\n  next();\n}\n```\n\n**3. Rate Limiting:**\n```javascript\nconst rateLimiter = {\n  '/api/public/*': { limit: 100, window: '1h' },\n  '/api/premium/*': { limit: 1000, window: '1h' },\n  '/api/internal/*': { limit: 10000, window: '1h' }\n};\n```\n\n**4. Request/Response Transformation:**\n```javascript\n// Transform legacy API response\nfunction transformResponse(response) {\n  return {\n    data: response.result,\n    meta: {\n      timestamp: Date.now(),\n      version: '2.0'\n    }\n  };\n}\n```\n\n**Architecture Patterns:**\n\n**1. Backend for Frontend (BFF):**\n```\nMobile App → Mobile Gateway → Services\nWeb App   → Web Gateway    → Services\nPartner   → Partner Gateway → Services\n```\n\n**2. Single Gateway:**\n```\nAll Clients → Single Gateway → Multiple Services\n```\n\n**Popular API Gateway Solutions:**\n\n**Cloud-Based:**\n- AWS API Gateway\n- Google Cloud Endpoints\n- Azure API Management\n- Kong Cloud\n\n**Self-Hosted:**\n- Kong\n- Ambassador\n- Zuul (Netflix)\n- Traefik\n- HAProxy\n\n**Example Implementation (Express.js):**\n```javascript\nconst express = require('express');\nconst httpProxy = require('http-proxy-middleware');\nconst rateLimit = require('express-rate-limit');\n\nconst app = express();\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100\n});\n\napp.use(limiter);\n\n// Authentication middleware\napp.use('/api', authenticate);\n\n// Route to user service\napp.use('/api/users', httpProxy({\n  target: 'http://user-service:8080',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/users': '/users'\n  }\n}));\n\n// Route to order service\napp.use('/api/orders', httpProxy({\n  target: 'http://order-service:8081',\n  changeOrigin: true,\n  pathRewrite: {\n    '^/api/orders': '/orders'\n  }\n}));\n\napp.listen(3000);\n```\n\n**Benefits:**\n- Centralized cross-cutting concerns\n- Simplified client implementations\n- Better security and monitoring\n- Service discovery and load balancing\n- API versioning and deprecation management\n- Analytics and insights\n\n**Challenges:**\n- Single point of failure\n- Additional latency\n- Complexity in configuration\n- Potential bottleneck\n- Vendor lock-in (for cloud solutions)\n\n**Best Practices:**\n- Keep gateways stateless\n- Implement proper health checks\n- Use caching strategically\n- Monitor performance metrics\n- Plan for high availability\n- Implement circuit breakers\n- Keep business logic in services, not gateway",
      "keywords": ["API gateway", "microservices", "routing", "authentication", "rate limiting", "service orchestration", "BFF", "Kong", "AWS API Gateway", "proxy"],
      "difficulty": "hard"
    },
    {
      "id": 16016,
      "tag": "apis",
      "question": "What is idempotency in APIs and why is it important?",
      "answer": "Idempotency means that making the same API request multiple times produces the same result as making it once.\n\n**Why Idempotency Matters:**\n- Network failures and retries\n- User accidentally clicking submit multiple times\n- Distributed system reliability\n- Safe operation repetition\n- Predictable API behavior\n\n**HTTP Methods and Idempotency:**\n\n**Idempotent Methods:**\n- **GET** - Reading data doesn't change state\n- **PUT** - Replacing entire resource with same data\n- **DELETE** - Deleting already deleted resource has no effect\n- **HEAD, OPTIONS** - Metadata operations\n\n**Non-Idempotent Methods:**\n- **POST** - Creating new resources (each call creates new resource)\n- **PATCH** - Partial updates may have different effects\n\n**Examples:**\n\n**Idempotent PUT:**\n```http\nPUT /api/users/123\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n\n// Multiple calls result in same user state\n```\n\n**Non-Idempotent POST:**\n```http\nPOST /api/users\n{\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\"\n}\n\n// Each call creates a new user\n```\n\n**Making POST Idempotent:**\n\n**1. Idempotency Keys:**\n```http\nPOST /api/orders\nIdempotency-Key: 550e8400-e29b-41d4-a716-446655440000\n{\n  \"product_id\": \"123\",\n  \"quantity\": 2\n}\n```\n\n**Server Implementation:**\n```javascript\napp.post('/api/orders', async (req, res) => {\n  const idempotencyKey = req.headers['idempotency-key'];\n  \n  if (!idempotencyKey) {\n    return res.status(400).json({ error: 'Idempotency-Key required' });\n  }\n  \n  // Check if request was already processed\n  const existingOrder = await redis.get(`order:${idempotencyKey}`);\n  if (existingOrder) {\n    return res.status(200).json(JSON.parse(existingOrder));\n  }\n  \n  // Process new order\n  const order = await createOrder(req.body);\n  \n  // Store result with expiration\n  await redis.setex(`order:${idempotencyKey}`, 3600, JSON.stringify(order));\n  \n  res.status(201).json(order);\n});\n```\n\n**2. Natural Idempotency:**\n```http\n// Use natural unique identifiers\nPUT /api/users/john@example.com\n{\n  \"name\": \"John Doe\",\n  \"preferences\": {...}\n}\n```\n\n**3. Conditional Requests:**\n```http\n// Only create if doesn't exist\nPOST /api/users\nIf-None-Match: *\n{\n  \"email\": \"john@example.com\",\n  \"name\": \"John Doe\"\n}\n\n// Server response if exists\n412 Precondition Failed\n```\n\n**PATCH Idempotency Considerations:**\n```javascript\n// Non-idempotent PATCH\nPATCH /api/users/123\n{\n  \"balance\": \"+10\"  // Adds 10 each time\n}\n\n// Idempotent PATCH\nPATCH /api/users/123\n{\n  \"balance\": 110   // Sets to 110\n}\n```\n\n**Implementation Strategies:**\n\n**1. Database Constraints:**\n```sql\n-- Unique constraint prevents duplicates\nCREATE TABLE orders (\n  id UUID PRIMARY KEY,\n  idempotency_key UUID UNIQUE NOT NULL,\n  -- other fields\n);\n```\n\n**2. State-Based Operations:**\n```javascript\n// Instead of increment operations\nfunction incrementCounter(id) {\n  return db.query('UPDATE counters SET value = value + 1 WHERE id = ?', [id]);\n}\n\n// Use absolute values\nfunction setCounter(id, value) {\n  return db.query('UPDATE counters SET value = ? WHERE id = ?', [value, id]);\n}\n```\n\n**3. Two-Phase Operations:**\n```javascript\n// Phase 1: Reserve/Lock\nconst reservation = await createReservation({\n  idempotencyKey,\n  productId,\n  quantity\n});\n\n// Phase 2: Confirm\nconst order = await confirmOrder(reservation.id);\n```\n\n**Best Practices:**\n- Use idempotency keys for critical operations\n- Store idempotency results with appropriate TTL\n- Handle concurrent requests properly\n- Document idempotent behavior clearly\n- Use HTTP status codes correctly (200 for repeated, 201 for new)\n- Implement proper error handling\n- Consider using UUIDs for idempotency keys\n- Set reasonable expiration times for stored results",
      "keywords": ["idempotency", "idempotent", "HTTP methods", "idempotency keys", "retry safety", "network failures", "duplicate requests", "state management"],
      "difficulty": "medium"
    },
    {
      "id": 16017,
      "tag": "apis",
      "question": "What are the best practices for API error handling?",
      "answer": "Proper API error handling provides clear, consistent, and actionable error information to clients.\n\n**HTTP Status Code Categories:**\n\n**4xx Client Errors:**\n- **400 Bad Request** - Invalid request syntax/data\n- **401 Unauthorized** - Authentication required\n- **403 Forbidden** - Insufficient permissions\n- **404 Not Found** - Resource doesn't exist\n- **409 Conflict** - Resource conflict (duplicate, version mismatch)\n- **422 Unprocessable Entity** - Validation errors\n- **429 Too Many Requests** - Rate limit exceeded\n\n**5xx Server Errors:**\n- **500 Internal Server Error** - Generic server error\n- **502 Bad Gateway** - Upstream server error\n- **503 Service Unavailable** - Server temporarily unavailable\n- **504 Gateway Timeout** - Upstream timeout\n\n**Error Response Structure:**\n\n**Basic Structure:**\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Request validation failed\",\n    \"details\": {\n      \"field\": \"email\",\n      \"issue\": \"Invalid email format\"\n    },\n    \"timestamp\": \"2023-10-01T12:00:00Z\",\n    \"path\": \"/api/users\",\n    \"requestId\": \"550e8400-e29b-41d4-a716-446655440000\"\n  }\n}\n```\n\n**Validation Errors:**\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Request validation failed\",\n    \"errors\": [\n      {\n        \"field\": \"email\",\n        \"code\": \"INVALID_FORMAT\",\n        \"message\": \"Email must be a valid email address\"\n      },\n      {\n        \"field\": \"age\",\n        \"code\": \"OUT_OF_RANGE\",\n        \"message\": \"Age must be between 18 and 120\"\n      }\n    ]\n  }\n}\n```\n\n**Implementation Examples:**\n\n**Express.js Error Handling:**\n```javascript\n// Custom error class\nclass APIError extends Error {\n  constructor(message, statusCode, code = null, details = null) {\n    super(message);\n    this.statusCode = statusCode;\n    this.code = code;\n    this.details = details;\n    this.timestamp = new Date().toISOString();\n  }\n}\n\n// Error handler middleware\nfunction errorHandler(err, req, res, next) {\n  let error = err;\n  \n  // Convert known errors\n  if (err.name === 'ValidationError') {\n    const errors = Object.values(err.errors).map(e => ({\n      field: e.path,\n      code: 'VALIDATION_ERROR',\n      message: e.message\n    }));\n    \n    error = new APIError('Validation failed', 422, 'VALIDATION_ERROR', { errors });\n  }\n  \n  const response = {\n    error: {\n      code: error.code || 'INTERNAL_ERROR',\n      message: error.message || 'Internal server error',\n      ...(error.details && { details: error.details }),\n      timestamp: error.timestamp || new Date().toISOString(),\n      path: req.path,\n      requestId: req.id\n    }\n  };\n  \n  // Don't expose internal errors in production\n  if (process.env.NODE_ENV === 'production' && error.statusCode >= 500) {\n    response.error.message = 'Internal server error';\n    delete response.error.details;\n  }\n  \n  res.status(error.statusCode || 500).json(response);\n}\n\napp.use(errorHandler);\n```\n\n**Specific Error Handlers:**\n```javascript\n// Not found handler\napp.use('*', (req, res) => {\n  throw new APIError(`Resource not found: ${req.path}`, 404, 'NOT_FOUND');\n});\n\n// Authentication error\nfunction requireAuth(req, res, next) {\n  const token = req.headers.authorization;\n  if (!token) {\n    throw new APIError('Authentication required', 401, 'AUTHENTICATION_REQUIRED');\n  }\n  // ... validate token\n}\n\n// Rate limiting error\napp.use('/api', rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 100,\n  handler: (req, res) => {\n    throw new APIError('Rate limit exceeded', 429, 'RATE_LIMIT_EXCEEDED', {\n      retryAfter: Math.round(req.rateLimit.resetTime / 1000)\n    });\n  }\n}));\n```\n\n**Error Logging:**\n```javascript\nfunction logError(error, req) {\n  const logData = {\n    timestamp: new Date().toISOString(),\n    requestId: req.id,\n    method: req.method,\n    path: req.path,\n    userAgent: req.headers['user-agent'],\n    ip: req.ip,\n    error: {\n      message: error.message,\n      stack: error.stack,\n      code: error.code,\n      statusCode: error.statusCode\n    }\n  };\n  \n  if (error.statusCode >= 500) {\n    logger.error('Server error', logData);\n  } else {\n    logger.warn('Client error', logData);\n  }\n}\n```\n\n**Client-Side Error Handling:**\n```javascript\n// JavaScript client\nasync function apiCall(url, options) {\n  try {\n    const response = await fetch(url, options);\n    \n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new APIError(errorData.error.message, response.status, errorData.error.code);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    if (error.status === 401) {\n      // Redirect to login\n      window.location.href = '/login';\n    } else if (error.status === 422) {\n      // Show validation errors\n      displayValidationErrors(error.details.errors);\n    } else {\n      // Show generic error\n      showErrorMessage('An error occurred. Please try again.');\n    }\n    throw error;\n  }\n}\n```\n\n**Best Practices:**\n\n1. **Consistent Format** - Use same error structure across all endpoints\n2. **Meaningful Messages** - Provide clear, actionable error messages\n3. **Appropriate Status Codes** - Use correct HTTP status codes\n4. **Error Codes** - Include machine-readable error codes\n5. **Request Tracking** - Include request IDs for debugging\n6. **Security** - Don't expose sensitive information in errors\n7. **Validation Details** - Provide specific field-level validation errors\n8. **Logging** - Log errors appropriately with context\n9. **Documentation** - Document all possible error responses\n10. **Retry Information** - Include retry-after headers when appropriate\n11. **Localization** - Support multiple languages for error messages\n12. **Graceful Degradation** - Handle partial failures appropriately",
      "keywords": ["error handling", "HTTP status codes", "error responses", "validation errors", "logging", "error codes", "API errors", "client errors", "server errors"],
      "difficulty": "medium"
    },
    {
      "id": 16018,
      "tag": "apis",
      "question": "What is HATEOAS and how does it relate to REST?",
      "answer": "HATEOAS (Hypermedia as the Engine of Application State) is a constraint of REST architecture where responses include links to related actions and resources.\n\n**Core Concept:**\nClients discover available actions dynamically through hypermedia links in responses, rather than having knowledge hardcoded.\n\n**HATEOAS Example:**\n```json\n{\n  \"id\": \"123\",\n  \"name\": \"John Doe\",\n  \"email\": \"john@example.com\",\n  \"status\": \"active\",\n  \"_links\": {\n    \"self\": {\n      \"href\": \"/api/users/123\"\n    },\n    \"edit\": {\n      \"href\": \"/api/users/123\",\n      \"method\": \"PUT\"\n    },\n    \"delete\": {\n      \"href\": \"/api/users/123\",\n      \"method\": \"DELETE\"\n    },\n    \"orders\": {\n      \"href\": \"/api/users/123/orders\"\n    },\n    \"deactivate\": {\n      \"href\": \"/api/users/123/deactivate\",\n      \"method\": \"POST\"\n    }\n  }\n}\n```\n\n**State-Dependent Links:**\n```json\n// Active user\n{\n  \"id\": \"123\",\n  \"status\": \"active\",\n  \"_links\": {\n    \"deactivate\": {\n      \"href\": \"/api/users/123/deactivate\",\n      \"method\": \"POST\"\n    }\n  }\n}\n\n// Inactive user\n{\n  \"id\": \"123\",\n  \"status\": \"inactive\",\n  \"_links\": {\n    \"activate\": {\n      \"href\": \"/api/users/123/activate\",\n      \"method\": \"POST\"\n    }\n  }\n}\n```\n\n**Collection with HATEOAS:**\n```json\n{\n  \"users\": [\n    {\n      \"id\": \"123\",\n      \"name\": \"John Doe\",\n      \"_links\": {\n        \"self\": { \"href\": \"/api/users/123\" }\n      }\n    }\n  ],\n  \"_links\": {\n    \"self\": { \"href\": \"/api/users?page=1&size=10\" },\n    \"next\": { \"href\": \"/api/users?page=2&size=10\" },\n    \"prev\": { \"href\": \"/api/users?page=0&size=10\" },\n    \"create\": {\n      \"href\": \"/api/users\",\n      \"method\": \"POST\"\n    }\n  },\n  \"page\": {\n    \"size\": 10,\n    \"totalElements\": 100,\n    \"totalPages\": 10,\n    \"number\": 1\n  }\n}\n```\n\n**Implementation Example:**\n```javascript\n// Express.js HATEOAS implementation\nfunction addHATEOASLinks(user, req) {\n  const baseUrl = `${req.protocol}://${req.get('host')}`;\n  \n  user._links = {\n    self: {\n      href: `${baseUrl}/api/users/${user.id}`\n    },\n    edit: {\n      href: `${baseUrl}/api/users/${user.id}`,\n      method: 'PUT'\n    },\n    orders: {\n      href: `${baseUrl}/api/users/${user.id}/orders`\n    }\n  };\n  \n  // State-dependent links\n  if (user.status === 'active') {\n    user._links.deactivate = {\n      href: `${baseUrl}/api/users/${user.id}/deactivate`,\n      method: 'POST'\n    };\n  } else {\n    user._links.activate = {\n      href: `${baseUrl}/api/users/${user.id}/activate`,\n      method: 'POST'\n    };\n  }\n  \n  return user;\n}\n\napp.get('/api/users/:id', async (req, res) => {\n  const user = await User.findById(req.params.id);\n  const userWithLinks = addHATEOASLinks(user, req);\n  res.json(userWithLinks);\n});\n```\n\n**Link Relation Types:**\n```json\n{\n  \"_links\": {\n    \"self\": { \"href\": \"/api/orders/123\" },\n    \"customer\": { \"href\": \"/api/customers/456\" },\n    \"items\": { \"href\": \"/api/orders/123/items\" },\n    \"payment\": { \"href\": \"/api/orders/123/payment\" },\n    \"cancel\": {\n      \"href\": \"/api/orders/123/cancel\",\n      \"method\": \"POST\"\n    },\n    \"edit\": {\n      \"href\": \"/api/orders/123\",\n      \"method\": \"PUT\"\n    }\n  }\n}\n```\n\n**Benefits of HATEOAS:**\n\n1. **Self-Documenting** - API describes itself\n2. **Discoverable** - Clients can explore available actions\n3. **Evolvable** - Server can change URLs without breaking clients\n4. **State-Aware** - Available actions depend on resource state\n5. **Loose Coupling** - Clients don't hardcode URLs\n\n**Challenges:**\n\n1. **Complexity** - More complex to implement and consume\n2. **Payload Size** - Additional metadata increases response size\n3. **Caching** - Links may complicate caching strategies\n4. **Client Support** - Not all clients handle hypermedia well\n5. **Learning Curve** - Developers need to understand hypermedia concepts\n\n**HATEOAS Standards:**\n\n**HAL (Hypertext Application Language):**\n```json\n{\n  \"_embedded\": {\n    \"orders\": [\n      {\n        \"id\": \"123\",\n        \"total\": 100.00,\n        \"_links\": {\n          \"self\": { \"href\": \"/orders/123\" }\n        }\n      }\n    ]\n  },\n  \"_links\": {\n    \"self\": { \"href\": \"/customers/456/orders\" }\n  }\n}\n```\n\n**JSON-LD:**\n```json\n{\n  \"@context\": \"https://schema.org\",\n  \"@type\": \"Person\",\n  \"@id\": \"/api/users/123\",\n  \"name\": \"John Doe\",\n  \"knows\": {\n    \"@id\": \"/api/users/456\"\n  }\n}\n```\n\n**When to Use HATEOAS:**\n- Public APIs with diverse clients\n- Long-lived API integrations\n- Complex resource relationships\n- Need for API discoverability\n- Evolving API requirements\n\n**When NOT to Use:**\n- Simple, well-defined APIs\n- High-performance requirements\n- Mobile apps with bandwidth constraints\n- Internal microservice communication\n- Clients that can't handle hypermedia",
      "keywords": ["HATEOAS", "hypermedia", "REST", "links", "discoverable", "self-documenting", "HAL", "JSON-LD", "state transitions", "loose coupling"],
      "difficulty": "hard"
    },
    {
      "id": 16019,
      "tag": "apis",
      "question": "What are the key considerations for API security?",
      "answer": "API security involves protecting APIs from various threats and ensuring secure data transmission and access control.\n\n**Common API Security Threats:**\n\n**OWASP API Security Top 10:**\n1. **Broken Object Level Authorization** - Accessing other users' objects\n2. **Broken User Authentication** - Weak authentication mechanisms\n3. **Excessive Data Exposure** - Returning sensitive data unnecessarily\n4. **Lack of Resources & Rate Limiting** - No protection against abuse\n5. **Broken Function Level Authorization** - Inadequate function access controls\n6. **Mass Assignment** - Allowing modification of unintended fields\n7. **Security Misconfiguration** - Improper security settings\n8. **Injection** - SQL, NoSQL, command injection attacks\n9. **Improper Assets Management** - Unpatched or legacy API versions\n10. **Insufficient Logging & Monitoring** - Poor attack detection\n\n**Authentication & Authorization:**\n\n**1. Token-Based Authentication:**\n```javascript\n// JWT implementation\nconst jwt = require('jsonwebtoken');\n\nfunction authenticateToken(req, res, next) {\n  const authHeader = req.headers['authorization'];\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({ error: 'Access token required' });\n  }\n  \n  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {\n    if (err) {\n      return res.status(403).json({ error: 'Invalid or expired token' });\n    }\n    req.user = user;\n    next();\n  });\n}\n```\n\n**2. API Key Authentication:**\n```javascript\nfunction validateApiKey(req, res, next) {\n  const apiKey = req.headers['x-api-key'];\n  \n  if (!apiKey) {\n    return res.status(401).json({ error: 'API key required' });\n  }\n  \n  // Validate against database or cache\n  const isValid = await validateKeyInDatabase(apiKey);\n  if (!isValid) {\n    return res.status(403).json({ error: 'Invalid API key' });\n  }\n  \n  next();\n}\n```\n\n**3. OAuth 2.0:**\n```javascript\nconst passport = require('passport');\nconst GoogleStrategy = require('passport-google-oauth20').Strategy;\n\npassport.use(new GoogleStrategy({\n  clientID: process.env.GOOGLE_CLIENT_ID,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n  callbackURL: \"/auth/google/callback\"\n}, async (accessToken, refreshToken, profile, done) => {\n  // Handle user authentication\n  const user = await findOrCreateUser(profile);\n  return done(null, user);\n}));\n```\n\n**Input Validation & Sanitization:**\n```javascript\nconst joi = require('joi');\nconst rateLimit = require('express-rate-limit');\n\n// Request validation\nconst userSchema = joi.object({\n  email: joi.string().email().required(),\n  password: joi.string().min(8).pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/).required(),\n  age: joi.number().integer().min(18).max(120)\n});\n\nfunction validateUser(req, res, next) {\n  const { error } = userSchema.validate(req.body);\n  if (error) {\n    return res.status(400).json({ error: error.details[0].message });\n  }\n  next();\n}\n\n// SQL injection prevention\nfunction getUserById(id) {\n  // Use parameterized queries\n  return db.query('SELECT * FROM users WHERE id = ?', [id]);\n}\n```\n\n**Rate Limiting & DDoS Protection:**\n```javascript\n// Rate limiting by IP\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP',\n  standardHeaders: true,\n  legacyHeaders: false\n});\n\n// Rate limiting by user\nconst userLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 1000,\n  keyGenerator: (req) => req.user?.id || req.ip,\n  skip: (req) => req.user?.tier === 'premium'\n});\n\napp.use('/api/', limiter, userLimiter);\n```\n\n**HTTPS & Data Encryption:**\n```javascript\n// Force HTTPS\nfunction requireHTTPS(req, res, next) {\n  if (!req.secure && req.get('x-forwarded-proto') !== 'https') {\n    return res.redirect(301, `https://${req.get('host')}${req.url}`);\n  }\n  next();\n}\n\n// Encrypt sensitive data\nconst crypto = require('crypto');\n\nfunction encryptSensitiveData(data) {\n  const algorithm = 'aes-256-gcm';\n  const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');\n  const iv = crypto.randomBytes(16);\n  \n  const cipher = crypto.createCipher(algorithm, key);\n  cipher.setAAD(Buffer.from('additional-data'));\n  \n  let encrypted = cipher.update(data, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  \n  const authTag = cipher.getAuthTag();\n  \n  return {\n    encrypted,\n    iv: iv.toString('hex'),\n    authTag: authTag.toString('hex')\n  };\n}\n```\n\n**CORS Security:**\n```javascript\nconst cors = require('cors');\n\n// Restrictive CORS configuration\nconst corsOptions = {\n  origin: function (origin, callback) {\n    const allowedOrigins = [\n      'https://myapp.com',\n      'https://app.mycompany.com'\n    ];\n    \n    if (!origin || allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  optionsSuccessStatus: 200,\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization']\n};\n\napp.use(cors(corsOptions));\n```\n\n**Security Headers:**\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n// Custom security headers\napp.use((req, res, next) => {\n  res.set({\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'X-XSS-Protection': '1; mode=block',\n    'Referrer-Policy': 'strict-origin-when-cross-origin'\n  });\n  next();\n});\n```\n\n**Logging & Monitoring:**\n```javascript\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.File({ filename: 'security.log' })\n  ]\n});\n\n// Security event logging\nfunction logSecurityEvent(event, req, details = {}) {\n  logger.warn('Security Event', {\n    event,\n    ip: req.ip,\n    userAgent: req.get('User-Agent'),\n    path: req.path,\n    method: req.method,\n    userId: req.user?.id,\n    timestamp: new Date().toISOString(),\n    ...details\n  });\n}\n\n// Failed authentication attempts\napp.post('/api/login', (req, res) => {\n  // ... authentication logic\n  if (!isValidCredentials) {\n    logSecurityEvent('FAILED_LOGIN', req, {\n      email: req.body.email\n    });\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n```\n\n**Best Practices:**\n\n1. **Principle of Least Privilege** - Grant minimum necessary permissions\n2. **Defense in Depth** - Multiple security layers\n3. **Secure by Default** - Secure configurations out of the box\n4. **Regular Security Audits** - Periodic security assessments\n5. **Keep Dependencies Updated** - Regular security patches\n6. **Input Validation** - Validate all inputs on server side\n7. **Output Encoding** - Prevent XSS attacks\n8. **Secure Storage** - Encrypt sensitive data at rest\n9. **API Versioning** - Maintain and deprecate versions securely\n10. **Error Handling** - Don't expose sensitive information in errors\n11. **Monitoring & Alerting** - Detect and respond to threats quickly\n12. **Security Testing** - Regular penetration testing and vulnerability scanning",
      "keywords": ["API security", "authentication", "authorization", "OWASP", "rate limiting", "HTTPS", "CORS", "input validation", "logging", "encryption", "security headers"],
      "difficulty": "hard"
    }
  ]
}