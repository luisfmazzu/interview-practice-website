{
  "technology": "javascript",
  "questions": [
    {
      "id": 0,
      "tag": "javascript",
      "question": "Explain the difference between `let`, `const`, and `var` in JavaScript.",
      "answer": "**var:**\n- Function-scoped or globally-scoped\n- Can be redeclared and updated\n- Hoisted with undefined initialization\n- Creates property on global object\n\n**let:**\n- Block-scoped\n- Can be updated but not redeclared in same scope\n- Hoisted but not initialized (temporal dead zone)\n- Does not create property on global object\n\n**const:**\n- Block-scoped\n- Cannot be updated or redeclared\n- Must be initialized at declaration\n- Hoisted but not initialized (temporal dead zone)\n- For objects/arrays, contents can be modified",
      "keywords": ["block scope", "function scope", "hoisting", "temporal dead zone", "redeclaration", "reassignment", "global object"],
      "difficulty": "easy"
    },
    {
      "id": 1,
      "tag": "javascript",
      "question": "What is a closure in JavaScript? Provide an example.",
      "answer": "A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.\n\n**Example:**\n```javascript\nfunction outerFunction(x) {\n  return function innerFunction(y) {\n    return x + y; // Has access to 'x'\n  };\n}\n\nconst addFive = outerFunction(5);\nconsole.log(addFive(3)); // 8\n```\n\n**Key points:**\n- Inner function maintains reference to outer scope\n- Enables data privacy and encapsulation\n- Commonly used in module patterns and callbacks\n- Can cause memory leaks if not handled properly",
      "keywords": ["outer scope", "inner function", "lexical scoping", "data privacy", "encapsulation", "module pattern", "callbacks", "memory leaks"],
      "difficulty": "medium"
    },
    {
      "id": 2,
      "tag": "javascript",
      "question": "Explain event bubbling and capturing in the DOM.",
      "answer": "Event propagation has three phases:\n\n**1. Capturing Phase:**\n- Event travels from root to target element\n- Rarely used, can be enabled with `addEventListener(event, handler, true)`\n\n**2. Target Phase:**\n- Event reaches the target element\n\n**3. Bubbling Phase:**\n- Event bubbles up from target to root\n- Default behavior\n\n**Example:**\n```javascript\n// Bubbling (default)\nelement.addEventListener('click', handler);\n\n// Capturing\nelement.addEventListener('click', handler, true);\n\n// Stop propagation\nevent.stopPropagation();\n```\n\n**Use cases:**\n- Event delegation\n- Handling events on dynamically created elements",
      "keywords": ["event propagation", "capturing phase", "bubbling phase", "target phase", "addEventListener", "stopPropagation", "event delegation"],
      "difficulty": "medium"
    },
    {
      "id": 3,
      "tag": "javascript",
      "question": "What is the difference between `==` and `===` in JavaScript?",
      "answer": "**== (Loose Equality):**\n- Performs type coercion before comparison\n- Converts operands to same type, then compares\n- Can lead to unexpected results\n\n**=== (Strict Equality):**\n- No type coercion\n- Compares both value and type\n- Recommended for most comparisons\n\n**Examples:**\n```javascript\n// Loose equality\n'5' == 5    // true (string coerced to number)\n0 == false  // true\nnull == undefined // true\n\n// Strict equality\n'5' === 5    // false (different types)\n0 === false  // false\nnull === undefined // false\n```\n\n**Best practice:** Use `===` unless you specifically need type coercion.",
      "keywords": ["type coercion", "loose equality", "strict equality", "value comparison", "type comparison", "best practices"],
      "difficulty": "easy"
    },
    {
      "id": 4,
      "tag": "javascript",
      "question": "Explain the concept of hoisting in JavaScript.",
      "answer": "Hoisting is JavaScript's behavior of moving declarations to the top of their scope during compilation.\n\n**Variable Hoisting:**\n```javascript\nconsole.log(x); // undefined (not error)\nvar x = 5;\n\n// Equivalent to:\nvar x;\nconsole.log(x); // undefined\nx = 5;\n```\n\n**Function Hoisting:**\n```javascript\n// Function declarations are fully hoisted\nsayHello(); // Works!\n\nfunction sayHello() {\n  console.log('Hello!');\n}\n\n// Function expressions are not hoisted\nsayGoodbye(); // TypeError\nvar sayGoodbye = function() {\n  console.log('Goodbye!');\n};\n```\n\n**let/const:**\n- Hoisted but not initialized (temporal dead zone)\n- Accessing before declaration throws ReferenceError",
      "keywords": ["hoisting", "declarations", "compilation", "function declarations", "function expressions", "temporal dead zone", "scope"],
      "difficulty": "medium"
    },
    {
      "id": 5,
      "tag": "javascript",
      "question": "What are arrow functions and how do they differ from regular functions?",
      "answer": "Arrow functions are a concise way to write functions introduced in ES6.\n\n**Syntax:**\n```javascript\n// Regular function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\n\n// Multiple statements\nconst multiply = (a, b) => {\n  const result = a * b;\n  return result;\n};\n```\n\n**Key Differences:**\n1. **No `this` binding** - inherits from enclosing scope\n2. **Cannot be used as constructors** - no `new` operator\n3. **No `arguments` object** - use rest parameters instead\n4. **Cannot be hoisted** - must be defined before use\n5. **More concise syntax** for simple functions\n\n**Example of `this` behavior:**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  increment() {\n    // Arrow function inherits `this` from Counter\n    setTimeout(() => {\n      this.count++; // Works correctly\n    }, 1000);\n  }\n}\n```",
      "keywords": ["ES6", "arrow functions", "this binding", "lexical scope", "constructors", "arguments object", "concise syntax", "hoisting"],
      "difficulty": "easy"
    },
    {
      "id": 6,
      "tag": "javascript",
      "question": "Explain destructuring assignment in JavaScript.",
      "answer": "Destructuring allows unpacking values from arrays or properties from objects into distinct variables.\n\n**Array Destructuring:**\n```javascript\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(rest);  // [3, 4, 5]\n\n// Skipping elements\nconst [a, , c] = [1, 2, 3];\nconsole.log(a, c); // 1, 3\n\n// Default values\nconst [x = 10, y = 20] = [5];\nconsole.log(x, y); // 5, 20\n```\n\n**Object Destructuring:**\n```javascript\nconst user = { name: 'John', age: 30, city: 'NYC' };\nconst { name, age, country = 'USA' } = user;\n\n// Renaming variables\nconst { name: userName, age: userAge } = user;\n\n// Nested destructuring\nconst { address: { street } } = { address: { street: '123 Main' } };\n```\n\n**Function Parameters:**\n```javascript\nfunction greet({ name, age = 25 }) {\n  console.log(`Hello ${name}, you are ${age}`);\n}\n\ngreet({ name: 'Alice' }); // Hello Alice, you are 25\n```",
      "keywords": ["destructuring", "array destructuring", "object destructuring", "rest operator", "default values", "parameter destructuring", "variable assignment"],
      "difficulty": "easy"
    },
    {
      "id": 7,
      "tag": "javascript",
      "question": "What is the difference between `null` and `undefined`?",
      "answer": "`null` and `undefined` both represent absence of value but have different meanings and behaviors.\n\n**undefined:**\n- Default value for uninitialized variables\n- Returned when accessing non-existent object properties\n- Returned by functions that don't explicitly return a value\n- Type is 'undefined'\n\n**null:**\n- Intentional absence of value\n- Must be explicitly assigned\n- Represents 'no value' or 'empty value'\n- Type is 'object' (historical JavaScript quirk)\n\n**Examples:**\n```javascript\nlet x;\nconsole.log(x); // undefined\n\nconst obj = {};\nconsole.log(obj.property); // undefined\n\nfunction doSomething() {}\nconsole.log(doSomething()); // undefined\n\n// null assignment\nlet data = null; // Intentionally empty\n\n// Type checking\ntypeof undefined; // 'undefined'\ntypeof null;      // 'object'\n\n// Equality\nnull == undefined;  // true (loose equality)\nnull === undefined; // false (strict equality)\n```\n\n**Best Practice:** Use `null` when you want to intentionally represent 'no value'.",
      "keywords": ["null", "undefined", "type checking", "uninitialized variables", "intentional absence", "equality comparison", "typeof operator"],
      "difficulty": "easy"
    },
    {
      "id": 8,
      "tag": "javascript",
      "question": "What are template literals and their advantages?",
      "answer": "Template literals are string literals that allow embedded expressions and multi-line strings, introduced in ES6.\n\n**Syntax:**\n```javascript\n// Basic template literal\nconst message = `Hello, World!`;\n\n// String interpolation\nconst name = 'Alice';\nconst age = 25;\nconst greeting = `Hello ${name}, you are ${age} years old`;\n\n// Expression evaluation\nconst total = `Total: ${price * quantity + tax}`;\n\n// Multi-line strings\nconst html = `\n  <div>\n    <h1>Title</h1>\n    <p>Content goes here</p>\n  </div>\n`;\n```\n\n**Advantages:**\n1. **String interpolation** - embed variables and expressions\n2. **Multi-line strings** - no need for concatenation or escape characters\n3. **Expression evaluation** - can include function calls and calculations\n4. **Improved readability** - cleaner syntax than concatenation\n\n**Tagged Templates:**\n```javascript\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, string, i) => {\n    const value = values[i] ? `<mark>${values[i]}</mark>` : '';\n    return result + string + value;\n  }, '');\n}\n\nconst term = 'JavaScript';\nconst text = highlight`Learn ${term} programming`;\n// Output: 'Learn <mark>JavaScript</mark> programming'\n```",
      "keywords": ["template literals", "string interpolation", "multi-line strings", "expression evaluation", "tagged templates", "ES6", "backticks", "embedded expressions"],
      "difficulty": "easy"
    },
    {
      "id": 9,
      "tag": "javascript",
      "question": "Explain the `this` keyword in JavaScript.",
      "answer": "The `this` keyword refers to the object that is executing the current function. Its value depends on how the function is called.\n\n**Global Context:**\n```javascript\nconsole.log(this); // Window object (browser) or global object (Node.js)\n```\n\n**Object Method:**\n```javascript\nconst obj = {\n  name: 'John',\n  greet() {\n    console.log(this.name); // 'John'\n  }\n};\nobj.greet();\n```\n\n**Function Call:**\n```javascript\nfunction sayHello() {\n  console.log(this); // undefined in strict mode, Window in non-strict\n}\nsayHello();\n```\n\n**Constructor Function:**\n```javascript\nfunction Person(name) {\n  this.name = name; // `this` refers to new instance\n}\nconst person = new Person('Alice');\n```\n\n**Explicit Binding:**\n```javascript\nconst obj1 = { name: 'John' };\nconst obj2 = { name: 'Jane' };\n\nfunction introduce() {\n  console.log(`Hi, I'm ${this.name}`);\n}\n\nintroduce.call(obj1);  // 'Hi, I'm John'\nintroduce.apply(obj2); // 'Hi, I'm Jane'\nconst boundFunc = introduce.bind(obj1);\nboundFunc(); // 'Hi, I'm John'\n```\n\n**Arrow Functions:**\n```javascript\nconst obj = {\n  name: 'John',\n  greet: () => {\n    console.log(this.name); // undefined - no `this` binding\n  }\n};\n```",
      "keywords": ["this keyword", "context binding", "object methods", "constructor functions", "call", "apply", "bind", "arrow functions", "global context"],
      "difficulty": "medium"
    },
    {
      "id": 10,
      "tag": "javascript",
      "question": "What are Promises and how do they work?",
      "answer": "Promises are objects representing the eventual completion or failure of an asynchronous operation.\n\n**Promise States:**\n- **Pending** - initial state, neither fulfilled nor rejected\n- **Fulfilled** - operation completed successfully\n- **Rejected** - operation failed\n\n**Creating Promises:**\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const success = Math.random() > 0.5;\n    if (success) {\n      resolve('Operation successful!');\n    } else {\n      reject(new Error('Operation failed'));\n    }\n  }, 1000);\n});\n```\n\n**Consuming Promises:**\n```javascript\npromise\n  .then(result => {\n    console.log(result); // Handle success\n    return 'Next value';\n  })\n  .then(value => {\n    console.log(value); // Chain additional operations\n  })\n  .catch(error => {\n    console.error(error); // Handle errors\n  })\n  .finally(() => {\n    console.log('Cleanup'); // Always executed\n  });\n```\n\n**Promise Utilities:**\n```javascript\n// Wait for all promises\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results));\n\n// First to resolve\nPromise.race([promise1, promise2])\n  .then(result => console.log(result));\n\n// All settle (resolve or reject)\nPromise.allSettled([promise1, promise2])\n  .then(results => console.log(results));\n```",
      "keywords": ["promises", "asynchronous", "pending", "fulfilled", "rejected", "then", "catch", "finally", "Promise.all", "Promise.race", "chaining"],
      "difficulty": "medium"
    },
    {
      "id": 11,
      "tag": "javascript",
      "question": "What is async/await and how does it relate to Promises?",
      "answer": "Async/await is syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code.\n\n**Basic Syntax:**\n```javascript\n// Promise-based approach\nfunction fetchUserData() {\n  return fetch('/api/user')\n    .then(response => response.json())\n    .then(data => {\n      console.log(data);\n      return data;\n    })\n    .catch(error => console.error(error));\n}\n\n// Async/await approach\nasync function fetchUserData() {\n  try {\n    const response = await fetch('/api/user');\n    const data = await response.json();\n    console.log(data);\n    return data;\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n**Key Points:**\n1. **`async` functions always return a Promise**\n2. **`await` can only be used inside `async` functions**\n3. **`await` pauses execution until Promise resolves**\n4. **Use try/catch for error handling**\n\n**Sequential vs Parallel Execution:**\n```javascript\n// Sequential (slower)\nasync function sequential() {\n  const user = await fetchUser();\n  const posts = await fetchPosts(); // Waits for user\n  return { user, posts };\n}\n\n// Parallel (faster)\nasync function parallel() {\n  const [user, posts] = await Promise.all([\n    fetchUser(),\n    fetchPosts()\n  ]);\n  return { user, posts };\n}\n```\n\n**Error Handling:**\n```javascript\nasync function handleErrors() {\n  try {\n    const result = await riskyOperation();\n    return result;\n  } catch (error) {\n    // Handle specific errors\n    if (error.code === 'NETWORK_ERROR') {\n      return 'Please check your connection';\n    }\n    throw error; // Re-throw unknown errors\n  }\n}\n```",
      "keywords": ["async await", "promises", "asynchronous", "syntactic sugar", "try catch", "sequential execution", "parallel execution", "Promise.all", "error handling"],
      "difficulty": "medium"
    },
    {
      "id": 12,
      "tag": "javascript",
      "question": "What is the difference between `forEach`, `map`, `filter`, and `reduce`?",
      "answer": "These are array methods for iteration and transformation, each serving different purposes.\n\n**forEach()** - executes function for each element, returns undefined:\n```javascript\nconst numbers = [1, 2, 3, 4];\nnumbers.forEach(num => console.log(num * 2));\n// Prints: 2, 4, 6, 8\n// Returns: undefined\n```\n\n**map()** - creates new array with transformed elements:\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n```\n\n**filter()** - creates new array with elements that pass test:\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst evens = numbers.filter(num => num % 2 === 0);\nconsole.log(evens); // [2, 4, 6]\n```\n\n**reduce()** - reduces array to single value:\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum); // 10\n\n// Complex example - grouping\nconst people = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 25 }\n];\n\nconst grouped = people.reduce((acc, person) => {\n  const age = person.age;\n  if (!acc[age]) acc[age] = [];\n  acc[age].push(person);\n  return acc;\n}, {});\n// Groups people by age\n```\n\n**Key Differences:**\n- **forEach**: Side effects only, no return value\n- **map**: 1:1 transformation, always returns array of same length\n- **filter**: Conditional inclusion, returns subset\n- **reduce**: Aggregation, returns single value (can be any type)",
      "keywords": ["forEach", "map", "filter", "reduce", "array methods", "iteration", "transformation", "functional programming", "side effects", "aggregation"],
      "difficulty": "easy"
    },
    {
      "id": 13,
      "tag": "javascript",
      "question": "What is the spread operator and rest parameters?",
      "answer": "Both use the same syntax (`...`) but serve different purposes depending on context.\n\n**Spread Operator** - expands iterables into individual elements:\n\n**Array Spreading:**\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n\n// Clone array\nconst cloned = [...arr1];\n\n// Convert string to array\nconst chars = [...'hello']; // ['h', 'e', 'l', 'l', 'o']\n```\n\n**Object Spreading:**\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }\n\n// Override properties\nconst updated = { ...obj1, b: 99 }; // { a: 1, b: 99 }\n```\n\n**Function Arguments:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconsole.log(Math.max(...numbers)); // 5\n```\n\n**Rest Parameters** - collects multiple elements into array:\n\n**Function Parameters:**\n```javascript\nfunction sum(first, ...rest) {\n  console.log(first); // First argument\n  console.log(rest);  // Array of remaining arguments\n  return first + rest.reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3, 4); // first = 1, rest = [2, 3, 4]\n```\n\n**Destructuring:**\n```javascript\nconst [head, ...tail] = [1, 2, 3, 4];\nconsole.log(head); // 1\nconsole.log(tail); // [2, 3, 4]\n\nconst { x, ...others } = { x: 1, y: 2, z: 3 };\nconsole.log(x);      // 1\nconsole.log(others); // { y: 2, z: 3 }\n```",
      "keywords": ["spread operator", "rest parameters", "array spreading", "object spreading", "destructuring", "function parameters", "clone", "merge", "ES6"],
      "difficulty": "easy"
    },
    {
      "id": 14,
      "tag": "javascript",
      "question": "What are JavaScript classes and how do they work?",
      "answer": "JavaScript classes are syntactic sugar over prototype-based inheritance, introduced in ES6.\n\n**Basic Class Syntax:**\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n  \n  static species() {\n    return 'Homo sapiens';\n  }\n}\n\nconst person = new Person('Alice', 30);\nconsole.log(person.greet()); // \"Hello, I'm Alice\"\nconsole.log(Person.species()); // \"Homo sapiens\"\n```\n\n**Inheritance:**\n```javascript\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age); // Call parent constructor\n    this.grade = grade;\n  }\n  \n  study() {\n    return `${this.name} is studying`;\n  }\n  \n  // Override parent method\n  greet() {\n    return `${super.greet()}, I'm a student`;\n  }\n}\n\nconst student = new Student('Bob', 20, 'A');\nconsole.log(student.greet()); // \"Hello, I'm Bob, I'm a student\"\n```\n\n**Private Fields (ES2022):**\n```javascript\nclass BankAccount {\n  #balance = 0; // Private field\n  \n  constructor(initialBalance) {\n    this.#balance = initialBalance;\n  }\n  \n  deposit(amount) {\n    this.#balance += amount;\n  }\n  \n  getBalance() {\n    return this.#balance;\n  }\n}\n\nconst account = new BankAccount(100);\n// account.#balance; // SyntaxError: Private field '#balance'\n```\n\n**Key Features:**\n- Constructor for initialization\n- Instance methods\n- Static methods\n- Inheritance with `extends`\n- `super` keyword for parent access\n- Private fields with `#`",
      "keywords": ["classes", "constructor", "inheritance", "extends", "super", "static methods", "private fields", "prototype", "ES6", "object-oriented"],
      "difficulty": "easy"
    },
    {
      "id": 15,
      "tag": "javascript",
      "question": "Explain prototypes and prototype chain in JavaScript.",
      "answer": "JavaScript uses prototype-based inheritance where objects can inherit properties and methods from other objects.\n\n**Prototype Basics:**\n```javascript\n// Every function has a prototype property\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\nconst person1 = new Person('Alice');\nconst person2 = new Person('Bob');\n\nconsole.log(person1.greet()); // \"Hello, I'm Alice\"\nconsole.log(person2.greet()); // \"Hello, I'm Bob\"\n\n// Both instances share the same method\nconsole.log(person1.greet === person2.greet); // true\n```\n\n**Prototype Chain:**\n```javascript\n// Objects have __proto__ property pointing to prototype\nconsole.log(person1.__proto__ === Person.prototype); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__); // null (end of chain)\n```\n\n**Property Lookup:**\n```javascript\nconst obj = { a: 1 };\nobj.b = 2;\n\n// Lookup order:\n// 1. Own properties: obj.a, obj.b\n// 2. Prototype: Object.prototype.toString, etc.\n// 3. If not found: undefined\n\nconsole.log(obj.toString()); // From Object.prototype\n```\n\n**Modern Prototype Methods:**\n```javascript\n// Create object with specific prototype\nconst animal = { species: 'mammal' };\nconst dog = Object.create(animal);\ndog.breed = 'labrador';\n\nconsole.log(dog.species); // 'mammal' (inherited)\n\n// Check prototype chain\nconsole.log(Object.getPrototypeOf(dog) === animal); // true\nconsole.log(dog.hasOwnProperty('breed')); // true\nconsole.log(dog.hasOwnProperty('species')); // false\n\n// Set prototype\nconst cat = { sound: 'meow' };\nObject.setPrototypeOf(cat, animal);\nconsole.log(cat.species); // 'mammal'\n```\n\n**Benefits:**\n- Memory efficiency (shared methods)\n- Dynamic inheritance\n- Flexible object relationships",
      "keywords": ["prototype", "prototype chain", "inheritance", "__proto__", "Object.create", "hasOwnProperty", "getPrototypeOf", "setPrototypeOf", "property lookup"],
      "difficulty": "medium"
    },
    {
      "id": 16,
      "tag": "javascript",
      "question": "What are modules in JavaScript? Explain ES6 modules.",
      "answer": "Modules allow code organization into separate files with explicit imports and exports, promoting reusability and maintainability.\n\n**ES6 Module Syntax:**\n\n**Named Exports:**\n```javascript\n// math.js\nexport const PI = 3.14159;\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport class Calculator {\n  multiply(a, b) {\n    return a * b;\n  }\n}\n\n// Alternative export syntax\nconst subtract = (a, b) => a - b;\nexport { subtract, PI as PIValue };\n```\n\n**Default Exports:**\n```javascript\n// utils.js\nconst formatDate = (date) => {\n  return date.toLocaleDateString();\n};\n\nexport default formatDate;\n\n// Or inline\nexport default function logger(message) {\n  console.log(`[LOG]: ${message}`);\n}\n```\n\n**Importing Modules:**\n```javascript\n// Named imports\nimport { add, PI, Calculator } from './math.js';\nimport { subtract, PIValue } from './math.js';\n\n// Default import\nimport formatDate from './utils.js';\nimport logger from './utils.js';\n\n// Mixed imports\nimport logger, { add, PI } from './combined.js';\n\n// Import all\nimport * as MathUtils from './math.js';\nconsole.log(MathUtils.add(2, 3));\n\n// Dynamic imports\nasync function loadModule() {\n  const { add } = await import('./math.js');\n  console.log(add(1, 2));\n}\n```\n\n**Module Features:**\n- **Static structure** - imports/exports are determined at compile time\n- **Singleton** - modules are cached after first load\n- **Strict mode** - always executed in strict mode\n- **Top-level scope** - variables don't pollute global scope\n- **Circular dependencies** - supported with limitations\n\n**Browser Usage:**\n```html\n<script type=\"module\" src=\"main.js\"></script>\n```\n\n**Benefits:**\n- Code organization and encapsulation\n- Dependency management\n- Tree shaking (dead code elimination)\n- Better tooling support",
      "keywords": ["modules", "ES6 modules", "import", "export", "named exports", "default export", "dynamic imports", "static structure", "tree shaking", "encapsulation"],
      "difficulty": "medium"
    },
    {
      "id": 17,
      "tag": "javascript",
      "question": "What is the event loop and how does JavaScript handle asynchronous operations?",
      "answer": "The event loop is JavaScript's mechanism for handling asynchronous operations in a single-threaded environment.\n\n**JavaScript Runtime Components:**\n1. **Call Stack** - executes synchronous code\n2. **Web APIs** - browser-provided APIs (setTimeout, DOM events, fetch)\n3. **Callback Queue** - holds completed async callbacks\n4. **Microtask Queue** - holds Promise callbacks (higher priority)\n5. **Event Loop** - moves tasks from queues to call stack\n\n**Event Loop Process:**\n```javascript\nconsole.log('1'); // Call stack\n\nsetTimeout(() => {\n  console.log('2'); // Callback queue\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3'); // Microtask queue\n});\n\nconsole.log('4'); // Call stack\n\n// Output: 1, 4, 3, 2\n```\n\n**Detailed Execution:**\n```javascript\nfunction example() {\n  console.log('Start');\n  \n  setTimeout(() => console.log('Timeout 1'), 0);\n  \n  Promise.resolve()\n    .then(() => console.log('Promise 1'))\n    .then(() => console.log('Promise 2'));\n  \n  setTimeout(() => console.log('Timeout 2'), 0);\n  \n  console.log('End');\n}\n\nexample();\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Timeout 1\n// Timeout 2\n```\n\n**Priority Order:**\n1. **Synchronous code** (call stack)\n2. **Microtasks** (Promises, queueMicrotask)\n3. **Macrotasks** (setTimeout, setInterval, I/O)\n\n**Microtask vs Macrotask:**\n```javascript\nsetTimeout(() => console.log('Macro 1'), 0);\n\nPromise.resolve().then(() => {\n  console.log('Micro 1');\n  Promise.resolve().then(() => console.log('Micro 2'));\n});\n\nsetTimeout(() => console.log('Macro 2'), 0);\n\n// Output: Micro 1, Micro 2, Macro 1, Macro 2\n```\n\n**Key Concepts:**\n- JavaScript is single-threaded but can handle concurrency\n- Async operations don't block the main thread\n- Microtasks have higher priority than macrotasks\n- Event loop ensures non-blocking execution",
      "keywords": ["event loop", "call stack", "callback queue", "microtask queue", "Web APIs", "asynchronous", "single-threaded", "concurrency", "macrotasks", "microtasks"],
      "difficulty": "hard"
    },
    {
      "id": 18,
      "tag": "javascript",
      "question": "What is debouncing and throttling? When would you use each?",
      "answer": "Debouncing and throttling are techniques to control function execution frequency, essential for performance optimization.\n\n**Debouncing** - delays execution until after a pause in events:\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Usage: Search input\nconst searchInput = document.getElementById('search');\nconst debouncedSearch = debounce((query) => {\n  console.log(`Searching for: ${query}`);\n  // API call here\n}, 300);\n\nsearchInput.addEventListener('input', (e) => {\n  debouncedSearch(e.target.value);\n});\n```\n\n**Throttling** - limits execution to once per time period:\n\n```javascript\nfunction throttle(func, delay) {\n  let lastExecTime = 0;\n  return function(...args) {\n    const currentTime = Date.now();\n    if (currentTime - lastExecTime >= delay) {\n      func.apply(this, args);\n      lastExecTime = currentTime;\n    }\n  };\n}\n\n// Usage: Scroll event\nconst throttledScroll = throttle(() => {\n  console.log('Scroll position:', window.scrollY);\n  // Update scroll indicator\n}, 100);\n\nwindow.addEventListener('scroll', throttledScroll);\n```\n\n**Advanced Throttling with Leading/Trailing:**\n```javascript\nfunction throttleAdvanced(func, delay, options = {}) {\n  let timeoutId;\n  let lastExecTime = 0;\n  const { leading = true, trailing = true } = options;\n  \n  return function(...args) {\n    const currentTime = Date.now();\n    const timeSinceLastExec = currentTime - lastExecTime;\n    \n    if (leading && timeSinceLastExec >= delay) {\n      func.apply(this, args);\n      lastExecTime = currentTime;\n    } else if (trailing) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n        lastExecTime = Date.now();\n      }, delay - timeSinceLastExec);\n    }\n  };\n}\n```\n\n**Use Cases:**\n\n**Debouncing:**\n- Search autocomplete\n- Form validation\n- Button click prevention\n- Window resize handling\n\n**Throttling:**\n- Scroll events\n- Mouse movement tracking\n- API rate limiting\n- Game controls\n- Animation frames\n\n**Key Differences:**\n- **Debouncing**: Waits for quiet period, executes once at end\n- **Throttling**: Executes at regular intervals during activity",
      "keywords": ["debouncing", "throttling", "performance optimization", "event handling", "rate limiting", "setTimeout", "clearTimeout", "leading", "trailing", "function execution"],
      "difficulty": "medium"
    },
    {
      "id": 19,
      "tag": "javascript",
      "question": "Explain call, apply, and bind methods.",
      "answer": "These methods allow explicit control over the `this` context and function arguments.\n\n**call()** - invokes function with specified `this` and individual arguments:\n\n```javascript\nfunction greet(greeting, punctuation) {\n  return `${greeting}, I'm ${this.name}${punctuation}`;\n}\n\nconst person = { name: 'Alice' };\n\n// Using call\nconst result = greet.call(person, 'Hello', '!');\nconsole.log(result); // \"Hello, I'm Alice!\"\n```\n\n**apply()** - same as call but takes arguments as array:\n\n```javascript\n// Using apply\nconst args = ['Hi', '.'];\nconst result2 = greet.apply(person, args);\nconsole.log(result2); // \"Hi, I'm Alice.\"\n\n// Practical example: Finding max in array\nconst numbers = [1, 5, 3, 9, 2];\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 9\n\n// Modern alternative with spread\nconst max2 = Math.max(...numbers);\n```\n\n**bind()** - creates new function with bound `this` and optional preset arguments:\n\n```javascript\n// Basic binding\nconst boundGreet = greet.bind(person);\nconsole.log(boundGreet('Hey', '?')); // \"Hey, I'm Alice?\"\n\n// Partial application\nconst boundGreetHello = greet.bind(person, 'Hello');\nconsole.log(boundGreetHello('!')); // \"Hello, I'm Alice!\"\n```\n\n**Practical Examples:**\n\n**Event Handlers:**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n    this.increment = this.increment.bind(this);\n  }\n  \n  increment() {\n    this.count++;\n    console.log(this.count);\n  }\n}\n\nconst counter = new Counter();\nconst button = document.getElementById('btn');\nbutton.addEventListener('click', counter.increment); // `this` preserved\n```\n\n**Method Borrowing:**\n```javascript\nconst obj1 = {\n  name: 'Object 1',\n  describe() {\n    return `I am ${this.name}`;\n  }\n};\n\nconst obj2 = { name: 'Object 2' };\n\n// Borrow method\nconst result = obj1.describe.call(obj2);\nconsole.log(result); // \"I am Object 2\"\n```\n\n**Array-like Objects:**\n```javascript\nfunction processArguments() {\n  // Convert arguments to real array\n  const args = Array.prototype.slice.call(arguments);\n  return args.map(arg => arg.toUpperCase());\n}\n\nconsole.log(processArguments('a', 'b', 'c')); // ['A', 'B', 'C']\n```\n\n**Key Differences:**\n- **call**: Immediate execution, individual arguments\n- **apply**: Immediate execution, array of arguments\n- **bind**: Returns new function, can preset arguments",
      "keywords": ["call", "apply", "bind", "this binding", "function context", "method borrowing", "partial application", "event handlers", "array-like objects"],
      "difficulty": "medium"
    },
    {
      "id": 20,
      "tag": "javascript",
      "question": "What are Set and Map data structures? How do they differ from arrays and objects?",
      "answer": "Set and Map are ES6 data structures that provide alternatives to arrays and objects with unique characteristics.\n\n**Set** - collection of unique values:\n\n```javascript\n// Creating Sets\nconst set = new Set();\nconst setWithValues = new Set([1, 2, 3, 2, 1]); // [1, 2, 3]\n\n// Set methods\nset.add(1);\nset.add(2);\nset.add(2); // Duplicate ignored\nconsole.log(set.size); // 2\n\nconsole.log(set.has(1)); // true\nset.delete(1);\nset.clear(); // Remove all\n\n// Iteration\nconst fruits = new Set(['apple', 'banana', 'orange']);\nfor (const fruit of fruits) {\n  console.log(fruit);\n}\n\n// Convert to array\nconst uniqueArray = [...new Set([1, 1, 2, 3, 3])];\nconsole.log(uniqueArray); // [1, 2, 3]\n```\n\n**Map** - collection of key-value pairs with any key type:\n\n```javascript\n// Creating Maps\nconst map = new Map();\nconst mapWithEntries = new Map([\n  ['name', 'Alice'],\n  [1, 'number key'],\n  [true, 'boolean key']\n]);\n\n// Map methods\nmap.set('key1', 'value1');\nmap.set(42, 'number key');\nconst obj = {};\nmap.set(obj, 'object key');\n\nconsole.log(map.get('key1')); // 'value1'\nconsole.log(map.has(42)); // true\nconsole.log(map.size); // 3\n\nmap.delete('key1');\nmap.clear();\n\n// Iteration\nconst userRoles = new Map([\n  ['alice', 'admin'],\n  ['bob', 'user'],\n  ['charlie', 'moderator']\n]);\n\nfor (const [user, role] of userRoles) {\n  console.log(`${user}: ${role}`);\n}\n\n// Get all keys/values\nconsole.log([...userRoles.keys()]); // ['alice', 'bob', 'charlie']\nconsole.log([...userRoles.values()]); // ['admin', 'user', 'moderator']\n```\n\n**WeakSet and WeakMap:**\n```javascript\n// WeakSet - only objects, weak references\nconst weakSet = new WeakSet();\nlet obj1 = { id: 1 };\nweakSet.add(obj1);\n// obj1 = null; // Object can be garbage collected\n\n// WeakMap - only object keys, weak references\nconst weakMap = new WeakMap();\nlet key = { id: 1 };\nweakMap.set(key, 'metadata');\n// key = null; // Entry can be garbage collected\n```\n\n**Comparison with Arrays and Objects:**\n\n**Set vs Array:**\n- Set: Unique values, no index access\n- Array: Allows duplicates, indexed access, many methods\n\n**Map vs Object:**\n- Map: Any key type, better iteration, size property\n- Object: String/Symbol keys only, prototype properties, better performance for records\n\n**Use Cases:**\n- **Set**: Removing duplicates, checking membership\n- **Map**: Key-value pairs with non-string keys, frequent additions/deletions\n- **WeakSet/WeakMap**: Metadata storage, avoiding memory leaks",
      "keywords": ["Set", "Map", "WeakSet", "WeakMap", "unique values", "key-value pairs", "data structures", "ES6", "iteration", "memory management", "garbage collection"],
      "difficulty": "medium"
    },
    {
      "id": 21,
      "tag": "javascript",
      "question": "What are generators and iterators in JavaScript?",
      "answer": "Generators and iterators provide a way to create custom iteration behavior and handle sequences of data lazily.\n\n**Iterators** - objects that implement the iteration protocol:\n\n```javascript\n// Iterator protocol requires next() method\nfunction createIterator(array) {\n  let index = 0;\n  \n  return {\n    next() {\n      if (index < array.length) {\n        return { value: array[index++], done: false };\n      }\n      return { value: undefined, done: true };\n    }\n  };\n}\n\nconst iterator = createIterator([1, 2, 3]);\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n\n**Generators** - functions that can pause and resume execution:\n\n```javascript\nfunction* numberGenerator() {\n  console.log('Start');\n  yield 1;\n  console.log('After first yield');\n  yield 2;\n  console.log('After second yield');\n  yield 3;\n  console.log('End');\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // \"Start\", { value: 1, done: false }\nconsole.log(gen.next()); // \"After first yield\", { value: 2, done: false }\nconsole.log(gen.next()); // \"After second yield\", { value: 3, done: false }\nconsole.log(gen.next()); // \"End\", { value: undefined, done: true }\n```\n\n**Generator Features:**\n\n**Infinite Sequences:**\n```javascript\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nconsole.log(fib.next().value); // 0\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 2\n```\n\n**Bidirectional Communication:**\n```javascript\nfunction* twoWayGenerator() {\n  const input1 = yield 'First output';\n  console.log('Received:', input1);\n  \n  const input2 = yield 'Second output';\n  console.log('Received:', input2);\n  \n  return 'Final result';\n}\n\nconst gen2 = twoWayGenerator();\nconsole.log(gen2.next());           // { value: 'First output', done: false }\nconsole.log(gen2.next('Hello'));    // \"Received: Hello\", { value: 'Second output', done: false }\nconsole.log(gen2.next('World'));    // \"Received: World\", { value: 'Final result', done: true }\n```\n\n**Async Generators:**\n```javascript\nasync function* asyncGenerator() {\n  for (let i = 0; i < 3; i++) {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    yield `Value ${i}`;\n  }\n}\n\n// Usage with for-await-of\nasync function consumeAsync() {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // Logs every second\n  }\n}\n```\n\n**Practical Applications:**\n\n**Custom Iterables:**\n```javascript\nclass Range {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  \n  *[Symbol.iterator]() {\n    for (let i = this.start; i <= this.end; i++) {\n      yield i;\n    }\n  }\n}\n\nconst range = new Range(1, 5);\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n```\n\n**Benefits:**\n- Lazy evaluation (values computed on demand)\n- Memory efficient for large sequences\n- Pausable execution\n- Clean syntax for complex iteration patterns\n- Built-in support for for-of loops",
      "keywords": ["generators", "iterators", "yield", "next", "iteration protocol", "lazy evaluation", "Symbol.iterator", "async generators", "infinite sequences", "pausable execution"],
      "difficulty": "hard"
    },
    {
      "id": 22,
      "tag": "javascript",
      "question": "What is currying and partial application?",
      "answer": "Currying and partial application are functional programming techniques for creating specialized functions from general ones.\n\n**Currying** - transforms function with multiple arguments into sequence of functions with single arguments:\n\n```javascript\n// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\n// Arrow function currying\nconst curriedAddArrow = a => b => c => a + b + c;\n\n// Usage\nconst result1 = curriedAdd(1)(2)(3); // 6\nconst addOne = curriedAdd(1);\nconst addOneTwo = addOne(2);\nconst result2 = addOneTwo(3); // 6\n```\n\n**Generic Curry Function:**\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return function(...nextArgs) {\n      return curried.apply(this, args.concat(nextArgs));\n    };\n  };\n}\n\n// Usage\nconst multiply = (a, b, c) => a * b * c;\nconst curriedMultiply = curry(multiply);\n\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24\n```\n\n**Partial Application** - creates function with some arguments preset:\n\n```javascript\nfunction partial(fn, ...presetArgs) {\n  return function(...laterArgs) {\n    return fn.apply(this, presetArgs.concat(laterArgs));\n  };\n}\n\n// Example function\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\n// Partial applications\nconst sayHello = partial(greet, 'Hello');\nconst sayHelloToAlice = partial(greet, 'Hello', 'Alice');\n\nconsole.log(sayHello('Bob', '!')); // \"Hello, Bob!\"\nconsole.log(sayHelloToAlice('.')); // \"Hello, Alice.\"\n```\n\n**Practical Examples:**\n\n**Event Handling:**\n```javascript\nconst handleEvent = curry((eventType, selector, handler) => {\n  document.querySelector(selector).addEventListener(eventType, handler);\n});\n\nconst onClick = handleEvent('click');\nconst onButtonClick = onClick('button');\n\nonButtonClick(() => console.log('Button clicked!'));\n```\n\n**Data Processing:**\n```javascript\nconst map = curry((fn, array) => array.map(fn));\nconst filter = curry((predicate, array) => array.filter(predicate));\n\nconst numbers = [1, 2, 3, 4, 5, 6];\n\n// Create specialized functions\nconst double = map(x => x * 2);\nconst filterEven = filter(x => x % 2 === 0);\n\nconst result = filterEven(double(numbers));\nconsole.log(result); // [4, 8, 12]\n\n// Function composition\nconst processNumbers = numbers => filterEven(double(numbers));\nconsole.log(processNumbers([1, 2, 3, 4, 5])); // [4, 8]\n```\n\n**API Wrapper:**\n```javascript\nconst apiCall = curry((method, url, data) => {\n  return fetch(url, {\n    method,\n    headers: { 'Content-Type': 'application/json' },\n    body: data ? JSON.stringify(data) : undefined\n  });\n});\n\nconst get = apiCall('GET');\nconst post = apiCall('POST');\n\nconst getUsers = get('/api/users');\nconst createUser = post('/api/users');\n\n// Usage\ngetUsers().then(response => response.json());\ncreateUser({ name: 'Alice' }).then(response => response.json());\n```\n\n**Key Differences:**\n- **Currying**: Always returns unary (single-argument) functions\n- **Partial Application**: Can preset any number of arguments\n- Both enable function specialization and reusability",
      "keywords": ["currying", "partial application", "functional programming", "function specialization", "higher-order functions", "function composition", "reusability", "single argument"],
      "difficulty": "medium"
    },
    {
      "id": 23,
      "tag": "javascript",
      "question": "What are Symbols and what are they used for?",
      "answer": "Symbols are primitive data type introduced in ES6 that represent unique identifiers, primarily used for object property keys.\n\n**Creating Symbols:**\n```javascript\n// Basic symbol creation\nconst sym1 = Symbol();\nconst sym2 = Symbol('description');\nconst sym3 = Symbol('description');\n\nconsole.log(sym2 === sym3); // false - always unique\nconsole.log(typeof sym1);   // 'symbol'\nconsole.log(sym2.toString()); // 'Symbol(description)'\n```\n\n**Symbol as Object Properties:**\n```javascript\nconst obj = {};\nconst uniqueKey = Symbol('uniqueProperty');\n\n// Setting symbol properties\nobj[uniqueKey] = 'secret value';\nobj.normalProperty = 'normal value';\n\nconsole.log(obj[uniqueKey]); // 'secret value'\nconsole.log(obj.normalProperty); // 'normal value'\n\n// Symbol properties are not enumerable\nconsole.log(Object.keys(obj)); // ['normalProperty']\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(uniqueProperty)]\n```\n\n**Global Symbol Registry:**\n```javascript\n// Create/retrieve global symbols\nconst globalSym1 = Symbol.for('shared');\nconst globalSym2 = Symbol.for('shared');\n\nconsole.log(globalSym1 === globalSym2); // true\nconsole.log(Symbol.keyFor(globalSym1)); // 'shared'\n\n// Local symbols are not in global registry\nconst localSym = Symbol('local');\nconsole.log(Symbol.keyFor(localSym)); // undefined\n```\n\n**Well-Known Symbols:**\n```javascript\n// Symbol.iterator - defines default iterator\nclass CustomIterable {\n  constructor(data) {\n    this.data = data;\n  }\n  \n  *[Symbol.iterator]() {\n    for (let item of this.data) {\n      yield item;\n    }\n  }\n}\n\nconst iterable = new CustomIterable([1, 2, 3]);\nfor (const value of iterable) {\n  console.log(value); // 1, 2, 3\n}\n\n// Symbol.toStringTag - customizes Object.prototype.toString\nclass CustomClass {\n  get [Symbol.toStringTag]() {\n    return 'CustomClass';\n  }\n}\n\nconst instance = new CustomClass();\nconsole.log(instance.toString()); // '[object CustomClass]'\n```\n\n**Advanced Use Cases:**\n\n**Private-like Properties:**\n```javascript\nconst _internal = Symbol('internal');\n\nclass Calculator {\n  constructor() {\n    this[_internal] = { operations: 0 };\n  }\n  \n  add(a, b) {\n    this[_internal].operations++;\n    return a + b;\n  }\n  \n  getOperationCount() {\n    return this[_internal].operations;\n  }\n}\n\nconst calc = new Calculator();\ncalc.add(1, 2);\nconsole.log(calc.getOperationCount()); // 1\n// calc[_internal] is not easily accessible from outside\n```\n\n**Protocol Implementation:**\n```javascript\nconst RENDER = Symbol('render');\nconst UPDATE = Symbol('update');\n\nclass Component {\n  [RENDER]() {\n    return '<div>Component</div>';\n  }\n  \n  [UPDATE](data) {\n    console.log('Updating with:', data);\n  }\n}\n\n// Framework code can use these symbols\nfunction renderComponent(component) {\n  return component[RENDER]();\n}\n```\n\n**Monkey-patching Prevention:**\n```javascript\nconst originalMethod = Symbol('originalMethod');\n\n// Library code\nArray.prototype[originalMethod] = Array.prototype.push;\nArray.prototype.push = function(...items) {\n  console.log('Push called with:', items);\n  return this[originalMethod](...items);\n};\n\n// User code cannot accidentally override the original\nconst arr = [1, 2];\narr.push(3); // Logs and pushes\n```\n\n**Benefits:**\n- Guaranteed uniqueness\n- Non-enumerable properties\n- Avoid naming collisions\n- Enable meta-programming\n- Protocol definition\n- Private-like behavior",
      "keywords": ["symbols", "unique identifiers", "object properties", "Symbol.for", "well-known symbols", "Symbol.iterator", "meta-programming", "private properties", "enumerable", "global registry"],
      "difficulty": "medium"
    },
    {
      "id": 24,
      "tag": "javascript",
      "question": "Explain JavaScript's garbage collection and memory management.",
      "answer": "JavaScript automatically manages memory through garbage collection, but understanding it helps prevent memory leaks and optimize performance.\n\n**Memory Lifecycle:**\n1. **Allocation** - memory allocated when creating variables, objects, functions\n2. **Usage** - reading/writing to allocated memory\n3. **Release** - memory freed when no longer needed\n\n**Garbage Collection Algorithms:**\n\n**Reference Counting (Historical):**\n```javascript\n// Circular reference problem (old browsers)\nfunction createCircularReference() {\n  const obj1 = {};\n  const obj2 = {};\n  \n  obj1.ref = obj2;\n  obj2.ref = obj1; // Circular reference\n  \n  return { obj1, obj2 };\n}\n\n// Objects won't be garbage collected in old reference counting systems\n```\n\n**Mark-and-Sweep (Modern):**\n```javascript\n// Objects reachable from root are marked as \"in use\"\n// Unreachable objects are swept (garbage collected)\n\nfunction demonstration() {\n  const obj = { data: 'important' };\n  \n  // obj is reachable from function scope\n  return obj.data;\n  \n  // After function returns, obj becomes unreachable\n  // and eligible for garbage collection\n}\n```\n\n**Common Memory Leaks:**\n\n**1. Global Variables:**\n```javascript\n// Accidental globals\nfunction leakyFunction() {\n  // Missing 'var', 'let', or 'const'\n  accidentalGlobal = 'This creates a global variable';\n}\n\n// Fix: Use strict mode\n'use strict';\nfunction properFunction() {\n  const localVariable = 'This stays local';\n}\n```\n\n**2. Event Listeners:**\n```javascript\n// Memory leak\nfunction addListeners() {\n  const element = document.getElementById('button');\n  const data = new Array(1000000).fill('data');\n  \n  element.addEventListener('click', function() {\n    console.log(data.length); // Closure keeps data alive\n  });\n  \n  // Element removed but listener not cleaned up\n  element.remove();\n}\n\n// Fix: Remove listeners\nfunction properEventHandling() {\n  const element = document.getElementById('button');\n  const data = new Array(1000000).fill('data');\n  \n  function clickHandler() {\n    console.log(data.length);\n  }\n  \n  element.addEventListener('click', clickHandler);\n  \n  // Cleanup\n  return function cleanup() {\n    element.removeEventListener('click', clickHandler);\n  };\n}\n```\n\n**3. Timers:**\n```javascript\n// Memory leak\nfunction leakyTimer() {\n  const data = new Array(1000000).fill('data');\n  \n  setInterval(() => {\n    console.log(data.length); // Keeps data alive forever\n  }, 1000);\n}\n\n// Fix: Clear timers\nfunction properTimer() {\n  const data = new Array(1000000).fill('data');\n  \n  const intervalId = setInterval(() => {\n    console.log(data.length);\n  }, 1000);\n  \n  // Cleanup after 10 seconds\n  setTimeout(() => {\n    clearInterval(intervalId);\n  }, 10000);\n}\n```\n\n**4. Closures:**\n```javascript\n// Potential memory issue\nfunction createHandlers() {\n  const largeData = new Array(1000000).fill('data');\n  \n  return {\n    // This closure keeps entire largeData alive\n    small: () => largeData.length,\n    // Even though this doesn't use largeData\n    other: () => console.log('hello')\n  };\n}\n\n// Fix: Limit closure scope\nfunction createHandlersOptimized() {\n  const largeData = new Array(1000000).fill('data');\n  const dataLength = largeData.length; // Extract only needed value\n  \n  return {\n    small: () => dataLength, // Only keeps dataLength\n    other: () => console.log('hello')\n  };\n}\n```\n\n**Memory Monitoring:**\n```javascript\n// Check memory usage (browser only)\nif ('memory' in performance) {\n  console.log('Used:', performance.memory.usedJSHeapSize);\n  console.log('Total:', performance.memory.totalJSHeapSize);\n  console.log('Limit:', performance.memory.jsHeapSizeLimit);\n}\n\n// WeakMap for metadata without preventing GC\nconst metadata = new WeakMap();\n\nfunction attachMetadata(obj, data) {\n  metadata.set(obj, data);\n  // When obj is garbage collected, metadata entry is also removed\n}\n```\n\n**Best Practices:**\n- Use `const`/`let` instead of `var`\n- Remove event listeners when done\n- Clear timers and intervals\n- Avoid global variables\n- Use WeakMap/WeakSet for temporary associations\n- Be cautious with closures\n- Profile memory usage in development",
      "keywords": ["garbage collection", "memory management", "memory leaks", "mark-and-sweep", "reference counting", "closures", "event listeners", "timers", "WeakMap", "performance"],
      "difficulty": "hard"
    },
    {
      "id": 25,
      "tag": "javascript",
      "question": "What are Proxy and Reflect in JavaScript?",
      "answer": "Proxy and Reflect are ES6 features that enable meta-programming by intercepting and customizing object operations.\n\n**Proxy** - creates wrapper around object to intercept operations:\n\n```javascript\n// Basic proxy\nconst target = {\n  name: 'Alice',\n  age: 30\n};\n\nconst proxy = new Proxy(target, {\n  get(target, property, receiver) {\n    console.log(`Getting property: ${property}`);\n    return Reflect.get(target, property, receiver);\n  },\n  \n  set(target, property, value, receiver) {\n    console.log(`Setting ${property} to ${value}`);\n    return Reflect.set(target, property, value, receiver);\n  }\n});\n\nconsole.log(proxy.name); // \"Getting property: name\", \"Alice\"\nproxy.age = 31;          // \"Setting age to 31\"\n```\n\n**Proxy Traps (Handler Methods):**\n```javascript\nconst validatedObject = new Proxy({}, {\n  get(target, property) {\n    if (property in target) {\n      return target[property];\n    }\n    throw new Error(`Property '${property}' does not exist`);\n  },\n  \n  set(target, property, value) {\n    if (typeof property === 'string' && property.startsWith('_')) {\n      throw new Error('Cannot set private properties');\n    }\n    \n    if (property === 'age' && (typeof value !== 'number' || value < 0)) {\n      throw new Error('Age must be a positive number');\n    }\n    \n    target[property] = value;\n    return true;\n  },\n  \n  has(target, property) {\n    return property in target && !property.startsWith('_');\n  },\n  \n  deleteProperty(target, property) {\n    if (property.startsWith('_')) {\n      throw new Error('Cannot delete private properties');\n    }\n    delete target[property];\n    return true;\n  }\n});\n\n// Usage\nvalidatedObject.name = 'Bob';  // OK\nvalidatedObject.age = 25;      // OK\n// validatedObject.age = -5;   // Error: Age must be a positive number\n// validatedObject._private = 'secret'; // Error: Cannot set private properties\n```\n\n**Function Proxies:**\n```javascript\nfunction originalFunction(a, b) {\n  return a + b;\n}\n\nconst proxiedFunction = new Proxy(originalFunction, {\n  apply(target, thisArg, args) {\n    console.log(`Calling function with args: ${args}`);\n    \n    // Validate arguments\n    if (args.some(arg => typeof arg !== 'number')) {\n      throw new Error('All arguments must be numbers');\n    }\n    \n    const result = Reflect.apply(target, thisArg, args);\n    console.log(`Result: ${result}`);\n    return result;\n  }\n});\n\nproxiedFunction(2, 3); // \"Calling function...\", \"Result: 5\", returns 5\n```\n\n**Reflect** - provides default object operations as functions:\n\n```javascript\nconst obj = { x: 1, y: 2 };\n\n// Reflect methods mirror proxy traps\nReflect.get(obj, 'x');           // 1 (same as obj.x)\nReflect.set(obj, 'z', 3);        // true (same as obj.z = 3)\nReflect.has(obj, 'x');           // true (same as 'x' in obj)\nReflect.deleteProperty(obj, 'y'); // true (same as delete obj.y)\n\n// Get property descriptors\nconst descriptor = Reflect.getOwnPropertyDescriptor(obj, 'x');\nconsole.log(descriptor); // { value: 1, writable: true, enumerable: true, configurable: true }\n\n// Prototype operations\nReflect.getPrototypeOf(obj);     // Object.prototype\nReflect.setPrototypeOf(obj, {}); // true\n```\n\n**Practical Applications:**\n\n**1. Observable Objects:**\n```javascript\nfunction createObservable(target, onChange) {\n  return new Proxy(target, {\n    set(target, property, value, receiver) {\n      const oldValue = target[property];\n      const result = Reflect.set(target, property, value, receiver);\n      \n      if (oldValue !== value) {\n        onChange(property, value, oldValue);\n      }\n      \n      return result;\n    }\n  });\n}\n\nconst state = createObservable(\n  { count: 0 },\n  (prop, newVal, oldVal) => {\n    console.log(`${prop} changed from ${oldVal} to ${newVal}`);\n  }\n);\n\nstate.count = 1; // \"count changed from 0 to 1\"\n```\n\n**2. API Wrapper:**\n```javascript\nconst api = new Proxy({}, {\n  get(target, endpoint) {\n    return function(options = {}) {\n      const url = `https://api.example.com/${endpoint}`;\n      return fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        ...options\n      }).then(response => response.json());\n    };\n  }\n});\n\n// Usage\napi.users().then(users => console.log(users));\napi.posts({ method: 'POST', body: JSON.stringify(data) });\n```\n\n**3. Default Values:**\n```javascript\nconst withDefaults = new Proxy({}, {\n  get(target, property) {\n    return property in target ? target[property] : 'default';\n  }\n});\n\nwithDefaults.name = 'Alice';\nconsole.log(withDefaults.name);     // 'Alice'\nconsole.log(withDefaults.unknown);  // 'default'\n```\n\n**Benefits:**\n- Intercept object operations\n- Create virtual properties\n- Implement custom behavior\n- Build reactive systems\n- Create DSLs (Domain Specific Languages)",
      "keywords": ["proxy", "reflect", "meta-programming", "traps", "handler", "intercept", "observable", "reactive", "virtual properties", "API wrapper"],
      "difficulty": "medium"
    },
    {
      "id": 26,
      "tag": "javascript",
      "question": "What is the difference between deep and shallow copying?",
      "answer": "Deep and shallow copying refer to different approaches for duplicating objects and arrays in JavaScript.\n\n**Shallow Copy** - copies only the first level of properties:\n\n```javascript\nconst original = {\n  name: 'Alice',\n  age: 30,\n  address: {\n    city: 'New York',\n    country: 'USA'\n  },\n  hobbies: ['reading', 'swimming']\n};\n\n// Shallow copy methods\nconst shallow1 = Object.assign({}, original);\nconst shallow2 = { ...original };\nconst shallow3 = Object.create(Object.getPrototypeOf(original), Object.getOwnPropertyDescriptors(original));\n\n// Modify nested object\nshallow1.address.city = 'Boston';\nconsole.log(original.address.city); // 'Boston' - original affected!\n\n// Modify array\nshallow2.hobbies.push('cooking');\nconsole.log(original.hobbies); // ['reading', 'swimming', 'cooking'] - original affected!\n\n// But top-level properties are independent\nshallow1.name = 'Bob';\nconsole.log(original.name); // 'Alice' - original not affected\n```\n\n**Deep Copy** - recursively copies all levels:\n\n```javascript\n// Method 1: JSON.parse/stringify (limited)\nconst deepCopy1 = JSON.parse(JSON.stringify(original));\ndeepCopy1.address.city = 'Chicago';\nconsole.log(original.address.city); // 'New York' - original not affected\n\n// Limitations of JSON method:\nconst complexObject = {\n  date: new Date(),\n  regex: /pattern/g,\n  func: () => 'hello',\n  undefined: undefined,\n  symbol: Symbol('test'),\n  [Symbol('key')]: 'value'\n};\n\nconst jsonCopy = JSON.parse(JSON.stringify(complexObject));\nconsole.log(jsonCopy);\n// {\n//   date: '2023-12-07T10:30:00.000Z', // String, not Date\n//   regex: {},                         // Empty object\n//   // func, undefined, symbols are lost\n// }\n```\n\n**Custom Deep Copy Implementation:**\n```javascript\nfunction deepCopy(obj, visited = new WeakMap()) {\n  // Handle null, undefined, and primitives\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle circular references\n  if (visited.has(obj)) {\n    return visited.get(obj);\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags);\n  }\n  \n  // Handle Arrays\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    visited.set(obj, arrCopy);\n    \n    for (let i = 0; i < obj.length; i++) {\n      arrCopy[i] = deepCopy(obj[i], visited);\n    }\n    \n    return arrCopy;\n  }\n  \n  // Handle Objects\n  const objCopy = Object.create(Object.getPrototypeOf(obj));\n  visited.set(obj, objCopy);\n  \n  // Copy own properties (including non-enumerable)\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  for (const key of Object.keys(descriptors)) {\n    if (descriptors[key].value !== undefined) {\n      descriptors[key].value = deepCopy(descriptors[key].value, visited);\n    }\n  }\n  Object.defineProperties(objCopy, descriptors);\n  \n  // Copy symbol properties\n  const symbols = Object.getOwnPropertySymbols(obj);\n  for (const symbol of symbols) {\n    objCopy[symbol] = deepCopy(obj[symbol], visited);\n  }\n  \n  return objCopy;\n}\n\n// Test with circular reference\nconst circular = { name: 'test' };\ncircular.self = circular;\n\nconst deepCopyResult = deepCopy(circular);\nconsole.log(deepCopyResult.self === deepCopyResult); // true - maintains structure\nconsole.log(deepCopyResult === circular); // false - different objects\n```\n\n**Modern Approaches:**\n\n**Using structuredClone (modern browsers):**\n```javascript\nconst original = {\n  date: new Date(),\n  regex: /test/g,\n  nested: { value: 42 },\n  array: [1, 2, { inner: 'value' }]\n};\n\nconst cloned = structuredClone(original);\ncloned.nested.value = 99;\nconsole.log(original.nested.value); // 42 - not affected\n\n// Supports most built-in types but not functions\n```\n\n**Library Solutions:**\n```javascript\n// Lodash cloneDeep\nconst _ = require('lodash');\nconst lodashDeep = _.cloneDeep(original);\n\n// Ramda clone\nconst R = require('ramda');\nconst ramdaClone = R.clone(original);\n```\n\n**Performance Considerations:**\n```javascript\n// Benchmark different approaches\nconst largeObject = {\n  // ... large nested structure\n};\n\nconsole.time('JSON');\nconst jsonCopy = JSON.parse(JSON.stringify(largeObject));\nconsole.timeEnd('JSON'); // Often fastest for simple objects\n\nconsole.time('Custom');\nconst customCopy = deepCopy(largeObject);\nconsole.timeEnd('Custom'); // More thorough but slower\n\nconsole.time('structuredClone');\nconst structuredCopy = structuredClone(largeObject);\nconsole.timeEnd('structuredClone'); // Good balance\n```\n\n**When to Use Each:**\n\n**Shallow Copy:**\n- Performance-critical code\n- Objects with only primitive values\n- When you only need to modify top-level properties\n\n**Deep Copy:**\n- Complex nested structures\n- When complete independence is required\n- Implementing undo/redo functionality\n- State management in applications",
      "keywords": ["shallow copy", "deep copy", "object cloning", "nested objects", "JSON.parse", "JSON.stringify", "structuredClone", "circular references", "performance", "WeakMap"],
      "difficulty": "medium"
    },
    {
      "id": 27,
      "tag": "javascript",
      "question": "What are Worker threads and how do they help with performance?",
      "answer": "Web Workers enable running JavaScript in background threads, allowing for concurrent execution without blocking the main UI thread.\n\n**Types of Workers:**\n\n**1. Web Workers (Dedicated Workers):**\n```javascript\n// main.js\nconst worker = new Worker('worker.js');\n\n// Send data to worker\nworker.postMessage({\n  command: 'calculate',\n  data: [1, 2, 3, 4, 5]\n});\n\n// Receive results from worker\nworker.onmessage = function(event) {\n  const { result, status } = event.data;\n  console.log('Result:', result);\n  \n  if (status === 'complete') {\n    worker.terminate(); // Clean up\n  }\n};\n\n// Handle errors\nworker.onerror = function(error) {\n  console.error('Worker error:', error);\n};\n```\n\n```javascript\n// worker.js\nself.onmessage = function(event) {\n  const { command, data } = event.data;\n  \n  if (command === 'calculate') {\n    // CPU-intensive calculation\n    let result = 0;\n    for (let i = 0; i < data.length; i++) {\n      // Simulate heavy computation\n      for (let j = 0; j < 1000000; j++) {\n        result += data[i] * Math.random();\n      }\n    }\n    \n    // Send result back to main thread\n    self.postMessage({\n      result: result,\n      status: 'complete'\n    });\n  }\n};\n\n// Handle errors in worker\nself.onerror = function(error) {\n  console.error('Error in worker:', error);\n};\n```\n\n**2. Shared Workers:**\n```javascript\n// Can be shared between multiple scripts/pages\nconst sharedWorker = new SharedWorker('shared-worker.js');\nconst port = sharedWorker.port;\n\nport.onmessage = function(event) {\n  console.log('Received from shared worker:', event.data);\n};\n\nport.postMessage('Hello from page 1');\nport.start();\n```\n\n```javascript\n// shared-worker.js\nconst connections = [];\n\nself.onconnect = function(event) {\n  const port = event.ports[0];\n  connections.push(port);\n  \n  port.onmessage = function(event) {\n    // Broadcast to all connected ports\n    connections.forEach(conn => {\n      if (conn !== port) {\n        conn.postMessage(`Broadcast: ${event.data}`);\n      }\n    });\n  };\n  \n  port.start();\n};\n```\n\n**3. Service Workers:**\n```javascript\n// Register service worker\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('service-worker.js')\n    .then(registration => {\n      console.log('SW registered:', registration);\n    })\n    .catch(error => {\n      console.log('SW registration failed:', error);\n    });\n}\n```\n\n```javascript\n// service-worker.js\nself.addEventListener('install', event => {\n  console.log('Service worker installing');\n  // Cache resources\n  event.waitUntil(\n    caches.open('v1').then(cache => {\n      return cache.addAll([\n        '/',\n        '/styles.css',\n        '/script.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // Intercept network requests\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n**Practical Examples:**\n\n**Image Processing:**\n```javascript\n// main.js\nfunction processImage(imageData) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker('image-processor.js');\n    \n    worker.postMessage({\n      imageData: imageData,\n      filter: 'blur'\n    });\n    \n    worker.onmessage = function(event) {\n      resolve(event.data.processedImageData);\n      worker.terminate();\n    };\n    \n    worker.onerror = reject;\n  });\n}\n\n// Usage\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\nprocessImage(imageData).then(processedData => {\n  ctx.putImageData(processedData, 0, 0);\n});\n```\n\n**Data Processing:**\n```javascript\n// main.js\nclass DataProcessor {\n  constructor() {\n    this.worker = new Worker('data-worker.js');\n    this.pendingTasks = new Map();\n    \n    this.worker.onmessage = (event) => {\n      const { taskId, result, error } = event.data;\n      const { resolve, reject } = this.pendingTasks.get(taskId);\n      \n      if (error) {\n        reject(new Error(error));\n      } else {\n        resolve(result);\n      }\n      \n      this.pendingTasks.delete(taskId);\n    };\n  }\n  \n  async processLargeDataset(data) {\n    const taskId = Date.now() + Math.random();\n    \n    return new Promise((resolve, reject) => {\n      this.pendingTasks.set(taskId, { resolve, reject });\n      \n      this.worker.postMessage({\n        taskId,\n        type: 'PROCESS_DATA',\n        data\n      });\n    });\n  }\n  \n  terminate() {\n    this.worker.terminate();\n  }\n}\n\n// Usage\nconst processor = new DataProcessor();\nprocessor.processLargeDataset(largeArray)\n  .then(result => console.log('Processed:', result))\n  .catch(error => console.error('Error:', error));\n```\n\n**Worker Pool Pattern:**\n```javascript\nclass WorkerPool {\n  constructor(workerScript, poolSize = 4) {\n    this.workers = [];\n    this.queue = [];\n    this.busyWorkers = new Set();\n    \n    for (let i = 0; i < poolSize; i++) {\n      const worker = new Worker(workerScript);\n      worker.onmessage = (event) => this.handleWorkerMessage(worker, event);\n      this.workers.push(worker);\n    }\n  }\n  \n  execute(data) {\n    return new Promise((resolve, reject) => {\n      const task = { data, resolve, reject };\n      \n      const availableWorker = this.workers.find(w => !this.busyWorkers.has(w));\n      \n      if (availableWorker) {\n        this.assignTask(availableWorker, task);\n      } else {\n        this.queue.push(task);\n      }\n    });\n  }\n  \n  assignTask(worker, task) {\n    this.busyWorkers.add(worker);\n    worker.currentTask = task;\n    worker.postMessage(task.data);\n  }\n  \n  handleWorkerMessage(worker, event) {\n    const task = worker.currentTask;\n    task.resolve(event.data);\n    \n    this.busyWorkers.delete(worker);\n    worker.currentTask = null;\n    \n    // Process queued tasks\n    if (this.queue.length > 0) {\n      const nextTask = this.queue.shift();\n      this.assignTask(worker, nextTask);\n    }\n  }\n}\n```\n\n**Benefits and Limitations:**\n\n**Benefits:**\n- Non-blocking UI\n- True parallelism\n- Improved performance for CPU-intensive tasks\n- Better user experience\n\n**Limitations:**\n- No direct DOM access\n- Limited API access\n- Communication overhead\n- Memory usage\n- Debugging complexity\n\n**Best Practices:**\n- Use for CPU-intensive tasks\n- Pool workers for repeated operations\n- Handle errors properly\n- Clean up workers when done\n- Consider transferable objects for large data",
      "keywords": ["web workers", "worker threads", "background processing", "parallelism", "postMessage", "service workers", "shared workers", "performance", "non-blocking", "CPU-intensive"],
      "difficulty": "medium"
    },
    {
      "id": 28,
      "tag": "javascript",
      "question": "What are the different ways to handle errors in JavaScript?",
      "answer": "JavaScript provides multiple mechanisms for error handling, from basic try-catch to advanced patterns for different scenarios.\n\n**Basic Error Handling:**\n\n**try-catch-finally:**\n```javascript\nfunction basicErrorHandling() {\n  try {\n    // Code that might throw an error\n    const result = riskyOperation();\n    return result;\n  } catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n    return null;\n  } finally {\n    // Always executed\n    console.log('Cleanup operations');\n  }\n}\n\n// Catching specific error types\nfunction specificErrorHandling() {\n  try {\n    JSON.parse('invalid json');\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      console.log('JSON parsing error');\n    } else if (error instanceof ReferenceError) {\n      console.log('Reference error');\n    } else {\n      console.log('Unknown error:', error);\n    }\n  }\n}\n```\n\n**Custom Error Classes:**\n```javascript\n// Custom error types\nclass ValidationError extends Error {\n  constructor(message, field) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NetworkError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.name = 'NetworkError';\n    this.statusCode = statusCode;\n  }\n}\n\n// Usage\nfunction validateUser(user) {\n  if (!user.email) {\n    throw new ValidationError('Email is required', 'email');\n  }\n  if (!user.email.includes('@')) {\n    throw new ValidationError('Invalid email format', 'email');\n  }\n}\n\ntry {\n  validateUser({ name: 'John' });\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.log(`Validation failed for ${error.field}: ${error.message}`);\n  }\n}\n```\n\n**Async Error Handling:**\n\n**Promise-based:**\n```javascript\n// Promise catch\nfetch('/api/data')\n  .then(response => {\n    if (!response.ok) {\n      throw new NetworkError(`HTTP ${response.status}`, response.status);\n    }\n    return response.json();\n  })\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error instanceof NetworkError) {\n      console.log(`Network error: ${error.message}`);\n    } else {\n      console.log('Unexpected error:', error);\n    }\n  });\n\n// Async/await with try-catch\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    \n    if (!response.ok) {\n      throw new NetworkError(`User not found`, response.status);\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    if (error instanceof NetworkError && error.statusCode === 404) {\n      return null; // User not found\n    }\n    throw error; // Re-throw unexpected errors\n  }\n}\n```\n\n**Global Error Handling:**\n```javascript\n// Unhandled promise rejections\nwindow.addEventListener('unhandledrejection', event => {\n  console.error('Unhandled promise rejection:', event.reason);\n  \n  // Prevent default browser behavior\n  event.preventDefault();\n  \n  // Report to error service\n  reportError(event.reason);\n});\n\n// Global error handler\nwindow.addEventListener('error', event => {\n  console.error('Global error:', {\n    message: event.message,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    error: event.error\n  });\n  \n  reportError(event.error);\n});\n\n// Error reporting function\nfunction reportError(error) {\n  // Send to monitoring service\n  fetch('/api/errors', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    })\n  }).catch(err => console.log('Failed to report error:', err));\n}\n```\n\n**Error Boundaries (React-like pattern):**\n```javascript\nclass ErrorBoundary {\n  constructor(component, fallback) {\n    this.component = component;\n    this.fallback = fallback;\n    this.hasError = false;\n  }\n  \n  render() {\n    if (this.hasError) {\n      return this.fallback;\n    }\n    \n    try {\n      return this.component();\n    } catch (error) {\n      this.hasError = true;\n      console.error('Component error:', error);\n      return this.fallback;\n    }\n  }\n  \n  reset() {\n    this.hasError = false;\n  }\n}\n\n// Usage\nfunction RiskyComponent() {\n  throw new Error('Component failed');\n}\n\nfunction FallbackComponent() {\n  return '<div>Something went wrong</div>';\n}\n\nconst boundary = new ErrorBoundary(RiskyComponent, FallbackComponent);\nconsole.log(boundary.render()); // \"<div>Something went wrong</div>\"\n```\n\n**Functional Error Handling Patterns:**\n\n**Result/Either Pattern:**\n```javascript\nclass Result {\n  constructor(value, error) {\n    this.value = value;\n    this.error = error;\n  }\n  \n  static ok(value) {\n    return new Result(value, null);\n  }\n  \n  static error(error) {\n    return new Result(null, error);\n  }\n  \n  isOk() {\n    return this.error === null;\n  }\n  \n  isError() {\n    return this.error !== null;\n  }\n  \n  map(fn) {\n    if (this.isError()) return this;\n    try {\n      return Result.ok(fn(this.value));\n    } catch (error) {\n      return Result.error(error);\n    }\n  }\n  \n  flatMap(fn) {\n    if (this.isError()) return this;\n    try {\n      return fn(this.value);\n    } catch (error) {\n      return Result.error(error);\n    }\n  }\n}\n\n// Usage\nfunction divide(a, b) {\n  if (b === 0) {\n    return Result.error(new Error('Division by zero'));\n  }\n  return Result.ok(a / b);\n}\n\nconst result = divide(10, 2)\n  .map(x => x * 2)\n  .map(x => x + 1);\n\nif (result.isOk()) {\n  console.log('Result:', result.value); // 11\n} else {\n  console.log('Error:', result.error.message);\n}\n```\n\n**Circuit Breaker Pattern:**\n```javascript\nclass CircuitBreaker {\n  constructor(failureThreshold = 5, timeout = 60000) {\n    this.failureThreshold = failureThreshold;\n    this.timeout = timeout;\n    this.failureCount = 0;\n    this.lastFailureTime = null;\n    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN\n  }\n  \n  async call(fn) {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'HALF_OPEN';\n      } else {\n        throw new Error('Circuit breaker is OPEN');\n      }\n    }\n    \n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  onSuccess() {\n    this.failureCount = 0;\n    this.state = 'CLOSED';\n  }\n  \n  onFailure() {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n    }\n  }\n}\n\n// Usage\nconst breaker = new CircuitBreaker(3, 5000);\n\nasync function makeApiCall() {\n  return breaker.call(() => fetch('/api/data'));\n}\n```\n\n**Best Practices:**\n- Use specific error types\n- Provide meaningful error messages\n- Log errors appropriately\n- Don't catch and ignore errors\n- Clean up resources in finally blocks\n- Use error boundaries for UI components\n- Implement proper error monitoring\n- Consider functional error handling patterns",
      "keywords": ["error handling", "try-catch", "custom errors", "promise catch", "async await", "global error handler", "unhandled rejection", "circuit breaker", "Result pattern", "error boundaries"],
      "difficulty": "medium"
    },
    {
      "id": 29,
      "tag": "javascript",
      "question": "Explain JavaScript's type coercion and how to avoid common pitfalls.",
      "answer": "Type coercion is JavaScript's automatic conversion of values from one type to another, which can lead to unexpected behavior if not understood properly.\n\n**Implicit Type Coercion:**\n\n**String Conversion:**\n```javascript\n// + operator with strings\nconsole.log('5' + 3);        // '53' (number to string)\nconsole.log('Hello' + true); // 'Hellotrue'\nconsole.log('5' + null);     // '5null'\nconsole.log('5' + undefined); // '5undefined'\n\n// Template literals\nconsole.log(`Value: ${42}`); // 'Value: 42'\n\n// String() function\nconsole.log(String(123));    // '123'\nconsole.log(String(true));   // 'true'\nconsole.log(String(null));   // 'null'\n```\n\n**Number Conversion:**\n```javascript\n// Arithmetic operators (except +)\nconsole.log('5' - 3);     // 2\nconsole.log('10' * 2);    // 20\nconsole.log('15' / 3);    // 5\nconsole.log('5' % 2);     // 1\n\n// Unary + operator\nconsole.log(+'42');       // 42\nconsole.log(+true);       // 1\nconsole.log(+false);      // 0\nconsole.log(+null);       // 0\nconsole.log(+undefined);  // NaN\nconsole.log(+'hello');    // NaN\n\n// Number() function\nconsole.log(Number('123')); // 123\nconsole.log(Number(''));    // 0\nconsole.log(Number(' '));   // 0\n```\n\n**Boolean Conversion:**\n```javascript\n// Falsy values\nconsole.log(Boolean(false));     // false\nconsole.log(Boolean(0));         // false\nconsole.log(Boolean(-0));        // false\nconsole.log(Boolean(0n));        // false (BigInt zero)\nconsole.log(Boolean(''));        // false\nconsole.log(Boolean(null));      // false\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(NaN));       // false\n\n// Everything else is truthy\nconsole.log(Boolean('0'));       // true (string '0')\nconsole.log(Boolean('false'));   // true (string 'false')\nconsole.log(Boolean([]));        // true (empty array)\nconsole.log(Boolean({}));        // true (empty object)\nconsole.log(Boolean(function(){})); // true\n```\n\n**Comparison Coercion:**\n\n**Abstract Equality (==):**\n```javascript\n// Same type - no coercion\nconsole.log(5 == 5);          // true\nconsole.log('hello' == 'hello'); // true\n\n// null and undefined\nconsole.log(null == undefined); // true\nconsole.log(null == 0);         // false\nconsole.log(undefined == 0);    // false\n\n// Number and string\nconsole.log(5 == '5');          // true (string to number)\nconsole.log(0 == '');           // true\nconsole.log(0 == '0');          // true\n\n// Boolean conversion\nconsole.log(true == 1);         // true\nconsole.log(false == 0);        // true\nconsole.log(true == '1');       // true\nconsole.log(false == '');       // true\n\n// Object to primitive\nconsole.log([1] == 1);          // true\nconsole.log([1,2] == '1,2');    // true\nconsole.log({} == '[object Object]'); // true\n```\n\n**Common Pitfalls:**\n\n**Array Coercion:**\n```javascript\n// Array to number/string conversion\nconsole.log([] + []);           // '' (empty string)\nconsole.log([1] + [2]);         // '12' (string concatenation)\nconsole.log([1,2] + [3,4]);     // '1,23,4'\n\n// Array in boolean context\nif ([]) {\n  console.log('Empty array is truthy!'); // This runs\n}\n\n// Array comparison\nconsole.log([] == 0);           // true\nconsole.log([] == false);       // true\nconsole.log([] == '');          // true\n```\n\n**Object Coercion:**\n```javascript\n// Object to primitive conversion\nconst obj = {\n  valueOf() { return 42; },\n  toString() { return 'hello'; }\n};\n\nconsole.log(obj + 1);           // 43 (valueOf used)\nconsole.log(obj + '');          // '42' (valueOf used)\nconsole.log(String(obj));       // 'hello' (toString used)\n\n// Date objects\nconst date = new Date(2023, 0, 1);\nconsole.log(date + 1000);       // String concatenation\nconsole.log(+date);             // Number (timestamp)\n```\n\n**Prevention Strategies:**\n\n**1. Use Strict Equality:**\n```javascript\n// Always prefer === and !==\nif (value === null) { /* ... */ }\nif (typeof value === 'string') { /* ... */ }\nif (array.length === 0) { /* ... */ }\n\n// ESLint rule: eqeqeq\n```\n\n**2. Explicit Type Conversion:**\n```javascript\n// Be explicit about conversions\nconst str = String(value);           // Not: '' + value\nconst num = Number(value);           // Not: +value\nconst bool = Boolean(value);         // Not: !!value\n\n// For specific conversions\nconst int = parseInt(str, 10);       // Always specify radix\nconst float = parseFloat(str);\n```\n\n**3. Input Validation:**\n```javascript\nfunction safeDivide(a, b) {\n  // Validate types\n  if (typeof a !== 'number' || typeof b !== 'number') {\n    throw new TypeError('Both arguments must be numbers');\n  }\n  \n  // Validate values\n  if (isNaN(a) || isNaN(b)) {\n    throw new Error('Arguments cannot be NaN');\n  }\n  \n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  \n  return a / b;\n}\n```\n\n**4. Utility Functions:**\n```javascript\n// Type checking utilities\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\nfunction isEmpty(value) {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string') return value.length === 0;\n  if (Array.isArray(value)) return value.length === 0;\n  if (typeof value === 'object') return Object.keys(value).length === 0;\n  return false;\n}\n\n// Safe conversion utilities\nfunction toNumber(value, defaultValue = 0) {\n  const num = Number(value);\n  return isNaN(num) ? defaultValue : num;\n}\n\nfunction toString(value, defaultValue = '') {\n  if (value === null || value === undefined) return defaultValue;\n  return String(value);\n}\n```\n\n**5. TypeScript:**\n```typescript\n// Use TypeScript for type safety\nfunction add(a: number, b: number): number {\n  return a + b; // Type errors caught at compile time\n}\n\n// Type guards\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  }\n}\n```\n\n**Best Practices:**\n- Always use strict equality (===, !==)\n- Be explicit about type conversions\n- Validate inputs in functions\n- Use TypeScript for larger projects\n- Enable strict ESLint rules\n- Test edge cases with different types\n- Understand the coercion rules\n- Prefer functional programming patterns",
      "keywords": ["type coercion", "implicit conversion", "strict equality", "loose equality", "truthy", "falsy", "type conversion", "comparison operators", "validation", "TypeScript"],
      "difficulty": "medium"
    }
  ]
}