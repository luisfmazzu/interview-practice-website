{
  "technology": "javascript",
  "questions": [
    {
      "id": 0,
      "tag": "javascript",
      "question": "Explain the difference between `let`, `const`, and `var` in JavaScript.",
      "answer": "**var:**\n- Function-scoped or globally-scoped\n- Can be redeclared and updated\n- Hoisted with undefined initialization\n- Creates property on global object\n\n**let:**\n- Block-scoped\n- Can be updated but not redeclared in same scope\n- Hoisted but not initialized (temporal dead zone)\n- Does not create property on global object\n\n**const:**\n- Block-scoped\n- Cannot be updated or redeclared\n- Must be initialized at declaration\n- Hoisted but not initialized (temporal dead zone)\n- For objects/arrays, contents can be modified",
      "keywords": ["block scope", "function scope", "hoisting", "temporal dead zone", "redeclaration", "reassignment", "global object"],
      "difficulty": "easy"
    },
    {
      "id": 1,
      "tag": "javascript",
      "question": "What is a closure in JavaScript? Provide an example.",
      "answer": "A closure is a function that has access to variables in its outer (enclosing) scope even after the outer function has returned.\n\n**Example:**\n```javascript\nfunction outerFunction(x) {\n  return function innerFunction(y) {\n    return x + y; // Has access to 'x'\n  };\n}\n\nconst addFive = outerFunction(5);\nconsole.log(addFive(3)); // 8\n```\n\n**Key points:**\n- Inner function maintains reference to outer scope\n- Enables data privacy and encapsulation\n- Commonly used in module patterns and callbacks\n- Can cause memory leaks if not handled properly",
      "keywords": ["outer scope", "inner function", "lexical scoping", "data privacy", "encapsulation", "module pattern", "callbacks", "memory leaks"],
      "difficulty": "medium"
    },
    {
      "id": 2,
      "tag": "javascript",
      "question": "Explain event bubbling and capturing in the DOM.",
      "answer": "Event propagation has three phases:\n\n**1. Capturing Phase:**\n- Event travels from root to target element\n- Rarely used, can be enabled with `addEventListener(event, handler, true)`\n\n**2. Target Phase:**\n- Event reaches the target element\n\n**3. Bubbling Phase:**\n- Event bubbles up from target to root\n- Default behavior\n\n**Example:**\n```javascript\n// Bubbling (default)\nelement.addEventListener('click', handler);\n\n// Capturing\nelement.addEventListener('click', handler, true);\n\n// Stop propagation\nevent.stopPropagation();\n```\n\n**Use cases:**\n- Event delegation\n- Handling events on dynamically created elements",
      "keywords": ["event propagation", "capturing phase", "bubbling phase", "target phase", "addEventListener", "stopPropagation", "event delegation"],
      "difficulty": "medium"
    },
    {
      "id": 3,
      "tag": "javascript",
      "question": "What is the difference between `==` and `===` in JavaScript?",
      "answer": "**== (Loose Equality):**\n- Performs type coercion before comparison\n- Converts operands to same type, then compares\n- Can lead to unexpected results\n\n**=== (Strict Equality):**\n- No type coercion\n- Compares both value and type\n- Recommended for most comparisons\n\n**Examples:**\n```javascript\n// Loose equality\n'5' == 5    // true (string coerced to number)\n0 == false  // true\nnull == undefined // true\n\n// Strict equality\n'5' === 5    // false (different types)\n0 === false  // false\nnull === undefined // false\n```\n\n**Best practice:** Use `===` unless you specifically need type coercion.",
      "keywords": ["type coercion", "loose equality", "strict equality", "value comparison", "type comparison", "best practices"],
      "difficulty": "easy"
    },
    {
      "id": 4,
      "tag": "javascript",
      "question": "Explain the concept of hoisting in JavaScript.",
      "answer": "Hoisting is JavaScript's behavior of moving declarations to the top of their scope during compilation.\n\n**Variable Hoisting:**\n```javascript\nconsole.log(x); // undefined (not error)\nvar x = 5;\n\n// Equivalent to:\nvar x;\nconsole.log(x); // undefined\nx = 5;\n```\n\n**Function Hoisting:**\n```javascript\n// Function declarations are fully hoisted\nsayHello(); // Works!\n\nfunction sayHello() {\n  console.log('Hello!');\n}\n\n// Function expressions are not hoisted\nsayGoodbye(); // TypeError\nvar sayGoodbye = function() {\n  console.log('Goodbye!');\n};\n```\n\n**let/const:**\n- Hoisted but not initialized (temporal dead zone)\n- Accessing before declaration throws ReferenceError",
      "keywords": ["hoisting", "declarations", "compilation", "function declarations", "function expressions", "temporal dead zone", "scope"],
      "difficulty": "medium"
    },
    {
      "id": 5,
      "tag": "javascript",
      "question": "What are arrow functions and how do they differ from regular functions?",
      "answer": "Arrow functions are a concise way to write functions introduced in ES6.\n\n**Syntax:**\n```javascript\n// Regular function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\n\n// Multiple statements\nconst multiply = (a, b) => {\n  const result = a * b;\n  return result;\n};\n```\n\n**Key Differences:**\n1. **No `this` binding** - inherits from enclosing scope\n2. **Cannot be used as constructors** - no `new` operator\n3. **No `arguments` object** - use rest parameters instead\n4. **Cannot be hoisted** - must be defined before use\n5. **More concise syntax** for simple functions\n\n**Example of `this` behavior:**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n  \n  increment() {\n    // Arrow function inherits `this` from Counter\n    setTimeout(() => {\n      this.count++; // Works correctly\n    }, 1000);\n  }\n}\n```",
      "keywords": ["ES6", "arrow functions", "this binding", "lexical scope", "constructors", "arguments object", "concise syntax", "hoisting"],
      "difficulty": "easy"
    },
    {
      "id": 6,
      "tag": "javascript",
      "question": "Explain destructuring assignment in JavaScript.",
      "answer": "Destructuring allows unpacking values from arrays or properties from objects into distinct variables.\n\n**Array Destructuring:**\n```javascript\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\nconsole.log(first); // 1\nconsole.log(rest);  // [3, 4, 5]\n\n// Skipping elements\nconst [a, , c] = [1, 2, 3];\nconsole.log(a, c); // 1, 3\n\n// Default values\nconst [x = 10, y = 20] = [5];\nconsole.log(x, y); // 5, 20\n```\n\n**Object Destructuring:**\n```javascript\nconst user = { name: 'John', age: 30, city: 'NYC' };\nconst { name, age, country = 'USA' } = user;\n\n// Renaming variables\nconst { name: userName, age: userAge } = user;\n\n// Nested destructuring\nconst { address: { street } } = { address: { street: '123 Main' } };\n```\n\n**Function Parameters:**\n```javascript\nfunction greet({ name, age = 25 }) {\n  console.log(`Hello ${name}, you are ${age}`);\n}\n\ngreet({ name: 'Alice' }); // Hello Alice, you are 25\n```",
      "keywords": ["destructuring", "array destructuring", "object destructuring", "rest operator", "default values", "parameter destructuring", "variable assignment"],
      "difficulty": "easy"
    },
    {
      "id": 7,
      "tag": "javascript",
      "question": "What is the difference between `null` and `undefined`?",
      "answer": "`null` and `undefined` both represent absence of value but have different meanings and behaviors.\n\n**undefined:**\n- Default value for uninitialized variables\n- Returned when accessing non-existent object properties\n- Returned by functions that don't explicitly return a value\n- Type is 'undefined'\n\n**null:**\n- Intentional absence of value\n- Must be explicitly assigned\n- Represents 'no value' or 'empty value'\n- Type is 'object' (historical JavaScript quirk)\n\n**Examples:**\n```javascript\nlet x;\nconsole.log(x); // undefined\n\nconst obj = {};\nconsole.log(obj.property); // undefined\n\nfunction doSomething() {}\nconsole.log(doSomething()); // undefined\n\n// null assignment\nlet data = null; // Intentionally empty\n\n// Type checking\ntypeof undefined; // 'undefined'\ntypeof null;      // 'object'\n\n// Equality\nnull == undefined;  // true (loose equality)\nnull === undefined; // false (strict equality)\n```\n\n**Best Practice:** Use `null` when you want to intentionally represent 'no value'.",
      "keywords": ["null", "undefined", "type checking", "uninitialized variables", "intentional absence", "equality comparison", "typeof operator"],
      "difficulty": "easy"
    },
    {
      "id": 8,
      "tag": "javascript",
      "question": "What are template literals and their advantages?",
      "answer": "Template literals are string literals that allow embedded expressions and multi-line strings, introduced in ES6.\n\n**Syntax:**\n```javascript\n// Basic template literal\nconst message = `Hello, World!`;\n\n// String interpolation\nconst name = 'Alice';\nconst age = 25;\nconst greeting = `Hello ${name}, you are ${age} years old`;\n\n// Expression evaluation\nconst total = `Total: ${price * quantity + tax}`;\n\n// Multi-line strings\nconst html = `\n  <div>\n    <h1>Title</h1>\n    <p>Content goes here</p>\n  </div>\n`;\n```\n\n**Advantages:**\n1. **String interpolation** - embed variables and expressions\n2. **Multi-line strings** - no need for concatenation or escape characters\n3. **Expression evaluation** - can include function calls and calculations\n4. **Improved readability** - cleaner syntax than concatenation\n\n**Tagged Templates:**\n```javascript\nfunction highlight(strings, ...values) {\n  return strings.reduce((result, string, i) => {\n    const value = values[i] ? `<mark>${values[i]}</mark>` : '';\n    return result + string + value;\n  }, '');\n}\n\nconst term = 'JavaScript';\nconst text = highlight`Learn ${term} programming`;\n// Output: 'Learn <mark>JavaScript</mark> programming'\n```",
      "keywords": ["template literals", "string interpolation", "multi-line strings", "expression evaluation", "tagged templates", "ES6", "backticks", "embedded expressions"],
      "difficulty": "easy"
    },
    {
      "id": 9,
      "tag": "javascript",
      "question": "Explain the `this` keyword in JavaScript.",
      "answer": "The `this` keyword refers to the object that is executing the current function. Its value depends on how the function is called.\n\n**Global Context:**\n```javascript\nconsole.log(this); // Window object (browser) or global object (Node.js)\n```\n\n**Object Method:**\n```javascript\nconst obj = {\n  name: 'John',\n  greet() {\n    console.log(this.name); // 'John'\n  }\n};\nobj.greet();\n```\n\n**Function Call:**\n```javascript\nfunction sayHello() {\n  console.log(this); // undefined in strict mode, Window in non-strict\n}\nsayHello();\n```\n\n**Constructor Function:**\n```javascript\nfunction Person(name) {\n  this.name = name; // `this` refers to new instance\n}\nconst person = new Person('Alice');\n```\n\n**Explicit Binding:**\n```javascript\nconst obj1 = { name: 'John' };\nconst obj2 = { name: 'Jane' };\n\nfunction introduce() {\n  console.log(`Hi, I'm ${this.name}`);\n}\n\nintroduce.call(obj1);  // 'Hi, I'm John'\nintroduce.apply(obj2); // 'Hi, I'm Jane'\nconst boundFunc = introduce.bind(obj1);\nboundFunc(); // 'Hi, I'm John'\n```\n\n**Arrow Functions:**\n```javascript\nconst obj = {\n  name: 'John',\n  greet: () => {\n    console.log(this.name); // undefined - no `this` binding\n  }\n};\n```",
      "keywords": ["this keyword", "context binding", "object methods", "constructor functions", "call", "apply", "bind", "arrow functions", "global context"],
      "difficulty": "medium"
    },
    {
      "id": 10,
      "tag": "javascript",
      "question": "What are Promises and how do they work?",
      "answer": "Promises are objects representing the eventual completion or failure of an asynchronous operation.\n\n**Promise States:**\n- **Pending** - initial state, neither fulfilled nor rejected\n- **Fulfilled** - operation completed successfully\n- **Rejected** - operation failed\n\n**Creating Promises:**\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    const success = Math.random() > 0.5;\n    if (success) {\n      resolve('Operation successful!');\n    } else {\n      reject(new Error('Operation failed'));\n    }\n  }, 1000);\n});\n```\n\n**Consuming Promises:**\n```javascript\npromise\n  .then(result => {\n    console.log(result); // Handle success\n    return 'Next value';\n  })\n  .then(value => {\n    console.log(value); // Chain additional operations\n  })\n  .catch(error => {\n    console.error(error); // Handle errors\n  })\n  .finally(() => {\n    console.log('Cleanup'); // Always executed\n  });\n```\n\n**Promise Utilities:**\n```javascript\n// Wait for all promises\nPromise.all([promise1, promise2, promise3])\n  .then(results => console.log(results));\n\n// First to resolve\nPromise.race([promise1, promise2])\n  .then(result => console.log(result));\n\n// All settle (resolve or reject)\nPromise.allSettled([promise1, promise2])\n  .then(results => console.log(results));\n```",
      "keywords": ["promises", "asynchronous", "pending", "fulfilled", "rejected", "then", "catch", "finally", "Promise.all", "Promise.race", "chaining"],
      "difficulty": "medium"
    },
    {
      "id": 11,
      "tag": "javascript",
      "question": "What is async/await and how does it relate to Promises?",
      "answer": "Async/await is syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code.\n\n**Basic Syntax:**\n```javascript\n// Promise-based approach\nfunction fetchUserData() {\n  return fetch('/api/user')\n    .then(response => response.json())\n    .then(data => {\n      console.log(data);\n      return data;\n    })\n    .catch(error => console.error(error));\n}\n\n// Async/await approach\nasync function fetchUserData() {\n  try {\n    const response = await fetch('/api/user');\n    const data = await response.json();\n    console.log(data);\n    return data;\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n**Key Points:**\n1. **`async` functions always return a Promise**\n2. **`await` can only be used inside `async` functions**\n3. **`await` pauses execution until Promise resolves**\n4. **Use try/catch for error handling**\n\n**Sequential vs Parallel Execution:**\n```javascript\n// Sequential (slower)\nasync function sequential() {\n  const user = await fetchUser();\n  const posts = await fetchPosts(); // Waits for user\n  return { user, posts };\n}\n\n// Parallel (faster)\nasync function parallel() {\n  const [user, posts] = await Promise.all([\n    fetchUser(),\n    fetchPosts()\n  ]);\n  return { user, posts };\n}\n```\n\n**Error Handling:**\n```javascript\nasync function handleErrors() {\n  try {\n    const result = await riskyOperation();\n    return result;\n  } catch (error) {\n    // Handle specific errors\n    if (error.code === 'NETWORK_ERROR') {\n      return 'Please check your connection';\n    }\n    throw error; // Re-throw unknown errors\n  }\n}\n```",
      "keywords": ["async await", "promises", "asynchronous", "syntactic sugar", "try catch", "sequential execution", "parallel execution", "Promise.all", "error handling"],
      "difficulty": "medium"
    },
    {
      "id": 12,
      "tag": "javascript",
      "question": "What is the difference between `forEach`, `map`, `filter`, and `reduce`?",
      "answer": "These are array methods for iteration and transformation, each serving different purposes.\n\n**forEach()** - executes function for each element, returns undefined:\n```javascript\nconst numbers = [1, 2, 3, 4];\nnumbers.forEach(num => console.log(num * 2));\n// Prints: 2, 4, 6, 8\n// Returns: undefined\n```\n\n**map()** - creates new array with transformed elements:\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num => num * 2);\nconsole.log(doubled); // [2, 4, 6, 8]\n```\n\n**filter()** - creates new array with elements that pass test:\n```javascript\nconst numbers = [1, 2, 3, 4, 5, 6];\nconst evens = numbers.filter(num => num % 2 === 0);\nconsole.log(evens); // [2, 4, 6]\n```\n\n**reduce()** - reduces array to single value:\n```javascript\nconst numbers = [1, 2, 3, 4];\nconst sum = numbers.reduce((acc, num) => acc + num, 0);\nconsole.log(sum); // 10\n\n// Complex example - grouping\nconst people = [\n  { name: 'Alice', age: 25 },\n  { name: 'Bob', age: 30 },\n  { name: 'Charlie', age: 25 }\n];\n\nconst grouped = people.reduce((acc, person) => {\n  const age = person.age;\n  if (!acc[age]) acc[age] = [];\n  acc[age].push(person);\n  return acc;\n}, {});\n// Groups people by age\n```\n\n**Key Differences:**\n- **forEach**: Side effects only, no return value\n- **map**: 1:1 transformation, always returns array of same length\n- **filter**: Conditional inclusion, returns subset\n- **reduce**: Aggregation, returns single value (can be any type)",
      "keywords": ["forEach", "map", "filter", "reduce", "array methods", "iteration", "transformation", "functional programming", "side effects", "aggregation"],
      "difficulty": "easy"
    },
    {
      "id": 13,
      "tag": "javascript",
      "question": "What is the spread operator and rest parameters?",
      "answer": "Both use the same syntax (`...`) but serve different purposes depending on context.\n\n**Spread Operator** - expands iterables into individual elements:\n\n**Array Spreading:**\n```javascript\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n\n// Clone array\nconst cloned = [...arr1];\n\n// Convert string to array\nconst chars = [...'hello']; // ['h', 'e', 'l', 'l', 'o']\n```\n\n**Object Spreading:**\n```javascript\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst merged = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }\n\n// Override properties\nconst updated = { ...obj1, b: 99 }; // { a: 1, b: 99 }\n```\n\n**Function Arguments:**\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\nconsole.log(Math.max(...numbers)); // 5\n```\n\n**Rest Parameters** - collects multiple elements into array:\n\n**Function Parameters:**\n```javascript\nfunction sum(first, ...rest) {\n  console.log(first); // First argument\n  console.log(rest);  // Array of remaining arguments\n  return first + rest.reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3, 4); // first = 1, rest = [2, 3, 4]\n```\n\n**Destructuring:**\n```javascript\nconst [head, ...tail] = [1, 2, 3, 4];\nconsole.log(head); // 1\nconsole.log(tail); // [2, 3, 4]\n\nconst { x, ...others } = { x: 1, y: 2, z: 3 };\nconsole.log(x);      // 1\nconsole.log(others); // { y: 2, z: 3 }\n```",
      "keywords": ["spread operator", "rest parameters", "array spreading", "object spreading", "destructuring", "function parameters", "clone", "merge", "ES6"],
      "difficulty": "easy"
    },
    {
      "id": 14,
      "tag": "javascript",
      "question": "What are JavaScript classes and how do they work?",
      "answer": "JavaScript classes are syntactic sugar over prototype-based inheritance, introduced in ES6.\n\n**Basic Class Syntax:**\n```javascript\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  \n  greet() {\n    return `Hello, I'm ${this.name}`;\n  }\n  \n  static species() {\n    return 'Homo sapiens';\n  }\n}\n\nconst person = new Person('Alice', 30);\nconsole.log(person.greet()); // \"Hello, I'm Alice\"\nconsole.log(Person.species()); // \"Homo sapiens\"\n```\n\n**Inheritance:**\n```javascript\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age); // Call parent constructor\n    this.grade = grade;\n  }\n  \n  study() {\n    return `${this.name} is studying`;\n  }\n  \n  // Override parent method\n  greet() {\n    return `${super.greet()}, I'm a student`;\n  }\n}\n\nconst student = new Student('Bob', 20, 'A');\nconsole.log(student.greet()); // \"Hello, I'm Bob, I'm a student\"\n```\n\n**Private Fields (ES2022):**\n```javascript\nclass BankAccount {\n  #balance = 0; // Private field\n  \n  constructor(initialBalance) {\n    this.#balance = initialBalance;\n  }\n  \n  deposit(amount) {\n    this.#balance += amount;\n  }\n  \n  getBalance() {\n    return this.#balance;\n  }\n}\n\nconst account = new BankAccount(100);\n// account.#balance; // SyntaxError: Private field '#balance'\n```\n\n**Key Features:**\n- Constructor for initialization\n- Instance methods\n- Static methods\n- Inheritance with `extends`\n- `super` keyword for parent access\n- Private fields with `#`",
      "keywords": ["classes", "constructor", "inheritance", "extends", "super", "static methods", "private fields", "prototype", "ES6", "object-oriented"],
      "difficulty": "easy"
    },
    {
      "id": 15,
      "tag": "javascript",
      "question": "Explain prototypes and prototype chain in JavaScript.",
      "answer": "JavaScript uses prototype-based inheritance where objects can inherit properties and methods from other objects.\n\n**Prototype Basics:**\n```javascript\n// Every function has a prototype property\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\nconst person1 = new Person('Alice');\nconst person2 = new Person('Bob');\n\nconsole.log(person1.greet()); // \"Hello, I'm Alice\"\nconsole.log(person2.greet()); // \"Hello, I'm Bob\"\n\n// Both instances share the same method\nconsole.log(person1.greet === person2.greet); // true\n```\n\n**Prototype Chain:**\n```javascript\n// Objects have __proto__ property pointing to prototype\nconsole.log(person1.__proto__ === Person.prototype); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__); // null (end of chain)\n```\n\n**Property Lookup:**\n```javascript\nconst obj = { a: 1 };\nobj.b = 2;\n\n// Lookup order:\n// 1. Own properties: obj.a, obj.b\n// 2. Prototype: Object.prototype.toString, etc.\n// 3. If not found: undefined\n\nconsole.log(obj.toString()); // From Object.prototype\n```\n\n**Modern Prototype Methods:**\n```javascript\n// Create object with specific prototype\nconst animal = { species: 'mammal' };\nconst dog = Object.create(animal);\ndog.breed = 'labrador';\n\nconsole.log(dog.species); // 'mammal' (inherited)\n\n// Check prototype chain\nconsole.log(Object.getPrototypeOf(dog) === animal); // true\nconsole.log(dog.hasOwnProperty('breed')); // true\nconsole.log(dog.hasOwnProperty('species')); // false\n\n// Set prototype\nconst cat = { sound: 'meow' };\nObject.setPrototypeOf(cat, animal);\nconsole.log(cat.species); // 'mammal'\n```\n\n**Benefits:**\n- Memory efficiency (shared methods)\n- Dynamic inheritance\n- Flexible object relationships",
      "keywords": ["prototype", "prototype chain", "inheritance", "__proto__", "Object.create", "hasOwnProperty", "getPrototypeOf", "setPrototypeOf", "property lookup"],
      "difficulty": "medium"
    },
    {
      "id": 16,
      "tag": "javascript",
      "question": "What are modules in JavaScript? Explain ES6 modules.",
      "answer": "Modules allow code organization into separate files with explicit imports and exports, promoting reusability and maintainability.\n\n**ES6 Module Syntax:**\n\n**Named Exports:**\n```javascript\n// math.js\nexport const PI = 3.14159;\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport class Calculator {\n  multiply(a, b) {\n    return a * b;\n  }\n}\n\n// Alternative export syntax\nconst subtract = (a, b) => a - b;\nexport { subtract, PI as PIValue };\n```\n\n**Default Exports:**\n```javascript\n// utils.js\nconst formatDate = (date) => {\n  return date.toLocaleDateString();\n};\n\nexport default formatDate;\n\n// Or inline\nexport default function logger(message) {\n  console.log(`[LOG]: ${message}`);\n}\n```\n\n**Importing Modules:**\n```javascript\n// Named imports\nimport { add, PI, Calculator } from './math.js';\nimport { subtract, PIValue } from './math.js';\n\n// Default import\nimport formatDate from './utils.js';\nimport logger from './utils.js';\n\n// Mixed imports\nimport logger, { add, PI } from './combined.js';\n\n// Import all\nimport * as MathUtils from './math.js';\nconsole.log(MathUtils.add(2, 3));\n\n// Dynamic imports\nasync function loadModule() {\n  const { add } = await import('./math.js');\n  console.log(add(1, 2));\n}\n```\n\n**Module Features:**\n- **Static structure** - imports/exports are determined at compile time\n- **Singleton** - modules are cached after first load\n- **Strict mode** - always executed in strict mode\n- **Top-level scope** - variables don't pollute global scope\n- **Circular dependencies** - supported with limitations\n\n**Browser Usage:**\n```html\n<script type=\"module\" src=\"main.js\"></script>\n```\n\n**Benefits:**\n- Code organization and encapsulation\n- Dependency management\n- Tree shaking (dead code elimination)\n- Better tooling support",
      "keywords": ["modules", "ES6 modules", "import", "export", "named exports", "default export", "dynamic imports", "static structure", "tree shaking", "encapsulation"],
      "difficulty": "medium"
    },
    {
      "id": 17,
      "tag": "javascript",
      "question": "What is the event loop and how does JavaScript handle asynchronous operations?",
      "answer": "The event loop is JavaScript's mechanism for handling asynchronous operations in a single-threaded environment.\n\n**JavaScript Runtime Components:**\n1. **Call Stack** - executes synchronous code\n2. **Web APIs** - browser-provided APIs (setTimeout, DOM events, fetch)\n3. **Callback Queue** - holds completed async callbacks\n4. **Microtask Queue** - holds Promise callbacks (higher priority)\n5. **Event Loop** - moves tasks from queues to call stack\n\n**Event Loop Process:**\n```javascript\nconsole.log('1'); // Call stack\n\nsetTimeout(() => {\n  console.log('2'); // Callback queue\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3'); // Microtask queue\n});\n\nconsole.log('4'); // Call stack\n\n// Output: 1, 4, 3, 2\n```\n\n**Detailed Execution:**\n```javascript\nfunction example() {\n  console.log('Start');\n  \n  setTimeout(() => console.log('Timeout 1'), 0);\n  \n  Promise.resolve()\n    .then(() => console.log('Promise 1'))\n    .then(() => console.log('Promise 2'));\n  \n  setTimeout(() => console.log('Timeout 2'), 0);\n  \n  console.log('End');\n}\n\nexample();\n// Output:\n// Start\n// End\n// Promise 1\n// Promise 2\n// Timeout 1\n// Timeout 2\n```\n\n**Priority Order:**\n1. **Synchronous code** (call stack)\n2. **Microtasks** (Promises, queueMicrotask)\n3. **Macrotasks** (setTimeout, setInterval, I/O)\n\n**Microtask vs Macrotask:**\n```javascript\nsetTimeout(() => console.log('Macro 1'), 0);\n\nPromise.resolve().then(() => {\n  console.log('Micro 1');\n  Promise.resolve().then(() => console.log('Micro 2'));\n});\n\nsetTimeout(() => console.log('Macro 2'), 0);\n\n// Output: Micro 1, Micro 2, Macro 1, Macro 2\n```\n\n**Key Concepts:**\n- JavaScript is single-threaded but can handle concurrency\n- Async operations don't block the main thread\n- Microtasks have higher priority than macrotasks\n- Event loop ensures non-blocking execution",
      "keywords": ["event loop", "call stack", "callback queue", "microtask queue", "Web APIs", "asynchronous", "single-threaded", "concurrency", "macrotasks", "microtasks"],
      "difficulty": "hard"
    },
    {
      "id": 18,
      "tag": "javascript",
      "question": "What is debouncing and throttling? When would you use each?",
      "answer": "Debouncing and throttling are techniques to control function execution frequency, essential for performance optimization.\n\n**Debouncing** - delays execution until after a pause in events:\n\n```javascript\nfunction debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Usage: Search input\nconst searchInput = document.getElementById('search');\nconst debouncedSearch = debounce((query) => {\n  console.log(`Searching for: ${query}`);\n  // API call here\n}, 300);\n\nsearchInput.addEventListener('input', (e) => {\n  debouncedSearch(e.target.value);\n});\n```\n\n**Throttling** - limits execution to once per time period:\n\n```javascript\nfunction throttle(func, delay) {\n  let lastExecTime = 0;\n  return function(...args) {\n    const currentTime = Date.now();\n    if (currentTime - lastExecTime >= delay) {\n      func.apply(this, args);\n      lastExecTime = currentTime;\n    }\n  };\n}\n\n// Usage: Scroll event\nconst throttledScroll = throttle(() => {\n  console.log('Scroll position:', window.scrollY);\n  // Update scroll indicator\n}, 100);\n\nwindow.addEventListener('scroll', throttledScroll);\n```\n\n**Advanced Throttling with Leading/Trailing:**\n```javascript\nfunction throttleAdvanced(func, delay, options = {}) {\n  let timeoutId;\n  let lastExecTime = 0;\n  const { leading = true, trailing = true } = options;\n  \n  return function(...args) {\n    const currentTime = Date.now();\n    const timeSinceLastExec = currentTime - lastExecTime;\n    \n    if (leading && timeSinceLastExec >= delay) {\n      func.apply(this, args);\n      lastExecTime = currentTime;\n    } else if (trailing) {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        func.apply(this, args);\n        lastExecTime = Date.now();\n      }, delay - timeSinceLastExec);\n    }\n  };\n}\n```\n\n**Use Cases:**\n\n**Debouncing:**\n- Search autocomplete\n- Form validation\n- Button click prevention\n- Window resize handling\n\n**Throttling:**\n- Scroll events\n- Mouse movement tracking\n- API rate limiting\n- Game controls\n- Animation frames\n\n**Key Differences:**\n- **Debouncing**: Waits for quiet period, executes once at end\n- **Throttling**: Executes at regular intervals during activity",
      "keywords": ["debouncing", "throttling", "performance optimization", "event handling", "rate limiting", "setTimeout", "clearTimeout", "leading", "trailing", "function execution"],
      "difficulty": "medium"
    },
    {
      "id": 19,
      "tag": "javascript",
      "question": "Explain call, apply, and bind methods.",
      "answer": "These methods allow explicit control over the `this` context and function arguments.\n\n**call()** - invokes function with specified `this` and individual arguments:\n\n```javascript\nfunction greet(greeting, punctuation) {\n  return `${greeting}, I'm ${this.name}${punctuation}`;\n}\n\nconst person = { name: 'Alice' };\n\n// Using call\nconst result = greet.call(person, 'Hello', '!');\nconsole.log(result); // \"Hello, I'm Alice!\"\n```\n\n**apply()** - same as call but takes arguments as array:\n\n```javascript\n// Using apply\nconst args = ['Hi', '.'];\nconst result2 = greet.apply(person, args);\nconsole.log(result2); // \"Hi, I'm Alice.\"\n\n// Practical example: Finding max in array\nconst numbers = [1, 5, 3, 9, 2];\nconst max = Math.max.apply(null, numbers);\nconsole.log(max); // 9\n\n// Modern alternative with spread\nconst max2 = Math.max(...numbers);\n```\n\n**bind()** - creates new function with bound `this` and optional preset arguments:\n\n```javascript\n// Basic binding\nconst boundGreet = greet.bind(person);\nconsole.log(boundGreet('Hey', '?')); // \"Hey, I'm Alice?\"\n\n// Partial application\nconst boundGreetHello = greet.bind(person, 'Hello');\nconsole.log(boundGreetHello('!')); // \"Hello, I'm Alice!\"\n```\n\n**Practical Examples:**\n\n**Event Handlers:**\n```javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n    this.increment = this.increment.bind(this);\n  }\n  \n  increment() {\n    this.count++;\n    console.log(this.count);\n  }\n}\n\nconst counter = new Counter();\nconst button = document.getElementById('btn');\nbutton.addEventListener('click', counter.increment); // `this` preserved\n```\n\n**Method Borrowing:**\n```javascript\nconst obj1 = {\n  name: 'Object 1',\n  describe() {\n    return `I am ${this.name}`;\n  }\n};\n\nconst obj2 = { name: 'Object 2' };\n\n// Borrow method\nconst result = obj1.describe.call(obj2);\nconsole.log(result); // \"I am Object 2\"\n```\n\n**Array-like Objects:**\n```javascript\nfunction processArguments() {\n  // Convert arguments to real array\n  const args = Array.prototype.slice.call(arguments);\n  return args.map(arg => arg.toUpperCase());\n}\n\nconsole.log(processArguments('a', 'b', 'c')); // ['A', 'B', 'C']\n```\n\n**Key Differences:**\n- **call**: Immediate execution, individual arguments\n- **apply**: Immediate execution, array of arguments\n- **bind**: Returns new function, can preset arguments",
      "keywords": ["call", "apply", "bind", "this binding", "function context", "method borrowing", "partial application", "event handlers", "array-like objects"],
      "difficulty": "medium"
    },
    {
      "id": 20,
      "tag": "javascript",
      "question": "What are Set and Map data structures? How do they differ from arrays and objects?",
      "answer": "Set and Map are ES6 data structures that provide alternatives to arrays and objects with unique characteristics.\n\n**Set** - collection of unique values:\n\n```javascript\n// Creating Sets\nconst set = new Set();\nconst setWithValues = new Set([1, 2, 3, 2, 1]); // [1, 2, 3]\n\n// Set methods\nset.add(1);\nset.add(2);\nset.add(2); // Duplicate ignored\nconsole.log(set.size); // 2\n\nconsole.log(set.has(1)); // true\nset.delete(1);\nset.clear(); // Remove all\n\n// Iteration\nconst fruits = new Set(['apple', 'banana', 'orange']);\nfor (const fruit of fruits) {\n  console.log(fruit);\n}\n\n// Convert to array\nconst uniqueArray = [...new Set([1, 1, 2, 3, 3])];\nconsole.log(uniqueArray); // [1, 2, 3]\n```\n\n**Map** - collection of key-value pairs with any key type:\n\n```javascript\n// Creating Maps\nconst map = new Map();\nconst mapWithEntries = new Map([\n  ['name', 'Alice'],\n  [1, 'number key'],\n  [true, 'boolean key']\n]);\n\n// Map methods\nmap.set('key1', 'value1');\nmap.set(42, 'number key');\nconst obj = {};\nmap.set(obj, 'object key');\n\nconsole.log(map.get('key1')); // 'value1'\nconsole.log(map.has(42)); // true\nconsole.log(map.size); // 3\n\nmap.delete('key1');\nmap.clear();\n\n// Iteration\nconst userRoles = new Map([\n  ['alice', 'admin'],\n  ['bob', 'user'],\n  ['charlie', 'moderator']\n]);\n\nfor (const [user, role] of userRoles) {\n  console.log(`${user}: ${role}`);\n}\n\n// Get all keys/values\nconsole.log([...userRoles.keys()]); // ['alice', 'bob', 'charlie']\nconsole.log([...userRoles.values()]); // ['admin', 'user', 'moderator']\n```\n\n**WeakSet and WeakMap:**\n```javascript\n// WeakSet - only objects, weak references\nconst weakSet = new WeakSet();\nlet obj1 = { id: 1 };\nweakSet.add(obj1);\n// obj1 = null; // Object can be garbage collected\n\n// WeakMap - only object keys, weak references\nconst weakMap = new WeakMap();\nlet key = { id: 1 };\nweakMap.set(key, 'metadata');\n// key = null; // Entry can be garbage collected\n```\n\n**Comparison with Arrays and Objects:**\n\n**Set vs Array:**\n- Set: Unique values, no index access\n- Array: Allows duplicates, indexed access, many methods\n\n**Map vs Object:**\n- Map: Any key type, better iteration, size property\n- Object: String/Symbol keys only, prototype properties, better performance for records\n\n**Use Cases:**\n- **Set**: Removing duplicates, checking membership\n- **Map**: Key-value pairs with non-string keys, frequent additions/deletions\n- **WeakSet/WeakMap**: Metadata storage, avoiding memory leaks",
      "keywords": ["Set", "Map", "WeakSet", "WeakMap", "unique values", "key-value pairs", "data structures", "ES6", "iteration", "memory management", "garbage collection"],
      "difficulty": "medium"
    },
    {
      "id": 21,
      "tag": "javascript",
      "question": "What are generators and iterators in JavaScript?",
      "answer": "Generators and iterators provide a way to create custom iteration behavior and handle sequences of data lazily.\n\n**Iterators** - objects that implement the iteration protocol:\n\n```javascript\n// Iterator protocol requires next() method\nfunction createIterator(array) {\n  let index = 0;\n  \n  return {\n    next() {\n      if (index < array.length) {\n        return { value: array[index++], done: false };\n      }\n      return { value: undefined, done: true };\n    }\n  };\n}\n\nconst iterator = createIterator([1, 2, 3]);\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n\n**Generators** - functions that can pause and resume execution:\n\n```javascript\nfunction* numberGenerator() {\n  console.log('Start');\n  yield 1;\n  console.log('After first yield');\n  yield 2;\n  console.log('After second yield');\n  yield 3;\n  console.log('End');\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // \"Start\", { value: 1, done: false }\nconsole.log(gen.next()); // \"After first yield\", { value: 2, done: false }\nconsole.log(gen.next()); // \"After second yield\", { value: 3, done: false }\nconsole.log(gen.next()); // \"End\", { value: undefined, done: true }\n```\n\n**Generator Features:**\n\n**Infinite Sequences:**\n```javascript\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nconsole.log(fib.next().value); // 0\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 1\nconsole.log(fib.next().value); // 2\n```\n\n**Bidirectional Communication:**\n```javascript\nfunction* twoWayGenerator() {\n  const input1 = yield 'First output';\n  console.log('Received:', input1);\n  \n  const input2 = yield 'Second output';\n  console.log('Received:', input2);\n  \n  return 'Final result';\n}\n\nconst gen2 = twoWayGenerator();\nconsole.log(gen2.next());           // { value: 'First output', done: false }\nconsole.log(gen2.next('Hello'));    // \"Received: Hello\", { value: 'Second output', done: false }\nconsole.log(gen2.next('World'));    // \"Received: World\", { value: 'Final result', done: true }\n```\n\n**Async Generators:**\n```javascript\nasync function* asyncGenerator() {\n  for (let i = 0; i < 3; i++) {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    yield `Value ${i}`;\n  }\n}\n\n// Usage with for-await-of\nasync function consumeAsync() {\n  for await (const value of asyncGenerator()) {\n    console.log(value); // Logs every second\n  }\n}\n```\n\n**Practical Applications:**\n\n**Custom Iterables:**\n```javascript\nclass Range {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  \n  *[Symbol.iterator]() {\n    for (let i = this.start; i <= this.end; i++) {\n      yield i;\n    }\n  }\n}\n\nconst range = new Range(1, 5);\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n```\n\n**Benefits:**\n- Lazy evaluation (values computed on demand)\n- Memory efficient for large sequences\n- Pausable execution\n- Clean syntax for complex iteration patterns\n- Built-in support for for-of loops",
      "keywords": ["generators", "iterators", "yield", "next", "iteration protocol", "lazy evaluation", "Symbol.iterator", "async generators", "infinite sequences", "pausable execution"],
      "difficulty": "hard"
    },
    {
      "id": 22,
      "tag": "javascript",
      "question": "What is currying and partial application?",
      "answer": "Currying and partial application are functional programming techniques for creating specialized functions from general ones.\n\n**Currying** - transforms function with multiple arguments into sequence of functions with single arguments:\n\n```javascript\n// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\n// Arrow function currying\nconst curriedAddArrow = a => b => c => a + b + c;\n\n// Usage\nconst result1 = curriedAdd(1)(2)(3); // 6\nconst addOne = curriedAdd(1);\nconst addOneTwo = addOne(2);\nconst result2 = addOneTwo(3); // 6\n```\n\n**Generic Curry Function:**\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    }\n    return function(...nextArgs) {\n      return curried.apply(this, args.concat(nextArgs));\n    };\n  };\n}\n\n// Usage\nconst multiply = (a, b, c) => a * b * c;\nconst curriedMultiply = curry(multiply);\n\nconsole.log(curriedMultiply(2)(3)(4)); // 24\nconsole.log(curriedMultiply(2, 3)(4)); // 24\nconsole.log(curriedMultiply(2)(3, 4)); // 24\n```\n\n**Partial Application** - creates function with some arguments preset:\n\n```javascript\nfunction partial(fn, ...presetArgs) {\n  return function(...laterArgs) {\n    return fn.apply(this, presetArgs.concat(laterArgs));\n  };\n}\n\n// Example function\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\n// Partial applications\nconst sayHello = partial(greet, 'Hello');\nconst sayHelloToAlice = partial(greet, 'Hello', 'Alice');\n\nconsole.log(sayHello('Bob', '!')); // \"Hello, Bob!\"\nconsole.log(sayHelloToAlice('.')); // \"Hello, Alice.\"\n```\n\n**Practical Examples:**\n\n**Event Handling:**\n```javascript\nconst handleEvent = curry((eventType, selector, handler) => {\n  document.querySelector(selector).addEventListener(eventType, handler);\n});\n\nconst onClick = handleEvent('click');\nconst onButtonClick = onClick('button');\n\nonButtonClick(() => console.log('Button clicked!'));\n```\n\n**Data Processing:**\n```javascript\nconst map = curry((fn, array) => array.map(fn));\nconst filter = curry((predicate, array) => array.filter(predicate));\n\nconst numbers = [1, 2, 3, 4, 5, 6];\n\n// Create specialized functions\nconst double = map(x => x * 2);\nconst filterEven = filter(x => x % 2 === 0);\n\nconst result = filterEven(double(numbers));\nconsole.log(result); // [4, 8, 12]\n\n// Function composition\nconst processNumbers = numbers => filterEven(double(numbers));\nconsole.log(processNumbers([1, 2, 3, 4, 5])); // [4, 8]\n```\n\n**API Wrapper:**\n```javascript\nconst apiCall = curry((method, url, data) => {\n  return fetch(url, {\n    method,\n    headers: { 'Content-Type': 'application/json' },\n    body: data ? JSON.stringify(data) : undefined\n  });\n});\n\nconst get = apiCall('GET');\nconst post = apiCall('POST');\n\nconst getUsers = get('/api/users');\nconst createUser = post('/api/users');\n\n// Usage\ngetUsers().then(response => response.json());\ncreateUser({ name: 'Alice' }).then(response => response.json());\n```\n\n**Key Differences:**\n- **Currying**: Always returns unary (single-argument) functions\n- **Partial Application**: Can preset any number of arguments\n- Both enable function specialization and reusability",
      "keywords": ["currying", "partial application", "functional programming", "function specialization", "higher-order functions", "function composition", "reusability", "single argument"],
      "difficulty": "medium"
    },
    {
      "id": 23,
      "tag": "javascript",
      "question": "What are Symbols and what are they used for?",
      "answer": "Symbols are primitive data type introduced in ES6 that represent unique identifiers, primarily used for object property keys.\n\n**Creating Symbols:**\n```javascript\n// Basic symbol creation\nconst sym1 = Symbol();\nconst sym2 = Symbol('description');\nconst sym3 = Symbol('description');\n\nconsole.log(sym2 === sym3); // false - always unique\nconsole.log(typeof sym1);   // 'symbol'\nconsole.log(sym2.toString()); // 'Symbol(description)'\n```\n\n**Symbol as Object Properties:**\n```javascript\nconst obj = {};\nconst uniqueKey = Symbol('uniqueProperty');\n\n// Setting symbol properties\nobj[uniqueKey] = 'secret value';\nobj.normalProperty = 'normal value';\n\nconsole.log(obj[uniqueKey]); // 'secret value'\nconsole.log(obj.normalProperty); // 'normal value'\n\n// Symbol properties are not enumerable\nconsole.log(Object.keys(obj)); // ['normalProperty']\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(uniqueProperty)]\n```\n\n**Global Symbol Registry:**\n```javascript\n// Create/retrieve global symbols\nconst globalSym1 = Symbol.for('shared');\nconst globalSym2 = Symbol.for('shared');\n\nconsole.log(globalSym1 === globalSym2); // true\nconsole.log(Symbol.keyFor(globalSym1)); // 'shared'\n\n// Local symbols are not in global registry\nconst localSym = Symbol('local');\nconsole.log(Symbol.keyFor(localSym)); // undefined\n```\n\n**Well-Known Symbols:**\n```javascript\n// Symbol.iterator - defines default iterator\nclass CustomIterable {\n  constructor(data) {\n    this.data = data;\n  }\n  \n  *[Symbol.iterator]() {\n    for (let item of this.data) {\n      yield item;\n    }\n  }\n}\n\nconst iterable = new CustomIterable([1, 2, 3]);\nfor (const value of iterable) {\n  console.log(value); // 1, 2, 3\n}\n\n// Symbol.toStringTag - customizes Object.prototype.toString\nclass CustomClass {\n  get [Symbol.toStringTag]() {\n    return 'CustomClass';\n  }\n}\n\nconst instance = new CustomClass();\nconsole.log(instance.toString()); // '[object CustomClass]'\n```\n\n**Advanced Use Cases:**\n\n**Private-like Properties:**\n```javascript\nconst _internal = Symbol('internal');\n\nclass Calculator {\n  constructor() {\n    this[_internal] = { operations: 0 };\n  }\n  \n  add(a, b) {\n    this[_internal].operations++;\n    return a + b;\n  }\n  \n  getOperationCount() {\n    return this[_internal].operations;\n  }\n}\n\nconst calc = new Calculator();\ncalc.add(1, 2);\nconsole.log(calc.getOperationCount()); // 1\n// calc[_internal] is not easily accessible from outside\n```\n\n**Protocol Implementation:**\n```javascript\nconst RENDER = Symbol('render');\nconst UPDATE = Symbol('update');\n\nclass Component {\n  [RENDER]() {\n    return '<div>Component</div>';\n  }\n  \n  [UPDATE](data) {\n    console.log('Updating with:', data);\n  }\n}\n\n// Framework code can use these symbols\nfunction renderComponent(component) {\n  return component[RENDER]();\n}\n```\n\n**Monkey-patching Prevention:**\n```javascript\nconst originalMethod = Symbol('originalMethod');\n\n// Library code\nArray.prototype[originalMethod] = Array.prototype.push;\nArray.prototype.push = function(...items) {\n  console.log('Push called with:', items);\n  return this[originalMethod](...items);\n};\n\n// User code cannot accidentally override the original\nconst arr = [1, 2];\narr.push(3); // Logs and pushes\n```\n\n**Benefits:**\n- Guaranteed uniqueness\n- Non-enumerable properties\n- Avoid naming collisions\n- Enable meta-programming\n- Protocol definition\n- Private-like behavior",
      "keywords": ["symbols", "unique identifiers", "object properties", "Symbol.for", "well-known symbols", "Symbol.iterator", "meta-programming", "private properties", "enumerable", "global registry"],
      "difficulty": "medium"
    },
    {
      "id": 24,
      "tag": "javascript",
      "question": "Explain JavaScript's garbage collection and memory management.",
      "answer": "JavaScript automatically manages memory through garbage collection, but understanding it helps prevent memory leaks and optimize performance.\n\n**Memory Lifecycle:**\n1. **Allocation** - memory allocated when creating variables, objects, functions\n2. **Usage** - reading/writing to allocated memory\n3. **Release** - memory freed when no longer needed\n\n**Garbage Collection Algorithms:**\n\n**Reference Counting (Historical):**\n```javascript\n// Circular reference problem (old browsers)\nfunction createCircularReference() {\n  const obj1 = {};\n  const obj2 = {};\n  \n  obj1.ref = obj2;\n  obj2.ref = obj1; // Circular reference\n  \n  return { obj1, obj2 };\n}\n\n// Objects won't be garbage collected in old reference counting systems\n```\n\n**Mark-and-Sweep (Modern):**\n```javascript\n// Objects reachable from root are marked as \"in use\"\n// Unreachable objects are swept (garbage collected)\n\nfunction demonstration() {\n  const obj = { data: 'important' };\n  \n  // obj is reachable from function scope\n  return obj.data;\n  \n  // After function returns, obj becomes unreachable\n  // and eligible for garbage collection\n}\n```\n\n**Common Memory Leaks:**\n\n**1. Global Variables:**\n```javascript\n// Accidental globals\nfunction leakyFunction() {\n  // Missing 'var', 'let', or 'const'\n  accidentalGlobal = 'This creates a global variable';\n}\n\n// Fix: Use strict mode\n'use strict';\nfunction properFunction() {\n  const localVariable = 'This stays local';\n}\n```\n\n**2. Event Listeners:**\n```javascript\n// Memory leak\nfunction addListeners() {\n  const element = document.getElementById('button');\n  const data = new Array(1000000).fill('data');\n  \n  element.addEventListener('click', function() {\n    console.log(data.length); // Closure keeps data alive\n  });\n  \n  // Element removed but listener not cleaned up\n  element.remove();\n}\n\n// Fix: Remove listeners\nfunction properEventHandling() {\n  const element = document.getElementById('button');\n  const data = new Array(1000000).fill('data');\n  \n  function clickHandler() {\n    console.log(data.length);\n  }\n  \n  element.addEventListener('click', clickHandler);\n  \n  // Cleanup\n  return function cleanup() {\n    element.removeEventListener('click', clickHandler);\n  };\n}\n```\n\n**3. Timers:**\n```javascript\n// Memory leak\nfunction leakyTimer() {\n  const data = new Array(1000000).fill('data');\n  \n  setInterval(() => {\n    console.log(data.length); // Keeps data alive forever\n  }, 1000);\n}\n\n// Fix: Clear timers\nfunction properTimer() {\n  const data = new Array(1000000).fill('data');\n  \n  const intervalId = setInterval(() => {\n    console.log(data.length);\n  }, 1000);\n  \n  // Cleanup after 10 seconds\n  setTimeout(() => {\n    clearInterval(intervalId);\n  }, 10000);\n}\n```\n\n**4. Closures:**\n```javascript\n// Potential memory issue\nfunction createHandlers() {\n  const largeData = new Array(1000000).fill('data');\n  \n  return {\n    // This closure keeps entire largeData alive\n    small: () => largeData.length,\n    // Even though this doesn't use largeData\n    other: () => console.log('hello')\n  };\n}\n\n// Fix: Limit closure scope\nfunction createHandlersOptimized() {\n  const largeData = new Array(1000000).fill('data');\n  const dataLength = largeData.length; // Extract only needed value\n  \n  return {\n    small: () => dataLength, // Only keeps dataLength\n    other: () => console.log('hello')\n  };\n}\n```\n\n**Memory Monitoring:**\n```javascript\n// Check memory usage (browser only)\nif ('memory' in performance) {\n  console.log('Used:', performance.memory.usedJSHeapSize);\n  console.log('Total:', performance.memory.totalJSHeapSize);\n  console.log('Limit:', performance.memory.jsHeapSizeLimit);\n}\n\n// WeakMap for metadata without preventing GC\nconst metadata = new WeakMap();\n\nfunction attachMetadata(obj, data) {\n  metadata.set(obj, data);\n  // When obj is garbage collected, metadata entry is also removed\n}\n```\n\n**Best Practices:**\n- Use `const`/`let` instead of `var`\n- Remove event listeners when done\n- Clear timers and intervals\n- Avoid global variables\n- Use WeakMap/WeakSet for temporary associations\n- Be cautious with closures\n- Profile memory usage in development",
      "keywords": ["garbage collection", "memory management", "memory leaks", "mark-and-sweep", "reference counting", "closures", "event listeners", "timers", "WeakMap", "performance"],
      "difficulty": "hard"
    },
    {
      "id": 25,
      "tag": "javascript",
      "question": "What are Proxy and Reflect in JavaScript?",
      "answer": "Proxy and Reflect are ES6 features that enable meta-programming by intercepting and customizing object operations.\n\n**Proxy** - creates wrapper around object to intercept operations:\n\n```javascript\n// Basic proxy\nconst target = {\n  name: 'Alice',\n  age: 30\n};\n\nconst proxy = new Proxy(target, {\n  get(target, property, receiver) {\n    console.log(`Getting property: ${property}`);\n    return Reflect.get(target, property, receiver);\n  },\n  \n  set(target, property, value, receiver) {\n    console.log(`Setting ${property} to ${value}`);\n    return Reflect.set(target, property, value, receiver);\n  }\n});\n\nconsole.log(proxy.name); // \"Getting property: name\", \"Alice\"\nproxy.age = 31;          // \"Setting age to 31\"\n```\n\n**Proxy Traps (Handler Methods):**\n```javascript\nconst validatedObject = new Proxy({}, {\n  get(target, property) {\n    if (property in target) {\n      return target[property];\n    }\n    throw new Error(`Property '${property}' does not exist`);\n  },\n  \n  set(target, property, value) {\n    if (typeof property === 'string' && property.startsWith('_')) {\n      throw new Error('Cannot set private properties');\n    }\n    \n    if (property === 'age' && (typeof value !== 'number' || value < 0)) {\n      throw new Error('Age must be a positive number');\n    }\n    \n    target[property] = value;\n    return true;\n  },\n  \n  has(target, property) {\n    return property in target && !property.startsWith('_');\n  },\n  \n  deleteProperty(target, property) {\n    if (property.startsWith('_')) {\n      throw new Error('Cannot delete private properties');\n    }\n    delete target[property];\n    return true;\n  }\n});\n\n// Usage\nvalidatedObject.name = 'Bob';  // OK\nvalidatedObject.age = 25;      // OK\n// validatedObject.age = -5;   // Error: Age must be a positive number\n// validatedObject._private = 'secret'; // Error: Cannot set private properties\n```\n\n**Function Proxies:**\n```javascript\nfunction originalFunction(a, b) {\n  return a + b;\n}\n\nconst proxiedFunction = new Proxy(originalFunction, {\n  apply(target, thisArg, args) {\n    console.log(`Calling function with args: ${args}`);\n    \n    // Validate arguments\n    if (args.some(arg => typeof arg !== 'number')) {\n      throw new Error('All arguments must be numbers');\n    }\n    \n    const result = Reflect.apply(target, thisArg, args);\n    console.log(`Result: ${result}`);\n    return result;\n  }\n});\n\nproxiedFunction(2, 3); // \"Calling function...\", \"Result: 5\", returns 5\n```\n\n**Reflect** - provides default object operations as functions:\n\n```javascript\nconst obj = { x: 1, y: 2 };\n\n// Reflect methods mirror proxy traps\nReflect.get(obj, 'x');           // 1 (same as obj.x)\nReflect.set(obj, 'z', 3);        // true (same as obj.z = 3)\nReflect.has(obj, 'x');           // true (same as 'x' in obj)\nReflect.deleteProperty(obj, 'y'); // true (same as delete obj.y)\n\n// Get property descriptors\nconst descriptor = Reflect.getOwnPropertyDescriptor(obj, 'x');\nconsole.log(descriptor); // { value: 1, writable: true, enumerable: true, configurable: true }\n\n// Prototype operations\nReflect.getPrototypeOf(obj);     // Object.prototype\nReflect.setPrototypeOf(obj, {}); // true\n```\n\n**Practical Applications:**\n\n**1. Observable Objects:**\n```javascript\nfunction createObservable(target, onChange) {\n  return new Proxy(target, {\n    set(target, property, value, receiver) {\n      const oldValue = target[property];\n      const result = Reflect.set(target, property, value, receiver);\n      \n      if (oldValue !== value) {\n        onChange(property, value, oldValue);\n      }\n      \n      return result;\n    }\n  });\n}\n\nconst state = createObservable(\n  { count: 0 },\n  (prop, newVal, oldVal) => {\n    console.log(`${prop} changed from ${oldVal} to ${newVal}`);\n  }\n);\n\nstate.count = 1; // \"count changed from 0 to 1\"\n```\n\n**2. API Wrapper:**\n```javascript\nconst api = new Proxy({}, {\n  get(target, endpoint) {\n    return function(options = {}) {\n      const url = `https://api.example.com/${endpoint}`;\n      return fetch(url, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' },\n        ...options\n      }).then(response => response.json());\n    };\n  }\n});\n\n// Usage\napi.users().then(users => console.log(users));\napi.posts({ method: 'POST', body: JSON.stringify(data) });\n```\n\n**3. Default Values:**\n```javascript\nconst withDefaults = new Proxy({}, {\n  get(target, property) {\n    return property in target ? target[property] : 'default';\n  }\n});\n\nwithDefaults.name = 'Alice';\nconsole.log(withDefaults.name);     // 'Alice'\nconsole.log(withDefaults.unknown);  // 'default'\n```\n\n**Benefits:**\n- Intercept object operations\n- Create virtual properties\n- Implement custom behavior\n- Build reactive systems\n- Create DSLs (Domain Specific Languages)",
      "keywords": ["proxy", "reflect", "meta-programming", "traps", "handler", "intercept", "observable", "reactive", "virtual properties", "API wrapper"],
      "difficulty": "medium"
    },
    {
      "id": 26,
      "tag": "javascript",
      "question": "What is the difference between deep and shallow copying?",
      "answer": "Deep and shallow copying refer to different approaches for duplicating objects and arrays in JavaScript.\n\n**Shallow Copy** - copies only the first level of properties:\n\n```javascript\nconst original = {\n  name: 'Alice',\n  age: 30,\n  address: {\n    city: 'New York',\n    country: 'USA'\n  },\n  hobbies: ['reading', 'swimming']\n};\n\n// Shallow copy methods\nconst shallow1 = Object.assign({}, original);\nconst shallow2 = { ...original };\nconst shallow3 = Object.create(Object.getPrototypeOf(original), Object.getOwnPropertyDescriptors(original));\n\n// Modify nested object\nshallow1.address.city = 'Boston';\nconsole.log(original.address.city); // 'Boston' - original affected!\n\n// Modify array\nshallow2.hobbies.push('cooking');\nconsole.log(original.hobbies); // ['reading', 'swimming', 'cooking'] - original affected!\n\n// But top-level properties are independent\nshallow1.name = 'Bob';\nconsole.log(original.name); // 'Alice' - original not affected\n```\n\n**Deep Copy** - recursively copies all levels:\n\n```javascript\n// Method 1: JSON.parse/stringify (limited)\nconst deepCopy1 = JSON.parse(JSON.stringify(original));\ndeepCopy1.address.city = 'Chicago';\nconsole.log(original.address.city); // 'New York' - original not affected\n\n// Limitations of JSON method:\nconst complexObject = {\n  date: new Date(),\n  regex: /pattern/g,\n  func: () => 'hello',\n  undefined: undefined,\n  symbol: Symbol('test'),\n  [Symbol('key')]: 'value'\n};\n\nconst jsonCopy = JSON.parse(JSON.stringify(complexObject));\nconsole.log(jsonCopy);\n// {\n//   date: '2023-12-07T10:30:00.000Z', // String, not Date\n//   regex: {},                         // Empty object\n//   // func, undefined, symbols are lost\n// }\n```\n\n**Custom Deep Copy Implementation:**\n```javascript\nfunction deepCopy(obj, visited = new WeakMap()) {\n  // Handle null, undefined, and primitives\n  if (obj === null || typeof obj !== 'object') {\n    return obj;\n  }\n  \n  // Handle circular references\n  if (visited.has(obj)) {\n    return visited.get(obj);\n  }\n  \n  // Handle Date\n  if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n  \n  // Handle RegExp\n  if (obj instanceof RegExp) {\n    return new RegExp(obj.source, obj.flags);\n  }\n  \n  // Handle Arrays\n  if (Array.isArray(obj)) {\n    const arrCopy = [];\n    visited.set(obj, arrCopy);\n    \n    for (let i = 0; i < obj.length; i++) {\n      arrCopy[i] = deepCopy(obj[i], visited);\n    }\n    \n    return arrCopy;\n  }\n  \n  // Handle Objects\n  const objCopy = Object.create(Object.getPrototypeOf(obj));\n  visited.set(obj, objCopy);\n  \n  // Copy own properties (including non-enumerable)\n  const descriptors = Object.getOwnPropertyDescriptors(obj);\n  for (const key of Object.keys(descriptors)) {\n    if (descriptors[key].value !== undefined) {\n      descriptors[key].value = deepCopy(descriptors[key].value, visited);\n    }\n  }\n  Object.defineProperties(objCopy, descriptors);\n  \n  // Copy symbol properties\n  const symbols = Object.getOwnPropertySymbols(obj);\n  for (const symbol of symbols) {\n    objCopy[symbol] = deepCopy(obj[symbol], visited);\n  }\n  \n  return objCopy;\n}\n\n// Test with circular reference\nconst circular = { name: 'test' };\ncircular.self = circular;\n\nconst deepCopyResult = deepCopy(circular);\nconsole.log(deepCopyResult.self === deepCopyResult); // true - maintains structure\nconsole.log(deepCopyResult === circular); // false - different objects\n```\n\n**Modern Approaches:**\n\n**Using structuredClone (modern browsers):**\n```javascript\nconst original = {\n  date: new Date(),\n  regex: /test/g,\n  nested: { value: 42 },\n  array: [1, 2, { inner: 'value' }]\n};\n\nconst cloned = structuredClone(original);\ncloned.nested.value = 99;\nconsole.log(original.nested.value); // 42 - not affected\n\n// Supports most built-in types but not functions\n```\n\n**Library Solutions:**\n```javascript\n// Lodash cloneDeep\nconst _ = require('lodash');\nconst lodashDeep = _.cloneDeep(original);\n\n// Ramda clone\nconst R = require('ramda');\nconst ramdaClone = R.clone(original);\n```\n\n**Performance Considerations:**\n```javascript\n// Benchmark different approaches\nconst largeObject = {\n  // ... large nested structure\n};\n\nconsole.time('JSON');\nconst jsonCopy = JSON.parse(JSON.stringify(largeObject));\nconsole.timeEnd('JSON'); // Often fastest for simple objects\n\nconsole.time('Custom');\nconst customCopy = deepCopy(largeObject);\nconsole.timeEnd('Custom'); // More thorough but slower\n\nconsole.time('structuredClone');\nconst structuredCopy = structuredClone(largeObject);\nconsole.timeEnd('structuredClone'); // Good balance\n```\n\n**When to Use Each:**\n\n**Shallow Copy:**\n- Performance-critical code\n- Objects with only primitive values\n- When you only need to modify top-level properties\n\n**Deep Copy:**\n- Complex nested structures\n- When complete independence is required\n- Implementing undo/redo functionality\n- State management in applications",
      "keywords": ["shallow copy", "deep copy", "object cloning", "nested objects", "JSON.parse", "JSON.stringify", "structuredClone", "circular references", "performance", "WeakMap"],
      "difficulty": "medium"
    },
    {
      "id": 27,
      "tag": "javascript",
      "question": "What are Worker threads and how do they help with performance?",
      "answer": "Web Workers enable running JavaScript in background threads, allowing for concurrent execution without blocking the main UI thread.\n\n**Types of Workers:**\n\n**1. Web Workers (Dedicated Workers):**\n```javascript\n// main.js\nconst worker = new Worker('worker.js');\n\n// Send data to worker\nworker.postMessage({\n  command: 'calculate',\n  data: [1, 2, 3, 4, 5]\n});\n\n// Receive results from worker\nworker.onmessage = function(event) {\n  const { result, status } = event.data;\n  console.log('Result:', result);\n  \n  if (status === 'complete') {\n    worker.terminate(); // Clean up\n  }\n};\n\n// Handle errors\nworker.onerror = function(error) {\n  console.error('Worker error:', error);\n};\n```\n\n```javascript\n// worker.js\nself.onmessage = function(event) {\n  const { command, data } = event.data;\n  \n  if (command === 'calculate') {\n    // CPU-intensive calculation\n    let result = 0;\n    for (let i = 0; i < data.length; i++) {\n      // Simulate heavy computation\n      for (let j = 0; j < 1000000; j++) {\n        result += data[i] * Math.random();\n      }\n    }\n    \n    // Send result back to main thread\n    self.postMessage({\n      result: result,\n      status: 'complete'\n    });\n  }\n};\n\n// Handle errors in worker\nself.onerror = function(error) {\n  console.error('Error in worker:', error);\n};\n```\n\n**2. Shared Workers:**\n```javascript\n// Can be shared between multiple scripts/pages\nconst sharedWorker = new SharedWorker('shared-worker.js');\nconst port = sharedWorker.port;\n\nport.onmessage = function(event) {\n  console.log('Received from shared worker:', event.data);\n};\n\nport.postMessage('Hello from page 1');\nport.start();\n```\n\n```javascript\n// shared-worker.js\nconst connections = [];\n\nself.onconnect = function(event) {\n  const port = event.ports[0];\n  connections.push(port);\n  \n  port.onmessage = function(event) {\n    // Broadcast to all connected ports\n    connections.forEach(conn => {\n      if (conn !== port) {\n        conn.postMessage(`Broadcast: ${event.data}`);\n      }\n    });\n  };\n  \n  port.start();\n};\n```\n\n**3. Service Workers:**\n```javascript\n// Register service worker\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('service-worker.js')\n    .then(registration => {\n      console.log('SW registered:', registration);\n    })\n    .catch(error => {\n      console.log('SW registration failed:', error);\n    });\n}\n```\n\n```javascript\n// service-worker.js\nself.addEventListener('install', event => {\n  console.log('Service worker installing');\n  // Cache resources\n  event.waitUntil(\n    caches.open('v1').then(cache => {\n      return cache.addAll([\n        '/',\n        '/styles.css',\n        '/script.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  // Intercept network requests\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n**Practical Examples:**\n\n**Image Processing:**\n```javascript\n// main.js\nfunction processImage(imageData) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker('image-processor.js');\n    \n    worker.postMessage({\n      imageData: imageData,\n      filter: 'blur'\n    });\n    \n    worker.onmessage = function(event) {\n      resolve(event.data.processedImageData);\n      worker.terminate();\n    };\n    \n    worker.onerror = reject;\n  });\n}\n\n// Usage\nconst canvas = document.getElementById('canvas');\nconst ctx = canvas.getContext('2d');\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\nprocessImage(imageData).then(processedData => {\n  ctx.putImageData(processedData, 0, 0);\n});\n```\n\n**Data Processing:**\n```javascript\n// main.js\nclass DataProcessor {\n  constructor() {\n    this.worker = new Worker('data-worker.js');\n    this.pendingTasks = new Map();\n    \n    this.worker.onmessage = (event) => {\n      const { taskId, result, error } = event.data;\n      const { resolve, reject } = this.pendingTasks.get(taskId);\n      \n      if (error) {\n        reject(new Error(error));\n      } else {\n        resolve(result);\n      }\n      \n      this.pendingTasks.delete(taskId);\n    };\n  }\n  \n  async processLargeDataset(data) {\n    const taskId = Date.now() + Math.random();\n    \n    return new Promise((resolve, reject) => {\n      this.pendingTasks.set(taskId, { resolve, reject });\n      \n      this.worker.postMessage({\n        taskId,\n        type: 'PROCESS_DATA',\n        data\n      });\n    });\n  }\n  \n  terminate() {\n    this.worker.terminate();\n  }\n}\n\n// Usage\nconst processor = new DataProcessor();\nprocessor.processLargeDataset(largeArray)\n  .then(result => console.log('Processed:', result))\n  .catch(error => console.error('Error:', error));\n```\n\n**Worker Pool Pattern:**\n```javascript\nclass WorkerPool {\n  constructor(workerScript, poolSize = 4) {\n    this.workers = [];\n    this.queue = [];\n    this.busyWorkers = new Set();\n    \n    for (let i = 0; i < poolSize; i++) {\n      const worker = new Worker(workerScript);\n      worker.onmessage = (event) => this.handleWorkerMessage(worker, event);\n      this.workers.push(worker);\n    }\n  }\n  \n  execute(data) {\n    return new Promise((resolve, reject) => {\n      const task = { data, resolve, reject };\n      \n      const availableWorker = this.workers.find(w => !this.busyWorkers.has(w));\n      \n      if (availableWorker) {\n        this.assignTask(availableWorker, task);\n      } else {\n        this.queue.push(task);\n      }\n    });\n  }\n  \n  assignTask(worker, task) {\n    this.busyWorkers.add(worker);\n    worker.currentTask = task;\n    worker.postMessage(task.data);\n  }\n  \n  handleWorkerMessage(worker, event) {\n    const task = worker.currentTask;\n    task.resolve(event.data);\n    \n    this.busyWorkers.delete(worker);\n    worker.currentTask = null;\n    \n    // Process queued tasks\n    if (this.queue.length > 0) {\n      const nextTask = this.queue.shift();\n      this.assignTask(worker, nextTask);\n    }\n  }\n}\n```\n\n**Benefits and Limitations:**\n\n**Benefits:**\n- Non-blocking UI\n- True parallelism\n- Improved performance for CPU-intensive tasks\n- Better user experience\n\n**Limitations:**\n- No direct DOM access\n- Limited API access\n- Communication overhead\n- Memory usage\n- Debugging complexity\n\n**Best Practices:**\n- Use for CPU-intensive tasks\n- Pool workers for repeated operations\n- Handle errors properly\n- Clean up workers when done\n- Consider transferable objects for large data",
      "keywords": ["web workers", "worker threads", "background processing", "parallelism", "postMessage", "service workers", "shared workers", "performance", "non-blocking", "CPU-intensive"],
      "difficulty": "medium"
    },
    {
      "id": 28,
      "tag": "javascript",
      "question": "What are the different ways to handle errors in JavaScript?",
      "answer": "JavaScript provides multiple mechanisms for error handling, from basic try-catch to advanced patterns for different scenarios.\n\n**Basic Error Handling:**\n\n**try-catch-finally:**\n```javascript\nfunction basicErrorHandling() {\n  try {\n    // Code that might throw an error\n    const result = riskyOperation();\n    return result;\n  } catch (error) {\n    // Handle the error\n    console.error('Error occurred:', error.message);\n    return null;\n  } finally {\n    // Always executed\n    console.log('Cleanup operations');\n  }\n}\n\n// Catching specific error types\nfunction specificErrorHandling() {\n  try {\n    JSON.parse('invalid json');\n  } catch (error) {\n    if (error instanceof SyntaxError) {\n      console.log('JSON parsing error');\n    } else if (error instanceof ReferenceError) {\n      console.log('Reference error');\n    } else {\n      console.log('Unknown error:', error);\n    }\n  }\n}\n```\n\n**Custom Error Classes:**\n```javascript\n// Custom error types\nclass ValidationError extends Error {\n  constructor(message, field) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n  }\n}\n\nclass NetworkError extends Error {\n  constructor(message, statusCode) {\n    super(message);\n    this.name = 'NetworkError';\n    this.statusCode = statusCode;\n  }\n}\n\n// Usage\nfunction validateUser(user) {\n  if (!user.email) {\n    throw new ValidationError('Email is required', 'email');\n  }\n  if (!user.email.includes('@')) {\n    throw new ValidationError('Invalid email format', 'email');\n  }\n}\n\ntry {\n  validateUser({ name: 'John' });\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.log(`Validation failed for ${error.field}: ${error.message}`);\n  }\n}\n```\n\n**Async Error Handling:**\n\n**Promise-based:**\n```javascript\n// Promise catch\nfetch('/api/data')\n  .then(response => {\n    if (!response.ok) {\n      throw new NetworkError(`HTTP ${response.status}`, response.status);\n    }\n    return response.json();\n  })\n  .then(data => console.log(data))\n  .catch(error => {\n    if (error instanceof NetworkError) {\n      console.log(`Network error: ${error.message}`);\n    } else {\n      console.log('Unexpected error:', error);\n    }\n  });\n\n// Async/await with try-catch\nasync function fetchUserData(userId) {\n  try {\n    const response = await fetch(`/api/users/${userId}`);\n    \n    if (!response.ok) {\n      throw new NetworkError(`User not found`, response.status);\n    }\n    \n    const user = await response.json();\n    return user;\n  } catch (error) {\n    if (error instanceof NetworkError && error.statusCode === 404) {\n      return null; // User not found\n    }\n    throw error; // Re-throw unexpected errors\n  }\n}\n```\n\n**Global Error Handling:**\n```javascript\n// Unhandled promise rejections\nwindow.addEventListener('unhandledrejection', event => {\n  console.error('Unhandled promise rejection:', event.reason);\n  \n  // Prevent default browser behavior\n  event.preventDefault();\n  \n  // Report to error service\n  reportError(event.reason);\n});\n\n// Global error handler\nwindow.addEventListener('error', event => {\n  console.error('Global error:', {\n    message: event.message,\n    filename: event.filename,\n    lineno: event.lineno,\n    colno: event.colno,\n    error: event.error\n  });\n  \n  reportError(event.error);\n});\n\n// Error reporting function\nfunction reportError(error) {\n  // Send to monitoring service\n  fetch('/api/errors', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      message: error.message,\n      stack: error.stack,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    })\n  }).catch(err => console.log('Failed to report error:', err));\n}\n```\n\n**Error Boundaries (React-like pattern):**\n```javascript\nclass ErrorBoundary {\n  constructor(component, fallback) {\n    this.component = component;\n    this.fallback = fallback;\n    this.hasError = false;\n  }\n  \n  render() {\n    if (this.hasError) {\n      return this.fallback;\n    }\n    \n    try {\n      return this.component();\n    } catch (error) {\n      this.hasError = true;\n      console.error('Component error:', error);\n      return this.fallback;\n    }\n  }\n  \n  reset() {\n    this.hasError = false;\n  }\n}\n\n// Usage\nfunction RiskyComponent() {\n  throw new Error('Component failed');\n}\n\nfunction FallbackComponent() {\n  return '<div>Something went wrong</div>';\n}\n\nconst boundary = new ErrorBoundary(RiskyComponent, FallbackComponent);\nconsole.log(boundary.render()); // \"<div>Something went wrong</div>\"\n```\n\n**Functional Error Handling Patterns:**\n\n**Result/Either Pattern:**\n```javascript\nclass Result {\n  constructor(value, error) {\n    this.value = value;\n    this.error = error;\n  }\n  \n  static ok(value) {\n    return new Result(value, null);\n  }\n  \n  static error(error) {\n    return new Result(null, error);\n  }\n  \n  isOk() {\n    return this.error === null;\n  }\n  \n  isError() {\n    return this.error !== null;\n  }\n  \n  map(fn) {\n    if (this.isError()) return this;\n    try {\n      return Result.ok(fn(this.value));\n    } catch (error) {\n      return Result.error(error);\n    }\n  }\n  \n  flatMap(fn) {\n    if (this.isError()) return this;\n    try {\n      return fn(this.value);\n    } catch (error) {\n      return Result.error(error);\n    }\n  }\n}\n\n// Usage\nfunction divide(a, b) {\n  if (b === 0) {\n    return Result.error(new Error('Division by zero'));\n  }\n  return Result.ok(a / b);\n}\n\nconst result = divide(10, 2)\n  .map(x => x * 2)\n  .map(x => x + 1);\n\nif (result.isOk()) {\n  console.log('Result:', result.value); // 11\n} else {\n  console.log('Error:', result.error.message);\n}\n```\n\n**Circuit Breaker Pattern:**\n```javascript\nclass CircuitBreaker {\n  constructor(failureThreshold = 5, timeout = 60000) {\n    this.failureThreshold = failureThreshold;\n    this.timeout = timeout;\n    this.failureCount = 0;\n    this.lastFailureTime = null;\n    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN\n  }\n  \n  async call(fn) {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'HALF_OPEN';\n      } else {\n        throw new Error('Circuit breaker is OPEN');\n      }\n    }\n    \n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  onSuccess() {\n    this.failureCount = 0;\n    this.state = 'CLOSED';\n  }\n  \n  onFailure() {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n    }\n  }\n}\n\n// Usage\nconst breaker = new CircuitBreaker(3, 5000);\n\nasync function makeApiCall() {\n  return breaker.call(() => fetch('/api/data'));\n}\n```\n\n**Best Practices:**\n- Use specific error types\n- Provide meaningful error messages\n- Log errors appropriately\n- Don't catch and ignore errors\n- Clean up resources in finally blocks\n- Use error boundaries for UI components\n- Implement proper error monitoring\n- Consider functional error handling patterns",
      "keywords": ["error handling", "try-catch", "custom errors", "promise catch", "async await", "global error handler", "unhandled rejection", "circuit breaker", "Result pattern", "error boundaries"],
      "difficulty": "medium"
    },
    {
      "id": 29,
      "tag": "javascript",
      "question": "Explain JavaScript's type coercion and how to avoid common pitfalls.",
      "answer": "Type coercion is JavaScript's automatic conversion of values from one type to another, which can lead to unexpected behavior if not understood properly.\n\n**Implicit Type Coercion:**\n\n**String Conversion:**\n```javascript\n// + operator with strings\nconsole.log('5' + 3);        // '53' (number to string)\nconsole.log('Hello' + true); // 'Hellotrue'\nconsole.log('5' + null);     // '5null'\nconsole.log('5' + undefined); // '5undefined'\n\n// Template literals\nconsole.log(`Value: ${42}`); // 'Value: 42'\n\n// String() function\nconsole.log(String(123));    // '123'\nconsole.log(String(true));   // 'true'\nconsole.log(String(null));   // 'null'\n```\n\n**Number Conversion:**\n```javascript\n// Arithmetic operators (except +)\nconsole.log('5' - 3);     // 2\nconsole.log('10' * 2);    // 20\nconsole.log('15' / 3);    // 5\nconsole.log('5' % 2);     // 1\n\n// Unary + operator\nconsole.log(+'42');       // 42\nconsole.log(+true);       // 1\nconsole.log(+false);      // 0\nconsole.log(+null);       // 0\nconsole.log(+undefined);  // NaN\nconsole.log(+'hello');    // NaN\n\n// Number() function\nconsole.log(Number('123')); // 123\nconsole.log(Number(''));    // 0\nconsole.log(Number(' '));   // 0\n```\n\n**Boolean Conversion:**\n```javascript\n// Falsy values\nconsole.log(Boolean(false));     // false\nconsole.log(Boolean(0));         // false\nconsole.log(Boolean(-0));        // false\nconsole.log(Boolean(0n));        // false (BigInt zero)\nconsole.log(Boolean(''));        // false\nconsole.log(Boolean(null));      // false\nconsole.log(Boolean(undefined)); // false\nconsole.log(Boolean(NaN));       // false\n\n// Everything else is truthy\nconsole.log(Boolean('0'));       // true (string '0')\nconsole.log(Boolean('false'));   // true (string 'false')\nconsole.log(Boolean([]));        // true (empty array)\nconsole.log(Boolean({}));        // true (empty object)\nconsole.log(Boolean(function(){})); // true\n```\n\n**Comparison Coercion:**\n\n**Abstract Equality (==):**\n```javascript\n// Same type - no coercion\nconsole.log(5 == 5);          // true\nconsole.log('hello' == 'hello'); // true\n\n// null and undefined\nconsole.log(null == undefined); // true\nconsole.log(null == 0);         // false\nconsole.log(undefined == 0);    // false\n\n// Number and string\nconsole.log(5 == '5');          // true (string to number)\nconsole.log(0 == '');           // true\nconsole.log(0 == '0');          // true\n\n// Boolean conversion\nconsole.log(true == 1);         // true\nconsole.log(false == 0);        // true\nconsole.log(true == '1');       // true\nconsole.log(false == '');       // true\n\n// Object to primitive\nconsole.log([1] == 1);          // true\nconsole.log([1,2] == '1,2');    // true\nconsole.log({} == '[object Object]'); // true\n```\n\n**Common Pitfalls:**\n\n**Array Coercion:**\n```javascript\n// Array to number/string conversion\nconsole.log([] + []);           // '' (empty string)\nconsole.log([1] + [2]);         // '12' (string concatenation)\nconsole.log([1,2] + [3,4]);     // '1,23,4'\n\n// Array in boolean context\nif ([]) {\n  console.log('Empty array is truthy!'); // This runs\n}\n\n// Array comparison\nconsole.log([] == 0);           // true\nconsole.log([] == false);       // true\nconsole.log([] == '');          // true\n```\n\n**Object Coercion:**\n```javascript\n// Object to primitive conversion\nconst obj = {\n  valueOf() { return 42; },\n  toString() { return 'hello'; }\n};\n\nconsole.log(obj + 1);           // 43 (valueOf used)\nconsole.log(obj + '');          // '42' (valueOf used)\nconsole.log(String(obj));       // 'hello' (toString used)\n\n// Date objects\nconst date = new Date(2023, 0, 1);\nconsole.log(date + 1000);       // String concatenation\nconsole.log(+date);             // Number (timestamp)\n```\n\n**Prevention Strategies:**\n\n**1. Use Strict Equality:**\n```javascript\n// Always prefer === and !==\nif (value === null) { /* ... */ }\nif (typeof value === 'string') { /* ... */ }\nif (array.length === 0) { /* ... */ }\n\n// ESLint rule: eqeqeq\n```\n\n**2. Explicit Type Conversion:**\n```javascript\n// Be explicit about conversions\nconst str = String(value);           // Not: '' + value\nconst num = Number(value);           // Not: +value\nconst bool = Boolean(value);         // Not: !!value\n\n// For specific conversions\nconst int = parseInt(str, 10);       // Always specify radix\nconst float = parseFloat(str);\n```\n\n**3. Input Validation:**\n```javascript\nfunction safeDivide(a, b) {\n  // Validate types\n  if (typeof a !== 'number' || typeof b !== 'number') {\n    throw new TypeError('Both arguments must be numbers');\n  }\n  \n  // Validate values\n  if (isNaN(a) || isNaN(b)) {\n    throw new Error('Arguments cannot be NaN');\n  }\n  \n  if (b === 0) {\n    throw new Error('Division by zero');\n  }\n  \n  return a / b;\n}\n```\n\n**4. Utility Functions:**\n```javascript\n// Type checking utilities\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\n\nfunction isArray(value) {\n  return Array.isArray(value);\n}\n\nfunction isEmpty(value) {\n  if (value === null || value === undefined) return true;\n  if (typeof value === 'string') return value.length === 0;\n  if (Array.isArray(value)) return value.length === 0;\n  if (typeof value === 'object') return Object.keys(value).length === 0;\n  return false;\n}\n\n// Safe conversion utilities\nfunction toNumber(value, defaultValue = 0) {\n  const num = Number(value);\n  return isNaN(num) ? defaultValue : num;\n}\n\nfunction toString(value, defaultValue = '') {\n  if (value === null || value === undefined) return defaultValue;\n  return String(value);\n}\n```\n\n**5. TypeScript:**\n```typescript\n// Use TypeScript for type safety\nfunction add(a: number, b: number): number {\n  return a + b; // Type errors caught at compile time\n}\n\n// Type guards\nfunction isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // TypeScript knows value is string here\n    console.log(value.toUpperCase());\n  }\n}\n```\n\n**Best Practices:**\n- Always use strict equality (===, !==)\n- Be explicit about type conversions\n- Validate inputs in functions\n- Use TypeScript for larger projects\n- Enable strict ESLint rules\n- Test edge cases with different types\n- Understand the coercion rules\n- Prefer functional programming patterns",
      "keywords": ["type coercion", "implicit conversion", "strict equality", "loose equality", "truthy", "falsy", "type conversion", "comparison operators", "validation", "TypeScript"],
      "difficulty": "medium"
    },
    {
      "id": 30,
      "tag": "javascript",
      "question": "Explain the JavaScript Event Loop and how it works.",
      "answer": "The Event Loop is JavaScript's mechanism for handling asynchronous operations while maintaining a single-threaded execution model.\n\n**Key Components:**\n\n**1. Call Stack:**\n- Executes functions in LIFO (Last In, First Out) order\n- Where synchronous code runs\n- Only one function can execute at a time\n\n**2. Web APIs (Browser) / C++ APIs (Node.js):**\n- Handle asynchronous operations (setTimeout, fetch, DOM events)\n- Run outside the main JavaScript thread\n\n**3. Callback Queue (Task Queue):**\n- Holds callbacks from completed async operations\n- FIFO (First In, First Out) order\n\n**4. Microtask Queue:**\n- Higher priority than callback queue\n- Contains Promise callbacks, queueMicrotask()\n\n**Event Loop Process:**\n```javascript\nconsole.log('1');\n\nsetTimeout(() => console.log('2'), 0);\n\nPromise.resolve().then(() => console.log('3'));\n\nconsole.log('4');\n\n// Output: 1, 4, 3, 2\n// Explanation:\n// 1. '1' - synchronous, executes immediately\n// 4. '4' - synchronous, executes immediately\n// 3. '3' - microtask (Promise), higher priority\n// 2. '2' - macrotask (setTimeout), lower priority\n```\n\n**Detailed Example:**\n```javascript\nfunction step1() {\n  console.log('Step 1');\n  setTimeout(() => console.log('Timer 1'), 0);\n  Promise.resolve().then(() => console.log('Promise 1'));\n}\n\nfunction step2() {\n  console.log('Step 2');\n  setTimeout(() => console.log('Timer 2'), 0);\n  Promise.resolve().then(() => console.log('Promise 2'));\n}\n\nstep1();\nstep2();\nconsole.log('Synchronous');\n\n// Output:\n// Step 1\n// Step 2\n// Synchronous\n// Promise 1\n// Promise 2\n// Timer 1\n// Timer 2\n```\n\n**Phases of Execution:**\n1. Execute all synchronous code\n2. Process all microtasks\n3. Process one macrotask\n4. Process all microtasks again\n5. Repeat steps 3-4\n\n**Common Pitfalls:**\n```javascript\n// Blocking the event loop\nfunction blockingLoop() {\n  const start = Date.now();\n  while (Date.now() - start < 5000) {\n    // Blocks for 5 seconds - bad!\n  }\n  console.log('Done');\n}\n\n// Better approach - non-blocking\nfunction nonBlockingLoop(iterations, callback) {\n  let i = 0;\n  function process() {\n    let start = Date.now();\n    while (i < iterations && Date.now() - start < 50) {\n      // Process for max 50ms\n      i++;\n    }\n    if (i < iterations) {\n      setTimeout(process, 0); // Yield control\n    } else {\n      callback();\n    }\n  }\n  process();\n}\n```",
      "keywords": ["event loop", "call stack", "callback queue", "microtask queue", "web apis", "asynchronous", "single-threaded", "macrotask", "non-blocking"],
      "difficulty": "hard"
    },
    {
      "id": 31,
      "tag": "javascript",
      "question": "What is prototype inheritance and how does it work in JavaScript?",
      "answer": "Prototype inheritance is JavaScript's mechanism for object inheritance, where objects can inherit properties and methods from other objects through the prototype chain.\n\n**Prototype Chain:**\n```javascript\n// Every object has a prototype\nconst obj = {};\nconsole.log(obj.__proto__ === Object.prototype); // true\nconsole.log(Object.prototype.__proto__ === null); // true (end of chain)\n\n// Constructor function approach\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\nconst john = new Person('John');\nconsole.log(john.greet()); // \"Hello, I'm John\"\nconsole.log(john.__proto__ === Person.prototype); // true\n```\n\n**Property Lookup:**\n```javascript\nfunction Animal(species) {\n  this.species = species;\n}\n\nAnimal.prototype.makeSound = function() {\n  return 'Some generic sound';\n};\n\nfunction Dog(name, breed) {\n  Animal.call(this, 'Canine'); // Call parent constructor\n  this.name = name;\n  this.breed = breed;\n}\n\n// Set up inheritance\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n\nDog.prototype.makeSound = function() {\n  return 'Woof!';\n};\n\nDog.prototype.wagTail = function() {\n  return `${this.name} is wagging tail`;\n};\n\nconst buddy = new Dog('Buddy', 'Golden Retriever');\n\n// Property lookup process:\n// 1. Look in buddy object - finds 'name', 'breed', 'species'\n// 2. Look in Dog.prototype - finds 'makeSound', 'wagTail'\n// 3. Look in Animal.prototype - finds original 'makeSound' (overridden)\n// 4. Look in Object.prototype - finds toString, hasOwnProperty, etc.\n// 5. null - end of chain\n\nconsole.log(buddy.makeSound()); // \"Woof!\" (from Dog.prototype)\nconsole.log(buddy.species); // \"Canine\" (from buddy object)\nconsole.log(buddy.toString()); // \"[object Object]\" (from Object.prototype)\n```\n\n**Modern Class Syntax (ES6):**\n```javascript\nclass Animal {\n  constructor(species) {\n    this.species = species;\n  }\n  \n  makeSound() {\n    return 'Some generic sound';\n  }\n  \n  static getKingdom() {\n    return 'Animalia';\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super('Canine'); // Call parent constructor\n    this.name = name;\n    this.breed = breed;\n  }\n  \n  makeSound() {\n    return 'Woof!';\n  }\n  \n  wagTail() {\n    return `${this.name} is wagging tail`;\n  }\n}\n\nconst rex = new Dog('Rex', 'German Shepherd');\nconsole.log(rex.makeSound()); // \"Woof!\"\nconsole.log(rex instanceof Dog); // true\nconsole.log(rex instanceof Animal); // true\nconsole.log(Dog.getKingdom()); // \"Animalia\"\n```\n\n**Object.create() Method:**\n```javascript\n// Creating objects with specific prototype\nconst vehiclePrototype = {\n  start() {\n    return `${this.type} is starting`;\n  },\n  stop() {\n    return `${this.type} has stopped`;\n  }\n};\n\nconst car = Object.create(vehiclePrototype);\ncar.type = 'Car';\ncar.wheels = 4;\n\nconst motorcycle = Object.create(vehiclePrototype);\nmotorcycle.type = 'Motorcycle';\nmotorcycle.wheels = 2;\n\nconsole.log(car.start()); // \"Car is starting\"\nconsole.log(motorcycle.start()); // \"Motorcycle is starting\"\n```\n\n**Prototype Methods:**\n```javascript\nfunction checkPrototype() {\n  const obj = { name: 'Test' };\n  \n  // Check if object has own property\n  console.log(obj.hasOwnProperty('name')); // true\n  console.log(obj.hasOwnProperty('toString')); // false\n  \n  // Check prototype relationship\n  console.log(Object.prototype.isPrototypeOf(obj)); // true\n  \n  // Get prototype\n  console.log(Object.getPrototypeOf(obj) === Object.prototype); // true\n  \n  // Set prototype\n  const newProto = { customMethod() { return 'custom'; } };\n  Object.setPrototypeOf(obj, newProto);\n  console.log(obj.customMethod()); // \"custom\"\n}\n```\n\n**Prototype Pollution (Security Concern):**\n```javascript\n// Dangerous - can affect all objects\nObject.prototype.isAdmin = true;\n\nconst user = { name: 'John' };\nconsole.log(user.isAdmin); // true - pollution!\n\n// Safe alternatives\nconst safeUser = Object.create(null); // No prototype\nsafeUser.name = 'Jane';\nconsole.log(safeUser.isAdmin); // undefined\n\n// Or use Map for key-value pairs\nconst userMap = new Map();\nuserMap.set('name', 'Bob');\nconsole.log(userMap.get('isAdmin')); // undefined\n```\n\n**Performance Considerations:**\n```javascript\n// Prototype methods are shared (memory efficient)\nfunction Person(name) {\n  this.name = name;\n  // Bad - creates new function for each instance\n  // this.greet = function() { return `Hi, ${this.name}`; };\n}\n\n// Good - shared across all instances\nPerson.prototype.greet = function() {\n  return `Hi, ${this.name}`;\n};\n\nconst person1 = new Person('Alice');\nconst person2 = new Person('Bob');\n\nconsole.log(person1.greet === person2.greet); // true (same function)\n```",
      "keywords": ["prototype", "inheritance", "prototype chain", "__proto__", "Object.create", "constructor function", "class extends", "instanceof", "hasOwnProperty", "prototype pollution"],
      "difficulty": "hard"
    },
    {
      "id": 32,
      "tag": "javascript",
      "question": "What are Generators and Iterators? How do they work?",
      "answer": "Generators and Iterators provide a way to create custom iteration behavior and pausable functions in JavaScript.\n\n**Iterators:**\nObjects that implement the iterator protocol with a `next()` method.\n\n```javascript\n// Custom Iterator\nfunction createRangeIterator(start, end) {\n  let current = start;\n  \n  return {\n    next() {\n      if (current <= end) {\n        return { value: current++, done: false };\n      } else {\n        return { value: undefined, done: true };\n      }\n    }\n  };\n}\n\nconst iterator = createRangeIterator(1, 3);\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: 3, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n\n**Generators:**\nFunctions that can be paused and resumed using `yield`.\n\n```javascript\n// Generator function\nfunction* numberGenerator() {\n  console.log('Start');\n  yield 1;\n  console.log('After first yield');\n  yield 2;\n  console.log('After second yield');\n  yield 3;\n  console.log('End');\n  return 'finished';\n}\n\nconst gen = numberGenerator();\nconsole.log(gen.next()); // \"Start\", { value: 1, done: false }\nconsole.log(gen.next()); // \"After first yield\", { value: 2, done: false }\nconsole.log(gen.next()); // \"After second yield\", { value: 3, done: false }\nconsole.log(gen.next()); // \"End\", { value: \"finished\", done: true }\n```\n\n**Generator with Parameters:**\n```javascript\nfunction* parameterGenerator() {\n  const first = yield 'First yield';\n  console.log('Received:', first);\n  \n  const second = yield 'Second yield';\n  console.log('Received:', second);\n  \n  return 'Done';\n}\n\nconst gen = parameterGenerator();\nconsole.log(gen.next());           // { value: \"First yield\", done: false }\nconsole.log(gen.next('Hello'));    // \"Received: Hello\", { value: \"Second yield\", done: false }\nconsole.log(gen.next('World'));    // \"Received: World\", { value: \"Done\", done: true }\n```\n\n**Practical Examples:**\n\n**Infinite Sequences:**\n```javascript\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) {\n    yield a;\n    [a, b] = [b, a + b];\n  }\n}\n\nconst fib = fibonacci();\nfor (let i = 0; i < 10; i++) {\n  console.log(fib.next().value);\n}\n// Output: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34\n```\n\n**Async Data Processing:**\n```javascript\nfunction* processData(data) {\n  for (const item of data) {\n    // Simulate processing\n    const processed = item * 2;\n    yield processed;\n  }\n}\n\nfunction* asyncDataProcessor(data) {\n  for (const item of data) {\n    // Simulate async operation\n    yield new Promise(resolve => {\n      setTimeout(() => resolve(item * 2), 100);\n    });\n  }\n}\n\n// Usage\nasync function processAsync() {\n  const data = [1, 2, 3, 4, 5];\n  const processor = asyncDataProcessor(data);\n  \n  for (const promise of processor) {\n    const result = await promise;\n    console.log('Processed:', result);\n  }\n}\n```\n\n**Generator Delegation:**\n```javascript\nfunction* innerGenerator() {\n  yield 'inner-1';\n  yield 'inner-2';\n}\n\nfunction* outerGenerator() {\n  yield 'outer-1';\n  yield* innerGenerator(); // Delegate to another generator\n  yield 'outer-2';\n}\n\nconst gen = outerGenerator();\nconsole.log([...gen]); // ['outer-1', 'inner-1', 'inner-2', 'outer-2']\n```\n\n**State Machine with Generators:**\n```javascript\nfunction* stateMachine() {\n  let state = 'idle';\n  \n  while (true) {\n    switch (state) {\n      case 'idle':\n        const action = yield 'waiting';\n        if (action === 'start') state = 'running';\n        break;\n        \n      case 'running':\n        const command = yield 'processing';\n        if (command === 'pause') state = 'paused';\n        else if (command === 'stop') state = 'idle';\n        break;\n        \n      case 'paused':\n        const resume = yield 'paused';\n        if (resume === 'resume') state = 'running';\n        else if (resume === 'stop') state = 'idle';\n        break;\n    }\n  }\n}\n\nconst machine = stateMachine();\nconsole.log(machine.next());           // { value: \"waiting\", done: false }\nconsole.log(machine.next('start'));   // { value: \"processing\", done: false }\nconsole.log(machine.next('pause'));   // { value: \"paused\", done: false }\nconsole.log(machine.next('resume'));  // { value: \"processing\", done: false }\n```\n\n**Iterator Protocol Implementation:**\n```javascript\nclass Range {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  \n  // Make object iterable\n  [Symbol.iterator]() {\n    let current = this.start;\n    const end = this.end;\n    \n    return {\n      next() {\n        if (current <= end) {\n          return { value: current++, done: false };\n        }\n        return { value: undefined, done: true };\n      }\n    };\n  }\n}\n\n// Usage\nconst range = new Range(1, 5);\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n\n// Or using spread operator\nconsole.log([...range]); // [1, 2, 3, 4, 5]\n```\n\n**Generator-based Async Control:**\n```javascript\nfunction* fetchSequence() {\n  try {\n    const user = yield fetch('/api/user');\n    const posts = yield fetch(`/api/posts/${user.id}`);\n    const comments = yield fetch(`/api/comments/${posts[0].id}`);\n    return { user, posts, comments };\n  } catch (error) {\n    console.log('Error in sequence:', error);\n  }\n}\n\n// Runner function\nasync function runGenerator(gen) {\n  let result = gen.next();\n  \n  while (!result.done) {\n    try {\n      const response = await result.value;\n      const data = await response.json();\n      result = gen.next(data);\n    } catch (error) {\n      result = gen.throw(error);\n    }\n  }\n  \n  return result.value;\n}\n\n// Usage\n// runGenerator(fetchSequence()).then(data => console.log(data));\n```\n\n**Key Benefits:**\n- Lazy evaluation\n- Memory efficient for large datasets\n- Pausable execution\n- Custom iteration behavior\n- State management\n- Async flow control",
      "keywords": ["generators", "iterators", "yield", "next()", "iterator protocol", "generator function", "lazy evaluation", "state machine", "async control", "Symbol.iterator"],
      "difficulty": "hard"
    },
    {
      "id": 33,
      "tag": "javascript",
      "question": "Explain the difference between `call`, `apply`, and `bind` methods.",
      "answer": "These methods are used to set the `this` context and invoke functions with specific arguments.\n\n**call() Method:**\nInvokes function immediately with specified `this` and individual arguments.\n\n```javascript\nfunction greet(greeting, punctuation) {\n  return `${greeting}, I'm ${this.name}${punctuation}`;\n}\n\nconst person = { name: 'Alice' };\n\n// Using call\nconst result = greet.call(person, 'Hello', '!');\nconsole.log(result); // \"Hello, I'm Alice!\"\n\n// Syntax: func.call(thisArg, arg1, arg2, ...)\n```\n\n**apply() Method:**\nSimilar to call, but takes arguments as an array.\n\n```javascript\nfunction introduce(greeting, age, city) {\n  return `${greeting}, I'm ${this.name}, ${age} years old from ${city}`;\n}\n\nconst user = { name: 'Bob' };\nconst args = ['Hi', 25, 'NYC'];\n\n// Using apply\nconst result = introduce.apply(user, args);\nconsole.log(result); // \"Hi, I'm Bob, 25 years old from NYC\"\n\n// Syntax: func.apply(thisArg, [arg1, arg2, ...])\n```\n\n**bind() Method:**\nReturns a new function with bound `this` context (doesn't invoke immediately).\n\n```javascript\nfunction sayHello(greeting) {\n  return `${greeting}, ${this.name}!`;\n}\n\nconst person = { name: 'Charlie' };\n\n// Using bind\nconst boundSayHello = sayHello.bind(person);\nconsole.log(boundSayHello('Hey')); // \"Hey, Charlie!\"\n\n// Bind with preset arguments (partial application)\nconst boundWithGreeting = sayHello.bind(person, 'Good morning');\nconsole.log(boundWithGreeting()); // \"Good morning, Charlie!\"\n\n// Syntax: func.bind(thisArg, arg1, arg2, ...)\n```\n\n**Practical Examples:**\n\n**Borrowing Methods:**\n```javascript\nconst array1 = [1, 2, 3];\nconst array2 = [4, 5, 6];\n\n// Borrow push method\nArray.prototype.push.apply(array1, array2);\nconsole.log(array1); // [1, 2, 3, 4, 5, 6]\n\n// Modern alternative with spread operator\n// array1.push(...array2);\n```\n\n**Finding Max/Min in Arrays:**\n```javascript\nconst numbers = [10, 5, 8, 3, 15, 2];\n\n// Using apply to pass array elements as individual arguments\nconst max = Math.max.apply(null, numbers);\nconst min = Math.min.apply(null, numbers);\n\nconsole.log(max); // 15\nconsole.log(min); // 2\n\n// Modern alternatives:\n// Math.max(...numbers)\n// Math.min(...numbers)\n```\n\n**Event Handler Binding:**\n```javascript\nclass Button {\n  constructor(element, text) {\n    this.element = element;\n    this.text = text;\n    this.clickCount = 0;\n    \n    // Bind method to preserve 'this' context\n    this.handleClick = this.handleClick.bind(this);\n    this.element.addEventListener('click', this.handleClick);\n  }\n  \n  handleClick() {\n    this.clickCount++;\n    console.log(`${this.text} clicked ${this.clickCount} times`);\n  }\n  \n  destroy() {\n    this.element.removeEventListener('click', this.handleClick);\n  }\n}\n\n// Usage\n// const button = new Button(document.getElementById('myButton'), 'Submit');\n```\n\n**Function Composition:**\n```javascript\nfunction multiply(a, b) {\n  return a * b;\n}\n\nfunction add(a, b) {\n  return a + b;\n}\n\n// Creating specialized functions\nconst double = multiply.bind(null, 2);\nconst addFive = add.bind(null, 5);\n\nconsole.log(double(8)); // 16\nconsole.log(addFive(3)); // 8\n\n// Composition\nfunction compose(fn1, fn2) {\n  return function(value) {\n    return fn1.call(this, fn2.call(this, value));\n  };\n}\n\nconst doubleThenAddFive = compose(addFive, double);\nconsole.log(doubleThenAddFive(3)); // 11 (3 * 2 + 5)\n```\n\n**Converting Array-like Objects:**\n```javascript\nfunction processArguments() {\n  // arguments is array-like but not a real array\n  console.log(typeof arguments.forEach); // undefined\n  \n  // Convert to real array using call\n  const argsArray = Array.prototype.slice.call(arguments);\n  console.log(Array.isArray(argsArray)); // true\n  \n  // Now we can use array methods\n  argsArray.forEach(arg => console.log(arg));\n  \n  // Modern alternatives:\n  // const argsArray = Array.from(arguments);\n  // const argsArray = [...arguments];\n}\n\nprocessArguments(1, 2, 3, 'hello');\n```\n\n**Polyfill Example (bind):**\n```javascript\n// Simple polyfill for bind (educational purpose)\nif (!Function.prototype.bind) {\n  Function.prototype.bind = function(thisArg) {\n    const fn = this;\n    const args = Array.prototype.slice.call(arguments, 1);\n    \n    return function() {\n      const finalArgs = args.concat(Array.prototype.slice.call(arguments));\n      return fn.apply(thisArg, finalArgs);\n    };\n  };\n}\n```\n\n**Performance Considerations:**\n```javascript\nconst obj = { name: 'Test' };\n\nfunction testFunction() {\n  return this.name;\n}\n\n// call and apply invoke immediately\nconsole.time('call');\nfor (let i = 0; i < 1000000; i++) {\n  testFunction.call(obj);\n}\nconsole.timeEnd('call');\n\n// bind creates new function each time (in loop)\nconsole.time('bind-in-loop');\nfor (let i = 0; i < 1000000; i++) {\n  const bound = testFunction.bind(obj);\n  bound();\n}\nconsole.timeEnd('bind-in-loop');\n\n// bind once, reuse (better)\nconst boundOnce = testFunction.bind(obj);\nconsole.time('bind-reuse');\nfor (let i = 0; i < 1000000; i++) {\n  boundOnce();\n}\nconsole.timeEnd('bind-reuse');\n```\n\n**Key Differences Summary:**\n- **call**: Immediate execution, individual arguments\n- **apply**: Immediate execution, array of arguments\n- **bind**: Returns new function, supports partial application\n- All three set the `this` context\n- call/apply are faster for one-time use\n- bind is better for reusable functions",
      "keywords": ["call", "apply", "bind", "this context", "function invocation", "partial application", "method borrowing", "event handlers", "array-like objects", "performance"],
      "difficulty": "medium"
    },
    {
      "id": 34,
      "tag": "javascript",
      "question": "What are WeakMap and WeakSet? How do they differ from Map and Set?",
      "answer": "WeakMap and WeakSet are collections that hold weak references to their keys/values, allowing for garbage collection when there are no other references.\n\n**WeakMap vs Map:**\n\n**WeakMap Characteristics:**\n- Keys MUST be objects (not primitives)\n- No iteration methods (no forEach, keys(), values())\n- No size property\n- Keys are weakly referenced\n- Not enumerable\n\n```javascript\n// WeakMap example\nconst wm = new WeakMap();\nconst key1 = { id: 1 };\nconst key2 = { id: 2 };\n\nwm.set(key1, 'value1');\nwm.set(key2, 'value2');\n\nconsole.log(wm.get(key1)); // 'value1'\nconsole.log(wm.has(key2)); // true\n\n// When key1 goes out of scope and is garbage collected,\n// its entry in WeakMap is automatically removed\n\n// WeakMap methods: set(), get(), has(), delete()\n// NO: size, clear(), keys(), values(), entries(), forEach()\n```\n\n**Regular Map for comparison:**\n```javascript\nconst map = new Map();\nconst obj = { id: 1 };\n\nmap.set(obj, 'value');\nmap.set('stringKey', 'value2'); // Primitives allowed\n\nconsole.log(map.size); // 2\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\n// obj won't be garbage collected while it's a key in Map\n```\n\n**WeakMap Use Cases:**\n\n**1. Private Data Storage:**\n```javascript\nconst privateData = new WeakMap();\n\nclass User {\n  constructor(name, ssn) {\n    this.name = name;\n    // Store sensitive data privately\n    privateData.set(this, { ssn });\n  }\n  \n  getSSN() {\n    const private = privateData.get(this);\n    return private ? private.ssn : null;\n  }\n}\n\nconst user = new User('Alice', '123-45-6789');\nconsole.log(user.name); // 'Alice'\nconsole.log(user.ssn); // undefined (not accessible)\nconsole.log(user.getSSN()); // '123-45-6789'\n\n// When user object is deleted, private data is also cleaned up\n```\n\n**2. DOM Element Metadata:**\n```javascript\nconst elementData = new WeakMap();\n\nfunction attachMetadata(element, data) {\n  elementData.set(element, data);\n}\n\nfunction getMetadata(element) {\n  return elementData.get(element);\n}\n\n// Usage\nconst button = document.getElementById('myButton');\nattachMetadata(button, {\n  clickCount: 0,\n  lastClicked: null\n});\n\n// When DOM element is removed, metadata is automatically cleaned up\n```\n\n**3. Caching with Automatic Cleanup:**\n```javascript\nconst cache = new WeakMap();\n\nfunction expensiveOperation(obj) {\n  if (cache.has(obj)) {\n    return cache.get(obj);\n  }\n  \n  // Simulate expensive computation\n  const result = JSON.stringify(obj).length * Math.random();\n  cache.set(obj, result);\n  return result;\n}\n\nconst data = { large: 'dataset', with: 'many', properties: true };\nconsole.log(expensiveOperation(data)); // Computed\nconsole.log(expensiveOperation(data)); // From cache\n\n// When data object is no longer referenced, cache entry is cleaned up\n```\n\n**WeakSet vs Set:**\n\n**WeakSet Characteristics:**\n- Values MUST be objects\n- No iteration methods\n- No size property  \n- Values are weakly referenced\n\n```javascript\n// WeakSet example\nconst ws = new WeakSet();\nconst obj1 = { name: 'Alice' };\nconst obj2 = { name: 'Bob' };\n\nws.add(obj1);\nws.add(obj2);\n\nconsole.log(ws.has(obj1)); // true\nws.delete(obj2);\nconsole.log(ws.has(obj2)); // false\n\n// WeakSet methods: add(), has(), delete()\n// NO: size, clear(), keys(), values(), entries(), forEach()\n```\n\n**WeakSet Use Cases:**\n\n**1. Object State Tracking:**\n```javascript\nconst processedObjects = new WeakSet();\n\nfunction processObject(obj) {\n  if (processedObjects.has(obj)) {\n    console.log('Already processed');\n    return;\n  }\n  \n  // Process the object\n  console.log('Processing...', obj);\n  processedObjects.add(obj);\n}\n\nconst data1 = { id: 1 };\nconst data2 = { id: 2 };\n\nprocessObject(data1); // \"Processing... { id: 1 }\"\nprocessObject(data1); // \"Already processed\"\nprocessObject(data2); // \"Processing... { id: 2 }\"\n```\n\n**2. Access Control:**\n```javascript\nconst authorizedUsers = new WeakSet();\n\nclass SecureResource {\n  constructor() {\n    this.data = 'Sensitive information';\n  }\n  \n  grantAccess(user) {\n    authorizedUsers.add(user);\n  }\n  \n  revokeAccess(user) {\n    authorizedUsers.delete(user);\n  }\n  \n  getData(user) {\n    if (authorizedUsers.has(user)) {\n      return this.data;\n    }\n    throw new Error('Access denied');\n  }\n}\n\nconst resource = new SecureResource();\nconst user1 = { name: 'Alice' };\nconst user2 = { name: 'Bob' };\n\nresource.grantAccess(user1);\nconsole.log(resource.getData(user1)); // \"Sensitive information\"\n\ntry {\n  console.log(resource.getData(user2)); // Throws error\n} catch (e) {\n  console.log(e.message); // \"Access denied\"\n}\n```\n\n**Memory Comparison Example:**\n```javascript\n// Regular Map holds strong references\nconst strongMap = new Map();\nconst weakMap = new WeakMap();\n\nfunction createObjects() {\n  for (let i = 0; i < 1000; i++) {\n    const obj = { id: i, data: new Array(1000).fill(i) };\n    strongMap.set(obj, `value-${i}`);\n    weakMap.set(obj, `value-${i}`);\n  }\n  // Objects go out of scope here\n}\n\ncreateObjects();\n\n// Force garbage collection (if available)\nif (global.gc) {\n  global.gc();\n}\n\nconsole.log('Strong map size:', strongMap.size); // Still 1000\n// WeakMap entries may be garbage collected\n\n// Clear strong references\nstrongMap.clear();\n```\n\n**When to Use Each:**\n\n**Use WeakMap/WeakSet when:**\n- You need automatic cleanup\n- Storing metadata about objects\n- Implementing private properties\n- Caching that should not prevent garbage collection\n- You don't need iteration\n\n**Use Map/Set when:**\n- You need to iterate over entries\n- You need to know the size\n- Keys/values can be primitives\n- You need enumeration methods\n- You want to prevent garbage collection of keys/values",
      "keywords": ["WeakMap", "WeakSet", "weak references", "garbage collection", "private data", "memory management", "Map", "Set", "enumeration", "metadata"],
      "difficulty": "medium"
    },
    {
      "id": 35,
      "tag": "javascript",
      "question": "Explain JavaScript modules: CommonJS, ES6 modules, and UMD. What are the differences?",
      "answer": "JavaScript modules are reusable pieces of code that encapsulate functionality and can be imported/exported between files.\n\n**CommonJS (Node.js):**\nSynchronous module system used primarily in Node.js.\n\n```javascript\n// math.js (CommonJS export)\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\nconst PI = 3.14159;\n\n// Export ways:\nmodule.exports = { add, multiply, PI };\n\n// Or individual exports:\n// exports.add = add;\n// exports.multiply = multiply;\n// exports.PI = PI;\n\n// Or mixed:\n// module.exports.subtract = (a, b) => a - b;\n```\n\n```javascript\n// main.js (CommonJS import)\nconst { add, multiply, PI } = require('./math');\n// Or: const math = require('./math');\n\nconsole.log(add(2, 3)); // 5\nconsole.log(multiply(4, 5)); // 20\nconsole.log(PI); // 3.14159\n\n// Conditional loading (dynamic)\nif (process.env.NODE_ENV === 'development') {\n  const debugTools = require('./debug-tools');\n  debugTools.enableLogging();\n}\n```\n\n**ES6 Modules (ESM):**\nStatic module system with compile-time optimization, now standard.\n\n```javascript\n// math.js (ES6 export)\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function multiply(a, b) {\n  return a * b;\n}\n\nexport const PI = 3.14159;\n\n// Default export\nexport default function subtract(a, b) {\n  return a - b;\n}\n\n// Or all at once:\n// export { add, multiply, PI, subtract as default };\n```\n\n```javascript\n// main.js (ES6 import)\nimport subtract, { add, multiply, PI } from './math.js';\n// Or: import * as math from './math.js';\n// Or: import subtract from './math.js';\n\nconsole.log(add(2, 3)); // 5\nconsole.log(subtract(10, 4)); // 6\nconsole.log(PI); // 3.14159\n\n// Dynamic imports (ES2020)\nasync function loadMath() {\n  const { add } = await import('./math.js');\n  return add(1, 2);\n}\n\n// Import for side effects only\nimport './polyfills.js';\n```\n\n**Advanced ES6 Module Patterns:**\n```javascript\n// Re-exports (barrel exports)\n// index.js\nexport { add, multiply } from './math.js';\nexport { format, parse } from './string-utils.js';\nexport { default as Calculator } from './calculator.js';\n\n// Rename exports\nexport { add as sum, multiply as product } from './math.js';\n\n// Mixed exports\nimport Calculator from './calculator.js';\nexport { Calculator };\nexport const VERSION = '1.0.0';\n```\n\n**UMD (Universal Module Definition):**\nPattern that works in multiple environments (browser, Node.js, AMD).\n\n```javascript\n// math.js (UMD pattern)\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD (RequireJS)\n    define(['dependency'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // CommonJS (Node.js)\n    module.exports = factory(require('dependency'));\n  } else {\n    // Browser globals\n    root.Math = factory(root.Dependency);\n  }\n}(typeof self !== 'undefined' ? self : this, function (dependency) {\n  'use strict';\n  \n  function add(a, b) {\n    return a + b;\n  }\n  \n  function multiply(a, b) {\n    return a * b;\n  }\n  \n  return {\n    add: add,\n    multiply: multiply\n  };\n}));\n```\n\n**Module Loading Comparison:**\n\n```javascript\n// CommonJS - Synchronous, runtime loading\nconst fs = require('fs'); // Loaded immediately\nif (condition) {\n  const optional = require('optional-module'); // Loaded conditionally\n}\n\n// ES6 - Static analysis, compile-time optimization\nimport fs from 'fs'; // Analyzed at compile time\n\n// Dynamic import for conditional loading\nif (condition) {\n  const module = await import('optional-module');\n}\n```\n\n**Browser Support:**\n\n```html\n<!-- Native ES6 modules -->\n<script type=\"module\" src=\"main.js\"></script>\n\n<!-- Fallback for older browsers -->\n<script nomodule src=\"main-bundle.js\"></script>\n\n<!-- Module with imports -->\n<script type=\"module\">\n  import { add } from './math.js';\n  console.log(add(2, 3));\n</script>\n```\n\n**Node.js ES6 Module Support:**\n\n```json\n// package.json\n{\n  \"type\": \"module\",\n  \"exports\": {\n    \"import\": \"./lib/index.js\",\n    \"require\": \"./lib/index.cjs\"\n  }\n}\n```\n\n```javascript\n// Node.js with .mjs extension\n// math.mjs\nexport const add = (a, b) => a + b;\n\n// main.mjs\nimport { add } from './math.mjs';\nconsole.log(add(1, 2));\n```\n\n**Practical Examples:**\n\n**Utility Library (ES6):**\n```javascript\n// utils/index.js\nexport { debounce, throttle } from './timing.js';\nexport { deepClone, merge } from './objects.js';\nexport { formatDate, parseDate } from './dates.js';\n\n// utils/timing.js\nexport function debounce(func, wait) {\n  let timeout;\n  return function executedFunction(...args) {\n    const later = () => {\n      clearTimeout(timeout);\n      func(...args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n}\n\nexport function throttle(func, limit) {\n  let inThrottle;\n  return function() {\n    const args = arguments;\n    const context = this;\n    if (!inThrottle) {\n      func.apply(context, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  }\n}\n```\n\n**Config Module Pattern:**\n```javascript\n// config.js\nconst config = {\n  development: {\n    apiUrl: 'http://localhost:3000',\n    debug: true\n  },\n  production: {\n    apiUrl: 'https://api.example.com',\n    debug: false\n  }\n};\n\nconst env = process.env.NODE_ENV || 'development';\nexport default config[env];\n\n// Usage\nimport config from './config.js';\nconsole.log(config.apiUrl);\n```\n\n**Key Differences Summary:**\n\n| Feature | CommonJS | ES6 Modules | UMD |\n|---------|----------|-------------|----- |\n| Loading | Synchronous | Static/Dynamic | Environment-dependent |\n| When resolved | Runtime | Compile-time | Runtime |\n| Tree shaking | No | Yes | No |\n| Circular deps | Supported | Supported | Depends |\n| Dynamic imports | Built-in | import() | Manual |\n| Browser support | No (needs bundler) | Yes (modern) | Yes |\n| File extension | .js | .js/.mjs | .js |\n\n**Best Practices:**\n- Use ES6 modules for new projects\n- Use named exports for utilities\n- Use default exports for main functionality\n- Avoid mixing module systems\n- Use dynamic imports for code splitting",
      "keywords": ["modules", "CommonJS", "ES6 modules", "UMD", "import", "export", "require", "dynamic import", "tree shaking", "module bundling"],
      "difficulty": "medium"
    },
    {
      "id": 36,
      "tag": "javascript",
      "question": "What is currying and partial application? Provide examples.",
      "answer": "Currying and partial application are functional programming techniques for creating specialized functions from more general ones.\n\n**Currying:**\nTransforms a function with multiple arguments into a sequence of functions, each taking a single argument.\n\n```javascript\n// Regular function\nfunction add(a, b, c) {\n  return a + b + c;\n}\n\n// Curried version\nfunction curriedAdd(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\n// Usage\nconst addOne = curriedAdd(1);\nconst addOneAndTwo = addOne(2);\nconst result = addOneAndTwo(3); // 6\n\n// Or chained\nconst result2 = curriedAdd(1)(2)(3); // 6\n```\n\n**Arrow Function Currying:**\n```javascript\n// More concise with arrow functions\nconst curriedMultiply = a => b => c => a * b * c;\n\nconst multiplyByTwo = curriedMultiply(2);\nconst multiplyByTwoAndThree = multiplyByTwo(3);\nconsole.log(multiplyByTwoAndThree(4)); // 24\n\n// One-liner usage\nconsole.log(curriedMultiply(2)(3)(4)); // 24\n```\n\n**Generic Curry Function:**\n```javascript\nfunction curry(fn) {\n  return function curried(...args) {\n    if (args.length >= fn.length) {\n      return fn.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      };\n    }\n  };\n}\n\n// Usage\nfunction sum(a, b, c, d) {\n  return a + b + c + d;\n}\n\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3)(4)); // 10\nconsole.log(curriedSum(1, 2)(3, 4)); // 10\nconsole.log(curriedSum(1)(2, 3, 4)); // 10\n```\n\n**Partial Application:**\nCreates a new function by fixing some arguments of the original function.\n\n```javascript\n// Original function\nfunction greet(greeting, name, punctuation) {\n  return `${greeting}, ${name}${punctuation}`;\n}\n\n// Partial application using bind\nconst sayHello = greet.bind(null, 'Hello');\nconst sayHelloToJohn = greet.bind(null, 'Hello', 'John');\n\nconsole.log(sayHello('Alice', '!')); // \"Hello, Alice!\"\nconsole.log(sayHelloToJohn('.')); // \"Hello, John.\"\n```\n\n**Custom Partial Function:**\n```javascript\nfunction partial(fn, ...args1) {\n  return function(...args2) {\n    return fn(...args1, ...args2);\n  };\n}\n\n// Usage\nfunction calculate(operation, a, b, c) {\n  if (operation === 'add') return a + b + c;\n  if (operation === 'multiply') return a * b * c;\n}\n\nconst addThreeNumbers = partial(calculate, 'add');\nconst multiplyByTwoAnd = partial(calculate, 'multiply', 2);\n\nconsole.log(addThreeNumbers(1, 2, 3)); // 6\nconsole.log(multiplyByTwoAnd(3, 4)); // 24\n```\n\n**Practical Examples:**\n\n**Event Handler Currying:**\n```javascript\n// Curried event handler creator\nconst createEventHandler = eventType => selector => callback => {\n  document.addEventListener(eventType, event => {\n    if (event.target.matches(selector)) {\n      callback(event);\n    }\n  });\n};\n\n// Specialized handlers\nconst onClick = createEventHandler('click');\nconst onButtonClick = onClick('button');\nconst onLinkClick = onClick('a');\n\n// Usage\nonButtonClick(event => console.log('Button clicked:', event.target.textContent));\nonLinkClick(event => {\n  event.preventDefault();\n  console.log('Link clicked:', event.target.href);\n});\n```\n\n**API Request Builder:**\n```javascript\n// Curried fetch wrapper\nconst apiRequest = method => baseUrl => endpoint => data => {\n  const url = `${baseUrl}${endpoint}`;\n  const options = {\n    method,\n    headers: { 'Content-Type': 'application/json' }\n  };\n  \n  if (data && method !== 'GET') {\n    options.body = JSON.stringify(data);\n  }\n  \n  return fetch(url, options).then(response => response.json());\n};\n\n// Create specialized request functions\nconst get = apiRequest('GET');\nconst post = apiRequest('POST');\nconst put = apiRequest('PUT');\n\nconst apiGet = get('https://api.example.com');\nconst apiPost = post('https://api.example.com');\n\n// Usage\napiGet('/users').then(users => console.log(users));\napiPost('/users')({ name: 'John', email: 'john@example.com' })\n  .then(user => console.log('Created:', user));\n```\n\n**Form Validation:**\n```javascript\n// Curried validators\nconst createValidator = errorMessage => validationFn => value => {\n  return validationFn(value) ? null : errorMessage;\n};\n\nconst required = createValidator('This field is required')\n  (value => value && value.trim().length > 0);\n\nconst minLength = length => createValidator(`Minimum ${length} characters`)\n  (value => value && value.length >= length);\n\nconst email = createValidator('Invalid email format')\n  (value => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value));\n\n// Compose validators\nfunction validateField(value, validators) {\n  for (const validator of validators) {\n    const error = validator(value);\n    if (error) return error;\n  }\n  return null;\n}\n\n// Usage\nconst nameValidators = [required, minLength(2)];\nconst emailValidators = [required, email];\n\nconsole.log(validateField('', nameValidators)); // \"This field is required\"\nconsole.log(validateField('J', nameValidators)); // \"Minimum 2 characters\"\nconsole.log(validateField('John', nameValidators)); // null (valid)\n```\n\n**Mathematical Operations:**\n```javascript\n// Curried mathematical operations\nconst power = base => exponent => Math.pow(base, exponent);\nconst square = power(2);\nconst cube = power(3);\n\nconst modulo = divisor => number => number % divisor;\nconst isEven = modulo(2);\nconst isDivisibleByThree = modulo(3);\n\n// Array processing with currying\nconst map = fn => array => array.map(fn);\nconst filter = predicate => array => array.filter(predicate);\nconst reduce = fn => initial => array => array.reduce(fn, initial);\n\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n// Functional pipeline\nconst squareNumbers = map(square);\nconst filterEven = filter(x => isEven(x) === 0);\nconst sumAll = reduce((acc, x) => acc + x)(0);\n\nconst result = sumAll(filterEven(squareNumbers(numbers)));\nconsole.log(result); // Sum of squares of even numbers\n```\n\n**Difference Between Currying and Partial Application:**\n\n```javascript\n// Original function\nfunction fullName(title, firstName, lastName) {\n  return `${title} ${firstName} ${lastName}`;\n}\n\n// Currying - always returns single-argument functions\nconst curriedFullName = title => firstName => lastName => \n  `${title} ${firstName} ${lastName}`;\n\n// Must be called with one argument at a time\nconst mrJohn = curriedFullName('Mr.')('John');\nconsole.log(mrJohn('Doe')); // \"Mr. John Doe\"\n\n// Partial Application - can fix any number of arguments\nconst partialFullName = partial(fullName, 'Dr.');\n\n// Can be called with remaining arguments\nconsole.log(partialFullName('Jane', 'Smith')); // \"Dr. Jane Smith\"\n\n// Or further partially applied\nconst drJane = partial(partialFullName, 'Jane');\nconsole.log(drJane('Smith')); // \"Dr. Jane Smith\"\n```\n\n**Benefits:**\n- **Code reuse**: Create specialized functions from general ones\n- **Composition**: Easily combine functions\n- **Configuration**: Pre-configure functions with common parameters\n- **Functional programming**: Enables point-free style\n- **Testing**: Easier to test smaller, focused functions\n\n**Use Cases:**\n- Event handling\n- API client configuration\n- Form validation  \n- Mathematical operations\n- Data transformation pipelines\n- Middleware creation",
      "keywords": ["currying", "partial application", "functional programming", "higher-order functions", "function composition", "specialized functions", "bind", "closure", "configuration"],
      "difficulty": "medium"
    },
    {
      "id": 37,
      "tag": "javascript",
      "question": "What is memoization and how can you implement it in JavaScript?",
      "answer": "Memoization is an optimization technique that stores the results of expensive function calls and returns cached results when the same inputs occur again.\n\n**Basic Memoization Implementation:**\n```javascript\nfunction memoize(fn) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      console.log('Cache hit!');\n      return cache.get(key);\n    }\n    \n    console.log('Computing...');\n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Usage example\nfunction expensiveFunction(n) {\n  // Simulate expensive computation\n  let result = 0;\n  for (let i = 0; i < n * 1000000; i++) {\n    result += i;\n  }\n  return result;\n}\n\nconst memoizedExpensive = memoize(expensiveFunction);\n\nconsole.log(memoizedExpensive(1000)); // Computing... (slow)\nconsole.log(memoizedExpensive(1000)); // Cache hit! (fast)\n```\n\n**Fibonacci with Memoization:**\n```javascript\n// Naive recursive Fibonacci (exponential time)\nfunction fibonacciNaive(n) {\n  if (n <= 1) return n;\n  return fibonacciNaive(n - 1) + fibonacciNaive(n - 2);\n}\n\n// Memoized Fibonacci (linear time)\nconst fibonacciMemo = memoize(function(n) {\n  if (n <= 1) return n;\n  return fibonacciMemo(n - 1) + fibonacciMemo(n - 2);\n});\n\n// Alternative: Manual memoization\nfunction fibonacci() {\n  const memo = {};\n  \n  function fib(n) {\n    if (n <= 1) return n;\n    if (memo[n]) return memo[n];\n    \n    memo[n] = fib(n - 1) + fib(n - 2);\n    return memo[n];\n  }\n  \n  return fib;\n}\n\nconst fibFast = fibonacci();\n\n// Performance comparison\nconsole.time('Naive fib(40)');\nconsole.log(fibonacciNaive(40)); // Very slow\nconsole.timeEnd('Naive fib(40)');\n\nconsole.time('Memoized fib(40)');\nconsole.log(fibonacciMemo(40)); // Fast\nconsole.timeEnd('Memoized fib(40)');\n```\n\n**Advanced Memoization with Custom Key Function:**\n```javascript\nfunction memoizeWithKeyFn(fn, keyFn = JSON.stringify) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = keyFn(args);\n    \n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Custom key function for object arguments\nfunction objectKeyFn(args) {\n  return args.map(arg => \n    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)\n  ).join('|');\n}\n\nconst processUser = memoizeWithKeyFn(\n  function(user, options) {\n    console.log('Processing user:', user.name);\n    return {\n      ...user,\n      processed: true,\n      timestamp: options.timestamp\n    };\n  },\n  objectKeyFn\n);\n\nconst user = { name: 'Alice', age: 30 };\nconst options = { timestamp: Date.now() };\n\nprocessUser(user, options); // \"Processing user: Alice\"\nprocessUser(user, options); // Cache hit - no console log\n```\n\n**LRU (Least Recently Used) Memoization:**\n```javascript\nfunction memoizeLRU(fn, maxSize = 100) {\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    \n    if (cache.has(key)) {\n      // Move to end (most recently used)\n      const value = cache.get(key);\n      cache.delete(key);\n      cache.set(key, value);\n      return value;\n    }\n    \n    const result = fn.apply(this, args);\n    \n    // Remove oldest entry if cache is full\n    if (cache.size >= maxSize) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    \n    cache.set(key, result);\n    return result;\n  };\n}\n\n// Usage\nconst expensiveComputation = memoizeLRU(\n  function(x, y) {\n    console.log(`Computing ${x} + ${y}`);\n    return x + y;\n  },\n  3 // Max 3 cached results\n);\n\nexpensiveComputation(1, 2); // Computing 1 + 2\nexpensiveComputation(3, 4); // Computing 3 + 4\nexpensiveComputation(5, 6); // Computing 5 + 6\nexpensiveComputation(7, 8); // Computing 7 + 8 (evicts 1,2)\nexpensiveComputation(1, 2); // Computing 1 + 2 (cache miss)\n```\n\n**Memoization with TTL (Time To Live):**\n```javascript\nfunction memoizeWithTTL(fn, ttlMs = 60000) { // 1 minute default\n  const cache = new Map();\n  \n  return function(...args) {\n    const key = JSON.stringify(args);\n    const now = Date.now();\n    \n    if (cache.has(key)) {\n      const { value, timestamp } = cache.get(key);\n      \n      if (now - timestamp < ttlMs) {\n        return value;\n      } else {\n        cache.delete(key); // Expired\n      }\n    }\n    \n    const result = fn.apply(this, args);\n    cache.set(key, { value: result, timestamp: now });\n    return result;\n  };\n}\n\n// Usage for API calls\nconst fetchUserData = memoizeWithTTL(\n  async function(userId) {\n    console.log(`Fetching user ${userId}`);\n    const response = await fetch(`/api/users/${userId}`);\n    return response.json();\n  },\n  30000 // Cache for 30 seconds\n);\n```\n\n**React Component Memoization Pattern:**\n```javascript\n// Memoized selector function\nconst memoizedSelector = memoize(function(state, props) {\n  return {\n    user: state.users.find(user => user.id === props.userId),\n    posts: state.posts.filter(post => post.authorId === props.userId),\n    stats: calculateUserStats(state.activities, props.userId)\n  };\n});\n\n// Usage in component\nfunction UserProfile({ userId }) {\n  const [state, setState] = useState(initialState);\n  \n  // Expensive computation only runs when dependencies change\n  const userData = useMemo(\n    () => memoizedSelector(state, { userId }),\n    [state, userId]\n  );\n  \n  return (\n    <div>\n      <h1>{userData.user.name}</h1>\n      <PostList posts={userData.posts} />\n      <UserStats stats={userData.stats} />\n    </div>\n  );\n}\n```\n\n**Class-based Memoization:**\n```javascript\nclass MemoizedCalculator {\n  constructor() {\n    this.cache = new Map();\n  }\n  \n  @memoize // Using decorator (if supported)\n  complexCalculation(a, b, c) {\n    console.log('Performing complex calculation...');\n    // Simulate expensive operation\n    return Math.pow(a, b) + Math.sqrt(c) * Math.PI;\n  }\n  \n  // Manual memoization\n  factorial(n) {\n    const key = `factorial_${n}`;\n    \n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    \n    const result = n <= 1 ? 1 : n * this.factorial(n - 1);\n    this.cache.set(key, result);\n    return result;\n  }\n  \n  clearCache() {\n    this.cache.clear();\n  }\n  \n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      keys: [...this.cache.keys()]\n    };\n  }\n}\n```\n\n**WeakMap Memoization (for object keys):**\n```javascript\nfunction memoizeWeakMap(fn) {\n  const cache = new WeakMap();\n  \n  return function(obj, ...otherArgs) {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n    \n    const objCache = cache.get(obj);\n    const key = JSON.stringify(otherArgs);\n    \n    if (objCache.has(key)) {\n      return objCache.get(key);\n    }\n    \n    const result = fn.call(this, obj, ...otherArgs);\n    objCache.set(key, result);\n    return result;\n  };\n}\n\n// Usage with DOM elements or objects\nconst processElement = memoizeWeakMap(function(element, operation) {\n  console.log('Processing element:', element.tagName);\n  // Expensive DOM operation\n  return element.getBoundingClientRect()[operation];\n});\n\nconst div = document.createElement('div');\nprocessElement(div, 'width'); // Computed\nprocessElement(div, 'width'); // Cached\n```\n\n**When to Use Memoization:**\n\n✅ **Good candidates:**\n- Pure functions (same input = same output)\n- Expensive computations\n- Recursive algorithms\n- API calls with predictable responses\n- Complex data transformations\n\n❌ **Avoid memoization for:**\n- Functions with side effects\n- Functions that return different results for same input\n- Functions called with unique inputs every time\n- Simple, fast operations\n\n**Performance Considerations:**\n- Memory usage increases with cache size\n- Key generation overhead\n- Cache lookup time\n- Consider cache eviction strategies\n- Profile before and after implementation",
      "keywords": ["memoization", "caching", "performance optimization", "dynamic programming", "fibonacci", "LRU cache", "TTL", "WeakMap", "recursive functions", "pure functions"],
      "difficulty": "medium"
    },
    {
      "id": 38,
      "tag": "javascript",
      "question": "Explain the difference between synchronous and asynchronous code. How does JavaScript handle asynchronous operations?",
      "answer": "Synchronous code executes line by line, blocking subsequent operations, while asynchronous code allows operations to run concurrently without blocking the main thread.\n\n**Synchronous Code:**\n```javascript\nconsole.log('Start');\n\n// Blocking operation\nfunction slowOperation() {\n  const start = Date.now();\n  while (Date.now() - start < 3000) {\n    // Block for 3 seconds\n  }\n  return 'Done';\n}\n\nconsole.log('Before slow operation');\nconst result = slowOperation(); // Blocks here\nconsole.log('Result:', result);\nconsole.log('End');\n\n// Output (with 3-second delay between lines 2 and 3):\n// Start\n// Before slow operation\n// Result: Done\n// End\n```\n\n**Asynchronous Code with Callbacks:**\n```javascript\nconsole.log('Start');\n\n// Non-blocking operation\nfunction asyncOperation(callback) {\n  setTimeout(() => {\n    callback('Async result');\n  }, 2000);\n}\n\nconsole.log('Before async operation');\nasyncOperation((result) => {\n  console.log('Result:', result);\n});\nconsole.log('After async operation');\nconsole.log('End');\n\n// Output (immediate):\n// Start\n// Before async operation\n// After async operation\n// End\n// Result: Async result (after 2 seconds)\n```\n\n**JavaScript's Asynchronous Mechanisms:**\n\n**1. Callbacks:**\n```javascript\n// Simple callback\nfunction fetchData(callback) {\n  setTimeout(() => {\n    const data = { id: 1, name: 'User' };\n    callback(null, data); // Error-first callback pattern\n  }, 1000);\n}\n\nfetchData((error, data) => {\n  if (error) {\n    console.error('Error:', error);\n  } else {\n    console.log('Data:', data);\n  }\n});\n\n// Callback hell example\nfetchData((err, user) => {\n  if (err) return console.error(err);\n  \n  fetchUserPosts(user.id, (err, posts) => {\n    if (err) return console.error(err);\n    \n    fetchPostComments(posts[0].id, (err, comments) => {\n      if (err) return console.error(err);\n      \n      console.log('Comments:', comments);\n    });\n  });\n});\n```\n\n**2. Promises:**\n```javascript\n// Promise-based approach\nfunction fetchDataPromise() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      const success = Math.random() > 0.2;\n      if (success) {\n        resolve({ id: 1, name: 'User' });\n      } else {\n        reject(new Error('Failed to fetch data'));\n      }\n    }, 1000);\n  });\n}\n\n// Promise chain\nfetchDataPromise()\n  .then(user => {\n    console.log('User:', user);\n    return fetchUserPosts(user.id);\n  })\n  .then(posts => {\n    console.log('Posts:', posts);\n    return fetchPostComments(posts[0].id);\n  })\n  .then(comments => {\n    console.log('Comments:', comments);\n  })\n  .catch(error => {\n    console.error('Error:', error.message);\n  });\n```\n\n**3. Async/Await:**\n```javascript\n// Async/await approach\nasync function fetchAllData() {\n  try {\n    console.log('Fetching user...');\n    const user = await fetchDataPromise();\n    console.log('User:', user);\n    \n    console.log('Fetching posts...');\n    const posts = await fetchUserPosts(user.id);\n    console.log('Posts:', posts);\n    \n    console.log('Fetching comments...');\n    const comments = await fetchPostComments(posts[0].id);\n    console.log('Comments:', comments);\n    \n    return { user, posts, comments };\n  } catch (error) {\n    console.error('Error:', error.message);\n    throw error;\n  }\n}\n\n// Usage\nfetchAllData()\n  .then(data => console.log('All data:', data))\n  .catch(error => console.error('Failed:', error));\n```\n\n**Concurrent vs Sequential Async Operations:**\n\n```javascript\n// Sequential execution (slower)\nasync function sequentialFetch() {\n  console.time('Sequential');\n  \n  const user1 = await fetchUser(1);    // Wait 1 second\n  const user2 = await fetchUser(2);    // Wait another 1 second\n  const user3 = await fetchUser(3);    // Wait another 1 second\n  \n  console.timeEnd('Sequential'); // ~3 seconds\n  return [user1, user2, user3];\n}\n\n// Concurrent execution (faster)\nasync function concurrentFetch() {\n  console.time('Concurrent');\n  \n  const [user1, user2, user3] = await Promise.all([\n    fetchUser(1),\n    fetchUser(2),\n    fetchUser(3)\n  ]);\n  \n  console.timeEnd('Concurrent'); // ~1 second\n  return [user1, user2, user3];\n}\n\n// Mixed approach - some sequential, some concurrent\nasync function mixedFetch() {\n  // Get user first (required for next step)\n  const user = await fetchUser(1);\n  \n  // Then fetch related data concurrently\n  const [posts, friends, settings] = await Promise.all([\n    fetchUserPosts(user.id),\n    fetchUserFriends(user.id),\n    fetchUserSettings(user.id)\n  ]);\n  \n  return { user, posts, friends, settings };\n}\n```\n\n**Error Handling in Async Code:**\n\n```javascript\n// Promise error handling\nfetchData()\n  .then(data => processData(data))\n  .then(result => saveResult(result))\n  .catch(error => {\n    // Handles errors from any step\n    console.error('Pipeline error:', error);\n    return handleError(error);\n  })\n  .finally(() => {\n    console.log('Cleanup operations');\n  });\n\n// Async/await error handling\nasync function robustAsyncFunction() {\n  let data, processedData, saveResult;\n  \n  try {\n    data = await fetchData();\n  } catch (error) {\n    console.error('Fetch failed:', error);\n    return handleFetchError(error);\n  }\n  \n  try {\n    processedData = await processData(data);\n  } catch (error) {\n    console.error('Processing failed:', error);\n    return handleProcessError(error, data);\n  }\n  \n  try {\n    saveResult = await saveData(processedData);\n    return saveResult;\n  } catch (error) {\n    console.error('Save failed:', error);\n    // Maybe rollback processed data\n    await rollbackData(processedData);\n    throw error;\n  }\n}\n```\n\n**Browser APIs and Async Operations:**\n\n```javascript\n// setTimeout/setInterval\nconst timeoutId = setTimeout(() => {\n  console.log('Delayed execution');\n}, 1000);\n\nconst intervalId = setInterval(() => {\n  console.log('Repeated execution');\n}, 5000);\n\n// Clean up\nclearTimeout(timeoutId);\nclearInterval(intervalId);\n\n// Fetch API\nasync function apiCall() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    \n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    return data;\n  } catch (error) {\n    if (error.name === 'TypeError') {\n      console.error('Network error:', error.message);\n    } else {\n      console.error('API error:', error.message);\n    }\n    throw error;\n  }\n}\n\n// File reading (Node.js)\nconst fs = require('fs').promises;\n\nasync function readFileAsync() {\n  try {\n    const data = await fs.readFile('file.txt', 'utf8');\n    return data;\n  } catch (error) {\n    console.error('File read error:', error.message);\n    throw error;\n  }\n}\n```\n\n**Custom Promise Implementation:**\n\n```javascript\n// Creating custom promises\nfunction delay(ms) {\n  return new Promise(resolve => {\n    setTimeout(resolve, ms);\n  });\n}\n\nfunction timeout(promise, ms) {\n  return Promise.race([\n    promise,\n    new Promise((_, reject) => {\n      setTimeout(() => reject(new Error('Operation timed out')), ms);\n    })\n  ]);\n}\n\nfunction retry(asyncFn, maxAttempts = 3, delayMs = 1000) {\n  return new Promise(async (resolve, reject) => {\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n      try {\n        const result = await asyncFn();\n        resolve(result);\n        return;\n      } catch (error) {\n        console.log(`Attempt ${attempt} failed:`, error.message);\n        \n        if (attempt === maxAttempts) {\n          reject(error);\n          return;\n        }\n        \n        await delay(delayMs);\n      }\n    }\n  });\n}\n\n// Usage\nretry(\n  () => fetch('https://unreliable-api.com/data'),\n  3,\n  2000\n).then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('All attempts failed:', error));\n```\n\n**Key Differences Summary:**\n\n| Aspect | Synchronous | Asynchronous |\n|--------|-------------|-------------|\n| Execution | Blocking | Non-blocking |\n| Order | Sequential | Can be concurrent |\n| Performance | Can freeze UI | Better responsiveness |\n| Complexity | Simpler | More complex |\n| Error handling | try-catch | Promises/callbacks |\n| Debugging | Easier | More challenging |\n\n**Best Practices:**\n- Use async/await for cleaner code\n- Handle errors appropriately\n- Avoid callback hell\n- Use Promise.all() for concurrent operations\n- Implement timeouts for network operations\n- Consider error recovery strategies",
      "keywords": ["synchronous", "asynchronous", "callbacks", "promises", "async await", "concurrent", "sequential", "non-blocking", "event loop", "error handling"],
      "difficulty": "medium"
    },
    {
      "id": 39,
      "tag": "javascript",
      "question": "What are Symbols in JavaScript and what are their use cases?",
      "answer": "Symbols are a primitive data type introduced in ES6 that represent unique identifiers. Every symbol is unique, even if they have the same description.\n\n**Creating Symbols:**\n```javascript\n// Creating symbols\nconst symbol1 = Symbol();\nconst symbol2 = Symbol('description');\nconst symbol3 = Symbol('description');\n\nconsole.log(symbol1); // Symbol()\nconsole.log(symbol2); // Symbol(description)\nconsole.log(symbol3); // Symbol(description)\n\n// Each symbol is unique\nconsole.log(symbol2 === symbol3); // false\nconsole.log(typeof symbol1); // 'symbol'\n```\n\n**Symbol Properties:**\n```javascript\n// Symbols as object properties\nconst mySymbol = Symbol('myProperty');\nconst obj = {};\n\n// Three ways to add symbol properties\nobj[mySymbol] = 'symbol value';\n\nconst obj2 = {\n  [Symbol('prop')]: 'value'\n};\n\nObject.defineProperty(obj, Symbol('hidden'), {\n  value: 'secret',\n  enumerable: false\n});\n\nconsole.log(obj[mySymbol]); // 'symbol value'\nconsole.log(obj.mySymbol); // undefined (not a string property)\n```\n\n**Symbol Registry - Global Symbols:**\n```javascript\n// Global symbol registry\nconst globalSymbol1 = Symbol.for('global.key');\nconst globalSymbol2 = Symbol.for('global.key');\n\nconsole.log(globalSymbol1 === globalSymbol2); // true (same reference)\n\n// Get key from symbol\nconst key = Symbol.keyFor(globalSymbol1);\nconsole.log(key); // 'global.key'\n\n// Local symbols don't have keys in global registry\nconst localSymbol = Symbol('local');\nconsole.log(Symbol.keyFor(localSymbol)); // undefined\n```\n\n**Use Case 1: Private Object Properties**\n```javascript\nconst _name = Symbol('name');\nconst _balance = Symbol('balance');\nconst _deposit = Symbol('deposit');\n\nclass BankAccount {\n  constructor(name, initialBalance) {\n    this[_name] = name;\n    this[_balance] = initialBalance;\n  }\n  \n  [_deposit](amount) {\n    this[_balance] += amount;\n  }\n  \n  deposit(amount) {\n    if (amount > 0) {\n      this[_deposit](amount);\n    }\n  }\n  \n  getBalance() {\n    return this[_balance];\n  }\n  \n  getInfo() {\n    return `Account for ${this[_name]}: $${this[_balance]}`;\n  }\n}\n\nconst account = new BankAccount('Alice', 1000);\naccount.deposit(500);\n\nconsole.log(account.getInfo()); // \"Account for Alice: $1500\"\nconsole.log(account.name); // undefined\nconsole.log(account.balance); // undefined\n\n// Symbol properties are not enumerable in for...in\nfor (const key in account) {\n  console.log(key); // Only shows regular properties, not symbol properties\n}\n```\n\n**Use Case 2: Avoiding Property Name Collisions**\n```javascript\n// Third-party library namespace\nconst LibraryA = {\n  [Symbol('version')]: '1.0.0',\n  [Symbol('init')]: function() {\n    console.log('Library A initialized');\n  }\n};\n\nconst LibraryB = {\n  [Symbol('version')]: '2.1.0',\n  [Symbol('init')]: function() {\n    console.log('Library B initialized');\n  }\n};\n\n// Merge without conflicts\nconst app = Object.assign({}, LibraryA, LibraryB);\n\n// No collision - each library keeps its symbol properties\nconsole.log(Object.getOwnPropertySymbols(app).length); // 4\n```\n\n**Use Case 3: Well-Known Symbols - Custom Iterator**\n```javascript\nclass NumberRange {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n  \n  // Implement iterator using Symbol.iterator\n  [Symbol.iterator]() {\n    let current = this.start;\n    const end = this.end;\n    \n    return {\n      next() {\n        if (current <= end) {\n          return { value: current++, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n}\n\nconst range = new NumberRange(1, 5);\n\n// Now works with for...of\nfor (const num of range) {\n  console.log(num); // 1, 2, 3, 4, 5\n}\n\n// And with spread operator\nconsole.log([...range]); // [1, 2, 3, 4, 5]\n```\n\n**Use Case 4: Symbol.toStringTag - Custom Object Type**\n```javascript\nclass CustomCollection {\n  constructor() {\n    this.items = [];\n  }\n  \n  // Custom string tag\n  get [Symbol.toStringTag]() {\n    return 'CustomCollection';\n  }\n  \n  add(item) {\n    this.items.push(item);\n  }\n  \n  toString() {\n    return `CustomCollection(${this.items.length} items)`;\n  }\n}\n\nconst collection = new CustomCollection();\ncollection.add('item1');\n\nconsole.log(Object.prototype.toString.call(collection)); \n// \"[object CustomCollection]\" instead of \"[object Object]\"\n```\n\n**Use Case 5: Symbol.hasInstance - Custom instanceof**\n```javascript\nclass MyArray {\n  static [Symbol.hasInstance](instance) {\n    return Array.isArray(instance);\n  }\n}\n\nconsole.log([1, 2, 3] instanceof MyArray); // true\nconsole.log('string' instanceof MyArray); // false\n\n// More complex example\nclass Numeric {\n  static [Symbol.hasInstance](instance) {\n    return typeof instance === 'number' || \n           !isNaN(parseFloat(instance));\n  }\n}\n\nconsole.log(42 instanceof Numeric);     // true\nconsole.log('123' instanceof Numeric);  // true\nconsole.log('abc' instanceof Numeric);  // false\n```\n\n**Use Case 6: Metadata and Configuration**\n```javascript\nconst CONFIG_SYMBOL = Symbol('config');\nconst METADATA_SYMBOL = Symbol('metadata');\n\nclass Component {\n  constructor(name) {\n    this.name = name;\n    this[CONFIG_SYMBOL] = {\n      version: '1.0.0',\n      dependencies: []\n    };\n    this[METADATA_SYMBOL] = {\n      created: new Date(),\n      author: 'system'\n    };\n  }\n  \n  getConfig() {\n    return this[CONFIG_SYMBOL];\n  }\n  \n  getMetadata() {\n    return this[METADATA_SYMBOL];\n  }\n  \n  // Factory method that preserves symbols\n  static create(name, config = {}) {\n    const component = new Component(name);\n    Object.assign(component[CONFIG_SYMBOL], config);\n    return component;\n  }\n}\n\nconst comp = Component.create('MyComponent', {\n  version: '2.0.0',\n  dependencies: ['react']\n});\n\nconsole.log(comp.getConfig()); // { version: '2.0.0', dependencies: ['react'] }\n```\n\n**Symbol Inspection Methods:**\n```javascript\nconst obj = {\n  regularProp: 'value',\n  [Symbol('sym1')]: 'symbol value 1',\n  [Symbol('sym2')]: 'symbol value 2'\n};\n\n// Regular property enumeration (doesn't include symbols)\nconsole.log(Object.keys(obj)); // ['regularProp']\nconsole.log(Object.getOwnPropertyNames(obj)); // ['regularProp']\n\n// Symbol property enumeration\nconsole.log(Object.getOwnPropertySymbols(obj)); \n// [Symbol(sym1), Symbol(sym2)]\n\n// All properties (including symbols)\nconsole.log(Reflect.ownKeys(obj)); \n// ['regularProp', Symbol(sym1), Symbol(sym2)]\n\n// Check if property exists\nconst sym = Object.getOwnPropertySymbols(obj)[0];\nconsole.log(sym in obj); // true\nconsole.log(obj.hasOwnProperty(sym)); // true\n```\n\n**Well-Known Symbols:**\n```javascript\n// Common well-known symbols\nconsole.log(Symbol.iterator);     // For iteration protocol\nconsole.log(Symbol.toStringTag);  // For Object.prototype.toString\nconsole.log(Symbol.hasInstance);  // For instanceof behavior\nconsole.log(Symbol.toPrimitive);  // For type conversion\nconsole.log(Symbol.asyncIterator); // For async iteration\n\n// Custom toPrimitive behavior\nclass Temperature {\n  constructor(celsius) {\n    this.celsius = celsius;\n  }\n  \n  [Symbol.toPrimitive](hint) {\n    switch (hint) {\n      case 'number':\n        return this.celsius;\n      case 'string':\n        return `${this.celsius}°C`;\n      default:\n        return this.celsius;\n    }\n  }\n}\n\nconst temp = new Temperature(25);\nconsole.log(+temp);           // 25 (number conversion)\nconsole.log(`${temp}`);       // \"25°C\" (string conversion)\nconsole.log(temp + 10);       // 35 (default conversion)\n```\n\n**Benefits of Symbols:**\n- **Privacy**: Properties aren't enumerable in normal loops\n- **Uniqueness**: No naming collisions\n- **Metadata**: Attach metadata without affecting object structure\n- **Protocols**: Enable custom behavior for built-in operations\n- **Backwards compatibility**: Adding symbol properties doesn't break existing code\n\n**Limitations:**\n- Not truly private (can be accessed via `Object.getOwnPropertySymbols`)\n- Not serializable in JSON\n- More complex debugging\n- Browser support considerations for older environments",
      "keywords": ["symbols", "primitive type", "unique identifiers", "private properties", "well-known symbols", "Symbol.iterator", "Symbol.toStringTag", "metadata", "property collision", "enumeration"],
      "difficulty": "medium"
    }
  ]
}