{
  "technology": "nextjs",
  "questions": [
    {
      "id": 5000,
      "tag": "nextjs",
      "question": "How does file-based routing work in Next.js?",
      "answer": "Next.js uses a file-based routing system where the file structure in the `pages` directory (or `app` directory in Next.js 13+) automatically creates routes for your application.\n\nIn the `pages` directory:\n- `pages/index.js` → `/` (home page)\n- `pages/about.js` → `/about`\n- `pages/contact.js` → `/contact`\n- `pages/blog/index.js` → `/blog`\n- `pages/blog/first-post.js` → `/blog/first-post`\n\nFor nested routes, you can create folders:\n```\npages/\n  index.js        → /\n  about.js        → /about\n  blog/\n    index.js      → /blog\n    first-post.js → /blog/first-post\n    second-post.js → /blog/second-post\n```\n\nIn Next.js 13+ with the `app` directory:\n- Each folder represents a route segment\n- `page.js` files make route segments publicly accessible\n- `layout.js` files create shared UI for segments\n\n```\napp/\n  page.js           → /\n  about/\n    page.js         → /about\n  blog/\n    page.js         → /blog\n    layout.js       → shared layout for blog routes\n    [slug]/\n      page.js       → /blog/[slug]\n```\n\nThis automatic routing eliminates the need for a separate routing configuration file, making development faster and more intuitive.",
      "keywords": ["file-based routing", "pages directory", "app directory", "nested routes", "route segments"],
      "difficulty": "easy"
    },
    {
      "id": 5001,
      "tag": "nextjs",
      "question": "What is the difference between Server-Side Rendering (SSR) and Static Site Generation (SSG) in Next.js?",
      "answer": "SSR and SSG are two different rendering methods in Next.js, each with distinct use cases:\n\n**Server-Side Rendering (SSR):**\n- Pages are rendered on the server for each request\n- HTML is generated at request time\n- Use `getServerSideProps()` to implement SSR\n- Best for pages with frequently changing data\n- Slower initial load but always fresh content\n\n```javascript\nexport async function getServerSideProps(context) {\n  const res = await fetch('https://api.example.com/data')\n  const data = await res.json()\n  \n  return {\n    props: { data }\n  }\n}\n```\n\n**Static Site Generation (SSG):**\n- Pages are pre-rendered at build time\n- HTML is generated once during build\n- Use `getStaticProps()` to implement SSG\n- Best for content that doesn't change frequently\n- Faster loading, can be cached by CDN\n\n```javascript\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/data')\n  const data = await res.json()\n  \n  return {\n    props: { data },\n    revalidate: 3600 // Revalidate every hour\n  }\n}\n```\n\n**When to use each:**\n- SSG: Blogs, marketing pages, documentation\n- SSR: User dashboards, real-time data, personalized content\n\nNext.js also supports Incremental Static Regeneration (ISR) which combines benefits of both approaches.",
      "keywords": ["SSR", "SSG", "getServerSideProps", "getStaticProps", "pre-rendering", "ISR"],
      "difficulty": "easy"
    },
    {
      "id": 5002,
      "tag": "nextjs",
      "question": "How do you create dynamic routes using brackets in Next.js?",
      "answer": "Dynamic routes in Next.js are created using square brackets `[]` in the filename, allowing you to capture URL parameters and create flexible routing patterns.\n\n**Basic Dynamic Route:**\nFile: `pages/posts/[id].js`\nMatches: `/posts/1`, `/posts/hello`, `/posts/my-post`\n\n```javascript\n// pages/posts/[id].js\nimport { useRouter } from 'next/router'\n\nexport default function Post() {\n  const router = useRouter()\n  const { id } = router.query\n  \n  return <div>Post ID: {id}</div>\n}\n```\n\n**Multiple Dynamic Segments:**\nFile: `pages/posts/[category]/[id].js`\nMatches: `/posts/tech/123`, `/posts/news/hello`\n\n```javascript\n// Access both parameters\nconst { category, id } = router.query\n```\n\n**Catch-all Routes:**\nFile: `pages/docs/[...slug].js`\nMatches: `/docs/a`, `/docs/a/b`, `/docs/a/b/c`\n\n```javascript\n// router.query.slug will be an array\n// /docs/a/b/c → slug: ['a', 'b', 'c']\nconst { slug } = router.query\n```\n\n**Optional Catch-all:**\nFile: `pages/docs/[[...slug]].js`\nMatches: `/docs`, `/docs/a`, `/docs/a/b`\n\nFor Static Generation with dynamic routes, you also need `getStaticPaths()`:\n\n```javascript\nexport async function getStaticPaths() {\n  return {\n    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],\n    fallback: false\n  }\n}\n```",
      "keywords": ["dynamic routes", "brackets", "useRouter", "query parameters", "catch-all routes", "getStaticPaths"],
      "difficulty": "easy"
    },
    {
      "id": 5003,
      "tag": "nextjs",
      "question": "What are Next.js API routes and how do you create them?",
      "answer": "Next.js API routes allow you to build API endpoints as part of your Next.js application, creating a full-stack solution without needing a separate backend server.\n\n**Creating API Routes:**\nAPI routes are created by adding files to the `pages/api` directory (or `app/api` in Next.js 13+).\n\n**Basic API Route:**\nFile: `pages/api/hello.js`\nEndpoint: `GET /api/hello`\n\n```javascript\n// pages/api/hello.js\nexport default function handler(req, res) {\n  res.status(200).json({ message: 'Hello World' })\n}\n```\n\n**HTTP Methods:**\n```javascript\nexport default function handler(req, res) {\n  if (req.method === 'GET') {\n    res.status(200).json({ message: 'GET request' })\n  } else if (req.method === 'POST') {\n    const { name } = req.body\n    res.status(200).json({ message: `Hello ${name}` })\n  } else {\n    res.setHeader('Allow', ['GET', 'POST'])\n    res.status(405).end(`Method ${req.method} Not Allowed`)\n  }\n}\n```\n\n**Dynamic API Routes:**\nFile: `pages/api/users/[id].js`\nEndpoint: `/api/users/123`\n\n```javascript\nexport default function handler(req, res) {\n  const { id } = req.query\n  res.status(200).json({ userId: id })\n}\n```\n\n**Key Features:**\n- Automatic request/response handling\n- Support for middleware\n- Built-in parsing for JSON, form data\n- File-based routing like pages\n- Can connect to databases, external APIs\n- Serverless by default when deployed\n\nAPI routes run on the server and are perfect for handling form submissions, authentication, database operations, and external API integrations.",
      "keywords": ["API routes", "handler function", "HTTP methods", "serverless", "backend", "req res"],
      "difficulty": "easy"
    },
    {
      "id": 5004,
      "tag": "nextjs",
      "question": "What's the difference between Next.js Link component and regular anchor tags?",
      "answer": "The Next.js `Link` component provides client-side navigation with significant performance benefits over regular anchor tags (`<a>`).\n\n**Next.js Link Component:**\n```javascript\nimport Link from 'next/link'\n\nfunction Navigation() {\n  return (\n    <nav>\n      <Link href=\"/about\">\n        <a>About Us</a>\n      </Link>\n      {/* In Next.js 13+, no need for <a> tag */}\n      <Link href=\"/contact\">Contact</Link>\n    </nav>\n  )\n}\n```\n\n**Key Differences:**\n\n1. **Client-side Navigation:**\n   - `Link`: Uses JavaScript to navigate, no full page reload\n   - `<a>`: Causes full page reload, slower navigation\n\n2. **Prefetching:**\n   - `Link`: Automatically prefetches pages in viewport for faster navigation\n   - `<a>`: No prefetching, each navigation requires fresh request\n\n3. **Performance:**\n   - `Link`: Maintains JavaScript state, faster transitions\n   - `<a>`: Loses state, reinitializes entire app\n\n4. **Bundle Splitting:**\n   - `Link`: Only loads necessary JavaScript for the target page\n   - `<a>`: Loads everything fresh\n\n**When to Use Each:**\n\n**Use Link for:**\n- Internal navigation within your app\n- Better user experience and performance\n- Maintaining application state\n\n**Use anchor tags for:**\n- External links to other websites\n- Downloads or non-page resources\n- When you need full page reload behavior\n\n```javascript\n{/* Internal navigation */}\n<Link href=\"/dashboard\">Dashboard</Link>\n\n{/* External link */}\n<a href=\"https://github.com\" target=\"_blank\" rel=\"noopener noreferrer\">\n  GitHub\n</a>\n```",
      "keywords": ["Link component", "client-side navigation", "prefetching", "anchor tags", "performance", "routing"],
      "difficulty": "easy"
    },
    {
      "id": 5005,
      "tag": "nextjs",
      "question": "What is the difference between getStaticProps and getServerSideProps in Next.js?",
      "answer": "Both `getStaticProps` and `getServerSideProps` are data fetching methods in Next.js, but they serve different purposes and execute at different times.\n\n**getStaticProps (Static Generation):**\n- Runs at **build time** in production\n- Generates static HTML with pre-fetched data\n- Perfect for content that doesn't change frequently\n\n```javascript\nexport async function getStaticProps() {\n  const res = await fetch('https://api.example.com/posts')\n  const posts = await res.json()\n  \n  return {\n    props: { posts },\n    revalidate: 3600 // ISR: revalidate every hour\n  }\n}\n```\n\n**getServerSideProps (Server-Side Rendering):**\n- Runs on **every request**\n- Generates HTML on the server for each request\n- Best for dynamic content or user-specific data\n\n```javascript\nexport async function getServerSideProps(context) {\n  const { req, res, query } = context\n  const userId = req.cookies.userId\n  \n  const userData = await fetch(`https://api.example.com/users/${userId}`)\n  const user = await userData.json()\n  \n  return {\n    props: { user }\n  }\n}\n```\n\n**Key Differences:**\n\n| Aspect | getStaticProps | getServerSideProps |\n|--------|----------------|--------------------|\n| **When it runs** | Build time | Every request |\n| **Performance** | Fastest (cached) | Slower (server processing) |\n| **Use case** | Static content | Dynamic/user data |\n| **CDN friendly** | Yes | No |\n| **Context access** | Limited | Full request context |\n\n**Choose getStaticProps for:**\n- Blogs, marketing pages, documentation\n- Content that updates infrequently\n- Maximum performance needs\n\n**Choose getServerSideProps for:**\n- User dashboards, personalized content\n- Real-time data requirements\n- When you need request-specific information",
      "keywords": ["getStaticProps", "getServerSideProps", "data fetching", "SSG", "SSR", "build time", "request time"],
      "difficulty": "easy"
    },
    {
      "id": 5006,
      "tag": "nextjs",
      "question": "How does Next.js Image optimization work with the next/image component?",
      "answer": "Next.js provides automatic image optimization through the `next/image` component, which significantly improves performance and user experience by optimizing images on-demand.\n\n**Key Features:**\n\n1. **Automatic Format Optimization:**\n   - Serves modern formats (WebP, AVIF) when supported\n   - Falls back to original format for older browsers\n   - Reduces file sizes by 30-80% typically\n\n2. **Responsive Images:**\n   - Automatically generates multiple sizes\n   - Serves appropriate size based on device\n   - Prevents layout shift with required width/height\n\n3. **Lazy Loading:**\n   - Images load only when entering viewport\n   - Improves initial page load performance\n   - Can be disabled with `priority` prop for above-fold images\n\n**Basic Usage:**\n```javascript\nimport Image from 'next/image'\n\nfunction ProfilePhoto() {\n  return (\n    <Image\n      src=\"/profile.jpg\"\n      alt=\"Profile photo\"\n      width={500}\n      height={300}\n      priority // Disable lazy loading for important images\n    />\n  )\n}\n```\n\n**Advanced Features:**\n\n```javascript\n<Image\n  src=\"/hero.jpg\"\n  alt=\"Hero image\"\n  fill // Fills parent container\n  sizes=\"(max-width: 768px) 100vw, 50vw\"\n  style={{\n    objectFit: 'cover'\n  }}\n  placeholder=\"blur\"\n  blurDataURL=\"data:image/jpeg;base64,/9j/4AAQ...\"\n/>\n```\n\n**Configuration Options:**\n```javascript\n// next.config.js\nmodule.exports = {\n  images: {\n    domains: ['example.com'], // Allow external domains\n    formats: ['image/webp'], // Preferred formats\n    deviceSizes: [640, 750, 828, 1080, 1200], // Breakpoints\n    imageSizes: [16, 32, 48, 64, 96], // Icon sizes\n  }\n}\n```\n\n**Performance Benefits:**\n- Reduces Cumulative Layout Shift (CLS)\n- Improves Core Web Vitals scores\n- Automatic optimization without manual intervention\n- Built-in loading states and error handling\n- Prevents loading oversized images on small screens",
      "keywords": ["image optimization", "next/image", "lazy loading", "WebP", "AVIF", "responsive images", "Core Web Vitals"],
      "difficulty": "medium"
    },
    {
      "id": 5007,
      "tag": "nextjs",
      "question": "What are custom App and Document components in Next.js and when should you use them?",
      "answer": "Custom App (`_app.js`) and Document (`_document.js`) components allow you to customize Next.js's default behavior for initializing pages and controlling server-rendered document structure.\n\n**Custom App Component (_app.js):**\nWraps every page in your application and runs on both client and server.\n\n```javascript\n// pages/_app.js\nimport '../styles/globals.css'\nimport { SessionProvider } from 'next-auth/react'\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <SessionProvider session={pageProps.session}>\n      <div className=\"app-layout\">\n        <nav>Global Navigation</nav>\n        <Component {...pageProps} />\n        <footer>Global Footer</footer>\n      </div>\n    </SessionProvider>\n  )\n}\n\nexport default MyApp\n```\n\n**Use Custom App for:**\n- Adding global CSS imports\n- Implementing layout components\n- Adding global state providers (Redux, Context)\n- Handling authentication wrappers\n- Adding analytics or error tracking\n- Persisting layout between page changes\n\n**Custom Document Component (_document.js):**\nControls the initial server-side rendered HTML document structure.\n\n```javascript\n// pages/_document.js\nimport { Html, Head, Main, NextScript } from 'next/document'\n\nexport default function Document() {\n  return (\n    <Html lang=\"en\">\n      <Head>\n        <link rel=\"preconnect\" href=\"https://fonts.googleapis.com\" />\n        <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap\" rel=\"stylesheet\" />\n        <meta name=\"theme-color\" content=\"#000000\" />\n      </Head>\n      <body className=\"light-theme\">\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  )\n}\n```\n\n**Use Custom Document for:**\n- Adding custom `<html>` and `<body>` attributes\n- Adding third-party scripts to `<head>`\n- Loading custom fonts\n- Adding meta tags that need to be in every page\n- Customizing server-side rendering behavior\n\n**Key Differences:**\n- `_app.js`: Runs on every page, client and server, handles page initialization\n- `_document.js`: Only runs on server, controls HTML document structure\n- Document changes require server restart to take effect\n- App changes reflect immediately in development",
      "keywords": ["custom App", "custom Document", "_app.js", "_document.js", "global layout", "HTML structure"],
      "difficulty": "medium"
    },
    {
      "id": 5008,
      "tag": "nextjs",
      "question": "How does Middleware work in Next.js 13+ and what are its use cases?",
      "answer": "Next.js Middleware allows you to run code before a request is completed, enabling you to modify responses, redirect, rewrite URLs, or add headers based on incoming requests.\n\n**Basic Middleware Setup:**\nCreate a `middleware.js` file in your project root:\n\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server'\n\nexport function middleware(request) {\n  // Check if user is authenticated\n  const token = request.cookies.get('token')\n  \n  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {\n    return NextResponse.redirect(new URL('/login', request.url))\n  }\n  \n  return NextResponse.next()\n}\n\n// Configure which paths the middleware runs on\nexport const config = {\n  matcher: ['/dashboard/:path*', '/admin/:path*']\n}\n```\n\n**Common Use Cases:**\n\n**1. Authentication & Authorization:**\n```javascript\nexport function middleware(request) {\n  const token = request.cookies.get('auth-token')\n  const isAuthPage = request.nextUrl.pathname.startsWith('/auth')\n  const isProtectedPage = request.nextUrl.pathname.startsWith('/dashboard')\n  \n  if (isProtectedPage && !token) {\n    return NextResponse.redirect(new URL('/auth/login', request.url))\n  }\n  \n  if (isAuthPage && token) {\n    return NextResponse.redirect(new URL('/dashboard', request.url))\n  }\n}\n```\n\n**2. A/B Testing:**\n```javascript\nexport function middleware(request) {\n  const variant = Math.random() < 0.5 ? 'a' : 'b'\n  const response = NextResponse.next()\n  response.cookies.set('ab-test', variant)\n  response.headers.set('x-ab-test', variant)\n  return response\n}\n```\n\n**3. Internationalization:**\n```javascript\nexport function middleware(request) {\n  const pathname = request.nextUrl.pathname\n  const pathnameIsMissingLocale = ['/en', '/es', '/fr'].every(\n    (locale) => !pathname.startsWith(`/${locale}/`) && pathname !== `/${locale}`\n  )\n  \n  if (pathnameIsMissingLocale) {\n    const locale = request.headers.get('accept-language')?.split(',')[0] || 'en'\n    return NextResponse.redirect(new URL(`/${locale}${pathname}`, request.url))\n  }\n}\n```\n\n**4. Rate Limiting:**\n```javascript\nconst rateLimitMap = new Map()\n\nexport function middleware(request) {\n  const ip = request.ip || 'unknown'\n  const limit = 10 // requests per minute\n  const windowMs = 60 * 1000 // 1 minute\n  \n  if (!rateLimitMap.has(ip)) {\n    rateLimitMap.set(ip, { count: 0, lastReset: Date.now() })\n  }\n  \n  const userData = rateLimitMap.get(ip)\n  \n  if (Date.now() - userData.lastReset > windowMs) {\n    userData.count = 0\n    userData.lastReset = Date.now()\n  }\n  \n  if (userData.count >= limit) {\n    return new NextResponse('Too Many Requests', { status: 429 })\n  }\n  \n  userData.count++\n  return NextResponse.next()\n}\n```\n\n**Configuration Options:**\n```javascript\nexport const config = {\n  matcher: [\n    '/((?!api|_next/static|_next/image|favicon.ico).*)'\n  ]\n}\n```\n\nMiddleware runs at the Edge Runtime, providing fast global execution with some API limitations compared to Node.js runtime.",
      "keywords": ["middleware", "authentication", "redirects", "Edge Runtime", "NextResponse", "request modification"],
      "difficulty": "medium"
    },
    {
      "id": 5009,
      "tag": "nextjs",
      "question": "How do environment variables work in Next.js and what are the security considerations?",
      "answer": "Next.js provides built-in support for environment variables with different visibility levels and security considerations for client-side and server-side usage.\n\n**Environment Variable Types:**\n\n**1. Server-side Only (Default):**\nVariables are only available in Node.js environment (API routes, getServerSideProps, getStaticProps).\n\n```javascript\n// .env.local\nDATABASE_URL=postgresql://localhost:5432/mydb\nAPI_SECRET_KEY=super-secret-key\n```\n\n```javascript\n// pages/api/users.js\nexport default function handler(req, res) {\n  const dbUrl = process.env.DATABASE_URL // ✅ Available server-side\n  const secretKey = process.env.API_SECRET_KEY // ✅ Available server-side\n  // These are NOT exposed to the browser\n}\n```\n\n**2. Client-side Exposed (NEXT_PUBLIC_ prefix):**\nVariables with `NEXT_PUBLIC_` prefix are exposed to the browser.\n\n```javascript\n// .env.local\nNEXT_PUBLIC_API_URL=https://api.example.com\nNEXT_PUBLIC_ANALYTICS_ID=GA-123456789\n```\n\n```javascript\n// components/Analytics.js\nexport default function Analytics() {\n  const analyticsId = process.env.NEXT_PUBLIC_ANALYTICS_ID // ✅ Available client-side\n  return <script async src={`https://www.googletagmanager.com/gtag/js?id=${analyticsId}`} />\n}\n```\n\n**Environment File Priority (highest to lowest):**\n1. `.env.local` (always loaded, should be in .gitignore)\n2. `.env.production` / `.env.development` (environment-specific)\n3. `.env` (default for all environments)\n\n**Security Best Practices:**\n\n**❌ Never expose secrets to client:**\n```javascript\n// WRONG - Don't do this\nNEXT_PUBLIC_DATABASE_PASSWORD=secret123 // Exposed to browser!\nNEXT_PUBLIC_JWT_SECRET=mysecret // Visible in browser!\n```\n\n**✅ Proper usage:**\n```javascript\n// .env.local\n// Server-only secrets\nDATABASE_PASSWORD=secret123\nJWT_SECRET=mysecret\nSTRIPE_SECRET_KEY=sk_test_...\n\n// Client-safe configuration\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...\nNEXT_PUBLIC_APP_NAME=MyApp\nNEXT_PUBLIC_API_BASE_URL=https://api.example.com\n```\n\n**Runtime Configuration:**\n```javascript\n// next.config.js\nmodule.exports = {\n  env: {\n    CUSTOM_KEY: process.env.CUSTOM_KEY,\n  },\n  // For public runtime config\n  publicRuntimeConfig: {\n    API_URL: process.env.API_URL,\n  },\n  // For server runtime config\n  serverRuntimeConfig: {\n    SECRET_KEY: process.env.SECRET_KEY,\n  }\n}\n```\n\n**Environment-specific Loading:**\n```javascript\n// Load different configs per environment\n// .env.development\nNEXT_PUBLIC_API_URL=http://localhost:3001\n\n// .env.production\nNEXT_PUBLIC_API_URL=https://api.production.com\n```\n\n**Important Security Notes:**\n- Client-exposed variables are embedded in the build and visible to users\n- Never put secrets, API keys, or sensitive data in NEXT_PUBLIC_ variables\n- Always add .env.local to .gitignore\n- Use different environment files for different deployment stages",
      "keywords": ["environment variables", "NEXT_PUBLIC", "security", "client-side", "server-side", "env files"],
      "difficulty": "medium"
    },
    {
      "id": 5010,
      "tag": "nextjs",
      "question": "How do you use the Head component in Next.js for SEO and meta tags?",
      "answer": "The Next.js `Head` component allows you to modify the `<head>` section of your pages, enabling you to add meta tags, titles, and other elements crucial for SEO and social media optimization.\n\n**Basic Usage:**\n```javascript\nimport Head from 'next/head'\n\nfunction BlogPost({ post }) {\n  return (\n    <>\n      <Head>\n        <title>{post.title} | My Blog</title>\n        <meta name=\"description\" content={post.excerpt} />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n      </Head>\n      <main>\n        <h1>{post.title}</h1>\n        <p>{post.content}</p>\n      </main>\n    </>\n  )\n}\n```\n\n**SEO Best Practices:**\n```javascript\nimport Head from 'next/head'\n\nfunction ProductPage({ product }) {\n  const structuredData = {\n    \"@context\": \"https://schema.org/\",\n    \"@type\": \"Product\",\n    \"name\": product.name,\n    \"description\": product.description,\n    \"offers\": {\n      \"@type\": \"Offer\",\n      \"price\": product.price\n    }\n  }\n\n  return (\n    <>\n      <Head>\n        {/* Basic SEO */}\n        <title>{product.name} - Buy Online | Store Name</title>\n        <meta name=\"description\" content={product.description} />\n        <meta name=\"keywords\" content={product.tags.join(', ')} />\n        \n        {/* Open Graph for social media */}\n        <meta property=\"og:title\" content={product.name} />\n        <meta property=\"og:description\" content={product.description} />\n        <meta property=\"og:image\" content={product.imageUrl} />\n        <meta property=\"og:type\" content=\"product\" />\n        \n        {/* Twitter Cards */}\n        <meta name=\"twitter:card\" content=\"summary_large_image\" />\n        <meta name=\"twitter:title\" content={product.name} />\n        <meta name=\"twitter:description\" content={product.description} />\n        <meta name=\"twitter:image\" content={product.imageUrl} />\n        \n        {/* Canonical URL */}\n        <link rel=\"canonical\" href={`https://example.com/products/${product.slug}`} />\n        \n        {/* Structured Data */}\n        <script\n          type=\"application/ld+json\"\n          dangerouslySetInnerHTML={{\n            __html: JSON.stringify(structuredData)\n          }}\n        />\n      </Head>\n      <main>\n        <h1>{product.name}</h1>\n        <p>{product.description}</p>\n        <p>Price: ${product.price}</p>\n      </main>\n    </>\n  )\n}\n```\n\n**Global Head Elements (_app.js):**\n```javascript\n// pages/_app.js\nimport Head from 'next/head'\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        {/* Global meta tags */}\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <meta name=\"theme-color\" content=\"#000000\" />\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n      </Head>\n      <Component {...pageProps} />\n    </>\n  )\n}\n```\n\n**Key Features:**\n- Automatically deduplicates tags (latest wins)\n- Supports all HTML head elements\n- Works with SSR and static generation\n- Merges with global head elements\n- Essential for SEO, social sharing, and performance",
      "keywords": ["Head component", "SEO", "meta tags", "Open Graph", "Twitter Cards", "structured data"],
      "difficulty": "easy"
    },
    {
      "id": 5011,
      "tag": "nextjs",
      "question": "How do you create custom error pages (404, 500) in Next.js?",
      "answer": "Next.js allows you to create custom error pages to provide better user experiences when things go wrong, replacing the default error pages with branded, helpful alternatives.\n\n**Custom 404 Page:**\nCreate `pages/404.js` for a custom \"Not Found\" page:\n\n```javascript\n// pages/404.js\nimport Link from 'next/link'\nimport Head from 'next/head'\n\nexport default function Custom404() {\n  return (\n    <>\n      <Head>\n        <title>Page Not Found | My App</title>\n      </Head>\n      <div className=\"error-container\">\n        <h1>404 - Page Not Found</h1>\n        <p>Sorry, the page you're looking for doesn't exist.</p>\n        <div className=\"error-actions\">\n          <Link href=\"/\">\n            <a className=\"btn-primary\">Go Home</a>\n          </Link>\n          <Link href=\"/search\">\n            <a className=\"btn-secondary\">Search</a>\n          </Link>\n        </div>\n      </div>\n    </>\n  )\n}\n\n// This page is statically generated at build time\nexport async function getStaticProps() {\n  return {\n    props: {}\n  }\n}\n```\n\n**Custom 500 Page:**\nCreate `pages/500.js` for server errors:\n\n```javascript\n// pages/500.js\nimport Head from 'next/head'\n\nexport default function Custom500() {\n  return (\n    <>\n      <Head>\n        <title>Server Error | My App</title>\n      </Head>\n      <div className=\"error-container\">\n        <h1>500 - Server Error</h1>\n        <p>Something went wrong on our end. We're working to fix it!</p>\n        <button onClick={() => window.location.reload()}>\n          Try Again\n        </button>\n      </div>\n    </>\n  )\n}\n```\n\n**Custom Error Page (All Errors):**\nCreate `pages/_error.js` to handle all error types:\n\n```javascript\n// pages/_error.js\nfunction Error({ statusCode, hasGetInitialPropsRun, err }) {\n  return (\n    <div className=\"error-page\">\n      <h1>\n        {statusCode\n          ? `A ${statusCode} error occurred on server`\n          : 'An error occurred on client'}\n      </h1>\n      <p>\n        {statusCode === 404\n          ? 'This page could not be found.'\n          : 'Sorry, something went wrong.'}\n      </p>\n    </div>\n  )\n}\n\nError.getInitialProps = ({ res, err }) => {\n  const statusCode = res ? res.statusCode : err ? err.statusCode : 404\n  return { statusCode }\n}\n\nexport default Error\n```\n\n**Error Handling in API Routes:**\n```javascript\n// pages/api/users/[id].js\nexport default function handler(req, res) {\n  const { id } = req.query\n  \n  try {\n    if (!id) {\n      return res.status(400).json({ error: 'User ID is required' })\n    }\n    \n    // Simulate user not found\n    if (id === 'unknown') {\n      return res.status(404).json({ error: 'User not found' })\n    }\n    \n    // Success case\n    res.status(200).json({ user: { id, name: 'John Doe' } })\n  } catch (error) {\n    console.error('API Error:', error)\n    res.status(500).json({ error: 'Internal server error' })\n  }\n}\n```\n\n**Error Boundaries for React Errors:**\n```javascript\n// components/ErrorBoundary.js\nimport { Component } from 'react'\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props)\n    this.state = { hasError: false }\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true }\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo)\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"error-fallback\">\n          <h2>Something went wrong.</h2>\n          <button onClick={() => this.setState({ hasError: false })}>\n            Try again\n          </button>\n        </div>\n      )\n    }\n    \n    return this.props.children\n  }\n}\n```\n\n**Best Practices:**\n- Custom error pages are automatically statically optimized\n- Include helpful navigation and search options\n- Log errors appropriately for debugging\n- Maintain consistent branding and styling\n- Provide clear, user-friendly error messages",
      "keywords": ["custom error pages", "404 page", "500 page", "_error.js", "error handling", "error boundaries"],
      "difficulty": "easy"
    },
    {
      "id": 5012,
      "tag": "nextjs",
      "question": "How does static file serving work in Next.js?",
      "answer": "Next.js provides built-in static file serving from the `public` directory, making it easy to serve images, fonts, icons, and other static assets without additional configuration.\n\n**Basic Static File Serving:**\nFiles in the `public` directory are served from the root URL path:\n\n```\npublic/\n├── favicon.ico        → /favicon.ico\n├── logo.png          → /logo.png\n├── images/\n│   ├── hero.jpg      → /images/hero.jpg\n│   └── avatar.png    → /images/avatar.png\n├── fonts/\n│   └── inter.woff2   → /fonts/inter.woff2\n└── documents/\n    └── resume.pdf    → /documents/resume.pdf\n```\n\n**Using Static Files in Components:**\n```javascript\nimport Image from 'next/image'\n\nfunction HomePage() {\n  return (\n    <div>\n      {/* Image optimization with next/image */}\n      <Image\n        src=\"/images/hero.jpg\"\n        alt=\"Hero image\"\n        width={800}\n        height={400}\n      />\n      \n      {/* Regular img tag */}\n      <img src=\"/logo.png\" alt=\"Company logo\" />\n      \n      {/* Download link */}\n      <a href=\"/documents/resume.pdf\" download>\n        Download Resume\n      </a>\n      \n      {/* Background image in CSS */}\n      <div className=\"hero-section\">\n        <h1>Welcome</h1>\n      </div>\n    </div>\n  )\n}\n```\n\n**CSS and Static Assets:**\n```css\n/* styles/globals.css */\n.hero-section {\n  background-image: url('/images/hero.jpg');\n  background-size: cover;\n  background-position: center;\n}\n\n@font-face {\n  font-family: 'CustomFont';\n  src: url('/fonts/custom-font.woff2') format('woff2');\n  font-display: swap;\n}\n\n.custom-text {\n  font-family: 'CustomFont', sans-serif;\n}\n```\n\n**Favicons and Meta Assets:**\n```javascript\n// pages/_document.js\nimport { Html, Head, Main, NextScript } from 'next/document'\n\nexport default function Document() {\n  return (\n    <Html>\n      <Head>\n        {/* Favicon */}\n        <link rel=\"icon\" href=\"/favicon.ico\" />\n        <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\" />\n        <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\" />\n        \n        {/* Manifest for PWA */}\n        <link rel=\"manifest\" href=\"/manifest.json\" />\n        \n        {/* Custom fonts */}\n        <link rel=\"preload\" href=\"/fonts/inter.woff2\" as=\"font\" type=\"font/woff2\" crossOrigin=\"\" />\n      </Head>\n      <body>\n        <Main />\n        <NextScript />\n      </body>\n    </Html>\n  )\n}\n```\n\n**PWA Manifest Example:**\n```json\n// public/manifest.json\n{\n  \"name\": \"My Next.js App\",\n  \"short_name\": \"MyApp\",\n  \"description\": \"A Progressive Web App built with Next.js\",\n  \"start_url\": \"/\",\n  \"display\": \"standalone\",\n  \"background_color\": \"#ffffff\",\n  \"theme_color\": \"#000000\",\n  \"icons\": [\n    {\n      \"src\": \"/icons/icon-192x192.png\",\n      \"sizes\": \"192x192\",\n      \"type\": \"image/png\"\n    },\n    {\n      \"src\": \"/icons/icon-512x512.png\",\n      \"sizes\": \"512x512\",\n      \"type\": \"image/png\"\n    }\n  ]\n}\n```\n\n**robots.txt and sitemap.xml:**\n```\n# public/robots.txt\nUser-agent: *\nAllow: /\nDisallow: /api/\n\nSitemap: https://example.com/sitemap.xml\n```\n\n```xml\n<!-- public/sitemap.xml -->\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url>\n    <loc>https://example.com</loc>\n    <lastmod>2023-12-01</lastmod>\n    <changefreq>daily</changefreq>\n    <priority>1.0</priority>\n  </url>\n</urlset>\n```\n\n**Important Notes:**\n- Files in `public` are served statically and cached\n- Don't use `public` for files that change frequently\n- Use next/image for optimized image serving\n- Static files are available immediately after build\n- No server-side processing for public files\n- Good for: images, fonts, icons, documents, manifest files\n- Avoid for: sensitive files, API responses, dynamic content",
      "keywords": ["static files", "public directory", "favicon", "images", "fonts", "manifest", "robots.txt"],
      "difficulty": "easy"
    },
    {
      "id": 5013,
      "tag": "nextjs",
      "question": "How do you use the useRouter hook for programmatic navigation in Next.js?",
      "answer": "The `useRouter` hook from Next.js provides programmatic navigation capabilities, allowing you to navigate, access route information, and handle routing events within your React components.\n\n**Basic useRouter Usage:**\n```javascript\nimport { useRouter } from 'next/router'\n\nfunction NavigationComponent() {\n  const router = useRouter()\n  \n  const handleNavigation = () => {\n    router.push('/dashboard')\n  }\n  \n  const handleBack = () => {\n    router.back()\n  }\n  \n  return (\n    <div>\n      <button onClick={handleNavigation}>Go to Dashboard</button>\n      <button onClick={handleBack}>Go Back</button>\n      <p>Current path: {router.pathname}</p>\n      <p>Current route: {router.asPath}</p>\n    </div>\n  )\n}\n```\n\n**Navigation Methods:**\n```javascript\nimport { useRouter } from 'next/router'\n\nfunction NavigationExample() {\n  const router = useRouter()\n  \n  const navigationExamples = {\n    // Basic navigation\n    goToAbout: () => router.push('/about'),\n    \n    // Navigation with query parameters\n    goToProfile: () => router.push({\n      pathname: '/profile',\n      query: { tab: 'settings', id: '123' }\n    }),\n    \n    // Navigation with URL object\n    goToPost: () => router.push({\n      pathname: '/posts/[slug]',\n      query: { slug: 'my-first-post' }\n    }),\n    \n    // Replace instead of push (no history entry)\n    replaceRoute: () => router.replace('/login'),\n    \n    // Navigate back/forward\n    goBack: () => router.back(),\n    goForward: () => router.forward(),\n    \n    // Reload current page\n    reloadPage: () => router.reload()\n  }\n  \n  return (\n    <div>\n      {Object.entries(navigationExamples).map(([name, handler]) => (\n        <button key={name} onClick={handler}>\n          {name}\n        </button>\n      ))}\n    </div>\n  )\n}\n```\n\n**Accessing Route Information:**\n```javascript\nimport { useRouter } from 'next/router'\n\nfunction RouteInfo() {\n  const router = useRouter()\n  \n  return (\n    <div>\n      <h2>Route Information:</h2>\n      <p><strong>Pathname:</strong> {router.pathname}</p>\n      <p><strong>AsPath:</strong> {router.asPath}</p>\n      <p><strong>Route:</strong> {router.route}</p>\n      <p><strong>Query:</strong> {JSON.stringify(router.query)}</p>\n      <p><strong>Locale:</strong> {router.locale}</p>\n      <p><strong>Is Ready:</strong> {router.isReady.toString()}</p>\n    </div>\n  )\n}\n\n// Example with dynamic route: /posts/[slug]\n// URL: /posts/hello-world?author=john\n// Results:\n// pathname: \"/posts/[slug]\"\n// asPath: \"/posts/hello-world?author=john\"\n// route: \"/posts/[slug]\"\n// query: { slug: \"hello-world\", author: \"john\" }\n```\n\n**Route Change Events:**\n```javascript\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\n\nfunction RouteChangeHandler() {\n  const router = useRouter()\n  \n  useEffect(() => {\n    const handleStart = (url) => {\n      console.log(`Loading: ${url}`)\n    }\n    \n    const handleComplete = (url) => {\n      console.log(`Finished loading: ${url}`)\n    }\n    \n    const handleError = (err, url) => {\n      console.log(`Error loading ${url}: ${err.message}`)\n    }\n    \n    router.events.on('routeChangeStart', handleStart)\n    router.events.on('routeChangeComplete', handleComplete)\n    router.events.on('routeChangeError', handleError)\n    \n    // Cleanup\n    return () => {\n      router.events.off('routeChangeStart', handleStart)\n      router.events.off('routeChangeComplete', handleComplete)\n      router.events.off('routeChangeError', handleError)\n    }\n  }, [router])\n  \n  return <div>Check console for route change events</div>\n}\n```\n\n**Conditional Navigation:**\n```javascript\nimport { useRouter } from 'next/router'\nimport { useEffect } from 'react'\n\nfunction ProtectedRoute({ children }) {\n  const router = useRouter()\n  const isAuthenticated = useAuth() // Custom hook\n  \n  useEffect(() => {\n    if (!isAuthenticated && router.isReady) {\n      router.replace({\n        pathname: '/login',\n        query: { returnUrl: router.asPath }\n      })\n    }\n  }, [isAuthenticated, router])\n  \n  if (!isAuthenticated) {\n    return <div>Loading...</div>\n  }\n  \n  return children\n}\n```\n\n**Form Submission with Navigation:**\n```javascript\nimport { useRouter } from 'next/router'\nimport { useState } from 'react'\n\nfunction ContactForm() {\n  const router = useRouter()\n  const [loading, setLoading] = useState(false)\n  \n  const handleSubmit = async (e) => {\n    e.preventDefault()\n    setLoading(true)\n    \n    try {\n      const response = await fetch('/api/contact', {\n        method: 'POST',\n        body: new FormData(e.target)\n      })\n      \n      if (response.ok) {\n        router.push('/thank-you')\n      } else {\n        throw new Error('Failed to submit')\n      }\n    } catch (error) {\n      console.error('Error:', error)\n      setLoading(false)\n    }\n  }\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"email\" type=\"email\" required />\n      <textarea name=\"message\" required />\n      <button type=\"submit\" disabled={loading}>\n        {loading ? 'Sending...' : 'Send Message'}\n      </button>\n    </form>\n  )\n}\n```\n\n**Key Features:**\n- Programmatic navigation without full page reload\n- Access to route parameters and query strings\n- Route change event handling\n- History manipulation (push, replace, back, forward)\n- Works seamlessly with Next.js routing system",
      "keywords": ["useRouter hook", "programmatic navigation", "router.push", "router.query", "route events", "navigation"],
      "difficulty": "easy"
    },
    {
      "id": 5014,
      "tag": "nextjs",
      "question": "What are the different CSS and styling options available in Next.js?",
      "answer": "Next.js supports multiple CSS and styling approaches, from traditional CSS files to modern CSS-in-JS solutions, each with specific use cases and benefits.\n\n**1. CSS Modules:**\nScoped CSS with automatic class name generation to avoid conflicts.\n\n```css\n/* styles/Button.module.css */\n.primary {\n  background-color: blue;\n  color: white;\n  padding: 8px 16px;\n  border: none;\n  border-radius: 4px;\n}\n\n.secondary {\n  background-color: gray;\n  color: white;\n}\n\n.large {\n  font-size: 18px;\n  padding: 12px 24px;\n}\n```\n\n```javascript\n// components/Button.js\nimport styles from '../styles/Button.module.css'\n\nfunction Button({ variant = 'primary', size, children, ...props }) {\n  const className = `${styles[variant]} ${size ? styles[size] : ''}`\n  \n  return (\n    <button className={className} {...props}>\n      {children}\n    </button>\n  )\n}\n```\n\n**2. Global CSS:**\nApplication-wide styles imported in `_app.js`.\n\n```css\n/* styles/globals.css */\n* {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n}\n\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto;\n  line-height: 1.6;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 16px;\n}\n```\n\n```javascript\n// pages/_app.js\nimport '../styles/globals.css'\n\nfunction MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}\n```\n\n**3. Styled JSX (Built-in):**\nCSS-in-JS solution that comes with Next.js by default.\n\n```javascript\nfunction StyledComponent() {\n  return (\n    <div>\n      <h1 className=\"title\">Hello World</h1>\n      <p className=\"description\">This is styled with JSX</p>\n      \n      <style jsx>{`\n        .title {\n          color: blue;\n          font-size: 2rem;\n          margin-bottom: 16px;\n        }\n        .description {\n          color: gray;\n          font-size: 1.1rem;\n        }\n      `}</style>\n      \n      {/* Global styles */}\n      <style jsx global>{`\n        body {\n          background-color: #f0f0f0;\n        }\n      `}</style>\n    </div>\n  )\n}\n```\n\n**4. Styled Components:**\nPopular CSS-in-JS library with theme support.\n\n```bash\nnpm install styled-components\n```\n\n```javascript\n// components/StyledComponents.js\nimport styled from 'styled-components'\n\nconst Button = styled.button`\n  background-color: ${props => props.primary ? 'blue' : 'gray'};\n  color: white;\n  padding: ${props => props.large ? '12px 24px' : '8px 16px'};\n  border: none;\n  border-radius: 4px;\n  font-size: ${props => props.large ? '18px' : '14px'};\n  cursor: pointer;\n  \n  &:hover {\n    opacity: 0.8;\n  }\n`\n\nconst Container = styled.div`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 16px;\n  \n  @media (max-width: 768px) {\n    padding: 0 8px;\n  }\n`\n\nfunction MyComponent() {\n  return (\n    <Container>\n      <Button primary large>Primary Button</Button>\n      <Button>Secondary Button</Button>\n    </Container>\n  )\n}\n```\n\n**5. Tailwind CSS:**\nUtility-first CSS framework.\n\n```bash\nnpm install -D tailwindcss postcss autoprefixer\nnpx tailwindcss init -p\n```\n\n```javascript\n// tailwind.config.js\nmodule.exports = {\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx}',\n    './components/**/*.{js,ts,jsx,tsx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: '#3B82F6',\n        secondary: '#6B7280'\n      }\n    },\n  },\n  plugins: [],\n}\n```\n\n```javascript\n// components/TailwindComponent.js\nfunction TailwindComponent() {\n  return (\n    <div className=\"max-w-4xl mx-auto p-4\">\n      <h1 className=\"text-3xl font-bold text-gray-900 mb-4\">\n        Tailwind CSS Example\n      </h1>\n      <button className=\"bg-primary text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition-colors\">\n        Primary Button\n      </button>\n      <button className=\"bg-secondary text-white px-4 py-2 rounded-lg ml-2 hover:bg-gray-600 transition-colors\">\n        Secondary Button\n      </button>\n    </div>\n  )\n}\n```\n\n**6. Emotion:**\nPerformant CSS-in-JS library.\n\n```bash\nnpm install @emotion/react @emotion/styled\n```\n\n```javascript\n// components/EmotionComponent.js\nimport styled from '@emotion/styled'\nimport { css } from '@emotion/react'\n\nconst Button = styled.button`\n  background-color: ${props => props.primary ? '#3B82F6' : '#6B7280'};\n  color: white;\n  padding: 8px 16px;\n  border: none;\n  border-radius: 4px;\n  cursor: pointer;\n`\n\nconst containerStyles = css`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 16px;\n`\n\nfunction EmotionComponent() {\n  return (\n    <div css={containerStyles}>\n      <Button primary>Primary</Button>\n      <Button>Secondary</Button>\n    </div>\n  )\n}\n```\n\n**Configuration in next.config.js:**\n```javascript\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true',\n})\n\nmodule.exports = withBundleAnalyzer({\n  // Enable styled-components SSR\n  compiler: {\n    styledComponents: true,\n  },\n  \n  // Custom webpack config for CSS\n  webpack: (config) => {\n    config.module.rules.push({\n      test: /\\.svg$/,\n      use: ['@svgr/webpack'],\n    })\n    return config\n  },\n})\n```\n\n**Choosing the Right Approach:**\n- **CSS Modules**: Best for component-scoped styles, easy migration\n- **Global CSS**: Traditional approach, good for base styles\n- **Styled JSX**: Built-in, no additional dependencies\n- **Styled Components**: Popular, great theming, server-side rendering\n- **Tailwind CSS**: Utility-first, rapid development, consistent design\n- **Emotion**: Performance-focused, flexible API\n\nAll approaches work with Next.js SSR and are optimized for production builds.",
      "keywords": ["CSS modules", "styled components", "Tailwind CSS", "styled JSX", "global CSS", "styling options"],
      "difficulty": "easy"
    },
    {
      "id": 5015,
      "tag": "nextjs",
      "question": "What is the Next.js build and deployment process?",
      "answer": "Next.js provides a comprehensive build and deployment process that optimizes your application for production with automatic code splitting, minification, and various deployment options.\n\n**Build Process:**\n\n**1. Development vs Production:**\n```bash\n# Development server\nnpm run dev          # or yarn dev\n# Features: Hot reloading, detailed error messages, no optimization\n\n# Production build\nnpm run build        # or yarn build\nnpm run start        # or yarn start\n# Features: Optimized bundles, minification, static generation\n```\n\n**2. Build Output Analysis:**\n```bash\n# After running `npm run build`\nPage                              Size     First Load JS\n┌ ○ /                             1.2 kB          85.3 kB\n├   └ css/abc123.css              0.5 kB\n├ ○ /about                        0.8 kB          84.9 kB\n├ ● /posts                        2.1 kB          87.2 kB\n├ ● /posts/[slug] (147 ms)        1.8 kB          86.9 kB\n└ ○ /404                          0.6 kB          84.7 kB\n\n○ (Static)   - Pre-rendered at build time\n● (SSG)      - Static site generation with getStaticProps\n⚡ (Server)   - Server-side renders at runtime\n```\n\n**3. Build Configuration:**\n```javascript\n// next.config.js\nmodule.exports = {\n  // Output settings\n  output: 'standalone', // For Docker deployments\n  trailingSlash: true,\n  \n  // Build optimizations\n  compress: true,\n  poweredByHeader: false,\n  generateEtags: true,\n  \n  // Bundle analyzer\n  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {\n    if (!dev && !isServer) {\n      config.resolve.alias = {\n        ...config.resolve.alias,\n        'react/jsx-runtime.js': 'preact/compat/jsx-runtime',\n        react: 'preact/compat',\n        'react-dom': 'preact/compat'\n      }\n    }\n    return config\n  },\n  \n  // Environment-specific builds\n  env: {\n    BUILD_TIME: new Date().toISOString(),\n  }\n}\n```\n\n**Deployment Options:**\n\n**1. Vercel (Recommended):**\n```bash\n# Install Vercel CLI\nnpm i -g vercel\n\n# Deploy\nvercel\n\n# Or connect GitHub repository for automatic deployments\n# Push to main branch triggers deployment\n```\n\n**2. Static Export:**\n```javascript\n// next.config.js\nmodule.exports = {\n  output: 'export',\n  trailingSlash: true,\n  images: {\n    unoptimized: true\n  }\n}\n```\n\n```bash\n# Build and export\nnpm run build\n\n# Output in `out/` directory\n# Can be served by any static hosting (Netlify, GitHub Pages, etc.)\n```\n\n**3. Docker Deployment:**\n```dockerfile\n# Dockerfile\nFROM node:18-alpine AS deps\nRUN apk add --no-cache libc6-compat\nWORKDIR /app\nCOPY package.json package-lock.json ./\nRUN npm ci --only=production\n\nFROM node:18-alpine AS builder\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine AS runner\nWORKDIR /app\nENV NODE_ENV production\n\nRUN addgroup --system --gid 1001 nodejs\nRUN adduser --system --uid 1001 nextjs\n\nCOPY --from=builder /app/public ./public\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./\nCOPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static\n\nUSER nextjs\n\nEXPOSE 3000\n\nENV PORT 3000\n\nCMD [\"node\", \"server.js\"]\n```\n\n**4. Custom Server Deployment:**\n```javascript\n// server.js\nconst { createServer } = require('http')\nconst { parse } = require('url')\nconst next = require('next')\n\nconst dev = process.env.NODE_ENV !== 'production'\nconst hostname = 'localhost'\nconst port = process.env.PORT || 3000\n\nconst app = next({ dev, hostname, port })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  createServer(async (req, res) => {\n    const parsedUrl = parse(req.url, true)\n    await handle(req, res, parsedUrl)\n  }).listen(port, (err) => {\n    if (err) throw err\n    console.log(`> Ready on http://${hostname}:${port}`)\n  })\n})\n```\n\n**Performance Optimization:**\n\n**1. Bundle Analysis:**\n```bash\n# Install bundle analyzer\nnpm install --save-dev @next/bundle-analyzer\n\n# Add to package.json\n\"scripts\": {\n  \"analyze\": \"ANALYZE=true npm run build\"\n}\n\n# Run analysis\nnpm run analyze\n```\n\n**2. Build Caching:**\n```javascript\n// next.config.js\nmodule.exports = {\n  // Enable SWC minification for faster builds\n  swcMinify: true,\n  \n  // Optimize images\n  images: {\n    formats: ['image/webp'],\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n  \n  // Compression\n  compress: true,\n  \n  // Experimental features\n  experimental: {\n    esmExternals: true,\n    serverMinification: true,\n  }\n}\n```\n\n**CI/CD Pipeline Example:**\n```yaml\n# .github/workflows/deploy.yml\nname: Deploy\non:\n  push:\n    branches: [main]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      \n      - run: npm ci\n      - run: npm run build\n      - run: npm run test\n      \n      - name: Deploy to Vercel\n        uses: amondnet/vercel-action@v25\n        with:\n          vercel-token: ${{ secrets.VERCEL_TOKEN }}\n          vercel-org-id: ${{ secrets.ORG_ID }}\n          vercel-project-id: ${{ secrets.PROJECT_ID }}\n```\n\n**Key Benefits:**\n- Automatic code splitting and optimization\n- Built-in performance monitoring\n- Multiple deployment strategies\n- Easy environment configuration\n- Zero-config deployment to Vercel\n- Support for serverless and traditional hosting",
      "keywords": ["build process", "deployment", "production", "optimization", "Vercel", "static export", "Docker"],
      "difficulty": "easy"
    },
    {
      "id": 5016,
      "tag": "nextjs",
      "question": "What are the key differences between App Router and Pages Router in Next.js 13+?",
      "answer": "Next.js 13 introduced the App Router as a new routing system alongside the existing Pages Router, bringing improved developer experience, better performance, and new features like React Server Components.\n\n**Routing Structure Differences:**\n\n**Pages Router (Traditional):**\n```\npages/\n├── index.js              → /\n├── about.js              → /about\n├── blog/\n│   ├── index.js          → /blog\n│   └── [slug].js         → /blog/[slug]\n├── api/\n│   └── users.js          → /api/users\n├── _app.js               → Custom App component\n└── _document.js          → Custom Document component\n```\n\n**App Router (New):**\n```\napp/\n├── layout.js             → Root layout\n├── page.js               → / (homepage)\n├── loading.js            → Loading UI\n├── error.js              → Error UI\n├── not-found.js          → 404 UI\n├── about/\n│   └── page.js           → /about\n├── blog/\n│   ├── page.js           → /blog\n│   ├── layout.js         → Blog layout\n│   └── [slug]/\n│       └── page.js       → /blog/[slug]\n└── api/\n    └── users/\n        └── route.js      → /api/users\n```\n\n**Data Fetching Differences:**\n\n**Pages Router:**\n```javascript\n// pages/posts/[id].js\nimport { GetServerSideProps, GetStaticProps } from 'next'\n\nexport default function Post({ post }) {\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  )\n}\n\n// Server-side rendering\nexport const getServerSideProps: GetServerSideProps = async ({ params }) => {\n  const post = await fetchPost(params.id)\n  return { props: { post } }\n}\n\n// Static generation\nexport const getStaticProps: GetStaticProps = async ({ params }) => {\n  const post = await fetchPost(params.id)\n  return {\n    props: { post },\n    revalidate: 3600\n  }\n}\n\nexport const getStaticPaths = async () => {\n  const paths = await getPostPaths()\n  return { paths, fallback: 'blocking' }\n}\n```\n\n**App Router:**\n```javascript\n// app/posts/[id]/page.js\nasync function fetchPost(id) {\n  const res = await fetch(`https://api.example.com/posts/${id}`, {\n    next: { revalidate: 3600 } // ISR\n  })\n  return res.json()\n}\n\nexport default async function Post({ params }) {\n  const post = await fetchPost(params.id)\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </article>\n  )\n}\n\n// Generate static params (equivalent to getStaticPaths)\nexport async function generateStaticParams() {\n  const posts = await fetch('https://api.example.com/posts').then(res => res.json())\n  \n  return posts.map((post) => ({\n    id: post.id.toString(),\n  }))\n}\n\n// Generate metadata\nexport async function generateMetadata({ params }) {\n  const post = await fetchPost(params.id)\n  \n  return {\n    title: post.title,\n    description: post.excerpt,\n  }\n}\n```\n\n**Layout System:**\n\n**Pages Router:**\n```javascript\n// pages/_app.js\nimport Layout from '../components/Layout'\n\nexport default function MyApp({ Component, pageProps }) {\n  return (\n    <Layout>\n      <Component {...pageProps} />\n    </Layout>\n  )\n}\n\n// Individual page layouts require manual implementation\nfunction BlogPost({ post }) {\n  return (\n    <BlogLayout>\n      <article>{post.content}</article>\n    </BlogLayout>\n  )\n}\n```\n\n**App Router:**\n```javascript\n// app/layout.js (Root Layout)\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <header>Global Header</header>\n        <main>{children}</main>\n        <footer>Global Footer</footer>\n      </body>\n    </html>\n  )\n}\n\n// app/blog/layout.js (Nested Layout)\nexport default function BlogLayout({ children }) {\n  return (\n    <div className=\"blog-container\">\n      <aside>Blog Sidebar</aside>\n      <div className=\"blog-content\">\n        {children}\n      </div>\n    </div>\n  )\n}\n```\n\n**Error Handling and Loading States:**\n\n**Pages Router:**\n```javascript\n// pages/_error.js\nfunction Error({ statusCode }) {\n  return (\n    <p>\n      {statusCode\n        ? `A ${statusCode} error occurred on server`\n        : 'An error occurred on client'}\n    </p>\n  )\n}\n\nError.getInitialProps = ({ res, err }) => {\n  const statusCode = res ? res.statusCode : err ? err.statusCode : 404\n  return { statusCode }\n}\n\n// Loading states require manual implementation\n```\n\n**App Router:**\n```javascript\n// app/error.js\n'use client'\n\nexport default function Error({ error, reset }) {\n  return (\n    <div>\n      <h2>Something went wrong!</h2>\n      <button onClick={() => reset()}>Try again</button>\n    </div>\n  )\n}\n\n// app/loading.js\nexport default function Loading() {\n  return <div className=\"spinner\">Loading...</div>\n}\n\n// app/not-found.js\nexport default function NotFound() {\n  return (\n    <div>\n      <h2>Not Found</h2>\n      <p>Could not find requested resource</p>\n    </div>\n  )\n}\n```\n\n**API Routes:**\n\n**Pages Router:**\n```javascript\n// pages/api/posts.js\nexport default function handler(req, res) {\n  if (req.method === 'GET') {\n    res.status(200).json({ posts: [] })\n  } else if (req.method === 'POST') {\n    res.status(201).json({ message: 'Created' })\n  }\n}\n```\n\n**App Router:**\n```javascript\n// app/api/posts/route.js\nexport async function GET() {\n  const posts = await fetchPosts()\n  return Response.json(posts)\n}\n\nexport async function POST(request) {\n  const data = await request.json()\n  const post = await createPost(data)\n  return Response.json(post, { status: 201 })\n}\n```\n\n**Key Advantages of App Router:**\n\n1. **React Server Components**: Better performance, smaller bundle sizes\n2. **Streaming**: Improved loading states and user experience\n3. **Nested Layouts**: More flexible layout system\n4. **Built-in Loading/Error States**: Automatic UI states\n5. **Simplified Data Fetching**: Async components, fetch in components\n6. **Better Developer Experience**: Colocation of related files\n7. **Improved SEO**: Better metadata handling\n\n**Migration Strategy:**\nBoth routers can coexist during migration. Start by moving simple pages to the app directory and gradually migrate complex features. The Pages Router will remain supported for the foreseeable future.",
      "keywords": ["App Router", "Pages Router", "React Server Components", "layouts", "data fetching", "Next.js 13"],
      "difficulty": "medium"
    },
    {
      "id": 5017,
      "tag": "nextjs",
      "question": "What are the key Next.js performance optimization techniques?",
      "answer": "Next.js provides numerous built-in and configurable performance optimizations that can significantly improve your application's speed, user experience, and Core Web Vitals scores.\n\n**Image Optimization:**\n\n**1. next/image Component:**\n```javascript\nimport Image from 'next/image'\n\n// Optimized image with priority loading\nfunction Hero() {\n  return (\n    <Image\n      src=\"/hero.jpg\"\n      alt=\"Hero image\"\n      width={1200}\n      height={600}\n      priority // Load immediately (above fold)\n      placeholder=\"blur\"\n      blurDataURL=\"data:image/jpeg;base64,/9j/4AAQ...\" // Low-quality placeholder\n      sizes=\"(max-width: 768px) 100vw, 50vw\" // Responsive sizing\n    />\n  )\n}\n\n// Fill container with optimized loading\nfunction Gallery() {\n  return (\n    <div style={{ position: 'relative', width: '100%', height: '400px' }}>\n      <Image\n        src=\"/gallery-image.jpg\"\n        alt=\"Gallery image\"\n        fill\n        style={{ objectFit: 'cover' }}\n        loading=\"lazy\" // Lazy load when in viewport\n      />\n    </div>\n  )\n}\n```\n\n**2. Image Configuration:**\n```javascript\n// next.config.js\nmodule.exports = {\n  images: {\n    formats: ['image/webp', 'image/avif'], // Modern formats\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n    domains: ['example.com', 'cdn.example.com'], // External domains\n    minimumCacheTTL: 60 * 60 * 24 * 365, // 1 year cache\n    dangerouslyAllowSVG: true,\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  }\n}\n```\n\n**Code Splitting and Bundle Optimization:**\n\n**1. Dynamic Imports:**\n```javascript\nimport dynamic from 'next/dynamic'\nimport { Suspense } from 'react'\n\n// Dynamic import with loading fallback\nconst HeavyComponent = dynamic(() => import('../components/HeavyComponent'), {\n  loading: () => <div>Loading...</div>,\n  ssr: false // Client-side only\n})\n\n// Dynamic import with named export\nconst Chart = dynamic(() => import('recharts').then(mod => ({ default: mod.LineChart })), {\n  ssr: false\n})\n\n// Conditional loading\nfunction Dashboard({ user }) {\n  const AdminPanel = dynamic(() => import('../components/AdminPanel'))\n  \n  return (\n    <div>\n      <h1>Dashboard</h1>\n      {user.isAdmin && (\n        <Suspense fallback={<div>Loading admin panel...</div>}>\n          <AdminPanel />\n        </Suspense>\n      )}\n    </div>\n  )\n}\n```\n\n**2. Bundle Analyzer:**\n```bash\nnpm install --save-dev @next/bundle-analyzer\n```\n\n```javascript\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true'\n})\n\nmodule.exports = withBundleAnalyzer({\n  // your config\n})\n```\n\n**Caching Strategies:**\n\n**1. Static Generation with ISR:**\n```javascript\n// App Router\nasync function fetchData() {\n  const res = await fetch('https://api.example.com/data', {\n    next: {\n      revalidate: 3600, // Revalidate every hour\n      tags: ['products'] // Cache tags for on-demand revalidation\n    }\n  })\n  return res.json()\n}\n\n// Pages Router\nexport async function getStaticProps() {\n  const data = await fetchData()\n  \n  return {\n    props: { data },\n    revalidate: 3600, // ISR\n    notFound: data.length === 0 // Return 404 if no data\n  }\n}\n```\n\n**2. API Route Caching:**\n```javascript\n// app/api/products/route.js\nexport async function GET() {\n  const products = await fetchProducts()\n  \n  return Response.json(products, {\n    status: 200,\n    headers: {\n      'Cache-Control': 'public, s-maxage=86400, stale-while-revalidate=604800'\n    }\n  })\n}\n```\n\n**Font Optimization:**\n\n```javascript\n// app/layout.js\nimport { Inter, Roboto_Mono } from 'next/font/google'\n\nconst inter = Inter({\n  subsets: ['latin'],\n  display: 'swap', // Better loading experience\n  variable: '--font-inter'\n})\n\nconst robotoMono = Roboto_Mono({\n  subsets: ['latin'],\n  display: 'swap',\n  variable: '--font-roboto-mono'\n})\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\" className={`${inter.variable} ${robotoMono.variable}`}>\n      <body className={inter.className}>\n        {children}\n      </body>\n    </html>\n  )\n}\n```\n\n**Script Optimization:**\n\n```javascript\nimport Script from 'next/script'\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <>\n      {/* Critical scripts - load immediately */}\n      <Script\n        src=\"https://www.googletagmanager.com/gtag/js?id=GA_TRACKING_ID\"\n        strategy=\"afterInteractive\"\n      />\n      \n      {/* Non-critical scripts - load after page is interactive */}\n      <Script\n        src=\"https://connect.facebook.net/en_US/sdk.js\"\n        strategy=\"lazyOnload\"\n      />\n      \n      {/* Inline scripts with proper strategy */}\n      <Script id=\"google-analytics\" strategy=\"afterInteractive\">\n        {`\n          window.dataLayer = window.dataLayer || [];\n          function gtag(){dataLayer.push(arguments);}\n          gtag('js', new Date());\n          gtag('config', 'GA_TRACKING_ID');\n        `}\n      </Script>\n      \n      <Component {...pageProps} />\n    </>\n  )\n}\n```\n\n**Webpack and Build Optimizations:**\n\n```javascript\n// next.config.js\nmodule.exports = {\n  // Enable SWC minification (faster than Terser)\n  swcMinify: true,\n  \n  // Compression\n  compress: true,\n  \n  // Remove powered by header\n  poweredByHeader: false,\n  \n  // Optimize build\n  experimental: {\n    esmExternals: true,\n    serverMinification: true,\n  },\n  \n  webpack: (config, { buildId, dev, isServer, defaultLoaders, webpack }) => {\n    // Bundle analyzer in production\n    if (!dev && !isServer) {\n      const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer')\n      config.plugins.push(\n        new BundleAnalyzerPlugin({\n          analyzerMode: 'static',\n          openAnalyzer: false,\n          reportFilename: '../bundle-analyzer.html'\n        })\n      )\n    }\n    \n    // Optimize chunks\n    config.optimization.splitChunks = {\n      chunks: 'all',\n      cacheGroups: {\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all',\n        },\n      },\n    }\n    \n    return config\n  }\n}\n```\n\n**Core Web Vitals Optimization:**\n\n```javascript\n// utils/webVitals.js\nexport function reportWebVitals(metric) {\n  if (metric.label === 'web-vital') {\n    // Log to analytics\n    gtag('event', metric.name, {\n      value: Math.round(metric.name === 'CLS' ? metric.value * 1000 : metric.value),\n      event_label: metric.id,\n      non_interaction: true,\n    })\n  }\n}\n\n// pages/_app.js\nimport { reportWebVitals } from '../utils/webVitals'\n\nfunction MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}\n\nexport { reportWebVitals }\n```\n\n**Performance Monitoring:**\n\n```javascript\n// next.config.js\nmodule.exports = {\n  // Enable performance monitoring\n  experimental: {\n    instrumentationHook: true,\n  },\n  \n  // Custom headers for performance\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'X-DNS-Prefetch-Control',\n            value: 'on'\n          },\n          {\n            key: 'Strict-Transport-Security',\n            value: 'max-age=63072000; includeSubDomains; preload'\n          }\n        ],\n      },\n    ]\n  }\n}\n```\n\n**Key Performance Benefits:**\n- Automatic code splitting reduces initial bundle size\n- Image optimization improves LCP (Largest Contentful Paint)\n- Font optimization prevents layout shifts (CLS)\n- Proper caching reduces server load and improves response times\n- Static generation enables global CDN distribution\n- Built-in performance monitoring helps identify bottlenecks",
      "keywords": ["performance optimization", "code splitting", "image optimization", "caching", "Core Web Vitals", "bundle analysis"],
      "difficulty": "medium"
    },
    {
      "id": 5018,
      "tag": "nextjs",
      "question": "What are advanced data fetching patterns and caching strategies in Next.js?",
      "answer": "Next.js provides sophisticated data fetching and caching mechanisms that enable complex patterns for optimal performance, from static generation to real-time updates with fine-grained cache control.\n\n**App Router Advanced Data Fetching:**\n\n**1. Server Components with Fetch API:**\n```javascript\n// app/posts/page.js - Server Component\nasync function getPosts() {\n  const res = await fetch('https://api.example.com/posts', {\n    next: {\n      revalidate: 3600, // ISR - revalidate every hour\n      tags: ['posts'], // Cache tags for selective revalidation\n    },\n    headers: {\n      'Authorization': `Bearer ${process.env.API_TOKEN}`,\n    },\n  })\n  \n  if (!res.ok) {\n    throw new Error('Failed to fetch posts')\n  }\n  \n  return res.json()\n}\n\nexport default async function PostsPage() {\n  const posts = await getPosts()\n  \n  return (\n    <div>\n      <h1>Blog Posts</h1>\n      {posts.map(post => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </article>\n      ))}\n    </div>\n  )\n}\n```\n\n**2. Parallel Data Fetching:**\n```javascript\n// app/dashboard/page.js\nasync function getUser() {\n  const res = await fetch('https://api.example.com/user', {\n    next: { tags: ['user'] }\n  })\n  return res.json()\n}\n\nasync function getAnalytics() {\n  const res = await fetch('https://api.example.com/analytics', {\n    next: { revalidate: 300 } // 5 minutes\n  })\n  return res.json()\n}\n\nasync function getNotifications() {\n  const res = await fetch('https://api.example.com/notifications', {\n    cache: 'no-store' // Always fresh data\n  })\n  return res.json()\n}\n\nexport default async function DashboardPage() {\n  // Parallel data fetching - all requests start simultaneously\n  const [user, analytics, notifications] = await Promise.all([\n    getUser(),\n    getAnalytics(),\n    getNotifications()\n  ])\n  \n  return (\n    <div className=\"dashboard\">\n      <UserProfile user={user} />\n      <AnalyticsWidget data={analytics} />\n      <NotificationList notifications={notifications} />\n    </div>\n  )\n}\n```\n\n**3. Streaming with Suspense:**\n```javascript\n// app/posts/[id]/page.js\nimport { Suspense } from 'react'\n\nasync function PostContent({ id }) {\n  const post = await fetch(`https://api.example.com/posts/${id}`, {\n    next: { revalidate: 3600 }\n  }).then(res => res.json())\n  \n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <div dangerouslySetInnerHTML={{ __html: post.content }} />\n    </article>\n  )\n}\n\nasync function PostComments({ id }) {\n  // Slower API call\n  await new Promise(resolve => setTimeout(resolve, 2000))\n  const comments = await fetch(`https://api.example.com/posts/${id}/comments`, {\n    cache: 'no-store'\n  }).then(res => res.json())\n  \n  return (\n    <section>\n      <h2>Comments</h2>\n      {comments.map(comment => (\n        <div key={comment.id}>{comment.text}</div>\n      ))}\n    </section>\n  )\n}\n\nexport default function PostPage({ params }) {\n  return (\n    <div>\n      {/* Fast content loads immediately */}\n      <Suspense fallback={<div>Loading post...</div>}>\n        <PostContent id={params.id} />\n      </Suspense>\n      \n      {/* Slow content streams in later */}\n      <Suspense fallback={<div>Loading comments...</div>}>\n        <PostComments id={params.id} />\n      </Suspense>\n    </div>\n  )\n}\n```\n\n**Cache Strategies:**\n\n**1. Request Memoization:**\n```javascript\n// Multiple components can call the same function - automatically deduplicated\nasync function getUserData(userId) {\n  console.log('Fetching user data...') // Only logged once per request\n  const res = await fetch(`https://api.example.com/users/${userId}`, {\n    next: { tags: [`user-${userId}`] }\n  })\n  return res.json()\n}\n\n// All three components will share the same request\nfunction UserProfile({ userId }) {\n  const user = await getUserData(userId)\n  return <h1>{user.name}</h1>\n}\n\nfunction UserAvatar({ userId }) {\n  const user = await getUserData(userId) // Same request, cached\n  return <img src={user.avatar} alt={user.name} />\n}\n\nfunction UserStats({ userId }) {\n  const user = await getUserData(userId) // Same request, cached\n  return <span>{user.posts} posts</span>\n}\n```\n\n**2. On-Demand Revalidation:**\n```javascript\n// app/api/revalidate/route.js\nimport { revalidateTag, revalidatePath } from 'next/cache'\nimport { NextRequest } from 'next/server'\n\nexport async function POST(request: NextRequest) {\n  const secret = request.nextUrl.searchParams.get('secret')\n  \n  if (secret !== process.env.REVALIDATION_SECRET) {\n    return Response.json({ message: 'Invalid secret' }, { status: 401 })\n  }\n  \n  const tag = request.nextUrl.searchParams.get('tag')\n  const path = request.nextUrl.searchParams.get('path')\n  \n  if (tag) {\n    // Revalidate all requests with this tag\n    revalidateTag(tag)\n    return Response.json({ revalidated: true, tag })\n  }\n  \n  if (path) {\n    // Revalidate specific path\n    revalidatePath(path)\n    return Response.json({ revalidated: true, path })\n  }\n  \n  return Response.json({ message: 'No tag or path specified' }, { status: 400 })\n}\n\n// Webhook from CMS to trigger revalidation\n// POST /api/revalidate?secret=token&tag=posts\n```\n\n**3. Custom Cache Control:**\n```javascript\n// app/api/posts/route.js\nimport { NextRequest } from 'next/server'\n\nexport async function GET(request: NextRequest) {\n  const posts = await fetchPosts()\n  \n  return Response.json(posts, {\n    status: 200,\n    headers: {\n      // Browser cache for 5 minutes, CDN cache for 1 hour, \n      // serve stale for 1 day while revalidating\n      'Cache-Control': 'public, s-maxage=3600, stale-while-revalidate=86400',\n      \n      // Vary cache by these headers\n      'Vary': 'Accept-Encoding, Accept-Language',\n      \n      // ETags for conditional requests\n      'ETag': generateETag(posts),\n    }\n  })\n}\n```\n\n**Advanced Patterns:**\n\n**1. Incremental Static Regeneration (ISR):**\n```javascript\n// app/products/[id]/page.js\nexport async function generateStaticParams() {\n  // Pre-generate popular products at build time\n  const popularProducts = await fetch('https://api.example.com/products/popular')\n    .then(res => res.json())\n  \n  return popularProducts.map((product) => ({\n    id: product.id.toString(),\n  }))\n}\n\nexport async function generateMetadata({ params }) {\n  const product = await fetch(`https://api.example.com/products/${params.id}`, {\n    next: { revalidate: 86400 } // Revalidate daily\n  }).then(res => res.json())\n  \n  return {\n    title: product.name,\n    description: product.description,\n    openGraph: {\n      title: product.name,\n      description: product.description,\n      images: [{ url: product.image }],\n    },\n  }\n}\n\nexport default async function ProductPage({ params }) {\n  const product = await fetch(`https://api.example.com/products/${params.id}`, {\n    next: {\n      revalidate: 86400, // Revalidate daily\n      tags: [`product-${params.id}`]\n    }\n  }).then(res => res.json())\n  \n  if (!product) {\n    notFound()\n  }\n  \n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      <div>Price: ${product.price}</div>\n    </div>\n  )\n}\n```\n\n**2. Client-Side Data Fetching with SWR:**\n```javascript\n'use client'\nimport useSWR from 'swr'\n\nconst fetcher = (url) => fetch(url).then(res => res.json())\n\nfunction RealTimeData() {\n  const { data, error, isLoading, mutate } = useSWR(\n    '/api/live-data',\n    fetcher,\n    {\n      refreshInterval: 5000, // Poll every 5 seconds\n      revalidateOnFocus: true,\n      revalidateOnReconnect: true,\n      dedupingInterval: 2000,\n      errorRetryCount: 3,\n      onError: (error) => {\n        console.error('SWR Error:', error)\n      }\n    }\n  )\n  \n  if (error) return <div>Failed to load</div>\n  if (isLoading) return <div>Loading...</div>\n  \n  return (\n    <div>\n      <h2>Live Data</h2>\n      <pre>{JSON.stringify(data, null, 2)}</pre>\n      <button onClick={() => mutate()}>Refresh</button>\n    </div>\n  )\n}\n```\n\n**3. Database Connection Optimization:**\n```javascript\n// lib/db.js\nimport { Pool } from 'pg'\n\nlet pool\n\nfunction getPool() {\n  if (!pool) {\n    pool = new Pool({\n      connectionString: process.env.DATABASE_URL,\n      max: 20, // Maximum connections\n      idleTimeoutMillis: 30000,\n      connectionTimeoutMillis: 2000,\n    })\n  }\n  return pool\n}\n\nexport async function query(text, params) {\n  const client = getPool()\n  const start = Date.now()\n  try {\n    const res = await client.query(text, params)\n    const duration = Date.now() - start\n    console.log('Executed query', { text, duration, rows: res.rowCount })\n    return res\n  } catch (error) {\n    console.error('Database query error:', error)\n    throw error\n  }\n}\n\n// Usage with caching\nexport async function getUser(id) {\n  const cacheKey = `user:${id}`\n  \n  // Try Redis cache first\n  const cached = await redis.get(cacheKey)\n  if (cached) {\n    return JSON.parse(cached)\n  }\n  \n  // Fallback to database\n  const result = await query(\n    'SELECT * FROM users WHERE id = $1',\n    [id]\n  )\n  \n  if (result.rows[0]) {\n    // Cache for 10 minutes\n    await redis.setex(cacheKey, 600, JSON.stringify(result.rows[0]))\n    return result.rows[0]\n  }\n  \n  return null\n}\n```\n\n**Performance Benefits:**\n- Request deduplication reduces API calls\n- Selective revalidation minimizes cache invalidation\n- Streaming improves perceived performance\n- ISR combines static generation with dynamic updates\n- Multi-level caching optimizes data access\n- Background revalidation keeps content fresh",
      "keywords": ["advanced data fetching", "caching strategies", "ISR", "Server Components", "streaming", "revalidation"],
      "difficulty": "hard"
    },
    {
      "id": 5019,
      "tag": "nextjs",
      "question": "How do you implement custom server configuration and advanced Next.js features?",
      "answer": "Next.js allows extensive customization through custom servers, advanced configuration, middleware, and integration with external services for complex enterprise applications.\n\n**Custom Server Implementation:**\n\n**1. Express.js Custom Server:**\n```javascript\n// server.js\nconst express = require('express')\nconst next = require('next')\nconst { createProxyMiddleware } = require('http-proxy-middleware')\nconst compression = require('compression')\nconst helmet = require('helmet')\nconst rateLimit = require('express-rate-limit')\n\nconst dev = process.env.NODE_ENV !== 'production'\nconst hostname = 'localhost'\nconst port = process.env.PORT || 3000\n\nconst app = next({ dev, hostname, port })\nconst handle = app.getRequestHandler()\n\napp.prepare().then(() => {\n  const server = express()\n  \n  // Security middleware\n  server.use(helmet({\n    contentSecurityPolicy: {\n      directives: {\n        defaultSrc: [\"'self'\"],\n        styleSrc: [\"'self'\", \"'unsafe-inline'\", 'fonts.googleapis.com'],\n        fontSrc: [\"'self'\", 'fonts.gstatic.com'],\n        imgSrc: [\"'self'\", 'data:', 'https:'],\n        scriptSrc: [\"'self'\", \"'unsafe-eval'\", \"'unsafe-inline'\"],\n      },\n    },\n  }))\n  \n  // Compression\n  server.use(compression())\n  \n  // Rate limiting\n  const limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100, // limit each IP to 100 requests per windowMs\n    message: 'Too many requests from this IP',\n    standardHeaders: true,\n    legacyHeaders: false,\n  })\n  server.use('/api/', limiter)\n  \n  // Custom API proxy\n  server.use('/api/external', createProxyMiddleware({\n    target: 'https://external-api.com',\n    changeOrigin: true,\n    pathRewrite: {\n      '^/api/external': '/v1'\n    },\n    onProxyReq: (proxyReq, req) => {\n      proxyReq.setHeader('Authorization', `Bearer ${process.env.EXTERNAL_API_KEY}`)\n    }\n  }))\n  \n  // Custom route handling\n  server.get('/health', (req, res) => {\n    res.json({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: process.memoryUsage()\n    })\n  })\n  \n  // Custom authentication middleware\n  server.use('/dashboard/*', (req, res, next) => {\n    const token = req.headers.authorization?.replace('Bearer ', '')\n    \n    if (!token) {\n      return res.redirect('/login')\n    }\n    \n    // Verify token logic\n    verifyToken(token)\n      .then(user => {\n        req.user = user\n        next()\n      })\n      .catch(() => res.redirect('/login'))\n  })\n  \n  // Custom route with SSR\n  server.get('/custom/:id', (req, res) => {\n    const actualPage = '/custom-page'\n    const queryParams = {\n      id: req.params.id,\n      userId: req.user?.id\n    }\n    \n    app.render(req, res, actualPage, queryParams)\n  })\n  \n  // Handle all other routes with Next.js\n  server.all('*', (req, res) => {\n    return handle(req, res)\n  })\n  \n  server.listen(port, (err) => {\n    if (err) throw err\n    console.log(`> Ready on http://${hostname}:${port}`)\n  })\n})\n```\n\n**2. Advanced next.config.js Configuration:**\n```javascript\n// next.config.js\nconst withBundleAnalyzer = require('@next/bundle-analyzer')({\n  enabled: process.env.ANALYZE === 'true'\n})\n\nconst ContentSecurityPolicy = `\n  default-src 'self' vercel.live;\n  script-src 'self' 'unsafe-eval' 'unsafe-inline' cdn.vercel-insights.com vercel.live;\n  style-src 'self' 'unsafe-inline';\n  img-src * blob: data:;\n  media-src 'none';\n  connect-src *;\n  font-src 'self' fonts.gstatic.com;\n`\n\nmodule.exports = withBundleAnalyzer({\n  // Build configuration\n  output: 'standalone', // For Docker deployments\n  generateEtags: true,\n  compress: true,\n  poweredByHeader: false,\n  \n  // Compiler options\n  compiler: {\n    removeConsole: process.env.NODE_ENV === 'production' ? {\n      exclude: ['error']\n    } : false,\n    reactRemoveProperties: process.env.NODE_ENV === 'production',\n    styledComponents: true,\n  },\n  \n  // Experimental features\n  experimental: {\n    serverComponentsExternalPackages: ['@prisma/client'],\n    instrumentationHook: true,\n    serverMinification: true,\n    optimizePackageImports: ['lodash', 'date-fns'],\n  },\n  \n  // Image optimization\n  images: {\n    formats: ['image/avif', 'image/webp'],\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n    minimumCacheTTL: 31536000, // 1 year\n    dangerouslyAllowSVG: true,\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.amazonaws.com',\n      },\n      {\n        protocol: 'https',\n        hostname: 'images.unsplash.com',\n      }\n    ],\n  },\n  \n  // Environment variables\n  env: {\n    CUSTOM_BUILD_TIME: new Date().toISOString(),\n    BUILD_ID: process.env.VERCEL_GIT_COMMIT_SHA || 'local',\n  },\n  \n  // Headers\n  async headers() {\n    return [\n      {\n        source: '/(.*)',\n        headers: [\n          {\n            key: 'Content-Security-Policy',\n            value: ContentSecurityPolicy.replace(/\\n/g, ''),\n          },\n          {\n            key: 'Strict-Transport-Security',\n            value: 'max-age=31536000; includeSubDomains; preload'\n          },\n          {\n            key: 'X-Frame-Options',\n            value: 'DENY'\n          },\n          {\n            key: 'X-Content-Type-Options',\n            value: 'nosniff'\n          },\n        ],\n      },\n      {\n        source: '/api/(.*)',\n        headers: [\n          {\n            key: 'Cache-Control',\n            value: 'public, max-age=0, must-revalidate'\n          }\n        ]\n      }\n    ]\n  },\n  \n  // Redirects\n  async redirects() {\n    return [\n      {\n        source: '/old-blog/:slug*',\n        destination: '/blog/:slug*',\n        permanent: true,\n      },\n      {\n        source: '/dashboard',\n        destination: '/dashboard/overview',\n        permanent: false,\n        has: [\n          {\n            type: 'cookie',\n            key: 'authorized',\n            value: 'true',\n          },\n        ],\n      },\n    ]\n  },\n  \n  // Rewrites\n  async rewrites() {\n    return {\n      beforeFiles: [\n        {\n          source: '/sitemap.xml',\n          destination: '/api/sitemap'\n        }\n      ],\n      afterFiles: [\n        {\n          source: '/api/proxy/:path*',\n          destination: 'https://external-api.com/:path*'\n        }\n      ],\n      fallback: [\n        {\n          source: '/:path*',\n          destination: '/404'\n        }\n      ]\n    }\n  },\n  \n  // Webpack customization\n  webpack: (config, { buildId, dev, isServer, defaultLoaders, nextRuntime, webpack }) => {\n    // Add custom webpack plugins\n    if (!isServer) {\n      config.resolve.fallback = {\n        ...config.resolve.fallback,\n        fs: false,\n      }\n    }\n    \n    // Custom module rules\n    config.module.rules.push({\n      test: /\\.svg$/i,\n      issuer: /\\.[jt]sx?$/,\n      use: ['@svgr/webpack'],\n    })\n    \n    // Bundle splitting optimization\n    config.optimization.splitChunks = {\n      ...config.optimization.splitChunks,\n      cacheGroups: {\n        ...config.optimization.splitChunks.cacheGroups,\n        commons: {\n          name: 'commons',\n          chunks: 'all',\n          minChunks: 2,\n        },\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendor',\n          chunks: 'all',\n        },\n      },\n    }\n    \n    // Add source maps in production for debugging\n    if (!dev) {\n      config.devtool = 'source-map'\n    }\n    \n    return config\n  },\n  \n  // TypeScript configuration\n  typescript: {\n    ignoreBuildErrors: false,\n    tsconfigPath: './tsconfig.json'\n  },\n  \n  // ESLint configuration\n  eslint: {\n    ignoreDuringBuilds: false,\n    dirs: ['pages', 'components', 'lib', 'app']\n  }\n})\n```\n\n**3. Advanced Middleware Patterns:**\n```javascript\n// middleware.js\nimport { NextResponse } from 'next/server'\nimport { jwtVerify } from 'jose'\nimport { geolocation } from '@vercel/edge'\n\n// Rate limiting store (in production, use Redis)\nconst rateLimitMap = new Map()\n\nfunction rateLimit(request) {\n  const ip = request.ip || 'anonymous'\n  const now = Date.now()\n  const windowMs = 60 * 1000 // 1 minute\n  const maxRequests = 60\n  \n  if (!rateLimitMap.has(ip)) {\n    rateLimitMap.set(ip, { count: 1, resetTime: now + windowMs })\n    return false\n  }\n  \n  const userData = rateLimitMap.get(ip)\n  \n  if (now > userData.resetTime) {\n    userData.count = 1\n    userData.resetTime = now + windowMs\n    return false\n  }\n  \n  if (userData.count >= maxRequests) {\n    return true // Rate limited\n  }\n  \n  userData.count++\n  return false\n}\n\nasync function verifyAuth(request) {\n  const token = request.cookies.get('auth-token')?.value\n  \n  if (!token) return null\n  \n  try {\n    const secret = new TextEncoder().encode(process.env.JWT_SECRET)\n    const { payload } = await jwtVerify(token, secret)\n    return payload\n  } catch {\n    return null\n  }\n}\n\nexport async function middleware(request) {\n  const { pathname } = request.nextUrl\n  \n  // Rate limiting\n  if (rateLimit(request)) {\n    return new NextResponse('Too Many Requests', {\n      status: 429,\n      headers: {\n        'Retry-After': '60'\n      }\n    })\n  }\n  \n  // Geolocation-based routing\n  if (pathname.startsWith('/geo')) {\n    const { country } = geolocation(request)\n    \n    if (country === 'CN') {\n      return NextResponse.redirect(new URL('/blocked', request.url))\n    }\n    \n    const response = NextResponse.next()\n    response.headers.set('x-country', country)\n    return response\n  }\n  \n  // Authentication middleware\n  if (pathname.startsWith('/dashboard') || pathname.startsWith('/admin')) {\n    const user = await verifyAuth(request)\n    \n    if (!user) {\n      const loginUrl = new URL('/login', request.url)\n      loginUrl.searchParams.set('callbackUrl', request.url)\n      return NextResponse.redirect(loginUrl)\n    }\n    \n    // Admin-only routes\n    if (pathname.startsWith('/admin') && user.role !== 'admin') {\n      return new NextResponse('Forbidden', { status: 403 })\n    }\n    \n    const response = NextResponse.next()\n    response.headers.set('x-user-id', user.sub)\n    return response\n  }\n  \n  // A/B testing\n  if (pathname === '/') {\n    const bucket = request.cookies.get('ab-test')?.value\n    \n    if (!bucket) {\n      const newBucket = Math.random() < 0.5 ? 'a' : 'b'\n      const response = NextResponse.next()\n      response.cookies.set('ab-test', newBucket, {\n        maxAge: 60 * 60 * 24 * 30, // 30 days\n        httpOnly: true,\n        secure: true,\n        sameSite: 'lax'\n      })\n      \n      if (newBucket === 'b') {\n        return NextResponse.rewrite(new URL('/home-variant-b', request.url))\n      }\n      \n      return response\n    }\n    \n    if (bucket === 'b') {\n      return NextResponse.rewrite(new URL('/home-variant-b', request.url))\n    }\n  }\n  \n  // Security headers\n  const response = NextResponse.next()\n  \n  response.headers.set('X-Frame-Options', 'DENY')\n  response.headers.set('X-Content-Type-Options', 'nosniff')\n  response.headers.set('Referrer-Policy', 'origin-when-cross-origin')\n  \n  return response\n}\n\nexport const config = {\n  matcher: [\n    '/((?!api|_next/static|_next/image|favicon.ico).*)'\n  ]\n}\n```\n\n**4. Instrumentation and Monitoring:**\n```javascript\n// instrumentation.js\nexport async function register() {\n  if (process.env.NEXT_RUNTIME === 'nodejs') {\n    const { NodeSDK } = await import('@opentelemetry/sdk-node')\n    const { getNodeAutoInstrumentations } = await import('@opentelemetry/auto-instrumentations-node')\n    const { Resource } = await import('@opentelemetry/resources')\n    const { SemanticResourceAttributes } = await import('@opentelemetry/semantic-conventions')\n    \n    const sdk = new NodeSDK({\n      resource: new Resource({\n        [SemanticResourceAttributes.SERVICE_NAME]: 'nextjs-app',\n        [SemanticResourceAttributes.SERVICE_VERSION]: '1.0.0',\n      }),\n      instrumentations: [getNodeAutoInstrumentations()],\n    })\n    \n    sdk.start()\n    \n    // Custom metrics\n    const { metrics } = await import('@opentelemetry/api')\n    const meter = metrics.getMeter('nextjs-app')\n    \n    const requestCounter = meter.createCounter('http_requests_total', {\n      description: 'Total number of HTTP requests'\n    })\n    \n    const responseTimeHistogram = meter.createHistogram('http_request_duration_ms', {\n      description: 'Duration of HTTP requests in milliseconds'\n    })\n    \n    // Monkey patch fetch for automatic instrumentation\n    const originalFetch = global.fetch\n    global.fetch = async (...args) => {\n      const start = Date.now()\n      try {\n        const response = await originalFetch(...args)\n        requestCounter.add(1, { \n          method: args[1]?.method || 'GET',\n          status: response.status.toString()\n        })\n        responseTimeHistogram.record(Date.now() - start)\n        return response\n      } catch (error) {\n        requestCounter.add(1, {\n          method: args[1]?.method || 'GET',\n          status: 'error'\n        })\n        throw error\n      }\n    }\n  }\n}\n```\n\n**Key Benefits:**\n- Custom server enables complex routing and middleware\n- Advanced configuration provides fine-grained control\n- Middleware enables edge-level processing\n- Instrumentation provides observability and monitoring\n- Security enhancements protect against common vulnerabilities\n- Performance optimizations improve application speed\n- A/B testing capabilities enable experimentation",
      "keywords": ["custom server", "advanced configuration", "middleware", "security", "monitoring", "instrumentation"],
      "difficulty": "hard"
    }
  ]
}