{
  "technology": "nestjs",
  "questions": [
    {
      "id": 7000,
      "tag": "nestjs",
      "question": "What is Nest.js and what are its core principles?",
      "answer": "Nest.js is a progressive Node.js framework for building efficient, reliable, and scalable server-side applications. It's built with TypeScript and combines elements of Object-Oriented Programming (OOP), Functional Programming (FP), and Functional Reactive Programming (FRP).\n\nCore principles of Nest.js:\n\n1. **Modularity**: Applications are organized into modules that encapsulate related components, making code more maintainable and reusable.\n\n2. **Dependency Injection**: Built-in IoC (Inversion of Control) container that manages dependencies automatically, promoting loose coupling and testability.\n\n3. **Decorator-based Architecture**: Heavily uses TypeScript decorators to define metadata and behavior, making code more declarative and readable.\n\n4. **Platform Independence**: Can work with different HTTP server frameworks (Express, Fastify) underneath while providing a consistent API.\n\n5. **Extensibility**: Modular architecture allows easy integration of third-party libraries and custom solutions.\n\nExample of a basic Nest.js application structure:\n\n```typescript\n// app.module.ts\n@Module({\n  imports: [UsersModule],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n\n// users.controller.ts\n@Controller('users')\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n  \n  @Get()\n  findAll() {\n    return this.usersService.findAll();\n  }\n}\n```\n\nNest.js provides excellent tooling, CLI support, and follows enterprise-grade patterns that make it ideal for large-scale applications.",
      "keywords": ["nestjs", "framework", "typescript", "modular", "dependency injection", "decorators", "scalable"],
      "difficulty": "easy"
    },
    {
      "id": 7001,
      "tag": "nestjs",
      "question": "Explain decorators in NestJS, particularly @Controller, @Get, and @Post decorators.",
      "answer": "Decorators in NestJS are special functions that add metadata to classes, methods, and properties. They're essential for defining routes, controllers, and other components in a declarative way.\n\n**@Controller Decorator:**\nDefines a class as a controller and optionally sets a route prefix:\n\n```typescript\n@Controller('users') // Route prefix: /users\nexport class UsersController {\n  // All routes in this controller will be prefixed with /users\n}\n\n@Controller() // No prefix, routes start from root\nexport class AppController {}\n```\n\n**@Get Decorator:**\nDefines a method as a GET endpoint handler:\n\n```typescript\n@Controller('users')\nexport class UsersController {\n  @Get() // GET /users\n  findAll() {\n    return 'All users';\n  }\n  \n  @Get(':id') // GET /users/:id\n  findOne(@Param('id') id: string) {\n    return `User ${id}`;\n  }\n  \n  @Get('profile/:id') // GET /users/profile/:id\n  getProfile(@Param('id') id: string) {\n    return `Profile of user ${id}`;\n  }\n}\n```\n\n**@Post Decorator:**\nDefines a method as a POST endpoint handler:\n\n```typescript\n@Controller('users')\nexport class UsersController {\n  @Post() // POST /users\n  create(@Body() createUserDto: CreateUserDto) {\n    return 'User created';\n  }\n  \n  @Post('login') // POST /users/login\n  login(@Body() loginDto: LoginDto) {\n    return 'Login successful';\n  }\n}\n```\n\nThese decorators work together to create a clean, declarative routing system that's easy to understand and maintain.",
      "keywords": ["decorators", "controller", "routes", "get", "post", "metadata", "typescript"],
      "difficulty": "easy"
    },
    {
      "id": 7002,
      "tag": "nestjs",
      "question": "How does dependency injection work in NestJS? Explain providers and their role.",
      "answer": "Dependency Injection (DI) in NestJS is a design pattern where dependencies are provided to a class rather than the class creating them itself. NestJS has a built-in IoC (Inversion of Control) container that manages this automatically.\n\n**Providers:**\nProviders are classes annotated with the `@Injectable()` decorator. They can be injected into other classes as dependencies:\n\n```typescript\n// user.service.ts\n@Injectable()\nexport class UserService {\n  private users = [];\n  \n  findAll() {\n    return this.users;\n  }\n  \n  create(user: any) {\n    this.users.push(user);\n    return user;\n  }\n}\n```\n\n**Dependency Injection in Controllers:**\n```typescript\n// user.controller.ts\n@Controller('users')\nexport class UserController {\n  constructor(private userService: UserService) {}\n  // UserService is automatically injected\n  \n  @Get()\n  findAll() {\n    return this.userService.findAll();\n  }\n  \n  @Post()\n  create(@Body() user: any) {\n    return this.userService.create(user);\n  }\n}\n```\n\n**Provider Registration:**\nProviders must be registered in modules:\n\n```typescript\n// user.module.ts\n@Module({\n  controllers: [UserController],\n  providers: [UserService], // Register the provider\n  exports: [UserService], // Export to make it available in other modules\n})\nexport class UserModule {}\n```\n\n**Benefits:**\n- **Testability**: Easy to mock dependencies for unit testing\n- **Loose Coupling**: Classes depend on abstractions, not concrete implementations\n- **Reusability**: Services can be shared across multiple controllers\n- **Maintainability**: Changes to dependencies don't affect dependent classes\n\nNestJS automatically resolves dependencies, creates instances, and manages their lifecycle.",
      "keywords": ["dependency injection", "providers", "injectable", "IoC", "services", "constructor", "modules"],
      "difficulty": "easy"
    },
    {
      "id": 7003,
      "tag": "nestjs",
      "question": "What are modules in NestJS and how do you organize them?",
      "answer": "Modules in NestJS are classes decorated with `@Module()` that organize related components (controllers, providers, etc.) into cohesive blocks. They help structure applications and manage dependencies.\n\n**Basic Module Structure:**\n```typescript\n// users.module.ts\n@Module({\n  imports: [], // Other modules this module depends on\n  controllers: [UsersController], // Controllers defined in this module\n  providers: [UsersService], // Providers available in this module\n  exports: [], // Providers to make available to other modules\n})\nexport class UsersModule {}\n```\n\n**Module Organization Patterns:**\n\n1. **Feature Modules** - Group related functionality:\n```typescript\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  controllers: [UsersController],\n  providers: [UsersService, UsersRepository],\n  exports: [UsersService], // Allow other modules to use UsersService\n})\nexport class UsersModule {}\n```\n\n2. **Shared Modules** - Common utilities and services:\n```typescript\n@Module({\n  providers: [DatabaseService, LoggerService],\n  exports: [DatabaseService, LoggerService],\n})\nexport class SharedModule {}\n```\n\n3. **Root Module** - Application entry point:\n```typescript\n@Module({\n  imports: [\n    UsersModule,\n    ProductsModule,\n    SharedModule,\n    ConfigModule.forRoot(),\n  ],\n  controllers: [AppController],\n  providers: [AppService],\n})\nexport class AppModule {}\n```\n\n**Module Communication:**\n```typescript\n// products.module.ts\n@Module({\n  imports: [UsersModule], // Import UsersModule to use its exports\n  controllers: [ProductsController],\n  providers: [ProductsService],\n})\nexport class ProductsModule {}\n\n// Now ProductsService can inject UsersService\n@Injectable()\nexport class ProductsService {\n  constructor(private usersService: UsersService) {}\n}\n```\n\n**Benefits:**\n- Clear separation of concerns\n- Reusable and composable components  \n- Better testing isolation\n- Lazy loading capabilities\n- Clear dependency boundaries",
      "keywords": ["modules", "organization", "imports", "exports", "providers", "controllers", "feature modules"],
      "difficulty": "easy"
    },
    {
      "id": 7004,
      "tag": "nestjs",
      "question": "Describe the request/response cycle in NestJS and how it processes HTTP requests.",
      "answer": "The request/response cycle in NestJS follows a well-defined pipeline that processes incoming HTTP requests through multiple layers before sending back a response.\n\n**Request/Response Flow:**\n\n1. **Incoming Request** → HTTP request hits the NestJS application\n2. **Middleware** → Global and route-specific middleware execute\n3. **Guards** → Authentication and authorization checks\n4. **Pipes** → Request data validation and transformation\n5. **Route Handler** → Controller method execution\n6. **Interceptors** → Response transformation and logging\n7. **Exception Filters** → Error handling if exceptions occur\n8. **Response** → Final response sent to client\n\n**Detailed Example:**\n```typescript\n// 1. Middleware (runs first)\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n  use(req: Request, res: Response, next: NextFunction) {\n    console.log('Request received:', req.method, req.url);\n    next();\n  }\n}\n\n// 2. Guard (authentication/authorization)\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const request = context.switchToHttp().getRequest();\n    return request.headers.authorization !== undefined;\n  }\n}\n\n// 3. Pipe (validation/transformation)\n@Injectable()\nexport class ValidationPipe implements PipeTransform {\n  transform(value: any, metadata: ArgumentMetadata) {\n    // Validate and transform the value\n    return value;\n  }\n}\n\n// 4. Controller with route handler\n@Controller('users')\nexport class UsersController {\n  @Post()\n  @UseGuards(AuthGuard)\n  @UsePipes(ValidationPipe)\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n}\n\n// 5. Interceptor (response handling)\n@Injectable()\nexport class ResponseInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler) {\n    return next.handle().pipe(\n      map(data => ({ success: true, data }))\n    );\n  }\n}\n```\n\n**Key Points:**\n- Each layer can modify the request or response\n- Errors can be caught and handled at any stage\n- The pipeline ensures consistent request processing\n- Decorators control which components apply to specific routes",
      "keywords": ["request cycle", "response cycle", "middleware", "guards", "pipes", "interceptors", "route handler"],
      "difficulty": "easy"
    },
    {
      "id": 7005,
      "tag": "nestjs",
      "question": "How do you create services and controllers in NestJS? Show the relationship between them.",
      "answer": "Services and controllers work together in NestJS following the separation of concerns principle. Controllers handle HTTP requests while services contain business logic.\n\n**Creating a Service:**\n```typescript\n// users.service.ts\n@Injectable()\nexport class UsersService {\n  private users: User[] = [];\n  \n  findAll(): User[] {\n    return this.users;\n  }\n  \n  findOne(id: number): User {\n    return this.users.find(user => user.id === id);\n  }\n  \n  create(createUserDto: CreateUserDto): User {\n    const newUser = {\n      id: Date.now(),\n      ...createUserDto,\n      createdAt: new Date(),\n    };\n    this.users.push(newUser);\n    return newUser;\n  }\n  \n  update(id: number, updateUserDto: UpdateUserDto): User {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex === -1) {\n      throw new NotFoundException('User not found');\n    }\n    this.users[userIndex] = { ...this.users[userIndex], ...updateUserDto };\n    return this.users[userIndex];\n  }\n  \n  delete(id: number): void {\n    const userIndex = this.users.findIndex(user => user.id === id);\n    if (userIndex === -1) {\n      throw new NotFoundException('User not found');\n    }\n    this.users.splice(userIndex, 1);\n  }\n}\n```\n\n**Creating a Controller:**\n```typescript\n// users.controller.ts\n@Controller('users')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) {}\n  \n  @Get()\n  findAll() {\n    return this.usersService.findAll();\n  }\n  \n  @Get(':id')\n  findOne(@Param('id', ParseIntPipe) id: number) {\n    return this.usersService.findOne(id);\n  }\n  \n  @Post()\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n  \n  @Put(':id')\n  update(\n    @Param('id', ParseIntPipe) id: number,\n    @Body() updateUserDto: UpdateUserDto,\n  ) {\n    return this.usersService.update(id, updateUserDto);\n  }\n  \n  @Delete(':id')\n  delete(@Param('id', ParseIntPipe) id: number) {\n    return this.usersService.delete(id);\n  }\n}\n```\n\n**Module Registration:**\n```typescript\n// users.module.ts\n@Module({\n  controllers: [UsersController],\n  providers: [UsersService],\n})\nexport class UsersModule {}\n```\n\n**Key Relationships:**\n- Controllers are thin layers that handle HTTP-specific concerns\n- Services contain business logic and data operations\n- Dependency injection connects them automatically\n- Services can be reused across multiple controllers\n- Both must be registered in their respective module",
      "keywords": ["services", "controllers", "injectable", "business logic", "http requests", "dependency injection"],
      "difficulty": "easy"
    },
    {
      "id": 7006,
      "tag": "nestjs",
      "question": "How do guards work in NestJS and what are different authentication strategies you can implement?",
      "answer": "Guards in NestJS are classes that implement the `CanActivate` interface and determine whether a request should be handled by the route handler. They're primarily used for authentication and authorization.\n\n**Basic Guard Implementation:**\n```typescript\n@Injectable()\nexport class AuthGuard implements CanActivate {\n  canActivate(\n    context: ExecutionContext,\n  ): boolean | Promise<boolean> | Observable<boolean> {\n    const request = context.switchToHttp().getRequest();\n    return this.validateRequest(request);\n  }\n  \n  private validateRequest(request: any): boolean {\n    // Authentication logic here\n    return request.headers.authorization !== undefined;\n  }\n}\n```\n\n**JWT Authentication Strategy:**\n```typescript\n@Injectable()\nexport class JwtAuthGuard extends AuthGuard('jwt') {\n  canActivate(context: ExecutionContext) {\n    return super.canActivate(context);\n  }\n  \n  handleRequest(err: any, user: any, info: any) {\n    if (err || !user) {\n      throw err || new UnauthorizedException();\n    }\n    return user;\n  }\n}\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor() {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: process.env.JWT_SECRET,\n    });\n  }\n  \n  async validate(payload: any) {\n    return { userId: payload.sub, username: payload.username };\n  }\n}\n```\n\n**Role-based Authorization Guard:**\n```typescript\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n  \n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    \n    if (!requiredRoles) {\n      return true;\n    }\n    \n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.roles?.includes(role));\n  }\n}\n\n// Usage with decorator\n@Roles(Role.Admin)\n@UseGuards(JwtAuthGuard, RolesGuard)\n@Get('admin')\nadminOnly() {\n  return 'Admin only content';\n}\n```\n\n**OAuth2 Strategy:**\n```typescript\n@Injectable()\nexport class GoogleStrategy extends PassportStrategy(Strategy, 'google') {\n  constructor() {\n    super({\n      clientID: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n      callbackURL: '/auth/google/callback',\n      scope: ['email', 'profile'],\n    });\n  }\n  \n  async validate(accessToken: string, refreshToken: string, profile: any) {\n    const { name, emails, photos } = profile;\n    const user = {\n      email: emails[0].value,\n      firstName: name.givenName,\n      lastName: name.familyName,\n      picture: photos[0].value,\n      accessToken,\n    };\n    return user;\n  }\n}\n```\n\n**Common Authentication Strategies:**\n- JWT tokens for stateless authentication\n- Session-based authentication\n- OAuth2 (Google, Facebook, GitHub)\n- API key authentication\n- Basic authentication\n- Custom token validation\n\nGuards execute after middleware but before pipes and provide fine-grained access control.",
      "keywords": ["guards", "authentication", "authorization", "jwt", "passport", "oauth2", "roles", "canactivate"],
      "difficulty": "medium"
    },
    {
      "id": 7007,
      "tag": "nestjs",
      "question": "Explain interceptors and pipes in NestJS. How do they help with data transformation?",
      "answer": "Interceptors and pipes are key components in NestJS that handle cross-cutting concerns and data transformation throughout the request/response lifecycle.\n\n**Pipes - Request Data Transformation:**\nPipes transform and validate incoming data before it reaches route handlers:\n\n```typescript\n// Custom validation pipe\n@Injectable()\nexport class ValidationPipe implements PipeTransform<any> {\n  async transform(value: any, { metatype }: ArgumentMetadata) {\n    if (!metatype || !this.toValidate(metatype)) {\n      return value;\n    }\n    \n    const object = plainToClass(metatype, value);\n    const errors = await validate(object);\n    \n    if (errors.length > 0) {\n      throw new BadRequestException('Validation failed');\n    }\n    return object;\n  }\n  \n  private toValidate(metatype: Function): boolean {\n    const types: Function[] = [String, Boolean, Number, Array, Object];\n    return !types.includes(metatype);\n  }\n}\n\n// Transform pipe example\n@Injectable()\nexport class ParseIntPipe implements PipeTransform<string, number> {\n  transform(value: string, metadata: ArgumentMetadata): number {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      throw new BadRequestException('Validation failed');\n    }\n    return val;\n  }\n}\n\n// Usage in controller\n@Get(':id')\nfindOne(@Param('id', ParseIntPipe) id: number) {\n  return this.usersService.findOne(id);\n}\n```\n\n**Interceptors - Request/Response Transformation:**\nInterceptors can transform requests and responses, add logging, caching, etc.:\n\n```typescript\n// Response transformation interceptor\n@Injectable()\nexport class ResponseInterceptor<T> implements NestInterceptor<T, Response<T>> {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {\n    return next.handle().pipe(\n      map(data => ({\n        success: true,\n        timestamp: new Date().toISOString(),\n        data,\n      }))\n    );\n  }\n}\n\n// Logging interceptor\n@Injectable()\nexport class LoggingInterceptor implements NestInterceptor {\n  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n    const request = context.switchToHttp().getRequest();\n    const { method, url } = request;\n    const now = Date.now();\n    \n    console.log(`${method} ${url} - Start`);\n    \n    return next.handle().pipe(\n      tap(() => {\n        console.log(`${method} ${url} - ${Date.now() - now}ms`);\n      })\n    );\n  }\n}\n\n// Caching interceptor\n@Injectable()\nexport class CacheInterceptor implements NestInterceptor {\n  constructor(private cacheManager: Cache) {}\n  \n  async intercept(context: ExecutionContext, next: CallHandler) {\n    const request = context.switchToHttp().getRequest();\n    const key = `${request.method}:${request.url}`;\n    \n    const cachedResponse = await this.cacheManager.get(key);\n    if (cachedResponse) {\n      return of(cachedResponse);\n    }\n    \n    return next.handle().pipe(\n      tap(response => {\n        this.cacheManager.set(key, response, { ttl: 300 });\n      })\n    );\n  }\n}\n```\n\n**Usage Examples:**\n```typescript\n@Controller('users')\n@UseInterceptors(ResponseInterceptor, LoggingInterceptor)\nexport class UsersController {\n  @Post()\n  @UsePipes(ValidationPipe)\n  create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n}\n```\n\n**Key Differences:**\n- **Pipes**: Transform/validate input data before route handler\n- **Interceptors**: Can modify both request and response, run before and after route handler\n- **Execution Order**: Guards → Pipes → Route Handler → Interceptors\n- **Use Cases**: Pipes for validation, Interceptors for logging, caching, response formatting",
      "keywords": ["interceptors", "pipes", "data transformation", "validation", "logging", "caching", "response formatting"],
      "difficulty": "medium"
    },
    {
      "id": 7008,
      "tag": "nestjs",
      "question": "How do exception filters work in NestJS and how do you implement custom error handling?",
      "answer": "Exception filters in NestJS catch and handle exceptions thrown during request processing. They provide a centralized way to format error responses and handle different types of exceptions consistently.\n\n**Built-in Exception Filters:**\nNestJS comes with built-in HTTP exceptions:\n\n```typescript\n@Controller('users')\nexport class UsersController {\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    const user = this.usersService.findOne(+id);\n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    return user;\n  }\n  \n  @Post()\n  create(@Body() createUserDto: CreateUserDto) {\n    if (!createUserDto.email) {\n      throw new BadRequestException('Email is required');\n    }\n    return this.usersService.create(createUserDto);\n  }\n}\n```\n\n**Custom Exception Filter:**\n```typescript\n@Catch(HttpException)\nexport class HttpExceptionFilter implements ExceptionFilter {\n  catch(exception: HttpException, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    const status = exception.getStatus();\n    const message = exception.getResponse();\n    \n    const errorResponse = {\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      method: request.method,\n      message: typeof message === 'string' ? message : (message as any).message,\n    };\n    \n    Logger.error(\n      `${request.method} ${request.url}`,\n      JSON.stringify(errorResponse),\n      'HttpExceptionFilter',\n    );\n    \n    response.status(status).json(errorResponse);\n  }\n}\n```\n\n**Global Exception Filter:**\n```typescript\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  private readonly logger = new Logger(AllExceptionsFilter.name);\n  \n  catch(exception: unknown, host: ArgumentsHost): void {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    const request = ctx.getRequest<Request>();\n    \n    let status = HttpStatus.INTERNAL_SERVER_ERROR;\n    let message = 'Internal server error';\n    \n    if (exception instanceof HttpException) {\n      status = exception.getStatus();\n      const errorResponse = exception.getResponse();\n      message = typeof errorResponse === 'string' \n        ? errorResponse \n        : (errorResponse as any).message;\n    } else if (exception instanceof Error) {\n      message = exception.message;\n    }\n    \n    const errorResponse = {\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      path: request.url,\n      method: request.method,\n      message,\n    };\n    \n    this.logger.error(\n      `${request.method} ${request.url}`,\n      exception instanceof Error ? exception.stack : exception,\n    );\n    \n    response.status(status).json(errorResponse);\n  }\n}\n```\n\n**Database Exception Filter:**\n```typescript\n@Catch(QueryFailedError)\nexport class DatabaseExceptionFilter implements ExceptionFilter {\n  catch(exception: QueryFailedError, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse<Response>();\n    \n    let status = HttpStatus.INTERNAL_SERVER_ERROR;\n    let message = 'Database error occurred';\n    \n    // Handle specific database errors\n    if (exception.message.includes('duplicate key')) {\n      status = HttpStatus.CONFLICT;\n      message = 'Resource already exists';\n    } else if (exception.message.includes('foreign key')) {\n      status = HttpStatus.BAD_REQUEST;\n      message = 'Invalid reference to related resource';\n    }\n    \n    response.status(status).json({\n      statusCode: status,\n      timestamp: new Date().toISOString(),\n      message,\n    });\n  }\n}\n```\n\n**Applying Exception Filters:**\n```typescript\n// Method level\n@Post()\n@UseFilters(HttpExceptionFilter)\ncreate(@Body() createUserDto: CreateUserDto) {\n  return this.usersService.create(createUserDto);\n}\n\n// Controller level\n@Controller('users')\n@UseFilters(HttpExceptionFilter)\nexport class UsersController {}\n\n// Global level\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalFilters(new AllExceptionsFilter());\n  await app.listen(3000);\n}\n```\n\n**Custom Exception Classes:**\n```typescript\nexport class BusinessLogicException extends HttpException {\n  constructor(message: string) {\n    super({\n      status: HttpStatus.UNPROCESSABLE_ENTITY,\n      error: 'Business Logic Error',\n      message,\n    }, HttpStatus.UNPROCESSABLE_ENTITY);\n  }\n}\n```\n\nException filters provide centralized error handling, consistent error responses, and proper logging for debugging and monitoring.",
      "keywords": ["exception filters", "error handling", "http exceptions", "custom exceptions", "global filters", "database errors"],
      "difficulty": "medium"
    },
    {
      "id": 7009,
      "tag": "nestjs",
      "question": "How do you integrate databases with NestJS using TypeORM? Show entity creation and repository patterns.",
      "answer": "TypeORM integration with NestJS provides a powerful ORM solution for database operations. It supports multiple databases and offers both Active Record and Data Mapper patterns.\n\n**Installation and Setup:**\n```typescript\n// app.module.ts\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: 'postgres',\n      host: 'localhost',\n      port: 5432,\n      username: 'postgres',\n      password: 'password',\n      database: 'nestjs_db',\n      entities: [User, Post, Category],\n      synchronize: true, // Don't use in production\n      logging: true,\n    }),\n    UsersModule,\n  ],\n})\nexport class AppModule {}\n```\n\n**Entity Creation:**\n```typescript\n// user.entity.ts\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn()\n  id: number;\n  \n  @Column({ unique: true })\n  email: string;\n  \n  @Column()\n  firstName: string;\n  \n  @Column()\n  lastName: string;\n  \n  @Column({ default: true })\n  isActive: boolean;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n  \n  @UpdateDateColumn()\n  updatedAt: Date;\n  \n  @OneToMany(() => Post, post => post.author)\n  posts: Post[];\n  \n  @ManyToMany(() => Category, category => category.users)\n  @JoinTable()\n  categories: Category[];\n}\n\n// post.entity.ts\n@Entity('posts')\nexport class Post {\n  @PrimaryGeneratedColumn()\n  id: number;\n  \n  @Column()\n  title: string;\n  \n  @Column('text')\n  content: string;\n  \n  @Column({ default: false })\n  isPublished: boolean;\n  \n  @ManyToOne(() => User, user => user.posts, { onDelete: 'CASCADE' })\n  author: User;\n  \n  @Column()\n  authorId: number;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n}\n```\n\n**Repository Pattern Implementation:**\n```typescript\n// users.module.ts\n@Module({\n  imports: [TypeOrmModule.forFeature([User, Post])],\n  controllers: [UsersController],\n  providers: [UsersService, UsersRepository],\n  exports: [UsersService],\n})\nexport class UsersModule {}\n\n// users.repository.ts\n@Injectable()\nexport class UsersRepository {\n  constructor(\n    @InjectRepository(User)\n    private userRepository: Repository<User>,\n  ) {}\n  \n  async findAll(): Promise<User[]> {\n    return this.userRepository.find({\n      relations: ['posts', 'categories'],\n    });\n  }\n  \n  async findOne(id: number): Promise<User> {\n    const user = await this.userRepository.findOne({\n      where: { id },\n      relations: ['posts'],\n    });\n    \n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    \n    return user;\n  }\n  \n  async create(createUserDto: CreateUserDto): Promise<User> {\n    const user = this.userRepository.create(createUserDto);\n    return this.userRepository.save(user);\n  }\n  \n  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {\n    await this.userRepository.update(id, updateUserDto);\n    return this.findOne(id);\n  }\n  \n  async remove(id: number): Promise<void> {\n    const result = await this.userRepository.delete(id);\n    if (result.affected === 0) {\n      throw new NotFoundException('User not found');\n    }\n  }\n  \n  async findByEmail(email: string): Promise<User | null> {\n    return this.userRepository.findOne({ where: { email } });\n  }\n  \n  async findActiveUsers(): Promise<User[]> {\n    return this.userRepository.find({\n      where: { isActive: true },\n      order: { createdAt: 'DESC' },\n    });\n  }\n}\n```\n\n**Service Layer:**\n```typescript\n// users.service.ts\n@Injectable()\nexport class UsersService {\n  constructor(private usersRepository: UsersRepository) {}\n  \n  async findAll(): Promise<User[]> {\n    return this.usersRepository.findAll();\n  }\n  \n  async findOne(id: number): Promise<User> {\n    return this.usersRepository.findOne(id);\n  }\n  \n  async create(createUserDto: CreateUserDto): Promise<User> {\n    // Check if user already exists\n    const existingUser = await this.usersRepository.findByEmail(createUserDto.email);\n    if (existingUser) {\n      throw new ConflictException('User with this email already exists');\n    }\n    \n    return this.usersRepository.create(createUserDto);\n  }\n  \n  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {\n    return this.usersRepository.update(id, updateUserDto);\n  }\n  \n  async remove(id: number): Promise<void> {\n    await this.usersRepository.remove(id);\n  }\n}\n```\n\n**Advanced Query Examples:**\n```typescript\n// Complex queries with QueryBuilder\nasync findUsersWithPosts(): Promise<User[]> {\n  return this.userRepository\n    .createQueryBuilder('user')\n    .leftJoinAndSelect('user.posts', 'post')\n    .where('post.isPublished = :published', { published: true })\n    .orderBy('user.createdAt', 'DESC')\n    .getMany();\n}\n\n// Transaction example\nasync createUserWithPost(userData: CreateUserDto, postData: CreatePostDto): Promise<User> {\n  return this.userRepository.manager.transaction(async manager => {\n    const user = await manager.save(User, userData);\n    await manager.save(Post, { ...postData, authorId: user.id });\n    return user;\n  });\n}\n```\n\n**Key Benefits:**\n- Type-safe database operations\n- Automatic entity mapping\n- Migration support\n- Query builder for complex queries\n- Connection pooling and caching\n- Multiple database support",
      "keywords": ["typeorm", "database", "entities", "repository", "relations", "queries", "orm", "postgresql"],
      "difficulty": "medium"
    },
    {
      "id": 7010,
      "tag": "nestjs",
      "question": "How do you implement validation with class-validator and DTOs in NestJS?",
      "answer": "DTOs (Data Transfer Objects) with class-validator provide robust request validation in NestJS. They ensure type safety and data integrity before processing requests.\n\n**Installing Dependencies:**\n```bash\nnpm install class-validator class-transformer\n```\n\n**Basic DTO with Validation:**\n```typescript\n// create-user.dto.ts\nimport { IsEmail, IsString, MinLength, MaxLength, IsOptional, IsBoolean } from 'class-validator';\n\nexport class CreateUserDto {\n  @IsEmail({}, { message: 'Please provide valid email' })\n  email: string;\n  \n  @IsString()\n  @MinLength(2, { message: 'First name must be at least 2 characters' })\n  @MaxLength(50, { message: 'First name cannot exceed 50 characters' })\n  firstName: string;\n  \n  @IsString()\n  @MinLength(2)\n  @MaxLength(50)\n  lastName: string;\n  \n  @IsString()\n  @MinLength(8, { message: 'Password must be at least 8 characters' })\n  password: string;\n  \n  @IsOptional()\n  @IsBoolean()\n  isActive?: boolean = true;\n}\n\n// update-user.dto.ts\nimport { PartialType, OmitType } from '@nestjs/mapped-types';\n\nexport class UpdateUserDto extends PartialType(\n  OmitType(CreateUserDto, ['password'] as const)\n) {}\n```\n\n**Global Validation Pipe Setup:**\n```typescript\n// main.ts\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true, // Strip properties not in DTO\n      forbidNonWhitelisted: true, // Throw error for extra properties\n      transform: true, // Transform payload to DTO instance\n      transformOptions: {\n        enableImplicitConversion: true,\n      },\n    })\n  );\n  \n  await app.listen(3000);\n}\n```\n\n**Controller with DTO Validation:**\n```typescript\n@Controller('users')\nexport class UsersController {\n  @Post()\n  async create(@Body() createUserDto: CreateUserDto) {\n    // Data is already validated and transformed\n    return this.usersService.create(createUserDto);\n  }\n  \n  @Put(':id')\n  async update(\n    @Param('id', ParseIntPipe) id: number,\n    @Body() updateUserDto: UpdateUserDto,\n  ) {\n    return this.usersService.update(id, updateUserDto);\n  }\n}\n```\n\n**Advanced Validation Examples:**\n```typescript\n// Complex validation DTO\nexport class CreatePostDto {\n  @IsString()\n  @MinLength(5)\n  @MaxLength(100)\n  title: string;\n  \n  @IsString()\n  @MinLength(20)\n  content: string;\n  \n  @IsArray()\n  @IsString({ each: true })\n  @ArrayMinSize(1)\n  @ArrayMaxSize(5)\n  tags: string[];\n  \n  @IsOptional()\n  @IsDateString()\n  publishedAt?: string;\n  \n  @IsNumber()\n  @IsPositive()\n  authorId: number;\n}\n\n// Custom validation decorator\nimport { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator';\n\nexport function IsStrongPassword(validationOptions?: ValidationOptions) {\n  return function (object: Object, propertyName: string) {\n    registerDecorator({\n      name: 'isStrongPassword',\n      target: object.constructor,\n      propertyName: propertyName,\n      options: validationOptions,\n      validator: {\n        validate(value: any, args: ValidationArguments) {\n          const regex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/;\n          return typeof value === 'string' && regex.test(value);\n        },\n        defaultMessage(args: ValidationArguments) {\n          return 'Password must contain uppercase, lowercase, number and special character';\n        },\n      },\n    });\n  };\n}\n```\n\n**Benefits:**\n- Automatic validation before route handlers\n- Type safety and IntelliSense support\n- Consistent error responses\n- Reusable validation logic\n- Built-in transformations",
      "keywords": ["validation", "dto", "class-validator", "data transfer objects", "decorators", "type safety"],
      "difficulty": "easy"
    },
    {
      "id": 7011,
      "tag": "nestjs",
      "question": "How do you handle configuration management and environment variables in NestJS?",
      "answer": "NestJS provides the `@nestjs/config` package for comprehensive configuration management, supporting environment variables, configuration files, and validation.\n\n**Installation and Basic Setup:**\n```bash\nnpm install @nestjs/config\n```\n\n```typescript\n// app.module.ts\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true, // Makes ConfigService available globally\n      envFilePath: ['.env.local', '.env'], // Multiple env files\n      ignoreEnvFile: process.env.NODE_ENV === 'production',\n      cache: true, // Cache environment variables\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n**Environment Variables (.env file):**\n```bash\n# .env\nDATABASE_HOST=localhost\nDATABASE_PORT=5432\nDATABASE_USERNAME=postgres\nDATABASE_PASSWORD=password\nDATABASE_NAME=nestjs_db\nJWT_SECRET=super-secret-key\nJWT_EXPIRES_IN=7d\nREDIS_URL=redis://localhost:6379\nAWS_REGION=us-east-1\nAWS_ACCESS_KEY_ID=your-access-key\nAWS_SECRET_ACCESS_KEY=your-secret-key\n```\n\n**Configuration Namespaces:**\n```typescript\n// config/database.config.ts\nimport { registerAs } from '@nestjs/config';\n\nexport default registerAs('database', () => ({\n  host: process.env.DATABASE_HOST || 'localhost',\n  port: parseInt(process.env.DATABASE_PORT, 10) || 5432,\n  username: process.env.DATABASE_USERNAME || 'postgres',\n  password: process.env.DATABASE_PASSWORD,\n  name: process.env.DATABASE_NAME || 'nest_db',\n}));\n\n// config/jwt.config.ts\nexport default registerAs('jwt', () => ({\n  secret: process.env.JWT_SECRET,\n  expiresIn: process.env.JWT_EXPIRES_IN || '1h',\n}));\n\n// config/aws.config.ts\nexport default registerAs('aws', () => ({\n  region: process.env.AWS_REGION || 'us-east-1',\n  accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n}));\n```\n\n**Loading Configuration in Module:**\n```typescript\n// app.module.ts\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,\n      load: [databaseConfig, jwtConfig, awsConfig],\n    }),\n    TypeOrmModule.forRootAsync({\n      imports: [ConfigModule],\n      useFactory: (configService: ConfigService) => ({\n        type: 'postgres',\n        host: configService.get('database.host'),\n        port: configService.get('database.port'),\n        username: configService.get('database.username'),\n        password: configService.get('database.password'),\n        database: configService.get('database.name'),\n        autoLoadEntities: true,\n        synchronize: configService.get('NODE_ENV') !== 'production',\n      }),\n      inject: [ConfigService],\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n**Using ConfigService in Services:**\n```typescript\n@Injectable()\nexport class AuthService {\n  constructor(\n    private configService: ConfigService,\n    private jwtService: JwtService,\n  ) {}\n  \n  async signToken(payload: any) {\n    return this.jwtService.sign(payload, {\n      secret: this.configService.get('jwt.secret'),\n      expiresIn: this.configService.get('jwt.expiresIn'),\n    });\n  }\n}\n\n@Injectable()\nexport class AwsService {\n  private s3: AWS.S3;\n  \n  constructor(private configService: ConfigService) {\n    AWS.config.update({\n      region: this.configService.get('aws.region'),\n      accessKeyId: this.configService.get('aws.accessKeyId'),\n      secretAccessKey: this.configService.get('aws.secretAccessKey'),\n    });\n    \n    this.s3 = new AWS.S3();\n  }\n}\n```\n\n**Configuration Validation:**\n```typescript\n// config/validation.schema.ts\nimport * as Joi from 'joi';\n\nexport const validationSchema = Joi.object({\n  NODE_ENV: Joi.string().valid('development', 'production', 'test').default('development'),\n  PORT: Joi.number().default(3000),\n  DATABASE_HOST: Joi.string().required(),\n  DATABASE_PORT: Joi.number().default(5432),\n  DATABASE_USERNAME: Joi.string().required(),\n  DATABASE_PASSWORD: Joi.string().required(),\n  JWT_SECRET: Joi.string().required(),\n  JWT_EXPIRES_IN: Joi.string().default('7d'),\n});\n\n// app.module.ts with validation\n@Module({\n  imports: [\n    ConfigModule.forRoot({\n      isGlobal: true,\n      validationSchema,\n      validationOptions: {\n        allowUnknown: true,\n        abortEarly: true,\n      },\n    }),\n  ],\n})\nexport class AppModule {}\n```\n\n**Benefits:**\n- Environment-specific configurations\n- Type-safe configuration access\n- Validation of required variables\n- Support for multiple configuration formats\n- Easy testing with different configurations",
      "keywords": ["configuration", "environment variables", "config service", "validation", "namespaces", "env files"],
      "difficulty": "easy"
    },
    {
      "id": 7012,
      "tag": "nestjs",
      "question": "How do you integrate Swagger documentation in NestJS applications?",
      "answer": "Swagger integration in NestJS provides automatic API documentation generation using the `@nestjs/swagger` package with decorators to describe endpoints, models, and responses.\n\n**Installation and Setup:**\n```bash\nnpm install @nestjs/swagger swagger-ui-express\n```\n\n**Basic Swagger Configuration:**\n```typescript\n// main.ts\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  \n  const config = new DocumentBuilder()\n    .setTitle('NestJS API')\n    .setDescription('The NestJS API documentation')\n    .setVersion('1.0')\n    .addTag('users', 'User management endpoints')\n    .addTag('posts', 'Post management endpoints')\n    .addBearerAuth(\n      {\n        type: 'http',\n        scheme: 'bearer',\n        bearerFormat: 'JWT',\n        name: 'JWT',\n        description: 'Enter JWT token',\n        in: 'header',\n      },\n      'JWT-auth'\n    )\n    .addServer('http://localhost:3000', 'Development server')\n    .addServer('https://api.example.com', 'Production server')\n    .build();\n    \n  const document = SwaggerModule.createDocument(app, config);\n  SwaggerModule.setup('api', app, document, {\n    swaggerOptions: {\n      persistAuthorization: true,\n    },\n  });\n  \n  await app.listen(3000);\n}\n```\n\n**DTO Documentation:**\n```typescript\n// create-user.dto.ts\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsEmail, IsString, MinLength, IsOptional, IsBoolean } from 'class-validator';\n\nexport class CreateUserDto {\n  @ApiProperty({\n    description: 'User email address',\n    example: 'john.doe@example.com',\n    format: 'email',\n  })\n  @IsEmail()\n  email: string;\n  \n  @ApiProperty({\n    description: 'User first name',\n    example: 'John',\n    minLength: 2,\n    maxLength: 50,\n  })\n  @IsString()\n  @MinLength(2)\n  firstName: string;\n  \n  @ApiProperty({\n    description: 'User last name',\n    example: 'Doe',\n    minLength: 2,\n    maxLength: 50,\n  })\n  @IsString()\n  @MinLength(2)\n  lastName: string;\n  \n  @ApiProperty({\n    description: 'User password',\n    example: 'StrongPassword123!',\n    minLength: 8,\n    format: 'password',\n  })\n  @IsString()\n  @MinLength(8)\n  password: string;\n  \n  @ApiPropertyOptional({\n    description: 'User active status',\n    example: true,\n    default: true,\n  })\n  @IsOptional()\n  @IsBoolean()\n  isActive?: boolean;\n}\n\n// user-response.dto.ts\nexport class UserResponseDto {\n  @ApiProperty({ example: 1 })\n  id: number;\n  \n  @ApiProperty({ example: 'john.doe@example.com' })\n  email: string;\n  \n  @ApiProperty({ example: 'John' })\n  firstName: string;\n  \n  @ApiProperty({ example: 'Doe' })\n  lastName: string;\n  \n  @ApiProperty({ example: true })\n  isActive: boolean;\n  \n  @ApiProperty({ example: '2023-12-01T10:00:00Z' })\n  createdAt: Date;\n}\n```\n\n**Controller Documentation:**\n```typescript\n// users.controller.ts\nimport {\n  ApiTags,\n  ApiOperation,\n  ApiResponse,\n  ApiParam,\n  ApiBearerAuth,\n  ApiQuery,\n} from '@nestjs/swagger';\n\n@ApiTags('users')\n@Controller('users')\nexport class UsersController {\n  @ApiOperation({ summary: 'Get all users' })\n  @ApiResponse({\n    status: 200,\n    description: 'List of users retrieved successfully',\n    type: [UserResponseDto],\n  })\n  @ApiQuery({\n    name: 'page',\n    required: false,\n    description: 'Page number',\n    example: 1,\n  })\n  @ApiQuery({\n    name: 'limit',\n    required: false,\n    description: 'Number of items per page',\n    example: 10,\n  })\n  @Get()\n  async findAll(\n    @Query('page', new DefaultValuePipe(1), ParseIntPipe) page: number,\n    @Query('limit', new DefaultValuePipe(10), ParseIntPipe) limit: number,\n  ) {\n    return this.usersService.findAll({ page, limit });\n  }\n  \n  @ApiOperation({ summary: 'Get user by ID' })\n  @ApiParam({\n    name: 'id',\n    description: 'User ID',\n    example: 1,\n  })\n  @ApiResponse({\n    status: 200,\n    description: 'User found',\n    type: UserResponseDto,\n  })\n  @ApiResponse({\n    status: 404,\n    description: 'User not found',\n  })\n  @Get(':id')\n  async findOne(@Param('id', ParseIntPipe) id: number) {\n    return this.usersService.findOne(id);\n  }\n  \n  @ApiOperation({ summary: 'Create new user' })\n  @ApiResponse({\n    status: 201,\n    description: 'User created successfully',\n    type: UserResponseDto,\n  })\n  @ApiResponse({\n    status: 400,\n    description: 'Validation error',\n  })\n  @ApiResponse({\n    status: 409,\n    description: 'User already exists',\n  })\n  @Post()\n  async create(@Body() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n  \n  @ApiOperation({ summary: 'Update user' })\n  @ApiBearerAuth('JWT-auth')\n  @ApiParam({ name: 'id', description: 'User ID' })\n  @ApiResponse({\n    status: 200,\n    description: 'User updated successfully',\n    type: UserResponseDto,\n  })\n  @Put(':id')\n  @UseGuards(JwtAuthGuard)\n  async update(\n    @Param('id', ParseIntPipe) id: number,\n    @Body() updateUserDto: UpdateUserDto,\n  ) {\n    return this.usersService.update(id, updateUserDto);\n  }\n}\n```\n\n**Advanced Swagger Features:**\n```typescript\n// Custom response schemas\n@ApiResponse({\n  status: 200,\n  description: 'Paginated user list',\n  schema: {\n    type: 'object',\n    properties: {\n      data: {\n        type: 'array',\n        items: { $ref: '#/components/schemas/UserResponseDto' },\n      },\n      meta: {\n        type: 'object',\n        properties: {\n          page: { type: 'number', example: 1 },\n          limit: { type: 'number', example: 10 },\n          total: { type: 'number', example: 100 },\n        },\n      },\n    },\n  },\n})\n\n// File upload documentation\n@ApiConsumes('multipart/form-data')\n@ApiBody({\n  schema: {\n    type: 'object',\n    properties: {\n      file: {\n        type: 'string',\n        format: 'binary',\n      },\n    },\n  },\n})\n@Post('upload')\n@UseInterceptors(FileInterceptor('file'))\nuploadFile(@UploadedFile() file: Express.Multer.File) {\n  return { filename: file.filename };\n}\n```\n\n**Benefits:**\n- Automatic API documentation generation\n- Interactive testing interface\n- Type-safe API contracts\n- Client SDK generation support\n- Easy API exploration for developers",
      "keywords": ["swagger", "documentation", "api", "openapi", "decorators", "schemas", "endpoints"],
      "difficulty": "easy"
    },
    {
      "id": 7013,
      "tag": "nestjs",
      "question": "How do you implement testing in NestJS? Explain unit testing and integration testing strategies.",
      "answer": "NestJS provides comprehensive testing capabilities with Jest integration, supporting both unit tests for individual components and integration tests for complete application flows.\n\n**Testing Setup (comes pre-configured):**\n```json\n// package.json\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:cov\": \"jest --coverage\",\n    \"test:e2e\": \"jest --config ./test/jest-e2e.json\"\n  }\n}\n```\n\n**Unit Testing - Service:**\n```typescript\n// users.service.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { UsersService } from './users.service';\nimport { User } from './user.entity';\nimport { NotFoundException, ConflictException } from '@nestjs/common';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n  let repository: Repository<User>;\n  \n  const mockUser = {\n    id: 1,\n    email: 'test@example.com',\n    firstName: 'John',\n    lastName: 'Doe',\n    isActive: true,\n  };\n  \n  const mockRepository = {\n    find: jest.fn(),\n    findOne: jest.fn(),\n    create: jest.fn(),\n    save: jest.fn(),\n    update: jest.fn(),\n    delete: jest.fn(),\n  };\n  \n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        UsersService,\n        {\n          provide: getRepositoryToken(User),\n          useValue: mockRepository,\n        },\n      ],\n    }).compile();\n    \n    service = module.get<UsersService>(UsersService);\n    repository = module.get<Repository<User>>(getRepositoryToken(User));\n  });\n  \n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  describe('findAll', () => {\n    it('should return an array of users', async () => {\n      mockRepository.find.mockResolvedValue([mockUser]);\n      \n      const result = await service.findAll();\n      \n      expect(result).toEqual([mockUser]);\n      expect(repository.find).toHaveBeenCalledWith({\n        relations: ['posts'],\n      });\n    });\n  });\n  \n  describe('findOne', () => {\n    it('should return a user when found', async () => {\n      mockRepository.findOne.mockResolvedValue(mockUser);\n      \n      const result = await service.findOne(1);\n      \n      expect(result).toEqual(mockUser);\n      expect(repository.findOne).toHaveBeenCalledWith({\n        where: { id: 1 },\n        relations: ['posts'],\n      });\n    });\n    \n    it('should throw NotFoundException when user not found', async () => {\n      mockRepository.findOne.mockResolvedValue(null);\n      \n      await expect(service.findOne(999)).rejects.toThrow(NotFoundException);\n    });\n  });\n  \n  describe('create', () => {\n    const createUserDto = {\n      email: 'new@example.com',\n      firstName: 'Jane',\n      lastName: 'Smith',\n      password: 'password123',\n    };\n    \n    it('should create and return a user', async () => {\n      mockRepository.findOne.mockResolvedValue(null); // Email not exists\n      mockRepository.create.mockReturnValue(mockUser);\n      mockRepository.save.mockResolvedValue(mockUser);\n      \n      const result = await service.create(createUserDto);\n      \n      expect(result).toEqual(mockUser);\n      expect(repository.create).toHaveBeenCalledWith(createUserDto);\n      expect(repository.save).toHaveBeenCalledWith(mockUser);\n    });\n    \n    it('should throw ConflictException if email already exists', async () => {\n      mockRepository.findOne.mockResolvedValue(mockUser);\n      \n      await expect(service.create(createUserDto)).rejects.toThrow(ConflictException);\n    });\n  });\n});\n```\n\n**Unit Testing - Controller:**\n```typescript\n// users.controller.spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { UsersController } from './users.controller';\nimport { UsersService } from './users.service';\n\ndescribe('UsersController', () => {\n  let controller: UsersController;\n  let service: UsersService;\n  \n  const mockUser = {\n    id: 1,\n    email: 'test@example.com',\n    firstName: 'John',\n    lastName: 'Doe',\n    isActive: true,\n  };\n  \n  const mockUsersService = {\n    findAll: jest.fn().mockResolvedValue([mockUser]),\n    findOne: jest.fn().mockResolvedValue(mockUser),\n    create: jest.fn().mockResolvedValue(mockUser),\n    update: jest.fn().mockResolvedValue(mockUser),\n    remove: jest.fn().mockResolvedValue(undefined),\n  };\n  \n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [UsersController],\n      providers: [\n        {\n          provide: UsersService,\n          useValue: mockUsersService,\n        },\n      ],\n    }).compile();\n    \n    controller = module.get<UsersController>(UsersController);\n    service = module.get<UsersService>(UsersService);\n  });\n  \n  describe('findAll', () => {\n    it('should return an array of users', async () => {\n      const result = await controller.findAll();\n      \n      expect(result).toEqual([mockUser]);\n      expect(service.findAll).toHaveBeenCalled();\n    });\n  });\n  \n  describe('create', () => {\n    it('should create a user', async () => {\n      const createUserDto = {\n        email: 'new@example.com',\n        firstName: 'Jane',\n        lastName: 'Smith',\n        password: 'password123',\n      };\n      \n      const result = await controller.create(createUserDto);\n      \n      expect(result).toEqual(mockUser);\n      expect(service.create).toHaveBeenCalledWith(createUserDto);\n    });\n  });\n});\n```\n\n**Integration Testing (E2E):**\n```typescript\n// test/users.e2e-spec.ts\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { INestApplication } from '@nestjs/common';\nimport * as request from 'supertest';\nimport { AppModule } from '../src/app.module';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { User } from '../src/users/user.entity';\n\ndescribe('UsersController (e2e)', () => {\n  let app: INestApplication;\n  let userRepository;\n  \n  beforeEach(async () => {\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [AppModule],\n    })\n      .overrideProvider(getRepositoryToken(User))\n      .useValue({\n        find: jest.fn().mockResolvedValue([]),\n        findOne: jest.fn(),\n        create: jest.fn(),\n        save: jest.fn(),\n        update: jest.fn(),\n        delete: jest.fn(),\n      })\n      .compile();\n      \n    app = moduleFixture.createNestApplication();\n    userRepository = moduleFixture.get(getRepositoryToken(User));\n    \n    await app.init();\n  });\n  \n  afterAll(async () => {\n    await app.close();\n  });\n  \n  describe('/users (GET)', () => {\n    it('should return empty array', () => {\n      return request(app.getHttpServer())\n        .get('/users')\n        .expect(200)\n        .expect([]);\n    });\n  });\n  \n  describe('/users (POST)', () => {\n    it('should create a user', () => {\n      const createUserDto = {\n        email: 'test@example.com',\n        firstName: 'John',\n        lastName: 'Doe',\n        password: 'password123',\n      };\n      \n      const savedUser = { id: 1, ...createUserDto };\n      userRepository.create.mockReturnValue(savedUser);\n      userRepository.save.mockResolvedValue(savedUser);\n      \n      return request(app.getHttpServer())\n        .post('/users')\n        .send(createUserDto)\n        .expect(201)\n        .expect(savedUser);\n    });\n    \n    it('should return validation error for invalid data', () => {\n      return request(app.getHttpServer())\n        .post('/users')\n        .send({ email: 'invalid-email' })\n        .expect(400);\n    });\n  });\n});\n```\n\n**Testing with Database (TestContainers):**\n```typescript\n// test/database-integration.spec.ts\nimport { Test } from '@nestjs/testing';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { PostgreSqlContainer } from 'testcontainers';\n\ndescribe('Database Integration', () => {\n  let container: PostgreSqlContainer;\n  \n  beforeAll(async () => {\n    container = await new PostgreSqlContainer().start();\n  });\n  \n  afterAll(async () => {\n    await container.stop();\n  });\n  \n  it('should perform database operations', async () => {\n    const module = await Test.createTestingModule({\n      imports: [\n        TypeOrmModule.forRoot({\n          type: 'postgres',\n          host: container.getHost(),\n          port: container.getPort(),\n          username: container.getUsername(),\n          password: container.getPassword(),\n          database: container.getDatabase(),\n          entities: [User],\n          synchronize: true,\n        }),\n        UsersModule,\n      ],\n    }).compile();\n    \n    // Test actual database operations\n  });\n});\n```\n\n**Key Testing Principles:**\n- Mock external dependencies in unit tests\n- Test business logic thoroughly\n- Use integration tests for complete flows\n- Test error scenarios and edge cases\n- Maintain high test coverage",
      "keywords": ["testing", "jest", "unit tests", "integration tests", "mocking", "e2e", "test coverage"],
      "difficulty": "easy"
    },
    {
      "id": 7014,
      "tag": "nestjs",
      "question": "How do you integrate GraphQL with NestJS? Show schema-first and code-first approaches.",
      "answer": "NestJS provides excellent GraphQL integration supporting both schema-first and code-first approaches using the `@nestjs/graphql` package with Apollo Server integration.\n\n**Installation and Setup:**\n```bash\nnpm install @nestjs/graphql @nestjs/apollo apollo-server-express graphql\n```\n\n**Basic GraphQL Module Setup:**\n```typescript\n// app.module.ts\nimport { GraphQLModule } from '@nestjs/graphql';\nimport { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';\n\n@Module({\n  imports: [\n    GraphQLModule.forRoot<ApolloDriverConfig>({\n      driver: ApolloDriver,\n      autoSchemaFile: join(process.cwd(), 'src/schema.gql'),\n      sortSchema: true,\n      playground: true,\n      introspection: true,\n    }),\n    UsersModule,\n  ],\n})\nexport class AppModule {}\n```\n\n**Code-First Approach:**\n\n**1. Entity/Object Types:**\n```typescript\n// user.model.ts\nimport { ObjectType, Field, ID, Int } from '@nestjs/graphql';\n\n@ObjectType()\nexport class User {\n  @Field(() => ID)\n  id: string;\n  \n  @Field()\n  email: string;\n  \n  @Field()\n  firstName: string;\n  \n  @Field()\n  lastName: string;\n  \n  @Field(() => Boolean, { defaultValue: true })\n  isActive: boolean;\n  \n  @Field(() => Date)\n  createdAt: Date;\n  \n  @Field(() => [Post], { nullable: 'items' })\n  posts: Post[];\n}\n\n@ObjectType()\nexport class Post {\n  @Field(() => ID)\n  id: string;\n  \n  @Field()\n  title: string;\n  \n  @Field()\n  content: string;\n  \n  @Field(() => Boolean)\n  isPublished: boolean;\n  \n  @Field(() => User)\n  author: User;\n  \n  @Field(() => ID)\n  authorId: string;\n}\n```\n\n**2. Input Types:**\n```typescript\n// user.inputs.ts\nimport { InputType, Field } from '@nestjs/graphql';\nimport { IsEmail, IsString, MinLength } from 'class-validator';\n\n@InputType()\nexport class CreateUserInput {\n  @Field()\n  @IsEmail()\n  email: string;\n  \n  @Field()\n  @IsString()\n  @MinLength(2)\n  firstName: string;\n  \n  @Field()\n  @IsString()\n  @MinLength(2)\n  lastName: string;\n  \n  @Field()\n  @IsString()\n  @MinLength(8)\n  password: string;\n}\n\n@InputType()\nexport class UpdateUserInput {\n  @Field({ nullable: true })\n  firstName?: string;\n  \n  @Field({ nullable: true })\n  lastName?: string;\n  \n  @Field({ nullable: true })\n  isActive?: boolean;\n}\n\n@InputType()\nexport class UsersFilter {\n  @Field({ nullable: true })\n  isActive?: boolean;\n  \n  @Field({ nullable: true })\n  search?: string;\n}\n```\n\n**3. Resolver:**\n```typescript\n// users.resolver.ts\nimport {\n  Resolver,\n  Query,\n  Mutation,\n  Args,\n  ResolveField,\n  Parent,\n  ID,\n  Int,\n} from '@nestjs/graphql';\nimport { UseGuards, UseFilters } from '@nestjs/common';\n\n@Resolver(() => User)\nexport class UsersResolver {\n  constructor(\n    private usersService: UsersService,\n    private postsService: PostsService,\n  ) {}\n  \n  @Query(() => [User], { name: 'users' })\n  async getUsers(\n    @Args('filter', { nullable: true }) filter?: UsersFilter,\n    @Args('limit', { type: () => Int, nullable: true }) limit?: number,\n    @Args('offset', { type: () => Int, nullable: true }) offset?: number,\n  ): Promise<User[]> {\n    return this.usersService.findAll({ filter, limit, offset });\n  }\n  \n  @Query(() => User, { name: 'user' })\n  async getUser(\n    @Args('id', { type: () => ID }) id: string,\n  ): Promise<User> {\n    return this.usersService.findOne(id);\n  }\n  \n  @Mutation(() => User)\n  async createUser(\n    @Args('input') input: CreateUserInput,\n  ): Promise<User> {\n    return this.usersService.create(input);\n  }\n  \n  @Mutation(() => User)\n  @UseGuards(JwtAuthGuard)\n  async updateUser(\n    @Args('id', { type: () => ID }) id: string,\n    @Args('input') input: UpdateUserInput,\n  ): Promise<User> {\n    return this.usersService.update(id, input);\n  }\n  \n  @Mutation(() => Boolean)\n  @UseGuards(JwtAuthGuard, AdminGuard)\n  async deleteUser(\n    @Args('id', { type: () => ID }) id: string,\n  ): Promise<boolean> {\n    await this.usersService.remove(id);\n    return true;\n  }\n  \n  // Field resolver for lazy loading\n  @ResolveField(() => [Post])\n  async posts(@Parent() user: User): Promise<Post[]> {\n    return this.postsService.findByAuthorId(user.id);\n  }\n}\n```\n\n**4. Advanced Features:**\n```typescript\n// Custom scalar\nimport { Scalar, CustomScalar } from '@nestjs/graphql';\nimport { GraphQLScalarType, Kind, ValueNode } from 'graphql';\n\n@Scalar('Date')\nexport class DateScalar implements CustomScalar<number, Date> {\n  description = 'Date custom scalar type';\n  \n  parseValue(value: number): Date {\n    return new Date(value);\n  }\n  \n  serialize(value: Date): number {\n    return value.getTime();\n  }\n  \n  parseLiteral(ast: ValueNode): Date {\n    if (ast.kind === Kind.INT) {\n      return new Date(ast.value);\n    }\n    return null;\n  }\n}\n\n// Subscription example\n@Resolver()\nexport class NotificationsResolver {\n  constructor(private pubSub: PubSub) {}\n  \n  @Subscription(() => String)\n  userCreated() {\n    return this.pubSub.asyncIterator('userCreated');\n  }\n  \n  @Mutation(() => User)\n  async createUser(@Args('input') input: CreateUserInput) {\n    const user = await this.usersService.create(input);\n    this.pubSub.publish('userCreated', { userCreated: user });\n    return user;\n  }\n}\n```\n\n**Schema-First Approach:**\n\n**1. Schema Definition:**\n```graphql\n# schema.graphql\ntype User {\n  id: ID!\n  email: String!\n  firstName: String!\n  lastName: String!\n  isActive: Boolean!\n  createdAt: Date!\n  posts: [Post!]!\n}\n\ntype Post {\n  id: ID!\n  title: String!\n  content: String!\n  isPublished: Boolean!\n  author: User!\n  authorId: ID!\n}\n\ninput CreateUserInput {\n  email: String!\n  firstName: String!\n  lastName: String!\n  password: String!\n}\n\ntype Query {\n  users(filter: UsersFilter, limit: Int, offset: Int): [User!]!\n  user(id: ID!): User!\n}\n\ntype Mutation {\n  createUser(input: CreateUserInput!): User!\n  updateUser(id: ID!, input: UpdateUserInput!): User!\n  deleteUser(id: ID!): Boolean!\n}\n\nscalar Date\n```\n\n**2. Resolver Implementation:**\n```typescript\n// users.resolver.ts (schema-first)\nimport { Resolver, Query, Args } from '@nestjs/graphql';\n\n@Resolver('User')\nexport class UsersResolver {\n  constructor(private usersService: UsersService) {}\n  \n  @Query()\n  async users(@Args() args: any) {\n    return this.usersService.findAll(args);\n  }\n  \n  @Query()\n  async user(@Args('id') id: string) {\n    return this.usersService.findOne(id);\n  }\n}\n```\n\n**Module Configuration:**\n```typescript\n// users.module.ts\n@Module({\n  imports: [TypeOrmModule.forFeature([User])],\n  providers: [UsersService, UsersResolver],\n})\nexport class UsersModule {}\n```\n\n**Benefits:**\n- Type-safe GraphQL operations\n- Automatic schema generation (code-first)\n- Built-in validation and transformation\n- Real-time subscriptions support\n- Excellent developer experience with IDE support",
      "keywords": ["graphql", "apollo", "resolvers", "schema", "mutations", "queries", "subscriptions", "code-first"],
      "difficulty": "easy"
    },
    {
      "id": 7015,
      "tag": "nestjs",
      "question": "What are microservices in NestJS and how do you implement basic inter-service communication?",
      "answer": "NestJS provides comprehensive microservices support with various transport layers (TCP, Redis, RabbitMQ, NATS, etc.) enabling distributed architecture with type-safe communication between services.\n\n**Basic Microservice Setup:**\n\n**1. TCP-based Microservice:**\n```typescript\n// main.ts (microservice)\nimport { NestFactory } from '@nestjs/core';\nimport { MicroserviceOptions, Transport } from '@nestjs/microservices';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.createMicroservice<MicroserviceOptions>(\n    AppModule,\n    {\n      transport: Transport.TCP,\n      options: {\n        host: 'localhost',\n        port: 3001,\n      },\n    },\n  );\n  \n  await app.listen();\n  console.log('Users microservice is listening on port 3001');\n}\nbootstrap();\n```\n\n**2. Microservice Controller:**\n```typescript\n// users.controller.ts (microservice)\nimport { Controller } from '@nestjs/common';\nimport { MessagePattern, Payload } from '@nestjs/microservices';\n\n@Controller()\nexport class UsersController {\n  constructor(private usersService: UsersService) {}\n  \n  @MessagePattern({ cmd: 'get_users' })\n  async getUsers(@Payload() data: { page: number; limit: number }) {\n    return this.usersService.findAll(data);\n  }\n  \n  @MessagePattern({ cmd: 'get_user' })\n  async getUser(@Payload() data: { id: number }) {\n    return this.usersService.findOne(data.id);\n  }\n  \n  @MessagePattern({ cmd: 'create_user' })\n  async createUser(@Payload() createUserDto: CreateUserDto) {\n    return this.usersService.create(createUserDto);\n  }\n  \n  @MessagePattern({ cmd: 'update_user' })\n  async updateUser(\n    @Payload() data: { id: number; updateUserDto: UpdateUserDto },\n  ) {\n    return this.usersService.update(data.id, data.updateUserDto);\n  }\n  \n  @MessagePattern({ cmd: 'delete_user' })\n  async deleteUser(@Payload() data: { id: number }) {\n    await this.usersService.remove(data.id);\n    return { success: true };\n  }\n}\n```\n\n**3. API Gateway (Client Service):**\n```typescript\n// main.ts (API Gateway)\nimport { NestFactory } from '@nestjs/core';\nimport { AppModule } from './app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  await app.listen(3000);\n  console.log('API Gateway is running on port 3000');\n}\nbootstrap();\n\n// app.module.ts (API Gateway)\n@Module({\n  imports: [\n    ClientsModule.register([\n      {\n        name: 'USERS_SERVICE',\n        transport: Transport.TCP,\n        options: {\n          host: 'localhost',\n          port: 3001,\n        },\n      },\n      {\n        name: 'POSTS_SERVICE',\n        transport: Transport.TCP,\n        options: {\n          host: 'localhost',\n          port: 3002,\n        },\n      },\n    ]),\n    UsersModule,\n  ],\n})\nexport class AppModule {}\n```\n\n**4. Client Controller (API Gateway):**\n```typescript\n// users.controller.ts (API Gateway)\nimport { Controller, Get, Post, Put, Delete, Body, Param, Inject } from '@nestjs/common';\nimport { ClientProxy } from '@nestjs/microservices';\nimport { Observable, firstValueFrom } from 'rxjs';\n\n@Controller('users')\nexport class UsersController {\n  constructor(\n    @Inject('USERS_SERVICE') private usersClient: ClientProxy,\n  ) {}\n  \n  @Get()\n  async getUsers(\n    @Query('page') page: number = 1,\n    @Query('limit') limit: number = 10,\n  ) {\n    return firstValueFrom(\n      this.usersClient.send({ cmd: 'get_users' }, { page, limit })\n    );\n  }\n  \n  @Get(':id')\n  async getUser(@Param('id') id: number) {\n    return firstValueFrom(\n      this.usersClient.send({ cmd: 'get_user' }, { id })\n    );\n  }\n  \n  @Post()\n  async createUser(@Body() createUserDto: CreateUserDto) {\n    return firstValueFrom(\n      this.usersClient.send({ cmd: 'create_user' }, createUserDto)\n    );\n  }\n  \n  @Put(':id')\n  async updateUser(\n    @Param('id') id: number,\n    @Body() updateUserDto: UpdateUserDto,\n  ) {\n    return firstValueFrom(\n      this.usersClient.send({ cmd: 'update_user' }, { id, updateUserDto })\n    );\n  }\n  \n  @Delete(':id')\n  async deleteUser(@Param('id') id: number) {\n    return firstValueFrom(\n      this.usersClient.send({ cmd: 'delete_user' }, { id })\n    );\n  }\n}\n```\n\n**Advanced Microservice Features:**\n\n**1. Redis Transport:**\n```typescript\n// Microservice with Redis\nconst app = await NestFactory.createMicroservice<MicroserviceOptions>(\n  AppModule,\n  {\n    transport: Transport.REDIS,\n    options: {\n      host: 'localhost',\n      port: 6379,\n      retryAttempts: 5,\n      retryDelay: 3000,\n    },\n  },\n);\n\n// Client registration\nClientsModule.register([\n  {\n    name: 'USERS_SERVICE',\n    transport: Transport.REDIS,\n    options: {\n      host: 'localhost',\n      port: 6379,\n    },\n  },\n])\n```\n\n**2. RabbitMQ with Event Patterns:**\n```typescript\n// Event-based communication\n@Controller()\nexport class UsersController {\n  @EventPattern('user_created')\n  async handleUserCreated(@Payload() data: User) {\n    console.log('User created event received:', data);\n    // Handle the event (send email, update cache, etc.)\n  }\n  \n  @MessagePattern({ cmd: 'create_user' })\n  async createUser(@Payload() createUserDto: CreateUserDto) {\n    const user = await this.usersService.create(createUserDto);\n    \n    // Emit event to other services\n    this.client.emit('user_created', user);\n    \n    return user;\n  }\n}\n\n// Client emitting events\n@Injectable()\nexport class UsersService {\n  constructor(\n    @Inject('NOTIFICATION_SERVICE') private notificationClient: ClientProxy,\n  ) {}\n  \n  async createUser(createUserDto: CreateUserDto) {\n    const user = await this.create(createUserDto);\n    \n    // Send welcome email notification\n    this.notificationClient.emit('send_welcome_email', {\n      userId: user.id,\n      email: user.email,\n      name: `${user.firstName} ${user.lastName}`,\n    });\n    \n    return user;\n  }\n}\n```\n\n**3. Error Handling:**\n```typescript\n// Custom exception filters for microservices\n@Catch(RpcException)\nexport class RpcExceptionFilter implements ExceptionFilter {\n  catch(exception: RpcException, host: ArgumentsHost) {\n    const error = exception.getError();\n    return throwError(() => error);\n  }\n}\n\n// Service with error handling\n@MessagePattern({ cmd: 'get_user' })\nasync getUser(@Payload() data: { id: number }) {\n  try {\n    const user = await this.usersService.findOne(data.id);\n    if (!user) {\n      throw new RpcException({\n        status: 'error',\n        message: 'User not found',\n        code: 404,\n      });\n    }\n    return user;\n  } catch (error) {\n    throw new RpcException({\n      status: 'error',\n      message: error.message,\n      code: 500,\n    });\n  }\n}\n```\n\n**Benefits:**\n- Service isolation and independent deployment\n- Scalability and fault tolerance\n- Technology diversity across services\n- Type-safe inter-service communication\n- Multiple transport layer options\n- Built-in load balancing and retry mechanisms",
      "keywords": ["microservices", "inter-service communication", "message patterns", "transport layers", "tcp", "redis", "events"],
      "difficulty": "easy"
    },
    {
      "id": 7016,
      "tag": "nestjs",
      "question": "How do you implement WebSocket functionality with gateways in NestJS?",
      "answer": "NestJS provides WebSocket support through gateways using Socket.IO by default, enabling real-time bidirectional communication between clients and servers with comprehensive event handling.\n\n**Installation and Basic Setup:**\n```bash\nnpm install @nestjs/websockets @nestjs/platform-socket.io socket.io\n```\n\n**Basic WebSocket Gateway:**\n```typescript\n// chat.gateway.ts\nimport {\n  WebSocketGateway,\n  WebSocketServer,\n  SubscribeMessage,\n  MessageBody,\n  ConnectedSocket,\n  OnGatewayInit,\n  OnGatewayConnection,\n  OnGatewayDisconnect,\n} from '@nestjs/websockets';\nimport { Server, Socket } from 'socket.io';\nimport { Logger } from '@nestjs/common';\n\n@WebSocketGateway({\n  cors: {\n    origin: '*',\n  },\n  namespace: '/chat',\n})\nexport class ChatGateway\n  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect\n{\n  @WebSocketServer()\n  server: Server;\n  \n  private logger: Logger = new Logger('ChatGateway');\n  private connectedUsers = new Map<string, string>(); // socketId -> userId\n  \n  afterInit(server: Server) {\n    this.logger.log('WebSocket Gateway initialized');\n  }\n  \n  handleConnection(client: Socket, ...args: any[]) {\n    this.logger.log(`Client connected: ${client.id}`);\n  }\n  \n  handleDisconnect(client: Socket) {\n    const userId = this.connectedUsers.get(client.id);\n    if (userId) {\n      this.connectedUsers.delete(client.id);\n      // Notify other users that this user went offline\n      client.broadcast.emit('userOffline', { userId });\n    }\n    this.logger.log(`Client disconnected: ${client.id}`);\n  }\n  \n  @SubscribeMessage('joinRoom')\n  handleJoinRoom(\n    @MessageBody() data: { room: string; userId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { room, userId } = data;\n    \n    client.join(room);\n    this.connectedUsers.set(client.id, userId);\n    \n    // Notify others in the room\n    client.to(room).emit('userJoined', {\n      userId,\n      message: `${userId} joined the room`,\n    });\n    \n    this.logger.log(`User ${userId} joined room: ${room}`);\n    \n    return {\n      event: 'joinedRoom',\n      data: { room, userId, message: 'Successfully joined room' },\n    };\n  }\n  \n  @SubscribeMessage('leaveRoom')\n  handleLeaveRoom(\n    @MessageBody() data: { room: string; userId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { room, userId } = data;\n    \n    client.leave(room);\n    \n    // Notify others in the room\n    client.to(room).emit('userLeft', {\n      userId,\n      message: `${userId} left the room`,\n    });\n    \n    return { event: 'leftRoom', data: { room, userId } };\n  }\n  \n  @SubscribeMessage('sendMessage')\n  async handleMessage(\n    @MessageBody() data: { room: string; message: string; userId: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { room, message, userId } = data;\n    \n    // Save message to database\n    const savedMessage = await this.chatService.saveMessage({\n      room,\n      message,\n      userId,\n      timestamp: new Date(),\n    });\n    \n    // Broadcast to all clients in the room\n    this.server.to(room).emit('newMessage', {\n      id: savedMessage.id,\n      message,\n      userId,\n      timestamp: savedMessage.timestamp,\n    });\n    \n    return {\n      event: 'messageSent',\n      data: { messageId: savedMessage.id },\n    };\n  }\n  \n  @SubscribeMessage('typing')\n  handleTyping(\n    @MessageBody() data: { room: string; userId: string; isTyping: boolean },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const { room, userId, isTyping } = data;\n    \n    // Broadcast typing status to others in the room (excluding sender)\n    client.to(room).emit('userTyping', { userId, isTyping });\n  }\n}\n```\n\n**Advanced Gateway with Authentication:**\n```typescript\n// auth.gateway.ts\nimport { UseGuards } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\n\n@WebSocketGateway({\n  cors: { origin: '*' },\n  middlewares: [AuthMiddleware],\n})\nexport class AuthenticatedGateway implements OnGatewayConnection {\n  constructor(\n    private jwtService: JwtService,\n    private usersService: UsersService,\n  ) {}\n  \n  async handleConnection(client: Socket) {\n    try {\n      // Extract token from handshake\n      const token = client.handshake.auth.token ||\n                   client.handshake.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        client.disconnect();\n        return;\n      }\n      \n      // Verify JWT token\n      const payload = this.jwtService.verify(token);\n      const user = await this.usersService.findOne(payload.sub);\n      \n      if (!user) {\n        client.disconnect();\n        return;\n      }\n      \n      // Store user data in socket\n      client.data.user = user;\n      client.join(`user_${user.id}`);\n      \n      this.logger.log(`Authenticated user ${user.id} connected`);\n      \n    } catch (error) {\n      this.logger.error('Authentication failed:', error);\n      client.disconnect();\n    }\n  }\n  \n  @UseGuards(WsAuthGuard)\n  @SubscribeMessage('privateMessage')\n  async handlePrivateMessage(\n    @MessageBody() data: { targetUserId: string; message: string },\n    @ConnectedSocket() client: Socket,\n  ) {\n    const sender = client.data.user;\n    const { targetUserId, message } = data;\n    \n    // Save private message\n    const savedMessage = await this.messagesService.createPrivateMessage({\n      senderId: sender.id,\n      receiverId: targetUserId,\n      message,\n    });\n    \n    // Send to target user\n    this.server.to(`user_${targetUserId}`).emit('privateMessage', {\n      id: savedMessage.id,\n      message,\n      senderId: sender.id,\n      senderName: sender.name,\n      timestamp: savedMessage.createdAt,\n    });\n    \n    return { event: 'privateMessageSent', data: { messageId: savedMessage.id } };\n  }\n}\n```\n\n**WebSocket Guards:**\n```typescript\n// ws-auth.guard.ts\nimport { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';\nimport { WsException } from '@nestjs/websockets';\n\n@Injectable()\nexport class WsAuthGuard implements CanActivate {\n  canActivate(context: ExecutionContext): boolean {\n    const client = context.switchToWs().getClient();\n    const user = client.data.user;\n    \n    if (!user) {\n      throw new WsException('Unauthorized');\n    }\n    \n    return true;\n  }\n}\n\n// ws-roles.guard.ts\n@Injectable()\nexport class WsRolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n  \n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(\n      ROLES_KEY,\n      [context.getHandler(), context.getClass()],\n    );\n    \n    if (!requiredRoles) {\n      return true;\n    }\n    \n    const client = context.switchToWs().getClient();\n    const user = client.data.user;\n    \n    return requiredRoles.some((role) => user.roles?.includes(role));\n  }\n}\n```\n\n**WebSocket Exception Filter:**\n```typescript\n// ws-exception.filter.ts\nimport { Catch, ArgumentsHost } from '@nestjs/common';\nimport { BaseWsExceptionFilter, WsException } from '@nestjs/websockets';\n\n@Catch(WsException)\nexport class WsExceptionFilter extends BaseWsExceptionFilter {\n  catch(exception: WsException, host: ArgumentsHost) {\n    const client = host.switchToWs().getClient();\n    const error = exception.getError();\n    \n    const errorResponse = {\n      event: 'error',\n      data: {\n        message: typeof error === 'string' ? error : error.message,\n        timestamp: new Date().toISOString(),\n      },\n    };\n    \n    client.emit('error', errorResponse);\n  }\n}\n```\n\n**Client-Side Integration Example:**\n```typescript\n// Frontend (React/Angular/Vue)\nimport { io, Socket } from 'socket.io-client';\n\nclass ChatService {\n  private socket: Socket;\n  \n  connect(token: string) {\n    this.socket = io('http://localhost:3000/chat', {\n      auth: { token },\n    });\n    \n    this.socket.on('connect', () => {\n      console.log('Connected to server');\n    });\n    \n    this.socket.on('newMessage', (data) => {\n      console.log('New message:', data);\n    });\n    \n    this.socket.on('userJoined', (data) => {\n      console.log('User joined:', data);\n    });\n  }\n  \n  joinRoom(room: string, userId: string) {\n    this.socket.emit('joinRoom', { room, userId });\n  }\n  \n  sendMessage(room: string, message: string, userId: string) {\n    this.socket.emit('sendMessage', { room, message, userId });\n  }\n  \n  disconnect() {\n    this.socket.disconnect();\n  }\n}\n```\n\n**Module Configuration:**\n```typescript\n// chat.module.ts\n@Module({\n  imports: [JwtModule, UsersModule],\n  providers: [ChatGateway, ChatService, WsAuthGuard],\n})\nexport class ChatModule {}\n```\n\n**Key Features:**\n- Real-time bidirectional communication\n- Room-based messaging\n- Authentication and authorization\n- Typing indicators and presence\n- Private messaging\n- Connection lifecycle management\n- Error handling and exception filters\n- Integration with REST APIs and databases",
      "keywords": ["websockets", "gateways", "socket.io", "real-time", "chat", "rooms", "authentication", "events"],
      "difficulty": "medium"
    },
    {
      "id": 7017,
      "tag": "nestjs",
      "question": "How do you implement task scheduling and cron jobs in NestJS?",
      "answer": "NestJS provides comprehensive task scheduling capabilities through the `@nestjs/schedule` package, supporting cron jobs, intervals, timeouts, and dynamic scheduling with full integration into the dependency injection system.\n\n**Installation and Setup:**\n```bash\nnpm install @nestjs/schedule\n```\n\n```typescript\n// app.module.ts\nimport { ScheduleModule } from '@nestjs/schedule';\n\n@Module({\n  imports: [\n    ScheduleModule.forRoot(),\n    // other modules\n  ],\n})\nexport class AppModule {}\n```\n\n**Basic Cron Jobs:**\n```typescript\n// tasks.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { Cron, CronExpression, Interval, Timeout } from '@nestjs/schedule';\n\n@Injectable()\nexport class TasksService {\n  private readonly logger = new Logger(TasksService.name);\n  \n  // Run every day at 2:00 AM\n  @Cron('0 2 * * *', {\n    name: 'dailyBackup',\n    timeZone: 'America/New_York',\n  })\n  async handleDailyBackup() {\n    this.logger.log('Starting daily backup...');\n    \n    try {\n      await this.performDatabaseBackup();\n      await this.uploadBackupToCloud();\n      await this.cleanupOldBackups();\n      \n      this.logger.log('Daily backup completed successfully');\n    } catch (error) {\n      this.logger.error('Daily backup failed:', error);\n      await this.sendBackupFailureAlert(error);\n    }\n  }\n  \n  // Run every 15 minutes\n  @Cron(CronExpression.EVERY_15_MINUTES, {\n    name: 'healthCheck',\n  })\n  async handleHealthCheck() {\n    this.logger.log('Performing health check...');\n    \n    const services = ['database', 'redis', 'external-api'];\n    \n    for (const service of services) {\n      try {\n        await this.checkServiceHealth(service);\n        this.logger.log(`${service} is healthy`);\n      } catch (error) {\n        this.logger.error(`${service} health check failed:`, error);\n        await this.alertServiceDown(service, error);\n      }\n    }\n  }\n  \n  // Run every Monday at 9:00 AM\n  @Cron('0 9 * * 1', {\n    name: 'weeklyReport',\n    timeZone: 'UTC',\n  })\n  async handleWeeklyReport() {\n    this.logger.log('Generating weekly report...');\n    \n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - 7);\n    \n    const reportData = await this.generateWeeklyMetrics(startDate);\n    const report = await this.createReportDocument(reportData);\n    \n    await this.emailWeeklyReport(report);\n    this.logger.log('Weekly report sent successfully');\n  }\n  \n  // Run at the start of every month\n  @Cron('0 0 1 * *', {\n    name: 'monthlyCleanup',\n  })\n  async handleMonthlyCleanup() {\n    this.logger.log('Starting monthly cleanup...');\n    \n    // Clean up old logs\n    const deletedLogs = await this.cleanupOldLogs(30); // 30 days old\n    \n    // Archive old data\n    const archivedRecords = await this.archiveOldData(90); // 90 days old\n    \n    // Clean up temporary files\n    await this.cleanupTempFiles();\n    \n    this.logger.log(\n      `Monthly cleanup completed: ${deletedLogs} logs deleted, ${archivedRecords} records archived`\n    );\n  }\n}\n```\n\n**Interval and Timeout Jobs:**\n```typescript\n@Injectable()\nexport class MonitoringService {\n  private readonly logger = new Logger(MonitoringService.name);\n  private isProcessing = false;\n  \n  // Run every 5 seconds\n  @Interval('metrics-collection', 5000)\n  async handleMetricsCollection() {\n    if (this.isProcessing) {\n      this.logger.warn('Previous metrics collection still running, skipping...');\n      return;\n    }\n    \n    this.isProcessing = true;\n    \n    try {\n      const metrics = await this.collectSystemMetrics();\n      await this.storeMetrics(metrics);\n      \n      // Check for alerts\n      await this.checkMetricsThresholds(metrics);\n    } catch (error) {\n      this.logger.error('Metrics collection failed:', error);\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n  \n  // Run once after 10 seconds on startup\n  @Timeout('startup-tasks', 10000)\n  async handleStartupTasks() {\n    this.logger.log('Running startup tasks...');\n    \n    try {\n      await this.initializeCache();\n      await this.validateConfiguration();\n      await this.registerServiceDiscovery();\n      \n      this.logger.log('Startup tasks completed');\n    } catch (error) {\n      this.logger.error('Startup tasks failed:', error);\n      process.exit(1);\n    }\n  }\n}\n```\n\n**Dynamic Scheduling:**\n```typescript\n// dynamic-scheduler.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { SchedulerRegistry } from '@nestjs/schedule';\nimport { CronJob } from 'cron';\n\n@Injectable()\nexport class DynamicSchedulerService {\n  private readonly logger = new Logger(DynamicSchedulerService.name);\n  \n  constructor(\n    private schedulerRegistry: SchedulerRegistry,\n    private notificationService: NotificationService,\n  ) {}\n  \n  async createUserReminder(\n    userId: string,\n    message: string,\n    cronExpression: string,\n  ) {\n    const jobName = `user-reminder-${userId}-${Date.now()}`;\n    \n    const job = new CronJob(cronExpression, async () => {\n      try {\n        await this.notificationService.sendReminder(userId, message);\n        this.logger.log(`Reminder sent to user ${userId}`);\n      } catch (error) {\n        this.logger.error(`Failed to send reminder to user ${userId}:`, error);\n      }\n    });\n    \n    this.schedulerRegistry.addCronJob(jobName, job);\n    job.start();\n    \n    this.logger.log(`Created reminder job: ${jobName}`);\n    return jobName;\n  }\n  \n  async scheduleOneTimeTask(\n    taskId: string,\n    executeAt: Date,\n    taskData: any,\n  ) {\n    const jobName = `one-time-task-${taskId}`;\n    const delay = executeAt.getTime() - Date.now();\n    \n    if (delay <= 0) {\n      throw new Error('Execution time must be in the future');\n    }\n    \n    const timeout = setTimeout(async () => {\n      try {\n        await this.executeTask(taskId, taskData);\n        this.logger.log(`One-time task ${taskId} completed`);\n      } catch (error) {\n        this.logger.error(`One-time task ${taskId} failed:`, error);\n      } finally {\n        this.schedulerRegistry.deleteTimeout(jobName);\n      }\n    }, delay);\n    \n    this.schedulerRegistry.addTimeout(jobName, timeout);\n    this.logger.log(`Scheduled one-time task: ${jobName} at ${executeAt}`);\n    \n    return jobName;\n  }\n  \n  async cancelJob(jobName: string) {\n    try {\n      // Try to delete as cron job first\n      const cronJob = this.schedulerRegistry.getCronJob(jobName);\n      cronJob.stop();\n      this.schedulerRegistry.deleteCronJob(jobName);\n    } catch {\n      try {\n        // Try to delete as timeout\n        this.schedulerRegistry.deleteTimeout(jobName);\n      } catch {\n        try {\n          // Try to delete as interval\n          this.schedulerRegistry.deleteInterval(jobName);\n        } catch (error) {\n          this.logger.error(`Failed to cancel job ${jobName}:`, error);\n          throw new Error(`Job ${jobName} not found`);\n        }\n      }\n    }\n    \n    this.logger.log(`Cancelled job: ${jobName}`);\n  }\n  \n  listActiveJobs() {\n    const cronJobs = this.schedulerRegistry.getCronJobs();\n    const timeouts = this.schedulerRegistry.getTimeouts();\n    const intervals = this.schedulerRegistry.getIntervals();\n    \n    return {\n      cronJobs: Array.from(cronJobs.keys()),\n      timeouts: Array.from(timeouts),\n      intervals: Array.from(intervals),\n    };\n  }\n}\n```\n\n**Advanced Scheduling with Queue Integration:**\n```typescript\n// queue-scheduler.service.ts\nimport { InjectQueue } from '@nestjs/bull';\nimport { Queue } from 'bull';\n\n@Injectable()\nexport class QueueSchedulerService {\n  constructor(\n    @InjectQueue('email') private emailQueue: Queue,\n    @InjectQueue('reports') private reportsQueue: Queue,\n  ) {}\n  \n  @Cron('0 8 * * *', { name: 'daily-emails' })\n  async scheduleDailyEmails() {\n    const users = await this.usersService.getActiveUsers();\n    \n    for (const user of users) {\n      await this.emailQueue.add(\n        'daily-digest',\n        { userId: user.id },\n        {\n          delay: Math.random() * 3600000, // Random delay up to 1 hour\n          attempts: 3,\n          backoff: {\n            type: 'exponential',\n            delay: 2000,\n          },\n        },\n      );\n    }\n  }\n  \n  @Cron('0 3 * * *', { name: 'generate-reports' })\n  async scheduleReportGeneration() {\n    const reportTypes = ['sales', 'analytics', 'performance'];\n    \n    for (const type of reportTypes) {\n      await this.reportsQueue.add(\n        'generate-report',\n        { type, date: new Date() },\n        {\n          priority: type === 'sales' ? 10 : 5,\n          removeOnComplete: 5,\n          removeOnFail: 10,\n        },\n      );\n    }\n  }\n}\n```\n\n**Configuration and Environment Support:**\n```typescript\n// config-based-tasks.service.ts\n@Injectable()\nexport class ConfigBasedTasksService {\n  constructor(private configService: ConfigService) {}\n  \n  @Cron(() => {\n    // Dynamic cron expression from configuration\n    return this.configService.get('BACKUP_CRON_EXPRESSION', '0 2 * * *');\n  })\n  async handleConfigurableBackup() {\n    const backupEnabled = this.configService.get('BACKUP_ENABLED', 'true') === 'true';\n    \n    if (!backupEnabled) {\n      this.logger.log('Backup is disabled in configuration');\n      return;\n    }\n    \n    // Perform backup logic\n  }\n}\n```\n\n**Module Setup:**\n```typescript\n// tasks.module.ts\n@Module({\n  imports: [ScheduleModule.forRoot()],\n  providers: [\n    TasksService,\n    MonitoringService,\n    DynamicSchedulerService,\n    QueueSchedulerService,\n  ],\n  exports: [DynamicSchedulerService],\n})\nexport class TasksModule {}\n```\n\n**Key Features:**\n- Cron-based scheduling with timezone support\n- Dynamic job creation and cancellation\n- Integration with queues for complex workflows\n- Error handling and logging\n- Configuration-driven scheduling\n- Memory-efficient job management\n- Support for one-time and recurring tasks",
      "keywords": ["scheduling", "cron jobs", "intervals", "timeouts", "dynamic scheduling", "task automation", "background jobs"],
      "difficulty": "medium"
    },
    {
      "id": 7018,
      "tag": "nestjs",
      "question": "How do you create custom decorators and use metadata reflection in NestJS?",
      "answer": "Custom decorators in NestJS leverage TypeScript's experimental decorator feature and Node.js's `reflect-metadata` library to add metadata to classes, methods, and parameters, enabling powerful metaprogramming capabilities.\n\n**Basic Custom Decorators:**\n\n**1. Method Decorators:**\n```typescript\n// decorators/roles.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);\n\n// decorators/cache.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const CACHE_KEY = 'cache';\nexport const Cache = (ttl: number) => SetMetadata(CACHE_KEY, { ttl });\n\n// decorators/rate-limit.decorator.ts\nexport const RATE_LIMIT_KEY = 'rateLimit';\nexport const RateLimit = (limit: number, windowMs: number) =>\n  SetMetadata(RATE_LIMIT_KEY, { limit, windowMs });\n\n// Usage in controller\n@Controller('users')\nexport class UsersController {\n  @Get()\n  @Roles('admin', 'moderator')\n  @Cache(300) // 5 minutes\n  @RateLimit(100, 60000) // 100 requests per minute\n  findAll() {\n    return this.usersService.findAll();\n  }\n}\n```\n\n**2. Parameter Decorators:**\n```typescript\n// decorators/current-user.decorator.ts\nimport { createParamDecorator, ExecutionContext } from '@nestjs/common';\n\nexport const CurrentUser = createParamDecorator(\n  (data: keyof User | undefined, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    const user = request.user;\n    \n    return data ? user?.[data] : user;\n  },\n);\n\n// decorators/ip-address.decorator.ts\nexport const IpAddress = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext) => {\n    const request = ctx.switchToHttp().getRequest();\n    return request.ip || request.connection.remoteAddress;\n  },\n);\n\n// decorators/pagination.decorator.ts\ninterface PaginationParams {\n  page: number;\n  limit: number;\n  offset: number;\n}\n\nexport const Pagination = createParamDecorator(\n  (data: unknown, ctx: ExecutionContext): PaginationParams => {\n    const request = ctx.switchToHttp().getRequest();\n    const page = parseInt(request.query.page) || 1;\n    const limit = Math.min(parseInt(request.query.limit) || 10, 100);\n    const offset = (page - 1) * limit;\n    \n    return { page, limit, offset };\n  },\n);\n\n// Usage\n@Get()\nasync findAll(\n  @CurrentUser() user: User,\n  @CurrentUser('id') userId: string,\n  @IpAddress() ip: string,\n  @Pagination() pagination: PaginationParams,\n) {\n  return this.usersService.findAll(pagination, user);\n}\n```\n\n**3. Advanced Custom Decorators:**\n```typescript\n// decorators/validate-ownership.decorator.ts\nimport { SetMetadata } from '@nestjs/common';\n\nexport const OWNERSHIP_KEY = 'ownership';\n\ninterface OwnershipConfig {\n  entity: string;\n  userIdField: string;\n  paramName: string;\n}\n\nexport const ValidateOwnership = (config: OwnershipConfig) =>\n  SetMetadata(OWNERSHIP_KEY, config);\n\n// decorators/audit.decorator.ts\nexport const AUDIT_KEY = 'audit';\n\ninterface AuditConfig {\n  action: string;\n  resource: string;\n  includePayload?: boolean;\n}\n\nexport const Audit = (config: AuditConfig) => SetMetadata(AUDIT_KEY, config);\n\n// decorators/transform-response.decorator.ts\nexport const TRANSFORM_KEY = 'transform';\n\ntype TransformFunction<T, R> = (data: T) => R;\n\nexport const TransformResponse = <T, R>(transformer: TransformFunction<T, R>) =>\n  SetMetadata(TRANSFORM_KEY, transformer);\n\n// Usage\n@Post()\n@ValidateOwnership({\n  entity: 'Post',\n  userIdField: 'authorId',\n  paramName: 'id',\n})\n@Audit({\n  action: 'CREATE_POST',\n  resource: 'posts',\n  includePayload: true,\n})\n@TransformResponse((post: Post) => ({\n  id: post.id,\n  title: post.title,\n  createdAt: post.createdAt,\n}))\ncreatePost(\n  @Body() createPostDto: CreatePostDto,\n  @CurrentUser() user: User,\n) {\n  return this.postsService.create(createPostDto, user.id);\n}\n```\n\n**4. Guards Using Custom Metadata:**\n```typescript\n// guards/roles.guard.ts\nimport { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { ROLES_KEY } from '../decorators/roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector) {}\n  \n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [\n      context.getHandler(),\n      context.getClass(),\n    ]);\n    \n    if (!requiredRoles) {\n      return true;\n    }\n    \n    const { user } = context.switchToHttp().getRequest();\n    return requiredRoles.some((role) => user.roles?.includes(role));\n  }\n}\n\n// guards/ownership.guard.ts\n@Injectable()\nexport class OwnershipGuard implements CanActivate {\n  constructor(\n    private reflector: Reflector,\n    private dataSource: DataSource,\n  ) {}\n  \n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const ownershipConfig = this.reflector.get<OwnershipConfig>(\n      OWNERSHIP_KEY,\n      context.getHandler(),\n    );\n    \n    if (!ownershipConfig) {\n      return true;\n    }\n    \n    const request = context.switchToHttp().getRequest();\n    const user = request.user;\n    const resourceId = request.params[ownershipConfig.paramName];\n    \n    if (!resourceId || !user) {\n      return false;\n    }\n    \n    // Check ownership in database\n    const repository = this.dataSource.getRepository(ownershipConfig.entity);\n    const resource = await repository.findOne({\n      where: { id: resourceId },\n      select: [ownershipConfig.userIdField],\n    });\n    \n    return resource?.[ownershipConfig.userIdField] === user.id;\n  }\n}\n```\n\n**5. Interceptors Using Metadata:**\n```typescript\n// interceptors/cache.interceptor.ts\n@Injectable()\nexport class CacheInterceptor implements NestInterceptor {\n  constructor(\n    private reflector: Reflector,\n    private cacheManager: Cache,\n  ) {}\n  \n  async intercept(context: ExecutionContext, next: CallHandler) {\n    const cacheConfig = this.reflector.get(CACHE_KEY, context.getHandler());\n    \n    if (!cacheConfig) {\n      return next.handle();\n    }\n    \n    const request = context.switchToHttp().getRequest();\n    const cacheKey = this.generateCacheKey(request);\n    \n    const cachedResult = await this.cacheManager.get(cacheKey);\n    if (cachedResult) {\n      return of(cachedResult);\n    }\n    \n    return next.handle().pipe(\n      tap(async (result) => {\n        await this.cacheManager.set(cacheKey, result, cacheConfig.ttl);\n      }),\n    );\n  }\n  \n  private generateCacheKey(request: any): string {\n    return `${request.method}:${request.url}:${JSON.stringify(request.query)}`;\n  }\n}\n\n// interceptors/audit.interceptor.ts\n@Injectable()\nexport class AuditInterceptor implements NestInterceptor {\n  constructor(\n    private reflector: Reflector,\n    private auditService: AuditService,\n  ) {}\n  \n  intercept(context: ExecutionContext, next: CallHandler) {\n    const auditConfig = this.reflector.get<AuditConfig>(\n      AUDIT_KEY,\n      context.getHandler(),\n    );\n    \n    if (!auditConfig) {\n      return next.handle();\n    }\n    \n    const request = context.switchToHttp().getRequest();\n    const startTime = Date.now();\n    \n    return next.handle().pipe(\n      tap(async (result) => {\n        const auditLog = {\n          action: auditConfig.action,\n          resource: auditConfig.resource,\n          userId: request.user?.id,\n          ip: request.ip,\n          userAgent: request.headers['user-agent'],\n          duration: Date.now() - startTime,\n          payload: auditConfig.includePayload ? request.body : undefined,\n          result: auditConfig.includePayload ? result : undefined,\n          timestamp: new Date(),\n        };\n        \n        await this.auditService.log(auditLog);\n      }),\n      catchError(async (error) => {\n        const auditLog = {\n          action: auditConfig.action,\n          resource: auditConfig.resource,\n          userId: request.user?.id,\n          ip: request.ip,\n          error: error.message,\n          timestamp: new Date(),\n        };\n        \n        await this.auditService.log(auditLog);\n        throw error;\n      }),\n    );\n  }\n}\n```\n\n**6. Class Decorators and Metadata:**\n```typescript\n// decorators/api-resource.decorator.ts\nexport const API_RESOURCE_KEY = 'apiResource';\n\ninterface ApiResourceConfig {\n  name: string;\n  version: string;\n  permissions?: string[];\n}\n\nexport const ApiResource = (config: ApiResourceConfig) => {\n  return (target: any) => {\n    Reflect.defineMetadata(API_RESOURCE_KEY, config, target);\n    return target;\n  };\n};\n\n// Usage\n@ApiResource({\n  name: 'users',\n  version: 'v1',\n  permissions: ['read', 'write'],\n})\n@Controller('users')\nexport class UsersController {\n  // controller methods\n}\n\n// Service to read class metadata\n@Injectable()\nexport class MetadataService {\n  getResourceConfig(target: any): ApiResourceConfig | undefined {\n    return Reflect.getMetadata(API_RESOURCE_KEY, target);\n  }\n  \n  getAllResourceConfigs(controllers: any[]): ApiResourceConfig[] {\n    return controllers\n      .map(controller => this.getResourceConfig(controller))\n      .filter(config => config !== undefined);\n  }\n}\n```\n\n**7. Advanced Metadata Composition:**\n```typescript\n// decorators/compose.decorator.ts\nexport function ComposeDecorators(...decorators: MethodDecorator[]) {\n  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n    decorators.forEach(decorator => {\n      decorator(target, propertyKey, descriptor);\n    });\n  };\n}\n\n// Usage\nconst AdminOnlyEndpoint = ComposeDecorators(\n  Roles('admin'),\n  Cache(60),\n  RateLimit(10, 60000),\n  Audit({ action: 'ADMIN_ACCESS', resource: 'admin' }),\n);\n\n@Get('admin-data')\n@AdminOnlyEndpoint\ngetAdminData() {\n  return this.adminService.getSensitiveData();\n}\n```\n\n**Key Benefits:**\n- Clean separation of cross-cutting concerns\n- Reusable metadata-driven functionality\n- Type-safe decorator composition\n- Dynamic behavior based on metadata\n- Integration with NestJS's dependency injection\n- Powerful metaprogramming capabilities",
      "keywords": ["custom decorators", "metadata", "reflection", "guards", "interceptors", "metaprogramming", "typescript decorators"],
      "difficulty": "hard"
    },
    {
      "id": 7019,
      "tag": "nestjs",
      "question": "How do you implement advanced microservices patterns like SAGA, Event Sourcing, and CQRS with message queues in NestJS?",
      "answer": "Advanced microservices patterns in NestJS enable complex distributed systems with eventual consistency, scalability, and fault tolerance using event-driven architectures and sophisticated message handling.\n\n**1. SAGA Pattern Implementation:**\n\n```typescript\n// saga/order-saga.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { EventEmitter2, OnEvent } from '@nestjs/event-emitter';\nimport { InjectQueue } from '@nestjs/bull';\nimport { Queue } from 'bull';\n\ninterface SagaStep {\n  action: string;\n  compensationAction: string;\n  service: string;\n  payload: any;\n}\n\n@Injectable()\nexport class OrderSagaService {\n  private readonly logger = new Logger(OrderSagaService.name);\n  private sagaSteps = new Map<string, SagaStep[]>();\n  private completedSteps = new Map<string, string[]>();\n  \n  constructor(\n    private eventEmitter: EventEmitter2,\n    @InjectQueue('saga') private sagaQueue: Queue,\n  ) {}\n  \n  async startOrderSaga(orderId: string, orderData: any) {\n    const steps: SagaStep[] = [\n      {\n        action: 'reserve_inventory',\n        compensationAction: 'release_inventory',\n        service: 'inventory',\n        payload: { items: orderData.items, orderId },\n      },\n      {\n        action: 'process_payment',\n        compensationAction: 'refund_payment',\n        service: 'payment',\n        payload: { amount: orderData.total, orderId },\n      },\n      {\n        action: 'create_shipment',\n        compensationAction: 'cancel_shipment',\n        service: 'shipping',\n        payload: { address: orderData.address, orderId },\n      },\n    ];\n    \n    this.sagaSteps.set(orderId, steps);\n    this.completedSteps.set(orderId, []);\n    \n    await this.executeNextStep(orderId, 0);\n  }\n  \n  private async executeNextStep(orderId: string, stepIndex: number) {\n    const steps = this.sagaSteps.get(orderId);\n    if (!steps || stepIndex >= steps.length) {\n      await this.completeSaga(orderId);\n      return;\n    }\n    \n    const step = steps[stepIndex];\n    this.logger.log(`Executing step ${stepIndex + 1}/${steps.length} for order ${orderId}: ${step.action}`);\n    \n    try {\n      await this.sagaQueue.add('execute-step', {\n        orderId,\n        stepIndex,\n        step,\n      }, {\n        attempts: 3,\n        backoff: { type: 'exponential', delay: 2000 },\n      });\n    } catch (error) {\n      this.logger.error(`Step failed for order ${orderId}:`, error);\n      await this.compensate(orderId, stepIndex - 1);\n    }\n  }\n  \n  @OnEvent('saga.step.completed')\n  async handleStepCompleted(event: { orderId: string; stepIndex: number; result: any }) {\n    const { orderId, stepIndex, result } = event;\n    const completed = this.completedSteps.get(orderId) || [];\n    completed.push(`step_${stepIndex}`);\n    this.completedSteps.set(orderId, completed);\n    \n    this.logger.log(`Step ${stepIndex + 1} completed for order ${orderId}`);\n    await this.executeNextStep(orderId, stepIndex + 1);\n  }\n  \n  @OnEvent('saga.step.failed')\n  async handleStepFailed(event: { orderId: string; stepIndex: number; error: any }) {\n    const { orderId, stepIndex, error } = event;\n    this.logger.error(`Step ${stepIndex + 1} failed for order ${orderId}:`, error);\n    await this.compensate(orderId, stepIndex - 1);\n  }\n  \n  private async compensate(orderId: string, fromStepIndex: number) {\n    this.logger.log(`Starting compensation for order ${orderId} from step ${fromStepIndex + 1}`);\n    \n    const steps = this.sagaSteps.get(orderId);\n    const completed = this.completedSteps.get(orderId) || [];\n    \n    // Execute compensation actions in reverse order\n    for (let i = fromStepIndex; i >= 0; i--) {\n      if (completed.includes(`step_${i}`)) {\n        const step = steps[i];\n        await this.sagaQueue.add('compensate-step', {\n          orderId,\n          stepIndex: i,\n          compensationAction: step.compensationAction,\n          service: step.service,\n          payload: step.payload,\n        });\n      }\n    }\n    \n    await this.failSaga(orderId);\n  }\n  \n  private async completeSaga(orderId: string) {\n    this.logger.log(`Saga completed successfully for order ${orderId}`);\n    this.eventEmitter.emit('saga.completed', { orderId });\n    this.cleanup(orderId);\n  }\n  \n  private async failSaga(orderId: string) {\n    this.logger.log(`Saga failed for order ${orderId}`);\n    this.eventEmitter.emit('saga.failed', { orderId });\n    this.cleanup(orderId);\n  }\n  \n  private cleanup(orderId: string) {\n    this.sagaSteps.delete(orderId);\n    this.completedSteps.delete(orderId);\n  }\n}\n```\n\n**2. Event Sourcing Implementation:**\n\n```typescript\n// event-sourcing/event-store.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { Repository } from 'typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\n\n@Entity('events')\nexport class EventStore {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n  \n  @Column()\n  aggregateId: string;\n  \n  @Column()\n  aggregateType: string;\n  \n  @Column()\n  eventType: string;\n  \n  @Column('jsonb')\n  eventData: any;\n  \n  @Column('jsonb', { nullable: true })\n  metadata: any;\n  \n  @Column()\n  version: number;\n  \n  @CreateDateColumn()\n  createdAt: Date;\n}\n\n@Injectable()\nexport class EventStoreService {\n  constructor(\n    @InjectRepository(EventStore)\n    private eventRepository: Repository<EventStore>,\n    private eventEmitter: EventEmitter2,\n  ) {}\n  \n  async saveEvents(\n    aggregateId: string,\n    aggregateType: string,\n    events: DomainEvent[],\n    expectedVersion: number,\n  ) {\n    const currentVersion = await this.getAggregateVersion(aggregateId);\n    \n    if (currentVersion !== expectedVersion) {\n      throw new Error('Concurrency conflict');\n    }\n    \n    const eventEntities = events.map((event, index) => {\n      const eventEntity = new EventStore();\n      eventEntity.aggregateId = aggregateId;\n      eventEntity.aggregateType = aggregateType;\n      eventEntity.eventType = event.constructor.name;\n      eventEntity.eventData = event;\n      eventEntity.metadata = { userId: event.userId, timestamp: new Date() };\n      eventEntity.version = currentVersion + index + 1;\n      return eventEntity;\n    });\n    \n    const savedEvents = await this.eventRepository.save(eventEntities);\n    \n    // Publish events for read model updates\n    for (const event of events) {\n      this.eventEmitter.emit(event.constructor.name, event);\n    }\n    \n    return savedEvents;\n  }\n  \n  async getEvents(aggregateId: string, fromVersion?: number): Promise<DomainEvent[]> {\n    const query = this.eventRepository\n      .createQueryBuilder('event')\n      .where('event.aggregateId = :aggregateId', { aggregateId })\n      .orderBy('event.version', 'ASC');\n    \n    if (fromVersion !== undefined) {\n      query.andWhere('event.version > :fromVersion', { fromVersion });\n    }\n    \n    const events = await query.getMany();\n    return events.map(event => this.deserializeEvent(event));\n  }\n  \n  async getAggregateVersion(aggregateId: string): Promise<number> {\n    const result = await this.eventRepository\n      .createQueryBuilder('event')\n      .select('MAX(event.version)', 'maxVersion')\n      .where('event.aggregateId = :aggregateId', { aggregateId })\n      .getRawOne();\n    \n    return result.maxVersion || 0;\n  }\n  \n  private deserializeEvent(eventEntity: EventStore): DomainEvent {\n    // Implement event deserialization based on eventType\n    const eventClass = this.getEventClass(eventEntity.eventType);\n    return Object.assign(new eventClass(), eventEntity.eventData);\n  }\n}\n\n// domain/user-aggregate.ts\nexport class User {\n  private id: string;\n  private email: string;\n  private name: string;\n  private isActive: boolean;\n  private version: number = 0;\n  private uncommittedEvents: DomainEvent[] = [];\n  \n  static fromHistory(events: DomainEvent[]): User {\n    const user = new User();\n    events.forEach(event => user.apply(event, false));\n    return user;\n  }\n  \n  create(id: string, email: string, name: string, userId: string) {\n    const event = new UserCreatedEvent(id, email, name, userId);\n    this.apply(event, true);\n  }\n  \n  updateEmail(newEmail: string, userId: string) {\n    if (this.email === newEmail) return;\n    \n    const event = new UserEmailUpdatedEvent(this.id, newEmail, userId);\n    this.apply(event, true);\n  }\n  \n  deactivate(userId: string) {\n    if (!this.isActive) return;\n    \n    const event = new UserDeactivatedEvent(this.id, userId);\n    this.apply(event, true);\n  }\n  \n  private apply(event: DomainEvent, isNew: boolean) {\n    switch (event.constructor.name) {\n      case 'UserCreatedEvent':\n        this.onUserCreated(event as UserCreatedEvent);\n        break;\n      case 'UserEmailUpdatedEvent':\n        this.onUserEmailUpdated(event as UserEmailUpdatedEvent);\n        break;\n      case 'UserDeactivatedEvent':\n        this.onUserDeactivated(event as UserDeactivatedEvent);\n        break;\n    }\n    \n    if (isNew) {\n      this.uncommittedEvents.push(event);\n    }\n    \n    this.version++;\n  }\n  \n  getUncommittedEvents(): DomainEvent[] {\n    return [...this.uncommittedEvents];\n  }\n  \n  markEventsAsCommitted() {\n    this.uncommittedEvents = [];\n  }\n}\n```\n\n**3. CQRS Implementation:**\n\n```typescript\n// cqrs/commands/create-user.command.ts\nexport class CreateUserCommand {\n  constructor(\n    public readonly email: string,\n    public readonly name: string,\n    public readonly userId: string,\n  ) {}\n}\n\n// cqrs/handlers/create-user.handler.ts\n@CommandHandler(CreateUserCommand)\nexport class CreateUserHandler implements ICommandHandler<CreateUserCommand> {\n  constructor(\n    private userRepository: UserRepository,\n    private eventStore: EventStoreService,\n  ) {}\n  \n  async execute(command: CreateUserCommand): Promise<void> {\n    const { email, name, userId } = command;\n    \n    // Check if user already exists\n    const existingUser = await this.userRepository.findByEmail(email);\n    if (existingUser) {\n      throw new ConflictException('User already exists');\n    }\n    \n    // Create aggregate\n    const user = new User();\n    const aggregateId = uuid();\n    user.create(aggregateId, email, name, userId);\n    \n    // Save events\n    await this.eventStore.saveEvents(\n      aggregateId,\n      'User',\n      user.getUncommittedEvents(),\n      0,\n    );\n    \n    user.markEventsAsCommitted();\n  }\n}\n\n// cqrs/queries/get-user.query.ts\nexport class GetUserQuery {\n  constructor(public readonly userId: string) {}\n}\n\n// cqrs/handlers/get-user.handler.ts\n@QueryHandler(GetUserQuery)\nexport class GetUserHandler implements IQueryHandler<GetUserQuery> {\n  constructor(\n    @InjectRepository(UserReadModel)\n    private userReadRepository: Repository<UserReadModel>,\n  ) {}\n  \n  async execute(query: GetUserQuery): Promise<UserReadModel> {\n    const user = await this.userReadRepository.findOne({\n      where: { id: query.userId },\n    });\n    \n    if (!user) {\n      throw new NotFoundException('User not found');\n    }\n    \n    return user;\n  }\n}\n\n// read-models/user-read-model.service.ts\n@Injectable()\nexport class UserReadModelService {\n  constructor(\n    @InjectRepository(UserReadModel)\n    private userReadRepository: Repository<UserReadModel>,\n  ) {}\n  \n  @OnEvent('UserCreatedEvent')\n  async handleUserCreated(event: UserCreatedEvent) {\n    const readModel = new UserReadModel();\n    readModel.id = event.aggregateId;\n    readModel.email = event.email;\n    readModel.name = event.name;\n    readModel.isActive = true;\n    readModel.createdAt = new Date();\n    \n    await this.userReadRepository.save(readModel);\n  }\n  \n  @OnEvent('UserEmailUpdatedEvent')\n  async handleUserEmailUpdated(event: UserEmailUpdatedEvent) {\n    await this.userReadRepository.update(\n      { id: event.aggregateId },\n      { email: event.newEmail, updatedAt: new Date() },\n    );\n  }\n  \n  @OnEvent('UserDeactivatedEvent')\n  async handleUserDeactivated(event: UserDeactivatedEvent) {\n    await this.userReadRepository.update(\n      { id: event.aggregateId },\n      { isActive: false, updatedAt: new Date() },\n    );\n  }\n}\n```\n\n**4. Message Queue Integration:**\n\n```typescript\n// messaging/message-bus.service.ts\n@Injectable()\nexport class MessageBusService {\n  constructor(\n    @InjectQueue('commands') private commandQueue: Queue,\n    @InjectQueue('events') private eventQueue: Queue,\n    private eventEmitter: EventEmitter2,\n  ) {}\n  \n  async publishCommand(command: any, options?: any) {\n    return this.commandQueue.add(\n      command.constructor.name,\n      command,\n      {\n        removeOnComplete: 10,\n        removeOnFail: 50,\n        attempts: 3,\n        backoff: { type: 'exponential', delay: 2000 },\n        ...options,\n      },\n    );\n  }\n  \n  async publishEvent(event: DomainEvent, options?: any) {\n    // Local event emission for same-service handlers\n    this.eventEmitter.emit(event.constructor.name, event);\n    \n    // Queue for cross-service communication\n    return this.eventQueue.add(\n      event.constructor.name,\n      event,\n      {\n        removeOnComplete: 5,\n        removeOnFail: 20,\n        ...options,\n      },\n    );\n  }\n  \n  async publishIntegrationEvent(event: any, targetService?: string) {\n    const routingKey = targetService ? `${targetService}.${event.constructor.name}` : event.constructor.name;\n    \n    return this.eventQueue.add(\n      'integration-event',\n      {\n        eventType: event.constructor.name,\n        eventData: event,\n        targetService,\n        routingKey,\n      },\n      {\n        removeOnComplete: 5,\n        removeOnFail: 20,\n      },\n    );\n  }\n}\n\n// processors/command.processor.ts\n@Processor('commands')\nexport class CommandProcessor {\n  constructor(\n    private commandBus: CommandBus,\n    private logger: Logger,\n  ) {}\n  \n  @Process()\n  async handleCommand(job: Job) {\n    const { name, data } = job;\n    \n    try {\n      this.logger.log(`Processing command: ${name}`);\n      await this.commandBus.execute(data);\n      this.logger.log(`Command completed: ${name}`);\n    } catch (error) {\n      this.logger.error(`Command failed: ${name}`, error);\n      throw error;\n    }\n  }\n}\n```\n\n**Module Configuration:**\n```typescript\n// app.module.ts\n@Module({\n  imports: [\n    CqrsModule,\n    EventEmitterModule.forRoot(),\n    BullModule.forRoot({\n      redis: {\n        host: 'localhost',\n        port: 6379,\n      },\n    }),\n    BullModule.registerQueue(\n      { name: 'commands' },\n      { name: 'events' },\n      { name: 'saga' },\n    ),\n  ],\n  providers: [\n    OrderSagaService,\n    EventStoreService,\n    MessageBusService,\n    UserReadModelService,\n    CommandProcessor,\n    EventProcessor,\n  ],\n})\nexport class AppModule {}\n```\n\n**Key Benefits:**\n- Eventual consistency across distributed systems\n- Fault tolerance with compensation patterns\n- Scalable event-driven architecture\n- Audit trail and temporal queries\n- Clear separation of read/write operations\n- Resilient message processing with retries",
      "keywords": ["saga pattern", "event sourcing", "cqrs", "message queues", "microservices", "distributed systems", "eventual consistency"],
      "difficulty": "hard"
    }
  ]
}