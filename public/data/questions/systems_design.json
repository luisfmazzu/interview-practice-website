{
  "category": "systems_design",
  "questions": [
    {
      "id": 3000,
      "tag": "systems_design",
      "question": "Design a URL shortening service like bit.ly. Consider scalability, performance, and reliability.",
      "answer": "**System Requirements:**\n- Shorten long URLs to 6-8 character codes\n- Handle 100M URLs per day\n- 100:1 read/write ratio\n- 99.9% uptime\n- Analytics tracking\n\n**Architecture Components:**\n\n**1. Load Balancer:**\n- Distribute incoming requests\n- Health checks for backend services\n- SSL termination\n\n**2. Application Servers:**\n- Stateless web servers\n- Handle URL encoding/decoding\n- Rate limiting and validation\n\n**3. Database Design:**\n- **Primary DB:** URL mappings (SQL/NoSQL)\n- **Cache:** Redis for hot URLs\n- **Analytics DB:** Click tracking data\n\n**4. URL Encoding:**\n- Base62 encoding (a-z, A-Z, 0-9)\n- Counter-based or hash-based approach\n- Collision detection and resolution\n\n**5. Caching Strategy:**\n- Cache popular URLs in Redis\n- CDN for static content\n- Browser caching headers\n\n**6. Analytics Service:**\n- Async processing of click events\n- Data pipeline for reporting\n- Real-time and batch analytics\n\n**Scalability Considerations:**\n- Database sharding by URL hash\n- Read replicas for analytics\n- Auto-scaling application servers\n- Rate limiting to prevent abuse",
      "keywords": ["load balancer", "horizontal scaling", "database sharding", "caching", "CDN", "rate limiting", "Base62 encoding", "hash function", "read replicas", "Redis", "stateless servers", "analytics pipeline", "collision detection", "auto-scaling", "microservices"],
      "difficulty": "hard"
    },
    {
      "id": 3001,
      "tag": "systems_design",
      "question": "How would you design a chat application like WhatsApp? Focus on real-time messaging and scalability.",
      "answer": "**System Requirements:**\n- Real-time messaging for millions of users\n- Support for 1-on-1 and group chats\n- Message delivery guarantees\n- Online presence tracking\n- File sharing capabilities\n\n**Architecture Components:**\n\n**1. Client Applications:**\n- Mobile apps (iOS/Android)\n- Web application\n- WebSocket connections for real-time communication\n\n**2. Gateway Services:**\n- Connection management\n- Authentication and authorization\n- Protocol translation (WebSocket, HTTP)\n- Load balancing connections\n\n**3. Message Service:**\n- Message routing and delivery\n- Temporary message storage\n- Push notification triggers\n- Message ordering and deduplication\n\n**4. User Service:**\n- User profiles and contacts\n- Online/offline status\n- Authentication management\n- Friend relationships\n\n**5. Data Storage:**\n- **Message Store:** Distributed database (Cassandra/MongoDB)\n- **User Store:** Relational database (PostgreSQL)\n- **Cache:** Redis for active conversations\n- **File Storage:** Object storage (S3) for media\n\n**6. Real-time Communication:**\n- WebSocket connections\n- Message queues (Apache Kafka)\n- Pub/Sub for group messages\n- Connection persistence\n\n**7. Notification Service:**\n- Push notifications (APNs, FCM)\n- Email notifications\n- SMS fallback\n\n**Scalability Solutions:**\n- Horizontal scaling of services\n- Database sharding by user ID\n- CDN for media files\n- Connection pooling and multiplexing",
      "keywords": ["WebSocket", "real-time messaging", "message queues", "pub/sub", "Apache Kafka", "push notifications", "database sharding", "connection pooling", "load balancer", "microservices", "distributed systems", "message delivery guarantees", "presence tracking", "horizontal scaling", "NoSQL", "object storage"],
      "difficulty": "hard"
    },
    {
      "id": 3002,
      "tag": "systems_design",
      "question": "Design a distributed cache system like Redis. Explain the architecture and key design decisions.",
      "answer": "**System Requirements:**\n- In-memory key-value storage\n- Sub-millisecond response times\n- High availability and fault tolerance\n- Support for various data types\n- Horizontal scalability\n\n**Core Architecture:**\n\n**1. Memory Management:**\n- Hash table for O(1) key lookups\n- Memory-efficient data structures\n- Eviction policies (LRU, LFU, TTL)\n- Memory fragmentation handling\n\n**2. Data Structures:**\n- Strings, Lists, Sets, Sorted Sets, Hashes\n- Efficient serialization/deserialization\n- Atomic operations support\n- Expiration tracking\n\n**3. Persistence:**\n- **RDB:** Point-in-time snapshots\n- **AOF:** Append-only file logging\n- Configurable persistence strategies\n- Fast restart and recovery\n\n**4. Networking:**\n- TCP server with custom protocol\n- Connection pooling\n- Pipelining support\n- Async I/O (epoll/kqueue)\n\n**5. Clustering:**\n- **Master-Slave Replication:**\n  - Asynchronous replication\n  - Automatic failover\n  - Read scaling with replicas\n\n- **Sharding (Redis Cluster):**\n  - Hash slot distribution (16384 slots)\n  - Consistent hashing\n  - Automatic resharding\n  - Client-side routing\n\n**6. High Availability:**\n- Sentinel for monitoring\n- Automatic master election\n- Health checks and alerts\n- Split-brain prevention\n\n**Key Design Decisions:**\n- Single-threaded for simplicity\n- Event-driven architecture\n- Copy-on-write for snapshots\n- Client-side sharding support",
      "keywords": ["in-memory storage", "key-value store", "hash table", "eviction policies", "LRU", "LFU", "TTL", "master-slave replication", "consistent hashing", "sharding", "high availability", "failover", "persistence", "RDB snapshots", "AOF", "atomic operations", "single-threaded", "event-driven architecture"],
      "difficulty": "hard"
    },
    {
      "id": 3003,
      "tag": "systems_design",
      "question": "What is the CAP theorem and how does it apply to distributed systems design?",
      "answer": "The CAP theorem, proposed by Eric Brewer, states that in any distributed system, you can only guarantee two out of three properties simultaneously:\n\n**Consistency (C):** All nodes see the same data at the same time. Every read receives the most recent write or an error.\n\n**Availability (A):** The system remains operational and responds to requests, even if some nodes fail.\n\n**Partition Tolerance (P):** The system continues to operate despite network failures that partition the system into separate groups.\n\n**Why You Can Only Choose Two:**\nWhen a network partition occurs, you must choose between consistency and availability. You cannot have both because:\n- If you prioritize consistency, you must reject requests to maintain data integrity (sacrificing availability)\n- If you prioritize availability, you must accept potentially stale data (sacrificing consistency)\n\n**Real-world Examples:**\n- **CP Systems:** Traditional RDBMS like PostgreSQL, MongoDB (strong consistency mode)\n- **AP Systems:** DNS, Cassandra, DynamoDB (eventual consistency)\n- **CA Systems:** Single-node databases (not truly distributed)\n\n**Practical Implications:**\n- Most modern systems choose partition tolerance by default\n- BASE (Basically Available, Soft state, Eventually consistent) vs ACID\n- Trade-offs must be made based on business requirements\n- Different parts of a system can make different CAP choices",
      "keywords": ["CAP theorem", "consistency", "availability", "partition tolerance", "distributed systems", "network partition", "eventual consistency", "strong consistency", "ACID", "BASE", "trade-offs", "fault tolerance", "data integrity"],
      "difficulty": "easy"
    },
    {
      "id": 3004,
      "tag": "systems_design",
      "question": "Explain the differences between horizontal and vertical scaling. When would you use each approach?",
      "answer": "**Vertical Scaling (Scale Up):**\nAdding more power to existing machines by increasing CPU, RAM, or storage capacity.\n\n**Advantages:**\n- Simpler to implement - no code changes needed\n- No distributed system complexity\n- Lower operational overhead\n- Better for applications with tight coupling\n\n**Disadvantages:**\n- Limited by hardware constraints\n- Single point of failure\n- Expensive at high performance levels\n- Downtime required for upgrades\n\n**Horizontal Scaling (Scale Out):**\nAdding more machines to the resource pool to handle increased load.\n\n**Advantages:**\n- No theoretical limit to scaling\n- Better fault tolerance and redundancy\n- Cost-effective with commodity hardware\n- Can handle sudden traffic spikes\n- Zero-downtime scaling possible\n\n**Disadvantages:**\n- Complex application architecture required\n- Data consistency challenges\n- Network latency between nodes\n- Higher operational complexity\n\n**When to Use Vertical Scaling:**\n- Legacy applications that cannot be distributed\n- Applications requiring strong consistency\n- Small to medium workloads\n- Database systems with complex queries\n- Rapid prototyping and development\n\n**When to Use Horizontal Scaling:**\n- Web applications with stateless services\n- Large-scale systems (millions of users)\n- Microservices architectures\n- Systems requiring high availability\n- Applications with predictable growth patterns",
      "keywords": ["horizontal scaling", "vertical scaling", "scale out", "scale up", "distributed systems", "fault tolerance", "stateless services", "microservices", "high availability", "load distribution", "commodity hardware", "single point of failure", "operational complexity"],
      "difficulty": "easy"
    },
    {
      "id": 3005,
      "tag": "systems_design",
      "question": "What are the main types of load balancers and their use cases?",
      "answer": "**Layer 4 (Transport Layer) Load Balancers:**\nOperate at the TCP/UDP level, making routing decisions based on IP addresses and ports.\n\n**Characteristics:**\n- Fast and efficient (no packet inspection)\n- Low latency and high throughput\n- Protocol-agnostic\n- Cannot make application-aware decisions\n\n**Use Cases:**\n- High-performance scenarios requiring minimal latency\n- Database connection pooling\n- Generic TCP/UDP service distribution\n\n**Layer 7 (Application Layer) Load Balancers:**\nOperate at the HTTP/HTTPS level, making intelligent routing decisions based on content.\n\n**Characteristics:**\n- Can inspect HTTP headers, URLs, and content\n- Advanced routing capabilities\n- SSL termination\n- Higher latency due to packet inspection\n\n**Use Cases:**\n- Web applications requiring content-based routing\n- Microservices architectures\n- API gateways\n- A/B testing and canary deployments\n\n**Common Load Balancing Algorithms:**\n- **Round Robin:** Distributes requests sequentially\n- **Weighted Round Robin:** Assigns different weights to servers\n- **Least Connections:** Routes to server with fewest active connections\n- **IP Hash:** Uses client IP to determine server (session affinity)\n- **Geographic:** Routes based on client location\n\n**Hardware vs Software Load Balancers:**\n- **Hardware:** Dedicated appliances (F5, Citrix NetScaler)\n- **Software:** Applications running on commodity hardware (HAProxy, NGINX, AWS ALB)\n\n**Cloud Load Balancers:**\n- Managed services (AWS ELB, Google Cloud Load Balancing)\n- Auto-scaling capabilities\n- Integration with cloud services",
      "keywords": ["load balancer", "Layer 4", "Layer 7", "TCP", "HTTP", "round robin", "least connections", "IP hash", "SSL termination", "session affinity", "HAProxy", "NGINX", "microservices", "high availability", "traffic distribution"],
      "difficulty": "easy"
    },
    {
      "id": 3006,
      "tag": "systems_design",
      "question": "Describe different caching strategies and when to use each one.",
      "answer": "**Cache-Aside (Lazy Loading):**\nApplication manages cache explicitly - checks cache first, loads from database on miss.\n\n**Process:**\n1. Check cache for data\n2. If cache miss, load from database\n3. Store data in cache\n4. Return data to client\n\n**Pros:** Simple to implement, cache only contains requested data\n**Cons:** Initial request latency on cache miss, potential for stale data\n**Use Cases:** Read-heavy applications, infrequently accessed data\n\n**Write-Through:**\nData is written to cache and database simultaneously.\n\n**Process:**\n1. Write data to cache\n2. Write data to database\n3. Confirm write completion\n\n**Pros:** Strong consistency, no data loss\n**Cons:** Higher write latency, unnecessary cache writes\n**Use Cases:** Applications requiring strong consistency\n\n**Write-Behind (Write-Back):**\nData is written to cache immediately, database updated asynchronously.\n\n**Process:**\n1. Write data to cache\n2. Acknowledge write to client\n3. Asynchronously update database\n\n**Pros:** Low write latency, reduced database load\n**Cons:** Risk of data loss, complex implementation\n**Use Cases:** Write-heavy applications, acceptable eventual consistency\n\n**Write-Around:**\nData is written directly to database, bypassing cache.\n\n**Pros:** Prevents cache pollution from infrequently accessed writes\n**Cons:** Recent writes not available in cache\n**Use Cases:** Applications with more reads than writes\n\n**Cache Levels:**\n- **Browser Cache:** Client-side caching\n- **CDN:** Geographic distribution\n- **Application Cache:** In-memory caching (Redis, Memcached)\n- **Database Cache:** Query result caching",
      "keywords": ["caching strategies", "cache-aside", "write-through", "write-behind", "write-around", "lazy loading", "cache miss", "cache hit", "eventual consistency", "strong consistency", "Redis", "Memcached", "CDN", "browser cache", "data consistency"],
      "difficulty": "easy"
    },
    {
      "id": 3007,
      "tag": "systems_design",
      "question": "What are microservices and what are their advantages and disadvantages compared to monolithic architecture?",
      "answer": "**Microservices Architecture:**\nA design approach where applications are built as a collection of small, independent services that communicate over well-defined APIs.\n\n**Key Characteristics:**\n- Single responsibility per service\n- Independently deployable\n- Technology agnostic\n- Decentralized governance\n- Failure isolation\n\n**Advantages:**\n\n**1. Scalability:**\n- Scale individual services based on demand\n- Resource optimization for specific components\n- Independent performance tuning\n\n**2. Development Flexibility:**\n- Different teams can work independently\n- Technology diversity (polyglot programming)\n- Faster development cycles\n- Easier to understand individual services\n\n**3. Fault Tolerance:**\n- Failure in one service doesn't bring down entire system\n- Circuit breaker patterns\n- Graceful degradation\n\n**4. Deployment:**\n- Independent deployment cycles\n- Reduced blast radius of changes\n- Easier rollbacks\n\n**Disadvantages:**\n\n**1. Complexity:**\n- Distributed system challenges\n- Network latency and reliability\n- Data consistency across services\n- Service discovery and configuration\n\n**2. Operational Overhead:**\n- More moving parts to monitor\n- Distributed debugging and logging\n- Service mesh complexity\n- Container orchestration\n\n**3. Data Management:**\n- No ACID transactions across services\n- Eventual consistency challenges\n- Data duplication\n\n**When to Use Microservices:**\n- Large, complex applications\n- Multiple development teams\n- Need for independent scaling\n- Different technology requirements\n\n**When to Use Monoliths:**\n- Small applications or teams\n- Simple deployment requirements\n- Strong consistency needs\n- Rapid prototyping",
      "keywords": ["microservices", "monolithic architecture", "service-oriented architecture", "independent deployment", "fault tolerance", "distributed systems", "polyglot programming", "circuit breaker", "service discovery", "eventual consistency", "ACID transactions", "container orchestration", "service mesh", "scalability"],
      "difficulty": "easy"
    },
    {
      "id": 3008,
      "tag": "systems_design",
      "question": "Explain the difference between SQL and NoSQL databases. When would you choose each?",
      "answer": "**SQL Databases (Relational):**\nUse structured query language and follow ACID properties with predefined schemas.\n\n**Characteristics:**\n- Structured data with relationships\n- ACID transactions\n- Strong consistency\n- Schema enforcement\n- Mature ecosystem and tooling\n\n**Examples:** PostgreSQL, MySQL, Oracle, SQL Server\n\n**Advantages:**\n- Strong data integrity and consistency\n- Complex queries and joins\n- Standardized SQL language\n- Mature ecosystem\n- ACID compliance\n\n**Disadvantages:**\n- Rigid schema changes\n- Vertical scaling limitations\n- Complex sharding\n- Performance bottlenecks with large datasets\n\n**NoSQL Databases:**\nNon-relational databases designed for specific data models and use cases.\n\n**Types:**\n\n**1. Document Stores (MongoDB, CouchDB):**\n- Semi-structured data (JSON, BSON)\n- Flexible schema\n- Good for content management, catalogs\n\n**2. Key-Value Stores (Redis, DynamoDB):**\n- Simple key-value pairs\n- High performance\n- Good for caching, sessions\n\n**3. Column-Family (Cassandra, HBase):**\n- Wide column storage\n- Time-series data\n- Good for analytics, IoT data\n\n**4. Graph Databases (Neo4j, Amazon Neptune):**\n- Relationships and connections\n- Good for social networks, recommendations\n\n**NoSQL Advantages:**\n- Horizontal scaling\n- Flexible schema\n- High performance for specific use cases\n- Better handling of unstructured data\n\n**NoSQL Disadvantages:**\n- Eventual consistency\n- Limited query capabilities\n- Less mature tooling\n- No standardized query language\n\n**When to Use SQL:**\n- Complex relationships and transactions\n- Strong consistency requirements\n- Well-defined schema\n- Reporting and analytics\n\n**When to Use NoSQL:**\n- Rapid development and iteration\n- Horizontal scaling needs\n- Unstructured or semi-structured data\n- Specific performance requirements",
      "keywords": ["SQL databases", "NoSQL databases", "ACID transactions", "relational databases", "document stores", "key-value stores", "column-family", "graph databases", "horizontal scaling", "eventual consistency", "schema flexibility", "MongoDB", "Redis", "Cassandra", "PostgreSQL"],
      "difficulty": "easy"
    },
    {
      "id": 3009,
      "tag": "systems_design",
      "question": "What is database sharding and what are the different sharding strategies?",
      "answer": "**Database Sharding:**\nA horizontal partitioning technique that splits large databases into smaller, faster, and more manageable pieces called shards.\n\n**Why Sharding is Needed:**\n- Overcome single database performance limits\n- Distribute load across multiple machines\n- Improve query response times\n- Handle large datasets that don't fit on one server\n- Increase overall system throughput\n\n**Sharding Strategies:**\n\n**1. Range-Based Sharding:**\nData is partitioned based on ranges of a key value.\n\n**Example:** Users A-M on Shard 1, N-Z on Shard 2\n**Pros:** Simple to implement, range queries efficient\n**Cons:** Uneven distribution, hotspots possible\n\n**2. Hash-Based Sharding:**\nUses a hash function to determine which shard stores the data.\n\n**Example:** hash(user_id) % number_of_shards\n**Pros:** Even distribution, good load balancing\n**Cons:** Range queries require multiple shards, resharding is complex\n\n**3. Directory-Based Sharding:**\nMaintains a lookup table that maps keys to shards.\n\n**Pros:** Flexible routing, dynamic shard assignment\n**Cons:** Additional complexity, lookup service becomes bottleneck\n\n**4. Consistent Hashing:**\nDistributes data using a hash ring to minimize redistribution when adding/removing shards.\n\n**Pros:** Minimal data movement during scaling\n**Cons:** Complex implementation, potential uneven distribution\n\n**Challenges with Sharding:**\n- **Cross-shard queries:** Joins across shards are expensive\n- **Rebalancing:** Moving data when adding/removing shards\n- **Hotspots:** Uneven load distribution\n- **Complexity:** Application must be shard-aware\n- **Transactions:** ACID properties across shards\n\n**Best Practices:**\n- Choose shard key carefully\n- Monitor shard performance and size\n- Plan for future growth\n- Implement proper error handling\n- Consider using database-native sharding solutions",
      "keywords": ["database sharding", "horizontal partitioning", "shard key", "range-based sharding", "hash-based sharding", "consistent hashing", "directory-based sharding", "hotspots", "cross-shard queries", "rebalancing", "data distribution", "scalability", "performance optimization"],
      "difficulty": "easy"
    },
    {
      "id": 3010,
      "tag": "systems_design",
      "question": "What is a Content Delivery Network (CDN) and how does it improve performance?",
      "answer": "**Content Delivery Network (CDN):**\nA geographically distributed network of servers that cache and deliver content to users from the nearest location.\n\n**How CDNs Work:**\n1. Content is cached on edge servers worldwide\n2. User requests are routed to nearest edge server\n3. If content exists, it's served immediately (cache hit)\n4. If not, content is fetched from origin server (cache miss)\n5. Content is cached for future requests\n\n**Performance Benefits:**\n\n**1. Reduced Latency:**\n- Geographic proximity to users\n- Shorter network paths\n- Faster time to first byte (TTFB)\n\n**2. Improved Throughput:**\n- Multiple edge servers handle traffic\n- Reduces load on origin servers\n- Better bandwidth utilization\n\n**3. Enhanced Availability:**\n- Redundancy across multiple locations\n- Failover capabilities\n- Origin server protection\n\n**Types of Content Cached:**\n- **Static Content:** Images, CSS, JavaScript, videos\n- **Dynamic Content:** API responses, personalized content\n- **Streaming Media:** Live and on-demand video\n\n**CDN Features:**\n\n**1. Cache Control:**\n- TTL (Time To Live) settings\n- Cache invalidation\n- Edge-side includes (ESI)\n\n**2. Security:**\n- DDoS protection\n- Web Application Firewall (WAF)\n- SSL/TLS termination\n\n**3. Optimization:**\n- Image compression and optimization\n- Minification of CSS/JavaScript\n- HTTP/2 and HTTP/3 support\n\n**4. Analytics:**\n- Real-time traffic monitoring\n- Performance metrics\n- Geographic usage patterns\n\n**Popular CDN Providers:**\n- Cloudflare\n- Amazon CloudFront\n- Akamai\n- Google Cloud CDN\n- Azure CDN\n\n**Use Cases:**\n- E-commerce websites\n- Media streaming platforms\n- Global web applications\n- API acceleration\n- Software distribution\n\n**Best Practices:**\n- Set appropriate cache headers\n- Optimize cache hit ratios\n- Monitor cache performance\n- Use multiple CDNs for redundancy",
      "keywords": ["CDN", "content delivery network", "edge servers", "cache hit", "cache miss", "latency reduction", "geographic distribution", "origin server", "TTL", "cache invalidation", "DDoS protection", "SSL termination", "image optimization", "CloudFront", "Cloudflare"],
      "difficulty": "easy"
    },
    {
      "id": 3011,
      "tag": "systems_design",
      "question": "Explain the concept of eventual consistency and provide examples of where it's used.",
      "answer": "**Eventual Consistency:**\nA consistency model where the system guarantees that if no new updates are made to a data item, eventually all accesses to that item will return the last updated value.\n\n**Key Characteristics:**\n- No immediate consistency guarantees\n- Updates propagate asynchronously\n- Temporary inconsistencies are acceptable\n- System remains available during updates\n- Conflicts are resolved over time\n\n**How It Works:**\n1. Write operations complete immediately on local replica\n2. Changes propagate to other replicas asynchronously\n3. Different replicas may have different values temporarily\n4. Eventually, all replicas converge to the same state\n\n**Advantages:**\n- High availability and partition tolerance\n- Better performance for distributed systems\n- Lower latency for write operations\n- Scales well across geographic regions\n- Supports offline operations\n\n**Disadvantages:**\n- Temporary data inconsistencies\n- Complex conflict resolution\n- Application must handle inconsistent reads\n- Difficult to reason about system state\n\n**Real-World Examples:**\n\n**1. DNS System:**\n- DNS updates propagate globally over time\n- Different DNS servers may return different values\n- Eventually, all servers have the updated record\n\n**2. Social Media Platforms:**\n- Like counts and comments may be temporarily inconsistent\n- Friend lists sync across data centers\n- User timelines eventually show all posts\n\n**3. E-commerce Inventory:**\n- Product availability updates across regions\n- Shopping cart synchronization\n- Price updates propagation\n\n**4. Distributed Databases:**\n- **Amazon DynamoDB:** Eventually consistent reads by default\n- **Cassandra:** Tunable consistency levels\n- **MongoDB:** Replica set lag\n\n**5. Cloud Storage:**\n- File synchronization services (Dropbox, Google Drive)\n- Cross-region data replication\n- Backup and disaster recovery\n\n**Conflict Resolution Strategies:**\n- Last-writer-wins\n- Vector clocks\n- CRDT (Conflict-free Replicated Data Types)\n- Application-specific resolution logic\n\n**When to Use:**\n- Global applications requiring high availability\n- Systems where temporary inconsistency is acceptable\n- Write-heavy workloads\n- Offline-capable applications",
      "keywords": ["eventual consistency", "distributed systems", "asynchronous replication", "conflict resolution", "high availability", "partition tolerance", "DNS propagation", "replica synchronization", "vector clocks", "CRDT", "last-writer-wins", "DynamoDB", "Cassandra", "data convergence", "consistency models"],
      "difficulty": "easy"
    },
    {
      "id": 3012,
      "tag": "systems_design",
      "question": "What are message queues and how do they improve system architecture?",
      "answer": "**Message Queues:**\nAsynchronous communication mechanisms that enable decoupled interaction between different parts of a system by storing messages in a queue until they can be processed.\n\n**Core Components:**\n- **Producer:** Sends messages to the queue\n- **Queue:** Stores messages temporarily\n- **Consumer:** Receives and processes messages\n- **Broker:** Manages the queue infrastructure\n\n**Key Benefits:**\n\n**1. Decoupling:**\n- Producers and consumers operate independently\n- Systems can evolve separately\n- Reduced tight dependencies\n\n**2. Scalability:**\n- Multiple consumers can process messages in parallel\n- Easy to add more workers for high load\n- Load balancing across consumers\n\n**3. Reliability:**\n- Messages persist until successfully processed\n- Retry mechanisms for failed processing\n- Dead letter queues for problematic messages\n\n**4. Asynchronous Processing:**\n- Non-blocking operations\n- Better user experience\n- Improved system responsiveness\n\n**Types of Message Queues:**\n\n**1. Point-to-Point:**\n- One producer, one consumer\n- Message consumed once\n- Examples: Amazon SQS, Azure Service Bus\n\n**2. Publish-Subscribe:**\n- One producer, multiple subscribers\n- Message copied to all subscribers\n- Examples: Apache Kafka, Redis Pub/Sub\n\n**3. Priority Queues:**\n- Messages processed based on priority\n- High-priority messages processed first\n\n**Popular Message Queue Systems:**\n- **Apache Kafka:** High-throughput, distributed streaming\n- **RabbitMQ:** Flexible routing, reliable delivery\n- **Amazon SQS:** Managed service, simple integration\n- **Redis:** In-memory, fast processing\n- **Apache Pulsar:** Multi-tenant, geo-replication\n\n**Use Cases:**\n- **Email Processing:** Queue emails for batch sending\n- **Image Processing:** Resize images asynchronously\n- **Order Processing:** Handle e-commerce order workflows\n- **Log Processing:** Aggregate and analyze logs\n- **Microservices Communication:** Inter-service messaging\n\n**Best Practices:**\n- Design idempotent message handlers\n- Implement proper error handling\n- Monitor queue lengths and processing times\n- Use appropriate message persistence settings\n- Plan for message ordering requirements",
      "keywords": ["message queues", "asynchronous communication", "producer", "consumer", "message broker", "decoupling", "scalability", "publish-subscribe", "point-to-point", "Apache Kafka", "RabbitMQ", "Amazon SQS", "dead letter queue", "idempotent processing", "microservices"],
      "difficulty": "easy"
    },
    {
      "id": 3013,
      "tag": "systems_design",
      "question": "What is API rate limiting and what strategies can be used to implement it?",
      "answer": "**API Rate Limiting:**\nA technique to control the rate of requests that clients can make to an API within a specified time window, preventing abuse and ensuring fair resource usage.\n\n**Why Rate Limiting is Important:**\n- Prevent DDoS attacks and abuse\n- Ensure fair usage among clients\n- Protect backend systems from overload\n- Maintain service quality and availability\n- Control costs and resource consumption\n\n**Rate Limiting Strategies:**\n\n**1. Token Bucket Algorithm:**\n- Bucket holds tokens that replenish at fixed rate\n- Each request consumes a token\n- Allows burst traffic up to bucket capacity\n- Smooth long-term rate limiting\n\n**Pros:** Handles bursts well, flexible\n**Cons:** More complex to implement\n\n**2. Leaky Bucket Algorithm:**\n- Requests enter bucket and leak out at fixed rate\n- Overflow requests are dropped\n- Smooths out irregular traffic patterns\n\n**Pros:** Consistent output rate, simple concept\n**Cons:** Doesn't handle bursts well\n\n**3. Fixed Window Counter:**\n- Count requests in fixed time windows\n- Reset counter at window boundaries\n- Simple to implement\n\n**Pros:** Easy implementation, low memory usage\n**Cons:** Burst issues at window boundaries\n\n**4. Sliding Window Log:**\n- Track timestamp of each request\n- Count requests in sliding time window\n- Most accurate but memory intensive\n\n**Pros:** Precise control, no boundary issues\n**Cons:** High memory usage, complex\n\n**5. Sliding Window Counter:**\n- Combination of fixed window and sliding window\n- Estimates current window based on previous window\n- Good balance of accuracy and efficiency\n\n**Implementation Considerations:**\n\n**1. Rate Limiting Scope:**\n- Per IP address\n- Per user/API key\n- Per endpoint\n- Global limits\n\n**2. Response Handling:**\n- Return 429 (Too Many Requests) status\n- Include retry-after headers\n- Provide clear error messages\n- Queue or drop exceeded requests\n\n**3. Storage Options:**\n- In-memory (Redis, Memcached)\n- Database-based\n- Distributed counters\n\n**4. Rate Limit Headers:**\n- X-RateLimit-Limit: Maximum requests allowed\n- X-RateLimit-Remaining: Requests remaining\n- X-RateLimit-Reset: When limit resets\n\n**Advanced Features:**\n- Different limits for different user tiers\n- Dynamic rate limits based on system load\n- Whitelist/blacklist functionality\n- Geographic-based limits",
      "keywords": ["API rate limiting", "token bucket", "leaky bucket", "fixed window", "sliding window", "DDoS protection", "429 status code", "burst handling", "rate limit headers", "Redis", "API gateway", "throttling", "request quota", "abuse prevention", "traffic shaping"],
      "difficulty": "easy"
    },
    {
      "id": 3014,
      "tag": "systems_design",
      "question": "Explain the differences between synchronous and asynchronous communication in distributed systems.",
      "answer": "**Synchronous Communication:**\nThe sender waits for a response from the receiver before continuing execution.\n\n**Characteristics:**\n- Blocking operation\n- Request-response pattern\n- Immediate feedback\n- Tight coupling between services\n- Real-time interaction\n\n**Examples:**\n- HTTP REST API calls\n- gRPC calls\n- Database queries\n- Synchronous RPC\n\n**Advantages:**\n- Simple to understand and implement\n- Immediate error handling\n- Strong consistency guarantees\n- Easy debugging and testing\n- Natural request-response flow\n\n**Disadvantages:**\n- Performance bottlenecks\n- Cascading failures\n- Lower fault tolerance\n- Resource blocking\n- Poor scalability under high load\n\n**Asynchronous Communication:**\nThe sender sends a message and continues execution without waiting for a response.\n\n**Characteristics:**\n- Non-blocking operation\n- Fire-and-forget or eventual response\n- Loose coupling between services\n- Event-driven architecture\n- Better fault isolation\n\n**Examples:**\n- Message queues (Kafka, RabbitMQ)\n- Event streaming\n- Webhooks\n- Email notifications\n- Background job processing\n\n**Advantages:**\n- Better performance and throughput\n- Improved fault tolerance\n- Higher scalability\n- Decoupled services\n- Can handle temporal failures\n\n**Disadvantages:**\n- Complex error handling\n- Eventual consistency\n- Harder to debug\n- Message ordering challenges\n- Potential message loss\n\n**When to Use Synchronous:**\n- User-facing operations requiring immediate response\n- Operations requiring strong consistency\n- Simple CRUD operations\n- Authentication and authorization\n- Real-time data validation\n\n**When to Use Asynchronous:**\n- Long-running processes\n- Batch operations\n- Event notifications\n- Data replication\n- Inter-service communication in microservices\n- Background tasks\n\n**Hybrid Approaches:**\n- **Request-Reply Pattern:** Async request with callback\n- **Saga Pattern:** Orchestrated async transactions\n- **CQRS:** Separate read/write models\n- **Event Sourcing:** Event-driven state changes\n\n**Best Practices:**\n- Choose based on business requirements\n- Consider failure scenarios\n- Implement proper monitoring\n- Design for idempotency\n- Plan for message delivery guarantees",
      "keywords": ["synchronous communication", "asynchronous communication", "blocking", "non-blocking", "request-response", "message queues", "event-driven architecture", "fault tolerance", "scalability", "loose coupling", "tight coupling", "eventual consistency", "saga pattern", "CQRS", "event sourcing"],
      "difficulty": "easy"
    },
    {
      "id": 3015,
      "tag": "systems_design",
      "question": "What is the Circuit Breaker pattern and how does it improve system resilience?",
      "answer": "**Circuit Breaker Pattern:**\nA design pattern that prevents cascading failures in distributed systems by monitoring service calls and 'breaking the circuit' when failure rates exceed thresholds.\n\n**How It Works:**\nThe circuit breaker acts like an electrical circuit breaker, with three states:\n\n**1. Closed State (Normal Operation):**\n- Requests pass through normally\n- Success/failure counts are tracked\n- If failure rate exceeds threshold, switch to Open\n\n**2. Open State (Circuit Breaker Activated):**\n- All requests fail immediately (fail-fast)\n- No calls made to the failing service\n- After timeout period, switch to Half-Open\n\n**3. Half-Open State (Testing Recovery):**\n- Limited number of test requests allowed\n- If requests succeed, return to Closed\n- If requests fail, return to Open\n\n**Key Components:**\n\n**1. Failure Threshold:**\n- Number or percentage of failures to trigger opening\n- Time window for measuring failures\n\n**2. Recovery Timeout:**\n- How long to wait before testing recovery\n- Exponential backoff for repeated failures\n\n**3. Success Threshold:**\n- Number of successful requests needed to close circuit\n- Gradual recovery verification\n\n**Benefits:**\n\n**1. Prevents Cascading Failures:**\n- Stops failures from propagating upstream\n- Protects healthy services from overload\n- Maintains system stability\n\n**2. Improves User Experience:**\n- Fast failure response instead of timeouts\n- Graceful degradation capabilities\n- Predictable error handling\n\n**3. Resource Protection:**\n- Prevents resource exhaustion\n- Reduces unnecessary network calls\n- Allows failing services to recover\n\n**4. Monitoring and Alerting:**\n- Clear visibility into service health\n- Automatic failure detection\n- Performance metrics collection\n\n**Implementation Considerations:**\n\n**1. Fallback Strategies:**\n- Return cached data\n- Default responses\n- Alternative service calls\n- Degraded functionality\n\n**2. Configuration:**\n- Appropriate failure thresholds\n- Recovery timeout values\n- Monitoring intervals\n\n**3. Testing:**\n- Chaos engineering\n- Failure injection testing\n- Load testing scenarios\n\n**Popular Implementations:**\n- **Netflix Hystrix** (Java)\n- **Polly** (.NET)\n- **circuit-breaker-js** (Node.js)\n- **go-circuit-breaker** (Go)\n- **Istio** (Service mesh)\n\n**Best Practices:**\n- Configure appropriate thresholds based on SLAs\n- Implement meaningful fallback responses\n- Monitor circuit breaker metrics\n- Test failure scenarios regularly\n- Use bulkhead pattern for resource isolation",
      "keywords": ["circuit breaker pattern", "fail-fast", "cascading failures", "system resilience", "failure threshold", "recovery timeout", "half-open state", "graceful degradation", "fallback strategy", "Netflix Hystrix", "chaos engineering", "service mesh", "bulkhead pattern", "fault tolerance", "distributed systems"],
      "difficulty": "easy"
    },
    {
      "id": 3016,
      "tag": "systems_design",
      "question": "What are the key principles of RESTful API design?",
      "answer": "**REST (Representational State Transfer):**\nAn architectural style for designing networked applications based on stateless communication and standard HTTP methods.\n\n**Core Principles:**\n\n**1. Stateless:**\n- Each request contains all information needed to process it\n- Server doesn't store client context between requests\n- Improves scalability and reliability\n\n**2. Client-Server Architecture:**\n- Clear separation of concerns\n- Client handles user interface\n- Server manages data storage and processing\n- Independent evolution of client and server\n\n**3. Cacheable:**\n- Responses should be explicitly marked as cacheable or non-cacheable\n- Improves performance and scalability\n- Reduces server load\n\n**4. Uniform Interface:**\n- Consistent way to interact with resources\n- Simplifies architecture\n- Enables independent evolution\n\n**5. Layered System:**\n- Architecture can be composed of multiple layers\n- Each layer only knows about immediate layers\n- Enables load balancers, proxies, gateways\n\n**6. Code on Demand (Optional):**\n- Server can send executable code to client\n- Rarely used in practice\n\n**RESTful Design Best Practices:**\n\n**1. Resource-Based URLs:**\n- Use nouns, not verbs: `/users/123` not `/getUser/123`\n- Hierarchical structure: `/users/123/orders/456`\n- Plural nouns for collections: `/users`\n\n**2. HTTP Methods:**\n- **GET:** Retrieve resources (idempotent, safe)\n- **POST:** Create new resources\n- **PUT:** Update/replace entire resource (idempotent)\n- **PATCH:** Partial updates\n- **DELETE:** Remove resources (idempotent)\n\n**3. HTTP Status Codes:**\n- **200 OK:** Successful GET, PUT, PATCH\n- **201 Created:** Successful POST\n- **204 No Content:** Successful DELETE\n- **400 Bad Request:** Client error\n- **401 Unauthorized:** Authentication required\n- **404 Not Found:** Resource doesn't exist\n- **500 Internal Server Error:** Server error\n\n**4. Content Negotiation:**\n- Use Accept header for response format\n- Support multiple formats (JSON, XML)\n- Version APIs appropriately\n\n**5. Error Handling:**\n- Consistent error response format\n- Meaningful error messages\n- Appropriate HTTP status codes\n\n**6. Pagination and Filtering:**\n- Limit large result sets\n- Provide pagination metadata\n- Support filtering and sorting parameters\n\n**Example RESTful API:**\n```\nGET /api/v1/users              # Get all users\nGET /api/v1/users/123          # Get specific user\nPOST /api/v1/users             # Create new user\nPUT /api/v1/users/123          # Update user\nDELETE /api/v1/users/123       # Delete user\nGET /api/v1/users/123/orders   # Get user's orders\n```",
      "keywords": ["REST", "RESTful API", "stateless", "HTTP methods", "resource-based URLs", "HTTP status codes", "idempotent", "content negotiation", "API versioning", "pagination", "uniform interface", "client-server architecture", "cacheable", "layered system", "error handling"],
      "difficulty": "easy"
    },
    {
      "id": 3017,
      "tag": "systems_design",
      "question": "Explain database indexing and its impact on query performance.",
      "answer": "**Database Indexing:**\nA data structure that improves query performance by creating shortcuts to quickly locate specific rows in a table without scanning the entire dataset.\n\n**How Indexes Work:**\n- Create a separate structure pointing to table rows\n- Organized for fast searching (B-trees, hash tables)\n- Map index keys to row locations\n- Enable database engine to find data quickly\n\n**Types of Indexes:**\n\n**1. Primary Index (Clustered):**\n- Determines physical storage order of data\n- One per table (usually on primary key)\n- Data pages are stored in key order\n- Fastest for range queries\n\n**2. Secondary Index (Non-clustered):**\n- Separate structure pointing to data rows\n- Multiple allowed per table\n- Doesn't affect physical data storage\n- Additional lookup required to get data\n\n**3. Unique Index:**\n- Ensures uniqueness of indexed columns\n- Automatically created for primary keys\n- Prevents duplicate values\n\n**4. Composite Index:**\n- Index on multiple columns\n- Column order matters for query optimization\n- Useful for multi-column WHERE clauses\n\n**5. Partial Index:**\n- Index on subset of rows meeting conditions\n- Smaller size, faster for specific queries\n- Good for sparse data\n\n**Performance Impact:**\n\n**Query Performance Benefits:**\n- **SELECT:** Dramatically faster lookups\n- **WHERE clauses:** Quick filtering\n- **ORDER BY:** Pre-sorted data\n- **JOIN operations:** Efficient matching\n- **MIN/MAX:** Instant results with proper index\n\n**Write Performance Costs:**\n- **INSERT:** Must update all relevant indexes\n- **UPDATE:** May need to update index entries\n- **DELETE:** Remove from indexes\n- Additional storage overhead\n- Index maintenance during operations\n\n**Index Selection Strategies:**\n\n**1. Query Analysis:**\n- Identify frequently used WHERE conditions\n- Look for JOIN columns\n- Consider ORDER BY clauses\n- Analyze query execution plans\n\n**2. Composite Index Guidelines:**\n- Put most selective columns first\n- Consider query patterns\n- Avoid too many columns (diminishing returns)\n\n**3. Monitoring:**\n- Track query performance metrics\n- Identify unused indexes\n- Monitor index fragmentation\n- Analyze execution plans regularly\n\n**Best Practices:**\n- Don't over-index (affects write performance)\n- Drop unused indexes\n- Regular index maintenance and rebuilding\n- Consider covering indexes for frequently accessed columns\n- Use database-specific optimization tools\n\n**Common Pitfalls:**\n- Indexing low-selectivity columns\n- Too many indexes on write-heavy tables\n- Ignoring composite index column order\n- Not maintaining indexes over time",
      "keywords": ["database indexing", "B-tree", "clustered index", "non-clustered index", "primary index", "secondary index", "composite index", "query optimization", "execution plan", "index selectivity", "covering index", "index fragmentation", "query performance", "write performance", "index maintenance"],
      "difficulty": "easy"
    },
    {
      "id": 3018,
      "tag": "systems_design",
      "question": "What is database normalization and what are the different normal forms?",
      "answer": "**Database Normalization:**\nThe process of organizing database tables to reduce data redundancy and improve data integrity by eliminating insertion, update, and deletion anomalies.\n\n**Goals of Normalization:**\n- Eliminate redundant data\n- Ensure data dependencies make sense\n- Reduce storage space\n- Prevent data inconsistencies\n- Improve data integrity\n\n**Normal Forms:**\n\n**First Normal Form (1NF):**\n- Each table cell contains only atomic (indivisible) values\n- No repeating groups or arrays\n- Each column contains values of the same type\n- Each row is unique\n\n**Example Violation:**\nCustomer table with 'Phone' column containing \"123-456-7890, 987-654-3210\"\n\n**Solution:** Create separate rows or table for each phone number\n\n**Second Normal Form (2NF):**\n- Must be in 1NF\n- All non-key attributes are fully functionally dependent on the primary key\n- Eliminates partial dependencies\n\n**Example Violation:**\nOrder table with composite key (OrderID, ProductID) but CustomerName depends only on OrderID\n\n**Solution:** Move CustomerName to separate Orders table\n\n**Third Normal Form (3NF):**\n- Must be in 2NF\n- No transitive dependencies\n- Non-key attributes should not depend on other non-key attributes\n\n**Example Violation:**\nEmployee table where City depends on ZipCode, not EmployeeID\n\n**Solution:** Create separate Location table\n\n**Boyce-Codd Normal Form (BCNF):**\n- Stricter version of 3NF\n- For every functional dependency A â†’ B, A must be a superkey\n- Handles cases where 3NF still has anomalies\n\n**Fourth Normal Form (4NF):**\n- Must be in BCNF\n- No multi-valued dependencies\n- Eliminates situations where one attribute determines multiple independent sets of values\n\n**Fifth Normal Form (5NF):**\n- Must be in 4NF\n- No join dependencies\n- Table cannot be decomposed into smaller tables without loss of information\n\n**Benefits of Normalization:**\n- Reduced data redundancy\n- Improved data consistency\n- Easier maintenance\n- Better data integrity\n- Reduced storage requirements\n- Cleaner table structure\n\n**Drawbacks of Normalization:**\n- Increased number of tables\n- More complex queries (more JOINs)\n- Potential performance impact\n- Increased complexity for developers\n\n**Denormalization:**\nIntentionally introducing redundancy to improve performance\n\n**When to Denormalize:**\n- Read-heavy applications\n- Performance is critical\n- Complex reporting requirements\n- Data warehouse scenarios\n- Caching frequently accessed data\n\n**Best Practices:**\n- Normalize to 3NF as a starting point\n- Consider BCNF for critical applications\n- Selectively denormalize for performance\n- Document design decisions\n- Balance normalization with performance needs\n- Use views to present denormalized data\n- Monitor query performance and adjust as needed",
      "keywords": ["database normalization", "normal forms", "1NF", "2NF", "3NF", "BCNF", "functional dependency", "data redundancy", "data integrity", "partial dependency", "transitive dependency", "denormalization", "data anomalies", "database design", "relational database"],
      "difficulty": "easy"
    },
    {
      "id": 3019,
      "tag": "systems_design",
      "question": "What are the key considerations for designing secure APIs?",
      "answer": "**API Security Fundamentals:**\nSecuring APIs requires implementing multiple layers of protection to prevent unauthorized access, data breaches, and malicious attacks.\n\n**Authentication and Authorization:**\n\n**1. Authentication Methods:**\n- **API Keys:** Simple but limited security\n- **JWT Tokens:** Stateless, includes claims\n- **OAuth 2.0:** Industry standard for authorization\n- **Basic Auth:** Username/password (use with HTTPS only)\n- **Certificate-based:** Mutual TLS authentication\n\n**2. Authorization Strategies:**\n- **Role-based Access Control (RBAC)**\n- **Attribute-based Access Control (ABAC)**\n- **Scope-based permissions**\n- **Resource-level authorization**\n\n**Data Protection:**\n\n**1. Encryption:**\n- **HTTPS/TLS:** Encrypt data in transit\n- **Database encryption:** Protect data at rest\n- **End-to-end encryption:** Sensitive data protection\n- **Field-level encryption:** Granular protection\n\n**2. Data Validation:**\n- **Input validation:** Prevent injection attacks\n- **Output encoding:** Prevent XSS\n- **Schema validation:** Ensure data integrity\n- **Sanitization:** Clean user inputs\n\n**Security Headers:**\n- **CORS:** Control cross-origin requests\n- **CSP:** Content Security Policy\n- **HSTS:** HTTP Strict Transport Security\n- **X-Frame-Options:** Prevent clickjacking\n- **X-Content-Type-Options:** Prevent MIME sniffing\n\n**Rate Limiting and Throttling:**\n- **API rate limits:** Prevent abuse\n- **Request throttling:** Control traffic flow\n- **IP-based limiting:** Block malicious IPs\n- **User-based quotas:** Fair usage policies\n\n**API Security Best Practices:**\n\n**1. Least Privilege Principle:**\n- Grant minimum necessary permissions\n- Implement fine-grained access controls\n- Regular permission audits\n- Time-limited access tokens\n\n**2. Error Handling:**\n- Don't expose sensitive information in errors\n- Generic error messages for security failures\n- Proper HTTP status codes\n- Security event logging\n\n**3. API Versioning:**\n- Maintain backward compatibility\n- Deprecate old versions securely\n- Security updates across versions\n- Clear migration paths\n\n**4. Monitoring and Logging:**\n- **Security event logging**\n- **Anomaly detection**\n- **Real-time monitoring**\n- **Audit trails**\n- **Performance monitoring**\n\n**Common API Vulnerabilities:**\n\n**1. OWASP API Security Top 10:**\n- Broken Object Level Authorization\n- Broken User Authentication\n- Excessive Data Exposure\n- Lack of Resources & Rate Limiting\n- Broken Function Level Authorization\n\n**2. Prevention Strategies:**\n- Regular security testing\n- Penetration testing\n- Code reviews\n- Dependency scanning\n- Static application security testing (SAST)\n\n**Implementation Checklist:**\n- Use HTTPS everywhere\n- Implement proper authentication\n- Validate all inputs\n- Apply rate limiting\n- Log security events\n- Regular security updates\n- API gateway implementation\n- Security testing in CI/CD",
      "keywords": ["API security", "authentication", "authorization", "OAuth 2.0", "JWT tokens", "HTTPS", "TLS encryption", "rate limiting", "CORS", "input validation", "OWASP", "security headers", "API gateway", "penetration testing", "security monitoring", "access control", "data protection"],
      "difficulty": "easy"
    },
    {
      "id": 3020,
      "tag": "systems_design",
      "question": "Explain the concept of data partitioning and its different strategies.",
      "answer": "**Data Partitioning:**\nThe process of dividing large datasets across multiple storage locations to improve performance, scalability, and manageability.\n\n**Why Partition Data:**\n- Improve query performance\n- Enable parallel processing\n- Reduce storage costs\n- Enhance scalability\n- Better maintenance and backup strategies\n- Distribute load across multiple systems\n\n**Partitioning Strategies:**\n\n**1. Horizontal Partitioning (Sharding):**\nSplit rows across multiple tables/databases based on criteria.\n\n**Methods:**\n- **Range Partitioning:** Based on value ranges (dates, IDs)\n- **Hash Partitioning:** Using hash function on partition key\n- **List Partitioning:** Explicit list of values per partition\n- **Round-robin:** Distribute rows evenly in cyclic manner\n\n**Example:** Partition user data by user_id ranges\n- Partition 1: user_id 1-1000000\n- Partition 2: user_id 1000001-2000000\n\n**2. Vertical Partitioning:**\nSplit columns across multiple tables based on access patterns.\n\n**Benefits:**\n- Separate frequently/infrequently accessed columns\n- Reduce I/O for queries needing few columns\n- Different storage strategies per partition\n- Security isolation\n\n**Example:** Split user table into profile and preferences tables\n\n**3. Functional Partitioning:**\nSeparate data by feature or service.\n\n**Characteristics:**\n- Each service owns its data\n- Aligns with microservices architecture\n- Clear service boundaries\n- Independent scaling\n\n**Example:** Separate databases for users, orders, inventory\n\n**Partitioning Considerations:**\n\n**1. Partition Key Selection:**\n- Choose key with good distribution\n- Consider query patterns\n- Avoid hotspots\n- Plan for future growth\n\n**2. Query Patterns:**\n- Single-partition queries are fastest\n- Cross-partition queries are expensive\n- Design schema to minimize cross-partition operations\n\n**3. Rebalancing:**\n- Adding/removing partitions\n- Data migration strategies\n- Minimal downtime approaches\n- Consistent hashing for dynamic partitioning\n\n**Challenges:**\n\n**1. Cross-Partition Operations:**\n- Joins across partitions are expensive\n- Distributed transactions complexity\n- Maintaining referential integrity\n- Aggregation queries\n\n**2. Partition Management:**\n- Monitoring partition sizes\n- Rebalancing when needed\n- Schema changes across partitions\n- Backup and recovery strategies\n\n**3. Application Complexity:**\n- Partition-aware application logic\n- Error handling for partition failures\n- Connection management\n- Data consistency challenges\n\n**Best Practices:**\n\n**1. Design Phase:**\n- Understand access patterns\n- Choose appropriate partitioning strategy\n- Plan for growth and rebalancing\n- Consider maintenance requirements\n\n**2. Implementation:**\n- Use database-native partitioning when possible\n- Implement monitoring and alerting\n- Design for partition failures\n- Test rebalancing procedures\n\n**3. Monitoring:**\n- Track partition sizes and growth\n- Monitor query performance across partitions\n- Identify hotspots and skewed data\n- Plan capacity based on trends\n\n**Tools and Technologies:**\n- PostgreSQL table partitioning\n- MySQL partitioning\n- MongoDB sharding\n- Apache Cassandra\n- Amazon DynamoDB\n- Google Cloud Spanner",
      "keywords": ["data partitioning", "horizontal partitioning", "vertical partitioning", "sharding", "range partitioning", "hash partitioning", "partition key", "cross-partition queries", "rebalancing", "consistent hashing", "functional partitioning", "data distribution", "hotspots", "partition management", "microservices"],
      "difficulty": "easy"
    },
    {
      "id": 3021,
      "tag": "systems_design",
      "question": "What is a service mesh and how does it benefit microservices architecture?",
      "answer": "**Service Mesh:**\nA dedicated infrastructure layer that handles service-to-service communication in microservices architectures, providing features like load balancing, security, and observability without requiring changes to application code.\n\n**Core Components:**\n\n**1. Data Plane:**\n- Network proxies (sidecars) deployed alongside each service\n- Handle all network traffic between services\n- Implement policies and collect telemetry\n- Examples: Envoy Proxy, Linkerd2-proxy\n\n**2. Control Plane:**\n- Manages and configures the proxies\n- Distributes policies and configuration\n- Collects telemetry and metrics\n- Provides APIs for management\n\n**Key Features:**\n\n**1. Traffic Management:**\n- **Load Balancing:** Multiple algorithms (round-robin, least connections)\n- **Circuit Breaking:** Prevent cascade failures\n- **Retries and Timeouts:** Improve reliability\n- **Traffic Splitting:** Canary deployments, A/B testing\n- **Routing Rules:** Header-based, geographic routing\n\n**2. Security:**\n- **Mutual TLS (mTLS):** Automatic encryption and authentication\n- **Service Identity:** Strong identity for each service\n- **Authorization Policies:** Fine-grained access control\n- **Certificate Management:** Automatic certificate rotation\n\n**3. Observability:**\n- **Distributed Tracing:** Request flow across services\n- **Metrics Collection:** Latency, throughput, error rates\n- **Access Logging:** Detailed request/response logs\n- **Service Topology:** Visualize service dependencies\n\n**4. Reliability:**\n- **Health Checking:** Automatic unhealthy instance removal\n- **Fault Injection:** Test system resilience\n- **Rate Limiting:** Protect services from overload\n- **Bulkhead Pattern:** Resource isolation\n\n**Benefits:**\n\n**1. Separation of Concerns:**\n- Application code focuses on business logic\n- Infrastructure concerns handled by service mesh\n- Language and framework agnostic\n- Simplified service development\n\n**2. Operational Consistency:**\n- Uniform policies across all services\n- Consistent security and observability\n- Centralized configuration management\n- Standardized deployment patterns\n\n**3. Enhanced Security:**\n- Zero-trust networking\n- Automatic encryption between services\n- Identity-based access control\n- Security policy enforcement\n\n**4. Improved Reliability:**\n- Automatic retries and circuit breaking\n- Load balancing and failover\n- Health checking and monitoring\n- Graceful degradation\n\n**Popular Service Mesh Solutions:**\n\n**1. Istio:**\n- Most feature-rich and popular\n- Strong security and policy features\n- Extensive ecosystem integration\n- Can be complex to operate\n\n**2. Linkerd:**\n- Lightweight and easy to use\n- Focus on simplicity and performance\n- Good for getting started\n- Rust-based data plane\n\n**3. Consul Connect:**\n- Part of HashiCorp Consul\n- Service discovery and mesh\n- Good for multi-platform deployments\n\n**4. AWS App Mesh:**\n- Managed service mesh for AWS\n- Integrates with AWS services\n- Based on Envoy Proxy\n\n**Implementation Considerations:**\n\n**1. Complexity:**\n- Additional operational overhead\n- Learning curve for teams\n- Debugging can be more complex\n- Resource consumption overhead\n\n**2. Performance:**\n- Additional network hop (proxy)\n- Latency overhead (typically minimal)\n- CPU and memory usage for sidecars\n\n**3. Migration Strategy:**\n- Gradual rollout approach\n- Start with observability features\n- Progressive security policy implementation\n- Team training and adoption\n\n**When to Use Service Mesh:**\n- Large number of microservices\n- Complex service interactions\n- Strong security requirements\n- Need for detailed observability\n- Multi-language/framework environment",
      "keywords": ["service mesh", "microservices", "sidecar proxy", "data plane", "control plane", "Istio", "Linkerd", "mTLS", "circuit breaker", "distributed tracing", "traffic management", "zero-trust", "Envoy proxy", "observability", "canary deployment", "load balancing"],
      "difficulty": "easy"
    },
    {
      "id": 3022,
      "tag": "systems_design",
      "question": "Design a real-time collaborative document editing system like Google Docs. Consider concurrency, conflict resolution, and scalability.",
      "answer": "**System Requirements:**\n- Real-time collaborative editing for multiple users\n- Support for millions of documents and concurrent users\n- Conflict resolution for simultaneous edits\n- Document versioning and history\n- Rich text formatting and commenting\n- Offline editing with sync\n- Sub-second latency for updates\n\n**Architecture Overview:**\n\n**1. Client Applications:**\n- **Web Application:** React/Angular with WebSocket connections\n- **Mobile Apps:** Native iOS/Android with real-time sync\n- **Rich Text Editor:** Custom editor with operational transforms\n- **Offline Support:** Local storage with conflict resolution\n\n**2. Real-time Communication Layer:**\n- **WebSocket Gateway:** Persistent connections for real-time updates\n- **Connection Management:** Handle user presence and connection state\n- **Message Routing:** Route operations to correct document sessions\n- **Load Balancing:** Distribute connections across multiple servers\n\n**3. Operational Transform Engine:**\n- **OT Algorithm:** Transform concurrent operations for consistency\n- **Operation Types:** Insert, Delete, Retain, Format operations\n- **State Vector:** Track document state across all clients\n- **Conflict Resolution:** Deterministic operation ordering\n\n**4. Document Service:**\n- **Document Management:** CRUD operations for documents\n- **Permission System:** Role-based access (owner, editor, viewer)\n- **Document Metadata:** Title, creation date, sharing settings\n- **Folder Structure:** Hierarchical organization\n\n**5. Collaboration Engine:**\n- **Session Management:** Track active editing sessions\n- **User Presence:** Show cursors and active users\n- **Comment System:** Threaded comments and suggestions\n- **Version Control:** Document history and snapshots\n\n**Data Storage:**\n\n**1. Document Store:**\n- **Primary Database:** PostgreSQL for document metadata\n- **Document Content:** MongoDB for rich text content and operations\n- **Version History:** Append-only log of operations\n- **Snapshots:** Periodic document snapshots for recovery\n\n**2. Real-time State:**\n- **Redis:** Active sessions, user presence, recent operations\n- **Operation Log:** Temporary storage for recent operations\n- **Cache:** Frequently accessed documents\n\n**3. File Storage:**\n- **Object Storage (S3):** Images, attachments, exports\n- **CDN:** Static assets and cached content\n- **Backup Storage:** Document backups and archival\n\n**Operational Transform Implementation:**\n\n**1. Operation Types:**\n```javascript\n// Insert operation\n{type: 'insert', position: 10, content: 'hello', author: 'user1'}\n\n// Delete operation\n{type: 'delete', position: 5, length: 3, author: 'user2'}\n\n// Format operation\n{type: 'format', position: 0, length: 5, attributes: {bold: true}}\n```\n\n**2. Transform Algorithm:**\n- **Inclusion Transformation:** Transform operation against another\n- **Exclusion Transformation:** Undo and redo with transforms\n- **Convergence:** Ensure all clients reach same final state\n- **Causality Preservation:** Maintain operation ordering\n\n**3. Conflict Resolution:**\n- **Deterministic Ordering:** Use timestamps and user IDs\n- **Position Adjustment:** Adjust positions based on concurrent ops\n- **Intention Preservation:** Maintain user's original intent\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Stateless Services:** Scale application servers independently\n- **Document Sharding:** Distribute documents across databases\n- **Session Affinity:** Route users to same collaboration server\n- **Auto-scaling:** Dynamic scaling based on load\n\n**2. Caching Strategy:**\n- **Document Cache:** Cache active documents in memory\n- **Operation Cache:** Recent operations for fast playback\n- **User Cache:** User permissions and preferences\n- **CDN:** Static content and document exports\n\n**3. Database Optimization:**\n- **Read Replicas:** Scale read operations\n- **Connection Pooling:** Efficient database connections\n- **Indexing:** Optimize queries for document access\n- **Partitioning:** Partition by document ID or user ID\n\n**High Availability:**\n- **Multi-region Deployment:** Global availability\n- **Load Balancers:** Health checks and failover\n- **Database Clustering:** Master-slave replication\n- **Backup and Recovery:** Regular backups and point-in-time recovery\n- **Circuit Breakers:** Prevent cascade failures\n\n**Performance Optimizations:**\n- **Delta Sync:** Send only changes, not full document\n- **Compression:** Compress operations and content\n- **Batching:** Batch multiple operations\n- **Lazy Loading:** Load document sections on demand\n- **Preloading:** Predictive content loading\n\n**Security Considerations:**\n- **Authentication:** OAuth 2.0 with JWT tokens\n- **Authorization:** Document-level permissions\n- **Encryption:** TLS for transport, encryption at rest\n- **Input Validation:** Sanitize and validate all operations\n- **Rate Limiting:** Prevent abuse and spam\n\n**Monitoring and Analytics:**\n- **Real-time Metrics:** Active users, operation rates\n- **Performance Monitoring:** Latency, throughput\n- **Error Tracking:** Operation conflicts, failures\n- **Usage Analytics:** Feature usage, collaboration patterns",
      "keywords": ["collaborative editing", "operational transform", "real-time synchronization", "WebSocket", "conflict resolution", "document versioning", "concurrent editing", "state vector", "Redis", "MongoDB", "horizontal scaling", "session management", "user presence", "offline sync", "rich text editor", "microservices"],
      "difficulty": "hard"
    },
    {
      "id": 3023,
      "tag": "systems_design",
      "question": "Design a video streaming platform like Netflix. Focus on content delivery, scalability, and user experience.",
      "answer": "**System Requirements:**\n- Stream videos to millions of concurrent users globally\n- Support multiple video qualities (360p to 4K)\n- Personalized recommendations and content discovery\n- Fast content loading and minimal buffering\n- Support for multiple devices and platforms\n- Content management and encoding pipeline\n- Analytics and monitoring\n\n**Architecture Overview:**\n\n**1. Client Applications:**\n- **Web Application:** React/Angular with video player\n- **Mobile Apps:** Native iOS/Android with offline download\n- **Smart TV Apps:** Platform-specific applications\n- **Gaming Consoles:** Xbox, PlayStation, Nintendo Switch\n- **Adaptive Bitrate Streaming:** HLS/DASH protocols\n\n**2. API Gateway:**\n- **Authentication:** User login and session management\n- **Rate Limiting:** Prevent API abuse\n- **Request Routing:** Route to appropriate microservices\n- **Load Balancing:** Distribute traffic across services\n- **SSL Termination:** Handle HTTPS encryption\n\n**3. Microservices Architecture:**\n\n**User Service:**\n- User profiles and preferences\n- Subscription management\n- Viewing history and watchlists\n- Authentication and authorization\n\n**Content Service:**\n- Content metadata (title, description, cast)\n- Content catalog and search\n- Content categorization and tagging\n- Content rights and licensing\n\n**Video Service:**\n- Video encoding and processing\n- Multiple quality versions\n- Thumbnail generation\n- Video metadata management\n\n**Recommendation Service:**\n- Machine learning models\n- Collaborative filtering\n- Content-based recommendations\n- Real-time personalization\n\n**Streaming Service:**\n- Video delivery optimization\n- Adaptive bitrate logic\n- CDN integration\n- Quality monitoring\n\n**Content Delivery Network (CDN):**\n\n**1. Global Edge Servers:**\n- **Geographic Distribution:** Servers in major cities worldwide\n- **Cache Strategy:** Cache popular content at edge locations\n- **Intelligent Routing:** Route users to nearest server\n- **Load Balancing:** Distribute load across edge servers\n\n**2. Content Caching:**\n- **Popular Content:** Cache trending and popular videos\n- **Predictive Caching:** Predict and pre-cache content\n- **Regional Preferences:** Cache region-specific content\n- **Time-based Caching:** Account for viewing patterns\n\n**3. Origin Servers:**\n- **Master Storage:** Store all video content\n- **Backup and Redundancy:** Multiple copies across regions\n- **High Bandwidth:** Handle requests from edge servers\n\n**Video Processing Pipeline:**\n\n**1. Content Ingestion:**\n- **Upload Interface:** Content provider upload portal\n- **Format Validation:** Check video format and quality\n- **Metadata Extraction:** Extract video properties\n- **Quality Checks:** Automated content verification\n\n**2. Video Encoding:**\n- **Multiple Formats:** H.264, H.265, VP9, AV1\n- **Multiple Resolutions:** 360p, 480p, 720p, 1080p, 4K\n- **Adaptive Bitrate:** Multiple bitrate versions\n- **Thumbnail Generation:** Create preview thumbnails\n- **Parallel Processing:** Distribute encoding across servers\n\n**3. Content Distribution:**\n- **CDN Upload:** Push encoded content to CDN\n- **Metadata Update:** Update content database\n- **Cache Warming:** Pre-populate edge caches\n- **Quality Assurance:** Verify content delivery\n\n**Data Storage:**\n\n**1. Content Metadata:**\n- **PostgreSQL:** Structured data (users, content info)\n- **Elasticsearch:** Search and discovery\n- **Redis:** Session data and real-time recommendations\n\n**2. Video Storage:**\n- **Object Storage (S3):** Massive video file storage\n- **Multi-region Replication:** Global content availability\n- **Tiered Storage:** Hot, warm, cold storage strategies\n\n**3. Analytics Data:**\n- **Data Lake:** Raw viewing data and events\n- **Data Warehouse:** Processed analytics data\n- **Real-time Streaming:** Kafka for real-time events\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Microservices:** Independent scaling of services\n- **Container Orchestration:** Kubernetes for deployment\n- **Auto-scaling:** Dynamic scaling based on demand\n- **Database Sharding:** Distribute data across databases\n\n**2. Caching Strategy:**\n- **Multi-level Caching:** Browser, CDN, application cache\n- **Content Prediction:** Machine learning for cache decisions\n- **Cache Invalidation:** Efficient cache update strategies\n\n**3. Performance Optimization:**\n- **Adaptive Streaming:** Adjust quality based on bandwidth\n- **Preloading:** Buffer next episodes automatically\n- **Compression:** Efficient video compression algorithms\n- **Edge Computing:** Process requests at edge locations\n\n**Recommendation System:**\n\n**1. Data Collection:**\n- **Viewing History:** What users watch and when\n- **User Interactions:** Ratings, searches, browsing\n- **Content Analysis:** Genre, actors, director preferences\n- **Contextual Data:** Time, device, location\n\n**2. Machine Learning Models:**\n- **Collaborative Filtering:** User-based and item-based\n- **Content-based Filtering:** Feature similarity\n- **Deep Learning:** Neural networks for complex patterns\n- **Real-time Updates:** Online learning algorithms\n\n**3. Personalization:**\n- **Home Page:** Personalized content rows\n- **Search Results:** Personalized ranking\n- **Continue Watching:** Resume playback features\n- **New Releases:** Personalized notifications\n\n**High Availability:**\n- **Multi-region Deployment:** Global redundancy\n- **Failover Mechanisms:** Automatic service recovery\n- **Health Monitoring:** Continuous system monitoring\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Fallback to lower quality\n\n**Monitoring and Analytics:**\n- **Real-time Monitoring:** Service health and performance\n- **Video Quality Metrics:** Buffering, startup time\n- **User Engagement:** Watch time, completion rates\n- **Business Metrics:** Subscriber growth, content ROI\n- **A/B Testing:** Feature and algorithm testing",
      "keywords": ["video streaming", "CDN", "adaptive bitrate streaming", "HLS", "DASH", "video encoding", "content delivery", "recommendation system", "machine learning", "microservices", "horizontal scaling", "caching strategy", "object storage", "edge servers", "personalization", "multi-region deployment"],
      "difficulty": "hard"
    },
    {
      "id": 3024,
      "tag": "systems_design",
      "question": "Design a ride-sharing service like Uber. Include driver matching, real-time tracking, and pricing algorithms.",
      "answer": "**System Requirements:**\n- Match riders with nearby drivers in real-time\n- Real-time location tracking for drivers and riders\n- Dynamic pricing based on supply and demand\n- Support for millions of users and drivers globally\n- Trip management from request to completion\n- Payment processing and billing\n- Driver and rider mobile applications\n\n**Architecture Overview:**\n\n**1. Mobile Applications:**\n- **Rider App:** Request rides, track driver, payments\n- **Driver App:** Accept rides, navigation, earnings\n- **Real-time Communication:** WebSocket connections\n- **Offline Capability:** Cache critical data locally\n- **Push Notifications:** Trip updates and alerts\n\n**2. API Gateway:**\n- **Load Balancing:** Distribute requests across services\n- **Authentication:** JWT-based user authentication\n- **Rate Limiting:** Prevent API abuse\n- **Request Routing:** Route to appropriate microservices\n- **SSL Termination:** Handle HTTPS encryption\n\n**3. Core Microservices:**\n\n**User Service:**\n- User registration and profiles\n- Authentication and authorization\n- Preference management\n- Account settings and history\n\n**Driver Service:**\n- Driver onboarding and verification\n- Vehicle information and documents\n- Driver status (online/offline)\n- Performance metrics and ratings\n\n**Location Service:**\n- Real-time location tracking\n- Geospatial queries and indexing\n- Location history storage\n- Privacy and data retention\n\n**Matching Service:**\n- Driver-rider matching algorithm\n- Real-time availability tracking\n- Distance and time calculations\n- Optimization for efficiency\n\n**Trip Service:**\n- Trip lifecycle management\n- Route planning and optimization\n- Trip state transitions\n- Fare calculation\n\n**Pricing Service:**\n- Dynamic pricing algorithms\n- Surge pricing implementation\n- Promotional pricing\n- Fare estimation\n\n**Payment Service:**\n- Payment processing\n- Multiple payment methods\n- Driver payouts\n- Transaction history\n\n**Location and Matching System:**\n\n**1. Real-time Location Tracking:**\n- **GPS Data:** Continuous location updates from drivers\n- **Location Updates:** Every 4-5 seconds for active drivers\n- **Geohashing:** Efficient location indexing\n- **Location Validation:** Filter invalid GPS coordinates\n\n**2. Geospatial Database:**\n- **Redis with Geospatial Commands:** Store driver locations\n- **MongoDB with 2dsphere Index:** Complex geospatial queries\n- **QuadTree/R-tree:** Efficient spatial indexing\n- **Sharding by Geography:** Distribute load by regions\n\n**3. Driver Matching Algorithm:**\n```\n1. Receive ride request with pickup location\n2. Query nearby drivers within radius (e.g., 2km)\n3. Filter available drivers (online, not on trip)\n4. Calculate ETA for each driver\n5. Apply business rules (driver rating, preferences)\n6. Rank drivers by distance and ETA\n7. Send requests to top 3-5 drivers\n8. First driver to accept gets the trip\n```\n\n**4. Geographic Partitioning:**\n- **City-based Sharding:** Separate databases per city\n- **Grid-based Partitioning:** Divide cities into grid cells\n- **Load Balancing:** Route requests to appropriate servers\n- **Hot Spot Handling:** Dynamic load distribution\n\n**Real-time Communication:**\n\n**1. WebSocket Connections:**\n- **Persistent Connections:** Real-time updates\n- **Connection Management:** Handle disconnections gracefully\n- **Message Queuing:** Queue messages during disconnections\n- **Scalable WebSocket Servers:** Multiple servers with load balancing\n\n**2. Event-driven Architecture:**\n- **Message Queues (Kafka):** Reliable event delivery\n- **Event Types:** Location updates, trip status changes\n- **Event Processing:** Real-time and batch processing\n- **Event Sourcing:** Complete audit trail\n\n**Dynamic Pricing System:**\n\n**1. Surge Pricing Algorithm:**\n```\nSurge Multiplier = f(\n  demand (ride requests),\n  supply (available drivers),\n  historical patterns,\n  external factors (weather, events),\n  time of day,\n  location density\n)\n```\n\n**2. Real-time Demand Tracking:**\n- **Heat Maps:** Visualize demand patterns\n- **Predictive Analytics:** Forecast demand spikes\n- **Supply Monitoring:** Track driver availability\n- **External Data:** Weather, events, traffic\n\n**3. Price Optimization:**\n- **Machine Learning:** Historical data analysis\n- **A/B Testing:** Test pricing strategies\n- **Price Elasticity:** Understand demand response\n- **Revenue Optimization:** Balance rides and revenue\n\n**Data Storage:**\n\n**1. Operational Databases:**\n- **PostgreSQL:** User accounts, trips, payments\n- **Redis:** Real-time data (locations, sessions)\n- **MongoDB:** Document storage for complex data\n- **Cassandra:** Time-series data (location history)\n\n**2. Analytics and ML:**\n- **Data Lake (S3):** Raw event data storage\n- **Data Warehouse:** Processed analytics data\n- **Streaming Platform (Kafka):** Real-time data pipeline\n- **ML Platform:** Model training and serving\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Microservices:** Independent scaling of services\n- **Database Sharding:** Geographic and functional sharding\n- **CDN:** Static content delivery\n- **Auto-scaling:** Dynamic resource allocation\n\n**2. Caching Strategy:**\n- **Application Cache:** Frequently accessed data\n- **Location Cache:** Recent driver locations\n- **Route Cache:** Pre-calculated routes\n- **User Cache:** User preferences and history\n\n**3. Performance Optimization:**\n- **Connection Pooling:** Efficient database connections\n- **Asynchronous Processing:** Non-blocking operations\n- **Batch Processing:** Group similar operations\n- **Precomputation:** Pre-calculate common queries\n\n**High Availability:**\n\n**1. Fault Tolerance:**\n- **Multi-region Deployment:** Global redundancy\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Fallback mechanisms\n- **Health Monitoring:** Continuous system monitoring\n\n**2. Data Consistency:**\n- **Eventually Consistent:** Location and availability data\n- **Strong Consistency:** Payment and trip data\n- **Conflict Resolution:** Handle concurrent updates\n- **Backup and Recovery:** Regular data backups\n\n**Security and Privacy:**\n- **Location Privacy:** Anonymize and aggregate data\n- **Data Encryption:** Encrypt sensitive data\n- **Access Control:** Role-based permissions\n- **Audit Logging:** Track all system actions\n- **PCI Compliance:** Secure payment processing\n\n**Monitoring and Analytics:**\n- **Real-time Dashboards:** System health and KPIs\n- **Performance Metrics:** Response times, success rates\n- **Business Metrics:** Trips, revenue, driver utilization\n- **Machine Learning:** Predictive analytics and optimization\n- **A/B Testing Framework:** Continuous feature testing",
      "keywords": ["ride-sharing", "geospatial database", "real-time tracking", "driver matching", "dynamic pricing", "surge pricing", "WebSocket", "location tracking", "geohashing", "microservices", "event-driven architecture", "Kafka", "machine learning", "horizontal scaling", "Redis geospatial", "mobile applications"],
      "difficulty": "hard"
    },
    {
      "id": 3025,
      "tag": "systems_design",
      "question": "Design a global payment system like PayPal. Consider security, compliance, fraud detection, and multi-currency support.",
      "answer": "**System Requirements:**\n- Process millions of transactions daily globally\n- Support multiple currencies and payment methods\n- Real-time fraud detection and prevention\n- PCI DSS compliance and security standards\n- International regulatory compliance\n- High availability (99.99% uptime)\n- Sub-second transaction processing\n- Multi-party transactions (splits, escrow)\n\n**Architecture Overview:**\n\n**1. API Gateway:**\n- **Rate Limiting:** Prevent API abuse and DDoS\n- **Authentication:** OAuth 2.0 and API key management\n- **SSL Termination:** Handle HTTPS encryption\n- **Request/Response Logging:** Audit trail for transactions\n- **Geographic Routing:** Route to regional data centers\n\n**2. Core Payment Services:**\n\n**Account Service:**\n- User account management and KYC\n- Business account verification\n- Account linking and hierarchy\n- Balance management and limits\n\n**Payment Processing Service:**\n- Transaction initiation and validation\n- Payment method tokenization\n- Settlement processing\n- Transaction state management\n\n**Wallet Service:**\n- Digital wallet management\n- Balance tracking and updates\n- Multi-currency support\n- Transaction history\n\n**Currency Service:**\n- Real-time exchange rate management\n- Currency conversion logic\n- Multi-currency transaction support\n- Hedging and risk management\n\n**Fraud Detection Service:**\n- Real-time fraud scoring\n- Machine learning models\n- Rule-based fraud prevention\n- Risk assessment and monitoring\n\n**Compliance Service:**\n- AML (Anti-Money Laundering) checks\n- Sanctions screening\n- Regulatory reporting\n- Audit trail maintenance\n\n**Transaction Processing Flow:**\n\n**1. Payment Initiation:**\n```\n1. User initiates payment request\n2. API Gateway validates and authenticates\n3. Fraud detection initial screening\n4. Payment method validation\n5. Available balance/credit check\n6. Create pending transaction record\n```\n\n**2. Fraud Detection:**\n```\n1. Real-time ML model scoring\n2. Rule-based checks (velocity, amount, location)\n3. Device fingerprinting\n4. Behavioral analysis\n5. Risk score calculation\n6. Approve/decline/review decision\n```\n\n**3. Payment Authorization:**\n```\n1. Reserve funds in source account\n2. Compliance checks (AML, sanctions)\n3. Multi-factor authentication if needed\n4. Generate authorization code\n5. Update transaction status\n```\n\n**4. Settlement:**\n```\n1. Debit source account\n2. Currency conversion if needed\n3. Credit destination account\n4. Generate settlement records\n5. Send confirmation notifications\n6. Update final transaction status\n```\n\n**Data Storage Architecture:**\n\n**1. Transaction Database:**\n- **Sharded PostgreSQL:** ACID compliance for transactions\n- **Sharding Key:** User ID or account ID\n- **Read Replicas:** Scale read operations\n- **Cross-region Replication:** Global availability\n\n**2. Real-time Data:**\n- **Redis Cluster:** Session data, fraud scores\n- **Apache Kafka:** Transaction events and audit logs\n- **Elasticsearch:** Transaction search and analytics\n- **Time-series DB:** Performance and fraud metrics\n\n**3. Document Storage:**\n- **MongoDB:** KYC documents, compliance records\n- **Object Storage (S3):** Receipts, statements\n- **Encrypted Storage:** Sensitive document protection\n\n**Multi-Currency Support:**\n\n**1. Exchange Rate Management:**\n- **Real-time Feeds:** Multiple currency data providers\n- **Rate Caching:** Cache rates with TTL\n- **Historical Rates:** Store for reconciliation\n- **Rate Validation:** Cross-reference multiple sources\n\n**2. Currency Conversion:**\n- **Conversion Engine:** Real-time currency conversion\n- **Spread Management:** Competitive exchange rates\n- **Hedging Strategy:** Risk management for exposure\n- **Settlement Optimization:** Netting and batching\n\n**3. Regional Processing:**\n- **Local Banking:** Partner with local banks\n- **Regulatory Compliance:** Country-specific rules\n- **Local Payment Methods:** Regional preferences\n- **Tax Calculation:** VAT, GST, local taxes\n\n**Fraud Detection System:**\n\n**1. Real-time Scoring:**\n- **Machine Learning Models:** Gradient boosting, neural networks\n- **Feature Engineering:** 200+ features (velocity, patterns)\n- **Model Training:** Continuous learning from new data\n- **A/B Testing:** Model performance comparison\n\n**2. Rule Engine:**\n- **Velocity Checks:** Transaction frequency limits\n- **Amount Limits:** Daily/monthly spending limits\n- **Geographic Rules:** Unusual location patterns\n- **Device Fingerprinting:** Device-based risk assessment\n\n**3. Risk Assessment:**\n```\nRisk Score = f(\n  transaction_amount,\n  user_history,\n  device_trust,\n  location_risk,\n  velocity_patterns,\n  network_analysis,\n  external_intelligence\n)\n```\n\n**Security Implementation:**\n\n**1. Data Protection:**\n- **Encryption at Rest:** AES-256 for sensitive data\n- **Encryption in Transit:** TLS 1.3 for all communications\n- **Key Management:** HSM-based key storage\n- **PCI DSS Compliance:** Level 1 merchant compliance\n\n**2. Access Control:**\n- **Zero Trust Architecture:** Verify every access request\n- **Multi-factor Authentication:** For sensitive operations\n- **Role-based Access:** Principle of least privilege\n- **API Security:** Rate limiting, token validation\n\n**3. Audit and Monitoring:**\n- **Immutable Audit Logs:** Blockchain-based audit trail\n- **Real-time Monitoring:** Security event detection\n- **Incident Response:** Automated threat response\n- **Penetration Testing:** Regular security assessments\n\n**Compliance Framework:**\n\n**1. Regulatory Compliance:**\n- **PCI DSS:** Payment card industry standards\n- **GDPR:** Data protection regulations\n- **PSD2:** European payment services directive\n- **AML/KYC:** Anti-money laundering compliance\n\n**2. Reporting Systems:**\n- **Suspicious Activity Reports:** Automated SAR generation\n- **Currency Transaction Reports:** Large transaction reporting\n- **Sanctions Screening:** Real-time sanctions checking\n- **Regulatory Filings:** Automated compliance reporting\n\n**Scalability and Performance:**\n\n**1. Horizontal Scaling:**\n- **Microservices Architecture:** Independent service scaling\n- **Database Sharding:** Distribute load across databases\n- **Auto-scaling:** Dynamic resource allocation\n- **Load Balancing:** Geographic and service-based routing\n\n**2. Performance Optimization:**\n- **Caching Strategy:** Multi-level caching\n- **Asynchronous Processing:** Non-blocking operations\n- **Connection Pooling:** Efficient database connections\n- **CDN:** Global content delivery\n\n**3. High Availability:**\n- **Multi-region Deployment:** Global redundancy\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Fallback mechanisms\n- **Disaster Recovery:** RTO < 4 hours, RPO < 1 hour\n\n**Integration Ecosystem:**\n- **Banking APIs:** ACH, wire transfers, credit cards\n- **Cryptocurrency:** Digital asset support\n- **E-commerce Platforms:** Shopping cart integration\n- **Mobile Wallets:** Apple Pay, Google Pay integration\n- **Point of Sale:** In-store payment processing\n\n**Monitoring and Analytics:**\n- **Real-time Dashboards:** Transaction volumes, success rates\n- **Fraud Analytics:** False positive rates, fraud detection\n- **Performance Metrics:** Latency, throughput, availability\n- **Business Intelligence:** Revenue, user growth, churn analysis\n- **Compliance Monitoring:** Regulatory adherence tracking",
      "keywords": ["payment system", "PCI DSS compliance", "fraud detection", "multi-currency", "AML", "KYC", "transaction processing", "ACID transactions", "real-time scoring", "encryption", "regulatory compliance", "machine learning", "risk assessment", "settlement", "tokenization", "microservices"],
      "difficulty": "hard"
    },
    {
      "id": 3026,
      "tag": "systems_design",
      "question": "Design a distributed search engine like Elasticsearch. Focus on indexing, querying, and scaling across multiple nodes.",
      "answer": "**System Requirements:**\n- Index and search billions of documents\n- Sub-second search response times\n- Horizontal scaling across multiple nodes\n- Full-text search with relevance scoring\n- Real-time indexing and updates\n- High availability and fault tolerance\n- Support for complex queries and aggregations\n- Multi-tenancy and data isolation\n\n**Architecture Overview:**\n\n**1. Cluster Management:**\n- **Master Nodes:** Cluster coordination and metadata management\n- **Data Nodes:** Store indexes and handle search requests\n- **Coordinating Nodes:** Route requests and aggregate results\n- **Ingest Nodes:** Pre-process documents before indexing\n- **Dedicated Roles:** Separate concerns for better performance\n\n**2. Core Components:**\n\n**Index Management:**\n- Index creation and configuration\n- Mapping definition and field types\n- Index templates and lifecycle policies\n- Alias management for zero-downtime operations\n\n**Document Processing:**\n- Document ingestion and parsing\n- Text analysis and tokenization\n- Field extraction and transformation\n- Bulk indexing optimizations\n\n**Search Engine:**\n- Query parsing and execution\n- Relevance scoring algorithms\n- Query optimization and caching\n- Aggregation framework\n\n**Cluster Coordination:**\n- Node discovery and membership\n- Shard allocation and rebalancing\n- Metadata synchronization\n- Health monitoring and recovery\n\n**Distributed Architecture:**\n\n**1. Sharding Strategy:**\n- **Horizontal Partitioning:** Split indexes across shards\n- **Shard Sizing:** Optimize shard size (20-50GB recommended)\n- **Shard Allocation:** Distribute shards across nodes\n- **Routing:** Hash-based document routing to shards\n\n```\nshard_id = hash(document_id) % number_of_shards\n```\n\n**2. Replication:**\n- **Primary-Replica Model:** Each shard has one primary and multiple replicas\n- **Synchronous Replication:** Ensure data consistency\n- **Replica Allocation:** Replicas on different nodes/racks\n- **Automatic Failover:** Promote replica to primary on failure\n\n**3. Cluster Topology:**\n```\nCluster\nâ”œâ”€â”€ Index A (5 shards, 1 replica)\nâ”‚   â”œâ”€â”€ Shard 0 (Primary on Node 1, Replica on Node 2)\nâ”‚   â”œâ”€â”€ Shard 1 (Primary on Node 2, Replica on Node 3)\nâ”‚   â””â”€â”€ ...\nâ”œâ”€â”€ Index B (3 shards, 2 replicas)\nâ””â”€â”€ Index C (10 shards, 1 replica)\n```\n\n**Indexing System:**\n\n**1. Document Processing Pipeline:**\n```\n1. Document Ingestion\n   â†“\n2. Field Extraction\n   â†“\n3. Text Analysis (tokenization, stemming, filtering)\n   â†“\n4. Inverted Index Construction\n   â†“\n5. Storage in Lucene Segments\n   â†“\n6. Refresh for Search Visibility\n```\n\n**2. Inverted Index Structure:**\n```\nTerm â†’ [Document IDs with term frequencies and positions]\n\"search\" â†’ [doc1:tf=3, doc5:tf=1, doc12:tf=2, ...]\n\"engine\" â†’ [doc1:tf=1, doc3:tf=2, doc12:tf=1, ...]\n```\n\n**3. Text Analysis:**\n- **Tokenization:** Break text into tokens\n- **Filtering:** Remove stop words, apply synonyms\n- **Normalization:** Lowercase, stemming, lemmatization\n- **Custom Analyzers:** Domain-specific text processing\n\n**4. Index Storage:**\n- **Lucene Segments:** Immutable storage units\n- **Segment Merging:** Background optimization process\n- **Compression:** Efficient storage with compression\n- **Memory Management:** Balance heap and filesystem cache\n\n**Query Processing:**\n\n**1. Query Execution Flow:**\n```\n1. Parse Query (Query DSL)\n   â†“\n2. Query Optimization\n   â†“\n3. Route to Relevant Shards\n   â†“\n4. Execute on Each Shard\n   â†“\n5. Score and Rank Results\n   â†“\n6. Aggregate Results\n   â†“\n7. Return Top Results\n```\n\n**2. Scoring Algorithm (TF-IDF based):**\n```\nscore = tf * idf * fieldNorm * queryNorm\n\nwhere:\n- tf = term frequency in document\n- idf = inverse document frequency\n- fieldNorm = field length normalization\n- queryNorm = query normalization\n```\n\n**3. Query Types:**\n- **Term Queries:** Exact term matching\n- **Match Queries:** Analyzed text matching\n- **Bool Queries:** Boolean combinations\n- **Range Queries:** Numeric and date ranges\n- **Fuzzy Queries:** Approximate string matching\n- **Aggregations:** Statistical computations\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Add Data Nodes:** Increase storage and processing capacity\n- **Shard Splitting:** Split large shards (requires reindexing)\n- **Index Rolling:** Time-based index creation\n- **Hot-Warm-Cold Architecture:** Tiered storage strategy\n\n**2. Performance Optimization:**\n- **Query Caching:** Cache frequently executed queries\n- **Field Data Caching:** Cache aggregation field data\n- **Routing:** Direct queries to specific shards\n- **Bulk Operations:** Batch indexing and updates\n\n**3. Resource Management:**\n- **Memory Management:** Heap size tuning (< 32GB)\n- **JVM Optimization:** GC tuning and settings\n- **Disk I/O:** SSD storage and multiple disk paths\n- **Network:** Dedicated cluster communication network\n\n**High Availability:**\n\n**1. Fault Tolerance:**\n- **Master Node Redundancy:** Multiple master-eligible nodes\n- **Split-brain Prevention:** Minimum master nodes quorum\n- **Shard Recovery:** Automatic recovery from node failures\n- **Data Replication:** Prevent data loss\n\n**2. Disaster Recovery:**\n- **Snapshot and Restore:** Regular cluster backups\n- **Cross-cluster Replication:** Multi-region setup\n- **Rolling Upgrades:** Zero-downtime updates\n- **Monitoring and Alerting:** Proactive issue detection\n\n**Data Management:**\n\n**1. Index Lifecycle:**\n- **Hot Phase:** Active writing and frequent searching\n- **Warm Phase:** Infrequent writes, regular searches\n- **Cold Phase:** Rare searches, compressed storage\n- **Delete Phase:** Automatic deletion of old data\n\n**2. Storage Optimization:**\n- **Compression:** Reduce storage requirements\n- **Force Merge:** Optimize segment structure\n- **Shrink API:** Reduce number of shards\n- **Rollover API:** Create new indexes based on size/age\n\n**Security and Multi-tenancy:**\n\n**1. Authentication and Authorization:**\n- **Role-based Access Control:** Granular permissions\n- **Field-level Security:** Hide sensitive fields\n- **Document-level Security:** Row-level access control\n- **API Key Authentication:** Secure API access\n\n**2. Data Isolation:**\n- **Index-based Separation:** Separate indexes per tenant\n- **Cluster-based Separation:** Dedicated clusters\n- **Namespace Prefixes:** Logical separation\n- **Resource Quotas:** Prevent resource abuse\n\n**Monitoring and Operations:**\n\n**1. Cluster Monitoring:**\n- **Cluster Health:** Red/yellow/green status\n- **Node Statistics:** CPU, memory, disk usage\n- **Index Statistics:** Size, document count, query performance\n- **Slow Query Logs:** Identify performance bottlenecks\n\n**2. Performance Metrics:**\n- **Query Latency:** P50, P95, P99 response times\n- **Indexing Rate:** Documents per second\n- **Search Rate:** Queries per second\n- **Resource Utilization:** Memory, CPU, disk I/O\n\n**3. Alerting:**\n- **Cluster Health Degradation**\n- **High Query Latency**\n- **Disk Space Exhaustion**\n- **Node Unavailability**\n- **Indexing Failures**",
      "keywords": ["distributed search", "inverted index", "sharding", "replication", "Lucene", "text analysis", "TF-IDF scoring", "cluster coordination", "horizontal scaling", "high availability", "query optimization", "index lifecycle", "fault tolerance", "aggregations", "full-text search", "elasticsearch"],
      "difficulty": "hard"
    },
    {
      "id": 3027,
      "tag": "systems_design",
      "question": "Design a social media feed like Instagram or Facebook. Consider personalization, real-time updates, and content ranking.",
      "answer": "**System Requirements:**\n- Serve personalized feeds to millions of users\n- Real-time feed updates and notifications\n- Support various content types (text, images, videos)\n- Content ranking and recommendation algorithms\n- High availability and low latency\n- Handle viral content and traffic spikes\n- Support for interactions (likes, comments, shares)\n- Content moderation and safety\n\n**Architecture Overview:**\n\n**1. Client Applications:**\n- **Mobile Apps:** Native iOS/Android applications\n- **Web Application:** Progressive web app\n- **Real-time Updates:** WebSocket connections\n- **Offline Support:** Local caching and sync\n- **Push Notifications:** Engagement notifications\n\n**2. API Gateway:**\n- **Authentication:** JWT-based user authentication\n- **Rate Limiting:** Prevent API abuse\n- **Request Routing:** Route to appropriate microservices\n- **Load Balancing:** Distribute traffic across services\n- **Caching:** API response caching\n\n**3. Core Microservices:**\n\n**User Service:**\n- User profiles and authentication\n- Friend/follower relationships\n- Privacy settings and preferences\n- User activity tracking\n\n**Content Service:**\n- Post creation and management\n- Content storage and metadata\n- Content moderation\n- Media processing pipeline\n\n**Feed Service:**\n- Feed generation and ranking\n- Personalization algorithms\n- Feed caching and optimization\n- Real-time feed updates\n\n**Interaction Service:**\n- Likes, comments, shares\n- Reaction processing\n- Engagement analytics\n- Spam and abuse detection\n\n**Notification Service:**\n- Real-time notifications\n- Push notification delivery\n- Notification preferences\n- Notification history\n\n**Recommendation Service:**\n- Content recommendation algorithms\n- User interest modeling\n- Trending content detection\n- Personalization engine\n\n**Feed Generation Strategies:**\n\n**1. Pull Model (On-demand):**\n```\n1. User requests feed\n2. Query posts from followed users\n3. Rank and personalize content\n4. Return top N posts\n5. Cache result for future requests\n```\n\n**Pros:** Fresh content, resource efficient for inactive users\n**Cons:** High latency, expensive for popular users\n\n**2. Push Model (Pre-computed):**\n```\n1. User creates new post\n2. Push to all followers' pre-computed feeds\n3. Store in followers' feed caches\n4. User requests show cached feed\n```\n\n**Pros:** Low latency, efficient for active users\n**Cons:** High storage cost, celebrity user problem\n\n**3. Hybrid Model (Best of Both):**\n```\n- Pull for users with many followers (celebrities)\n- Push for regular users\n- Real-time mixing for fresh content\n- Intelligent caching strategies\n```\n\n**Content Ranking Algorithm:**\n\n**1. Engagement Prediction:**\n```\nEngagement_Score = f(\n  user_content_affinity,\n  content_quality_score,\n  temporal_decay,\n  content_type_preference,\n  social_signals,\n  user_activity_patterns,\n  content_freshness\n)\n```\n\n**2. Machine Learning Features:**\n- **User Features:** Age, location, interests, past behavior\n- **Content Features:** Type, topic, quality score, virality\n- **Interaction Features:** Historical engagement patterns\n- **Temporal Features:** Time of day, recency\n- **Social Features:** Friend interactions, social proof\n\n**3. Ranking Models:**\n- **Logistic Regression:** Baseline engagement prediction\n- **Deep Neural Networks:** Complex pattern recognition\n- **Gradient Boosting:** Feature interaction modeling\n- **Multi-objective Optimization:** Balance engagement, diversity, safety\n\n**Real-time Updates System:**\n\n**1. Event-driven Architecture:**\n```\nUser Action â†’ Event Stream â†’ Feed Updates â†’ Real-time Delivery\n```\n\n**2. Streaming Pipeline:**\n- **Apache Kafka:** Event streaming platform\n- **Stream Processing:** Apache Flink/Spark Streaming\n- **Real-time Analytics:** Update engagement signals\n- **Fan-out Service:** Distribute updates to followers\n\n**3. WebSocket Implementation:**\n- **Connection Management:** Handle millions of connections\n- **Message Queuing:** Queue updates during disconnections\n- **Load Balancing:** Distribute connections across servers\n- **Graceful Degradation:** Fallback to polling\n\n**Data Storage Architecture:**\n\n**1. User and Social Graph:**\n- **PostgreSQL:** User profiles, relationships\n- **Graph Database (Neo4j):** Complex social graph queries\n- **Redis:** Session data, active user cache\n\n**2. Content Storage:**\n- **MongoDB:** Post metadata and content\n- **Object Storage (S3):** Images, videos, attachments\n- **CDN:** Global content delivery\n- **Elasticsearch:** Content search and discovery\n\n**3. Feed Storage:**\n- **Redis Cluster:** Hot feed cache\n- **Cassandra:** Time-series feed data\n- **MemcacheD:** Application-level caching\n\n**4. Analytics and ML:**\n- **Data Lake (S3):** Raw user interaction data\n- **Data Warehouse:** Processed analytics data\n- **Feature Store:** ML features for real-time serving\n- **Model Serving:** Real-time ML inference\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Microservices:** Independent scaling of services\n- **Database Sharding:** Distribute data across databases\n- **Feed Partitioning:** Partition feeds by user segments\n- **Geographic Distribution:** Multi-region deployment\n\n**2. Caching Strategy:**\n- **L1 Cache:** Application memory cache\n- **L2 Cache:** Redis cluster cache\n- **L3 Cache:** CDN edge cache\n- **Intelligent Prefetching:** Predictive content loading\n\n**3. Performance Optimization:**\n- **Lazy Loading:** Load content on demand\n- **Image Optimization:** Multiple resolutions, compression\n- **Connection Pooling:** Efficient database connections\n- **Asynchronous Processing:** Non-blocking operations\n\n**Content Moderation:**\n\n**1. Automated Moderation:**\n- **AI Content Detection:** Inappropriate content identification\n- **Spam Detection:** Machine learning-based spam filtering\n- **Hate Speech Detection:** Natural language processing\n- **Image Recognition:** Unsafe image detection\n\n**2. Human Moderation:**\n- **Review Queue:** Flagged content review\n- **Community Reporting:** User-driven content reporting\n- **Appeal Process:** Content decision appeals\n- **Moderator Tools:** Efficient moderation interfaces\n\n**Personalization Engine:**\n\n**1. User Interest Modeling:**\n- **Implicit Signals:** Clicks, time spent, scrolling behavior\n- **Explicit Signals:** Likes, shares, comments, follows\n- **Content Topics:** NLP-based topic extraction\n- **Interest Evolution:** Adapt to changing preferences\n\n**2. Recommendation Algorithms:**\n- **Collaborative Filtering:** Similar user recommendations\n- **Content-based Filtering:** Similar content recommendations\n- **Hybrid Approaches:** Combine multiple signals\n- **Deep Learning:** Neural collaborative filtering\n\n**3. A/B Testing Framework:**\n- **Experiment Management:** Control and treatment groups\n- **Metric Tracking:** Engagement, retention, satisfaction\n- **Statistical Significance:** Robust experiment analysis\n- **Gradual Rollout:** Safe feature deployment\n\n**High Availability:**\n\n**1. Fault Tolerance:**\n- **Multi-region Deployment:** Global redundancy\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Reduce functionality vs. outage\n- **Health Monitoring:** Continuous system monitoring\n\n**2. Disaster Recovery:**\n- **Data Replication:** Cross-region data backup\n- **Failover Mechanisms:** Automatic service recovery\n- **Backup Strategies:** Regular data backups\n- **Recovery Testing:** Regular disaster recovery drills\n\n**Monitoring and Analytics:**\n- **Real-time Dashboards:** System health and performance\n- **User Engagement Metrics:** Time spent, interactions\n- **Content Performance:** Viral content tracking\n- **Business KPIs:** Daily/monthly active users\n- **Performance Monitoring:** Latency, error rates\n\n**Privacy and Security:**\n- **Data Encryption:** Encrypt sensitive user data\n- **Privacy Controls:** Granular privacy settings\n- **GDPR Compliance:** Data protection regulations\n- **Secure APIs:** Authentication and authorization\n- **Audit Logging:** Track all system actions",
      "keywords": ["social media feed", "content ranking", "personalization", "machine learning", "real-time updates", "WebSocket", "event-driven architecture", "content moderation", "recommendation system", "A/B testing", "microservices", "horizontal scaling", "CDN", "user engagement", "viral content", "feed generation"],
      "difficulty": "hard"
    },
    {
      "id": 3028,
      "tag": "systems_design",
      "question": "Design a distributed messaging system like Slack or Discord. Include real-time messaging, channels, and presence tracking.",
      "answer": "**System Requirements:**\n- Real-time messaging for millions of concurrent users\n- Support for public channels and private groups\n- Direct messaging between users\n- Message history and search capabilities\n- File sharing and rich media support\n- User presence and typing indicators\n- Push notifications and offline message delivery\n- High availability and message delivery guarantees\n\n**Architecture Overview:**\n\n**1. Client Applications:**\n- **Desktop Apps:** Electron-based cross-platform apps\n- **Mobile Apps:** Native iOS/Android applications\n- **Web Application:** Real-time web interface\n- **WebSocket Connections:** Persistent real-time communication\n- **Offline Support:** Local message caching\n\n**2. API Gateway:**\n- **Authentication:** JWT-based user authentication\n- **Rate Limiting:** Prevent spam and abuse\n- **Load Balancing:** Distribute connections across servers\n- **Protocol Translation:** HTTP to WebSocket routing\n- **SSL Termination:** Secure communication\n\n**3. Core Microservices:**\n\n**User Service:**\n- User authentication and profiles\n- User preferences and settings\n- Contact management\n- Account security and 2FA\n\n**Workspace Service:**\n- Team/workspace management\n- Member roles and permissions\n- Workspace settings and policies\n- Billing and subscription management\n\n**Channel Service:**\n- Channel creation and management\n- Channel membership and permissions\n- Channel discovery and search\n- Archive and retention policies\n\n**Message Service:**\n- Message storage and retrieval\n- Message routing and delivery\n- Message formatting and validation\n- Message threading and replies\n\n**Presence Service:**\n- Online/offline status tracking\n- Typing indicators\n- Activity status (away, busy, etc.)\n- Last seen timestamps\n\n**Notification Service:**\n- Push notifications\n- Email notifications\n- Desktop notifications\n- Notification preferences\n\n**File Service:**\n- File upload and storage\n- Image/video processing\n- File sharing and permissions\n- Virus scanning and security\n\n**Real-time Messaging Architecture:**\n\n**1. Connection Management:**\n```\nClient â†’ Load Balancer â†’ WebSocket Gateway â†’ Message Router\n```\n\n**2. WebSocket Gateway:**\n- **Connection Persistence:** Maintain client connections\n- **Authentication:** Validate user sessions\n- **Heartbeat Mechanism:** Detect disconnections\n- **Connection Recovery:** Resume connections gracefully\n- **Load Balancing:** Distribute connections across nodes\n\n**3. Message Routing:**\n```\n1. Receive message from sender\n2. Validate message and permissions\n3. Store message in database\n4. Route to all channel/DM participants\n5. Send via WebSocket to online users\n6. Queue for offline users\n7. Trigger push notifications\n```\n\n**4. Message Delivery Guarantees:**\n- **At-least-once Delivery:** Messages guaranteed to be delivered\n- **Idempotency:** Prevent duplicate message processing\n- **Message Ordering:** Maintain chronological order\n- **Acknowledgments:** Confirm message receipt\n\n**Data Storage Design:**\n\n**1. Message Storage:**\n```\nMessages Table:\n- message_id (UUID)\n- channel_id\n- user_id\n- content\n- message_type (text, file, system)\n- timestamp\n- thread_id (for threaded messages)\n- edited_timestamp\n- deleted_flag\n```\n\n**Storage Strategy:**\n- **Hot Storage:** Recent messages (last 30 days) in fast databases\n- **Warm Storage:** Older messages (30 days - 1 year) in cost-effective storage\n- **Cold Storage:** Archive (1+ years) in object storage\n\n**2. Database Architecture:**\n- **PostgreSQL:** Structured data (users, channels, workspaces)\n- **Cassandra:** Message storage (time-series, high write volume)\n- **Redis:** Real-time data (presence, typing indicators)\n- **Elasticsearch:** Message search and indexing\n\n**3. Sharding Strategy:**\n- **Workspace-based Sharding:** Distribute by workspace_id\n- **Channel-based Sharding:** Distribute by channel_id\n- **Time-based Partitioning:** Partition messages by timestamp\n- **Hot/Cold Separation:** Recent vs. historical data\n\n**Presence and Status System:**\n\n**1. Presence Tracking:**\n```\nPresence Updates:\n- user_id\n- workspace_id\n- status (online, away, busy, offline)\n- last_activity_timestamp\n- device_type\n- client_version\n```\n\n**2. Real-time Status Updates:**\n- **WebSocket Events:** Broadcast status changes\n- **Heartbeat Monitoring:** Detect user disconnections\n- **Status Propagation:** Update all relevant channels/DMs\n- **Graceful Degradation:** Handle connection losses\n\n**3. Typing Indicators:**\n```\nTyping Events:\n- user_id\n- channel_id\n- typing_status (started, stopped)\n- timestamp\n- expires_at (auto-cleanup)\n```\n\n**Channel and Permission System:**\n\n**1. Channel Types:**\n- **Public Channels:** Open to all workspace members\n- **Private Channels:** Invite-only access\n- **Direct Messages:** 1-on-1 conversations\n- **Group Messages:** Small group conversations\n\n**2. Permission Model:**\n```\nPermissions:\n- workspace_admin\n- channel_admin\n- channel_member\n- guest_user\n\nActions:\n- send_messages\n- delete_messages\n- manage_channel\n- invite_users\n- upload_files\n```\n\n**3. Access Control:**\n- **Role-based Permissions:** Predefined roles\n- **Fine-grained Controls:** Per-channel permissions\n- **Inheritance:** Workspace-level permissions\n- **Audit Logging:** Track permission changes\n\n**Search and Discovery:**\n\n**1. Message Search:**\n- **Full-text Search:** Elasticsearch-based search\n- **Advanced Filters:** Date, user, channel, file type\n- **Search Relevance:** Ranking based on recency and relevance\n- **Search Suggestions:** Auto-complete and suggestions\n\n**2. Indexing Strategy:**\n```\nSearch Index:\n- message_content (analyzed text)\n- channel_id\n- user_id\n- timestamp\n- file_metadata\n- message_type\n```\n\n**3. Search Performance:**\n- **Incremental Indexing:** Real-time index updates\n- **Search Caching:** Cache popular search queries\n- **Distributed Search:** Parallel search across shards\n- **Search Analytics:** Track search patterns\n\n**File Sharing System:**\n\n**1. File Upload Flow:**\n```\n1. Client uploads file to CDN/Object Storage\n2. Generate file metadata and thumbnail\n3. Virus scan and content validation\n4. Create message with file reference\n5. Broadcast file message to channel\n6. Update search index with file content\n```\n\n**2. File Processing:**\n- **Image Processing:** Generate thumbnails and previews\n- **Video Processing:** Extract thumbnails and metadata\n- **Document Processing:** Extract text for search\n- **Security Scanning:** Virus and malware detection\n\n**3. Storage Strategy:**\n- **Object Storage (S3):** Primary file storage\n- **CDN:** Global file delivery\n- **Compression:** Optimize storage and transfer\n- **Encryption:** Encrypt files at rest and in transit\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Microservices:** Independent service scaling\n- **Database Sharding:** Distribute data across databases\n- **Connection Pooling:** Efficient WebSocket management\n- **Auto-scaling:** Dynamic resource allocation\n\n**2. Performance Optimization:**\n- **Message Batching:** Batch multiple messages\n- **Connection Multiplexing:** Efficient connection usage\n- **Caching Layers:** Multi-level caching strategy\n- **Asynchronous Processing:** Non-blocking operations\n\n**3. Load Distribution:**\n- **Geographic Distribution:** Multi-region deployment\n- **Workspace Isolation:** Separate high-traffic workspaces\n- **Channel Partitioning:** Distribute large channels\n- **Message Queuing:** Handle traffic spikes\n\n**High Availability:**\n\n**1. Fault Tolerance:**\n- **Multi-region Deployment:** Global redundancy\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Maintain core functionality\n- **Health Monitoring:** Continuous system monitoring\n\n**2. Data Consistency:**\n- **Eventually Consistent:** Message delivery and presence\n- **Strong Consistency:** User authentication and permissions\n- **Conflict Resolution:** Handle concurrent operations\n- **Backup and Recovery:** Regular data backups\n\n**Monitoring and Analytics:**\n- **Real-time Dashboards:** System health and performance\n- **Message Metrics:** Volume, delivery rates, latency\n- **User Engagement:** Active users, message frequency\n- **Performance Monitoring:** WebSocket connections, database performance\n- **Error Tracking:** Message delivery failures, system errors\n\n**Security and Privacy:**\n- **End-to-end Encryption:** Optional message encryption\n- **Data Retention:** Configurable message retention policies\n- **Audit Logging:** Track all system activities\n- **Compliance:** GDPR, HIPAA, SOC 2 compliance\n- **DLP Integration:** Data loss prevention scanning",
      "keywords": ["distributed messaging", "real-time communication", "WebSocket", "message routing", "presence tracking", "typing indicators", "microservices", "message delivery", "file sharing", "search indexing", "channel permissions", "horizontal scaling", "event-driven architecture", "push notifications", "high availability", "Cassandra"],
      "difficulty": "hard"
    },
    {
      "id": 3029,
      "tag": "systems_design",
      "question": "Design a distributed file storage system like Dropbox or Google Drive. Include file synchronization, versioning, and sharing.",
      "answer": "**System Requirements:**\n- Store and sync files across multiple devices\n- Support for billions of files and petabytes of data\n- Real-time file synchronization\n- File versioning and conflict resolution\n- File sharing with granular permissions\n- Cross-platform client applications\n- High availability and data durability\n- Efficient bandwidth usage and delta sync\n\n**Architecture Overview:**\n\n**1. Client Applications:**\n- **Desktop Sync Clients:** Windows, macOS, Linux\n- **Mobile Apps:** iOS and Android applications\n- **Web Interface:** Browser-based file management\n- **API Clients:** Third-party integrations\n- **Offline Support:** Local file caching and conflict resolution\n\n**2. API Gateway:**\n- **Authentication:** OAuth 2.0 and JWT tokens\n- **Rate Limiting:** Prevent API abuse\n- **Load Balancing:** Distribute requests across services\n- **Request Routing:** Route to appropriate microservices\n- **Compression:** Gzip response compression\n\n**3. Core Microservices:**\n\n**User Service:**\n- User registration and authentication\n- User profiles and preferences\n- Subscription and billing management\n- Device management and authorization\n\n**File Metadata Service:**\n- File and folder metadata storage\n- File hierarchy and organization\n- File permissions and sharing\n- Version history tracking\n\n**Sync Service:**\n- File synchronization coordination\n- Conflict detection and resolution\n- Delta sync optimization\n- Client state management\n\n**Storage Service:**\n- File content storage and retrieval\n- Chunk-based storage optimization\n- Data deduplication\n- Storage tier management\n\n**Sharing Service:**\n- File and folder sharing\n- Permission management\n- Link sharing and access control\n- Collaborative editing support\n\n**Notification Service:**\n- Real-time sync notifications\n- File change events\n- Sharing notifications\n- System alerts\n\n**File Storage Architecture:**\n\n**1. Chunk-based Storage:**\n```\nFile Chunking:\n1. Split files into fixed-size chunks (4MB)\n2. Generate hash for each chunk (SHA-256)\n3. Store chunks independently\n4. Maintain chunk-to-file mapping\n5. Enable deduplication across files\n```\n\n**2. Storage Structure:**\n```\nFile Metadata:\n- file_id (UUID)\n- filename\n- size\n- checksum\n- created_at\n- modified_at\n- version\n- parent_folder_id\n- owner_id\n- permissions\n\nChunk Metadata:\n- chunk_id (hash)\n- size\n- storage_location\n- reference_count\n- created_at\n```\n\n**3. Storage Tiers:**\n- **Hot Storage:** Recently accessed files (SSD)\n- **Warm Storage:** Moderately accessed files (HDD)\n- **Cold Storage:** Archived files (Object storage)\n- **Glacier:** Long-term backup (Archival storage)\n\n**Synchronization System:**\n\n**1. Delta Sync Algorithm:**\n```\nSync Process:\n1. Client sends file metadata and checksums\n2. Server compares with stored metadata\n3. Identify changed chunks using rolling hash\n4. Transfer only modified chunks\n5. Reconstruct file on client/server\n6. Update metadata and version\n```\n\n**2. Conflict Resolution:**\n```\nConflict Types:\n- Simultaneous edits on different devices\n- Rename conflicts\n- Delete vs. modify conflicts\n\nResolution Strategy:\n- Last-writer-wins for simple conflicts\n- Create conflict copies for complex conflicts\n- User-driven resolution for critical conflicts\n- Automatic merging for compatible changes\n```\n\n**3. Rolling Hash Implementation:**\n```\nRolling Hash (Rabin fingerprinting):\n- Efficient chunk boundary detection\n- Variable-size chunks for better deduplication\n- Content-aware chunking\n- Minimize transferred data\n```\n\n**Data Storage Design:**\n\n**1. Metadata Storage:**\n- **PostgreSQL:** File metadata, user data, permissions\n- **Redis:** Session data, real-time sync state\n- **Elasticsearch:** File search and indexing\n\n**2. File Content Storage:**\n- **Object Storage (S3):** Primary file chunk storage\n- **CDN:** Global content delivery\n- **Local Cache:** Edge caching for hot data\n\n**3. Database Sharding:**\n- **User-based Sharding:** Distribute by user_id\n- **Geographic Sharding:** Regional data distribution\n- **File Size Sharding:** Separate large file handling\n\n**File Versioning System:**\n\n**1. Version Management:**\n```\nVersion Structure:\n- version_id\n- file_id\n- version_number\n- created_at\n- size\n- checksum\n- chunk_list\n- change_description\n```\n\n**2. Version Storage Strategy:**\n- **Incremental Versioning:** Store only changed chunks\n- **Snapshot Versioning:** Periodic full snapshots\n- **Retention Policies:** Automatic old version cleanup\n- **Version Limits:** Configurable version history depth\n\n**3. Version Operations:**\n- **Restore:** Revert to previous version\n- **Compare:** Show differences between versions\n- **Branch:** Create alternative version paths\n- **Merge:** Combine version changes\n\n**File Sharing and Permissions:**\n\n**1. Permission Model:**\n```\nPermission Types:\n- Owner: Full control\n- Editor: Read/write access\n- Viewer: Read-only access\n- Commenter: View and comment\n\nShare Types:\n- User-specific sharing\n- Link-based sharing\n- Public sharing\n- Team/group sharing\n```\n\n**2. Access Control:**\n- **ACL (Access Control Lists):** Fine-grained permissions\n- **Inheritance:** Folder-level permission inheritance\n- **Expiration:** Time-limited access\n- **Password Protection:** Additional security layer\n\n**3. Collaborative Features:**\n- **Real-time Collaboration:** Multiple users editing\n- **Comment System:** File and folder comments\n- **Activity Feed:** Track file changes and access\n- **Notification System:** Share and change notifications\n\n**Synchronization Optimization:**\n\n**1. Bandwidth Optimization:**\n- **Delta Sync:** Transfer only changed portions\n- **Compression:** Compress data before transfer\n- **Batching:** Group multiple operations\n- **Prioritization:** Sync important files first\n\n**2. Performance Optimization:**\n- **Parallel Transfers:** Multiple concurrent uploads/downloads\n- **Adaptive Transfer:** Adjust based on network conditions\n- **Resume Capability:** Resume interrupted transfers\n- **Smart Sync:** Sync files on-demand\n\n**3. Network Efficiency:**\n- **Connection Pooling:** Reuse HTTP connections\n- **Keep-alive Connections:** Maintain persistent connections\n- **HTTP/2:** Multiplexed requests\n- **Edge Servers:** Geographically distributed servers\n\n**Scalability Solutions:**\n\n**1. Horizontal Scaling:**\n- **Microservices:** Independent service scaling\n- **Database Sharding:** Distribute data load\n- **Load Balancing:** Distribute traffic\n- **Auto-scaling:** Dynamic resource allocation\n\n**2. Storage Scaling:**\n- **Distributed Storage:** Scale storage horizontally\n- **Deduplication:** Reduce storage requirements\n- **Compression:** Optimize storage efficiency\n- **Tiered Storage:** Cost-effective storage management\n\n**3. Performance Scaling:**\n- **Caching Layers:** Multi-level caching\n- **CDN Integration:** Global content delivery\n- **Database Optimization:** Query optimization and indexing\n- **Async Processing:** Background processing queues\n\n**High Availability:**\n\n**1. Data Durability:**\n- **Multi-region Replication:** Geographic redundancy\n- **Multiple Copies:** 3+ copies of each chunk\n- **Erasure Coding:** Efficient redundancy\n- **Checksums:** Data integrity verification\n\n**2. Fault Tolerance:**\n- **Service Redundancy:** Multiple service instances\n- **Circuit Breakers:** Prevent cascade failures\n- **Graceful Degradation:** Maintain core functionality\n- **Health Monitoring:** Continuous system monitoring\n\n**3. Disaster Recovery:**\n- **Backup Strategies:** Regular data backups\n- **Recovery Procedures:** Automated recovery processes\n- **RTO/RPO Goals:** Recovery time and point objectives\n- **Cross-region Failover:** Automatic failover mechanisms\n\n**Security and Privacy:**\n\n**1. Data Protection:**\n- **Encryption at Rest:** AES-256 file encryption\n- **Encryption in Transit:** TLS 1.3 for all communications\n- **Client-side Encryption:** Optional end-to-end encryption\n- **Key Management:** Secure key storage and rotation\n\n**2. Access Security:**\n- **Two-factor Authentication:** Enhanced account security\n- **Device Authorization:** Trusted device management\n- **Session Management:** Secure session handling\n- **Audit Logging:** Comprehensive activity logging\n\n**3. Compliance:**\n- **GDPR Compliance:** Data protection regulations\n- **HIPAA Compliance:** Healthcare data protection\n- **Data Residency:** Geographic data storage requirements\n- **Privacy Controls:** User data control and deletion\n\n**Monitoring and Analytics:**\n- **Real-time Dashboards:** System health and performance\n- **Sync Performance:** Transfer speeds and success rates\n- **Storage Metrics:** Usage patterns and growth\n- **User Analytics:** Feature usage and engagement\n- **Error Tracking:** Sync failures and system errors\n\n**Client-side Features:**\n- **Smart Sync:** On-demand file downloading\n- **Selective Sync:** Choose folders to sync\n- **Bandwidth Controls:** Limit sync bandwidth usage\n- **Conflict Resolution UI:** User-friendly conflict handling\n- **Activity Monitor:** Track sync status and progress",
      "keywords": ["distributed file storage", "file synchronization", "delta sync", "chunk-based storage", "deduplication", "version control", "conflict resolution", "rolling hash", "file sharing", "permissions", "microservices", "horizontal scaling", "data durability", "encryption", "real-time sync", "object storage"],
      "difficulty": "hard"
    }
  ]
}